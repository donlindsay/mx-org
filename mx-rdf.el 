(defun mx/rdf-startup ()) 

(defvar mx-rdf-startup
  (cond
   (overview)
    (hideblocks)))

(defun mx-drawer ()
  (org-insert-property-drawer))

(defvar mx-rdf-drawer (drawer)
  '((org-insert-drawer . '((mx-org-hidden       . nil)
			   (mx-org-state        . nil)
			   (mx-org-properties   . nil)
			   (mx-rdfs-owl2        . nil)
			   (mx-n3               . nil))
		       )))

(defun mx/dev-tags ()
  (setq org-tag-alist '((:startgroup . nil)
			("@file" . ?f)
			("@buffer" . ?b)
			("@window" . ?w)
			("@frame" . ?f)
			(:endgroup . nil)
			(:startgroup . nil)
			("@doc" . ?d)
			("@src" . ?s)
			("@block" . ?bl)
			("@import" . ?i)
			("@export" . ?e)
			(:endgroup . nil)
			(:startgroup . nil)
			("org" . ?o)
			("elisp" . ?el)
			("n3" . ?n3)
			("owl2" . ?owl)
			("rdfs" . ?r)
			("shell" . ?s)
			("axiom" . ?a)
			("grammar" . ?g)
			(:endgroup . nil)
			(:startgroup . nil)
			("proof" . ?p)
			("theorem" . ?t)
			("def" . ?d)
			("desc" . ?ds)
			("example" . ?ex)
			(:endgroup . nil))
	)
  )

(defun mx/org-header-args ()
  (setq mx-org-src-block-properties
	'((mx-org-header-arg . '((:export . results)
				 (:header-args . mx-rdf)
				 (:session . *mx-rdf*))
			     )
	  )
	)
  )

(defun mx/org-rdf-properties () 
  (setq mx-org-rdf-properties . '(:see-also
  . org-property-allowed-value-functions)))

(defun mx/org-global-properties ()
  "'List of property/value pairs that can be inherited by any entry.
This list will be combined with the constant
`org-global-properties-fixed'.  The entries in this list are cons
cells where the car is a property name and cdr is a string with
the value.'  

Note: it might make sense to make a separate file for holding the
list since it might be somewhat long and can be imported.A
related question is if you want to define all the owl2 and rdfs
only tags."
  (setq org-global-properties
	'((mx-org-n3-triple . '((mx-subject     . nil)
				(mx-predicate   . nil)
				(mx-object . nil)) ) ) ) )
	
   

   this may be where drawers will be appropriate as they are easily
   handled, are custom definable, and have good code support.

   also, the syntax of drawers is similar to n3 syntax, making the
   production of n3 strings easier, if, for instance, i want to do
   string replacement and filtering functions, or want to do things
   with agenda and column views

(defvar BEGIN_EXAMPLE owl2-rdfs property drawer
  :owl2-rdfs:
  :doc-string "owl2 and rdfs markup element drawer"
  :type drawer
  :end:
(defvar END_EXAMPLE

(defvar property: mx-rdf_all          mx-rdfs-type
(defvar property: mx-rdf+             mx-n3-predicate
(defvar property: mx-rdf+             rdfs-type

(defun  or elisp via org-file-properties
   
     "You can set buffer-local values for the same purpose in the variable
     `org-file-properties' this by adding lines like
   
     (defvar PROPERTY: NAME VALUE"

org-entry-put-multivalued-property pom property &rest values

(defun  calls 
  
   "(defvar call [<inside header arguments>] (<arguments>) <end header arguments>"

(defvar call: mx-rdf-imenu-add-to-menubar
(defvar call: mx-rdf-button-panel
(defvar call: mx-rdf-ac-predictive
(defvar CALL: factorial(n=5)
(defvar CALL: factorial[:session special](n=5)
(defvar CALL: mx-rdf-todo-keywords (<arguments>)


(defun  functions 
(defun  Periodic Functions 
   Captured [2014-06-18 Wed 08:14]
   {Periodic function} (Math.), a function whose values recur at
   fixed intervals as the variable uniformly increases. The
   trigonomertic functions, as sin(x), tan(x), etc., are
   periodic functions. Exponential functions are also
   periodic, having an imaginary period, and the elliptic
   functions have not only a real but an imaginary period,
   and are hence called doubly periodic.
(defun  mx-rdf-org-ac 
(defvar name: mx-rdf-org-ac
(defvar BEGIN_SRC emacs-lisp
  (defun mx-rdf-ac-predictive ()
    "Enable org-ac and predictive mode. Warning: resource intensive."
    (interactive)
    (progn
      (predictive-mode)             
      (org-ac/setup-current-buffer))
    )
(defvar END_SRC

(defun  mx-rdf-todo 
(defvar name:     mx-rdf-todo-keywords
(defvar headers:  :var data1=1
(defvar begin_src emacs-lisp          :var data2=2
(progn 
;; buttonize
(org-babel-execute-src-block)

(setq org-todo-keywords
       '((sequence "TODO" "|" "DONE")
         (sequence "REPORT" "BUG" "KNOWNCAUSE" "|" "FIXED")
         (sequence "|" "CANCELED")))

(message "data1:%S, data2:%S" data1 data2))
(defvar end_src
(defvar results:
: data1:1, data2:2

(defvar name: named-block
(defvar header: :var data=2
(defvar begin_src emacs-lisp
(message "data:%S" data)
(defvar end_src
(defvar results: named-block
: data:2

(defun  mx-rdf-button-panel 
   :properties:
   :doc-string  "A panel window with a set of custom buttons for common tasks."
   :import      buffer-buttons.el
   :end:

  "Buffer buttons placed at the bottom or top of this file. So
   that they can be used in a two window frame, when the buttons
   are ready, code the frame window geometry setup. See
   buffer-buttons.el for more.

   Another feature is inline buttons for source blocks. Buttons
   provide quick access to executions and editing functions. Source
   blocks, like repls, with buttons."

(defun  mx-rdf-button-definitions
(defvar name: mx-rdf-button-definitions
(defvar BEGIN_SRC emacs-lisp
  ; eval-last-sexp
  (define-buffer-button (elisp-eval b
                                    :label "<- Eval"
                                    :prefix ";;")
    (save-excursion
      (goto-char (button-start b))
      (eval-last-sexp nil)))
  ; org-edit-src-code
  (define-buffer-button (elisp-eval b
                                    :label "Edit Src"
                                    :prefix ";;")
    (save-excursion
      (goto-char (button-start b))
      (org-edit-src-code nil)))
  ; org-execute-source-block
  (define-buffer-button (elisp-eval b
                                    :label "Exec Src"
                                    :prefix ";;")
    (save-excursion
      (goto-char (button-start b))
      (org-execute-source-block nil)))
(defvar end_src

(defun   define the buttons in source blocks

(defun  mx-rdf-yas 
(defvar name: yasnippet-functions
(defvar BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
                      (lambda ()
                        (org-set-local 'yas/trigger-key [tab])
                        (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))
  


 (add-hook 'org-mode-hook
                      (lambda ()
                        (make-variable-buffer-local 'yas/trigger-key)
                        (setq yas/trigger-key [tab])
                        (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
                        (define-key yas/keymap [tab]
                      'yas/next-field)))

(defun yas/org-very-safe-expand ()
              (let ((yas/fallback-behavior 'return-nil))
              (yas/expand)))

(defvar END_SRC
(defun  mx-rdf-imenu
(defun  mx-rdf-predictive-mode
(defun  mx-rdf-lob-ingest 
 :properties:
 :mx-rdf-lob-file ~/src/lisp/mx-rdf/mx-rdf-library-of-babel.org
 :end:

(defvar name: mx-rdf-lob-ingest
(defvar BEGIN_SRC emacs-lisp
; (org-babel-lob-ingest)

(defvar END_SRC


(defun  tasks 
(defun  dfa-dg.org
This file has mainly become about deterministic finite automata and
directed graphs. This is progress because my targets have been source
blocks and n3. (defvar begin_src might read as (defvar deterministic-finite-automata
and n3 might read as directed-graph. My current interest is developing
this code along those lines and with a focus on producing code that i
can load into gruff, which at this point means turtle and hence, n3.

(defun  determine the significance of (:how) (:what) and (seq (:how :much))
(defun  TODO do i want a (defvar property: list of all owl2 and rdfs? 

(defvar property: mx-rdf_all          mx-rdf-rdfs-type
(defvar property: mx-rdf+             mx-rdf-predicate
(defvar property: mx-rdf-predicate    rdfs-type

(defun  drawers
(defvar drawer:   hidden state

(defun  TODO edit for mx-rdf-lob-file
(defun  utilities							      :shell:
(defun  XPath							     :rdf:fn:

    [Definition: XPath operates on the abstract, logical structure of an
    XML document, rather than its surface syntax. This logical
    structure, known as the data model, is defined in [XQuery 1.0 and
    XPath 2.0 Data Model (Second Edition)].]

    XPath is designed to be embedded in a host language such as [XSL
    Transformations (XSLT) Version 2.0 (Second Edition)] or [XQuery 1.0:
    An XML Query Language (Second Edition)]. XPath has a natural subset
    that can be used for matching (testing whether or not a node matches
    a pattern); this use of XPath is described in [XSL Transformations
    (XSLT) Version 2.0 (Second Edition)].

    XQuery Version 1.0 is an extension of XPath Version 2.0. Any
    expression that is syntactically valid and executes successfully in
    both XPath 2.0 and XQuery 1.0 will return the same result in both
    languages. Since these languages are so closely related, their
    grammars and language descriptions are generated from a common
    source to ensure consistency, and the editors of these
    specifications work together closely.

(defun  IRI is an extention of URI.					:rdf:
  URI is still used in documentation for backward compatibility
  with the larger corpus of specifications.

[Definition: Within this specification, the term
URI refers to a Universal Resource Identifier as
defined in [RFC3986] and extended in [RFC3987]
with the new name IRI.] The term URI has been
retained in preference to IRI to avoid introducing
new names for concepts such as "Base URI" that are
defined or referenced across the whole family of
XML specifications.



[Definition: Statically known documents. This is a
mapping from strings onto types. The string
represents the absolute URI of a resource that is
potentially available using the fn:doc
function. The type is the static type of a call to
fn:doc with the given URI as its literal
argument. ] If the argument to fn:doc is a string
literal that is not present in statically known
documents, then the static type of fn:doc is
document-node()?.

Note:

The purpose of the statically known documents is
to provide static type information, not to
determine which documents are available. A URI
need not be found in the statically known
documents to be accessed using fn:doc.

(defun  XPath is defined 
     in terms of the data model and the expression context.
(defun  XPath defines						  :rdf:debug:
     two phases of processing called the static
     analysis phase and the dynamic evaluation phase
(defun (defun  thus
      (((data-model) (expression-context)) 
      (xpath) 
      ((static-analysis-phase) (dynamic-evalution-phase)))
(defun  rdf							  :rdf:debug:
(defun  owl							    :rdf:owl:
(defun (defun  owl2 in triples						    :rdf:owl:
(defun (defun  Annotations

       "... the OWL 2 RDF-Based Semantics includes many semantic
       conditions that can in a sense be regarded as being
       "axiomatic", and thus can be considered a replacement for
       the missing axiomatic triples."
       [[file:///usr/share/doc/w3-recs/html/www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/index.html#Appendix:_Axiomatic_Triples_.28Informative.29]]

(defun  (defun  owl2 in turtle

(defun '(mx-rdf-owl2-AllDifferent '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-AllDifferent rdfs:subClassOf mx-rdfs-resource .

'(mx-rdf-owl2-AllDisjointClasses '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-AllDisjointClasses mx-rdfs-subClassOf mx-rdfs-resource .

'(mx-rdf-owl2-AllDisjointProperties '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-AllDisjointProperties mx-rdfs-subClassOf mx-rdfs-resource .

'(mx-rdf-owl2-Annotation '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-Annotation mx-rdfs-subClassOf mx-rdfs-resource .

'(mx-rdf-owl2-AnnotationProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-AnnotationProperty mx-rdfs-subClassOf rdf:Property .

'(mx-rdf-owl2-AsymmetricProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-AsymmetricProperty mx-rdfs-subClassOf '(mx-rdf-owl2-ObjectProperty .

'(mx-rdf-owl2-Axiom '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-Axiom mx-rdfs-subClassOf mx-rdfs-resource .

'(mx-rdf-owl2-Class '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-Class mx-rdfs-subClassOf 'mx-rdfs-class) .

'(mx-rdf-owl2-DataRange '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-DataRange mx-rdfs-subClassOf mx-rdf-Datatype .

'(mx-rdf-owl2-DatatypeProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-DatatypeProperty mx-rdfs-subClassOf rdf:Property .

'(mx-rdf-owl2-DeprecatedClass '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-DeprecatedClass mx-rdfs-subClassOf 'mx-rdfs-class) .

'(mx-rdf-owl2-DeprecatedProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-DeprecatedProperty mx-rdfs-subClassOf rdf:Property .

'(mx-rdf-owl2-FunctionalProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-FunctionalProperty mx-rdfs-subClassOf rdf:Property .

'(mx-rdf-owl2-InverseFunctionalProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-InverseFunctionalProperty mx-rdfs-subClassOf '(mx-rdf-owl2-ObjectProperty .

'(mx-rdf-owl2-IrreflexiveProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-IrreflexiveProperty mx-rdfs-subClassOf '(mx-rdf-owl2-ObjectProperty .

'(mx-rdf-owl2-NamedIndividual '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-NamedIndividual mx-rdfs-subClassOf '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-NegativePropertyAssertion '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-NegativePropertyAssertion mx-rdfs-subClassOf mx-rdfs-resource .

'(mx-rdf-owl2-Nothing '((mx-rdf-type . '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-Nothing mx-rdfs-subClassOf '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-ObjectProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-ObjectProperty mx-rdfs-subClassOf rdf:Property .

'(mx-rdf-owl2-Ontology '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-Ontology mx-rdfs-subClassOf mx-rdfs-resource .

'(mx-rdf-owl2-OntologyProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-OntologyProperty mx-rdfs-subClassOf rdf:Property .

'(mx-rdf-owl2-ReflexiveProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-ReflexiveProperty mx-rdfs-subClassOf '(mx-rdf-owl2-ObjectProperty .

'(mx-rdf-owl2-Restriction '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-Restriction mx-rdfs-subClassOf '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-SymmetricProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-SymmetricProperty mx-rdfs-subClassOf '(mx-rdf-owl2-ObjectProperty .

'(mx-rdf-owl2-Thing '((mx-rdf-type . '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-TransitiveProperty '((mx-rdf-type . 'mx-rdfs-class) .

'(mx-rdf-owl2-TransitiveProperty mx-rdfs-subClassOf '(mx-rdf-owl2-ObjectProperty .

(defun (defun  Axiomatic Triples for the Properties

'(mx-rdf-owl2-allValuesFrom '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-allValuesFrom mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-allValuesFrom mx-rdf-range 'mx-rdfs-class) .

'(mx-rdf-owl2-annotatedProperty '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-annotatedProperty mx-rdf-domain mx-rdfs-resource .

'(mx-rdf-owl2-annotatedProperty mx-rdf-range mx-rdfs-resource .

'(mx-rdf-owl2-annotatedSource '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-annotatedSource mx-rdf-domain mx-rdfs-resource .

'(mx-rdf-owl2-annotatedSource mx-rdf-range mx-rdfs-resource .

'(mx-rdf-owl2-annotatedTarget '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-annotatedTarget mx-rdf-domain mx-rdfs-resource .

'(mx-rdf-owl2-annotatedTarget mx-rdf-range mx-rdfs-resource .

'(mx-rdf-owl2-assertionProperty '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-assertionProperty mx-rdf-domain '(mx-rdf-owl2-NegativePropertyAssertion .

'(mx-rdf-owl2-assertionProperty mx-rdf-range rdf:Property .

'(mx-rdf-owl2-backwardCompatibleWith '((mx-rdf-type . '(mx-rdf-owl2-AnnotationProperty .

'(mx-rdf-owl2-backwardCompatibleWith '((mx-rdf-type . '(mx-rdf-owl2-OntologyProperty .

'(mx-rdf-owl2-backwardCompatibleWith mx-rdf-domain '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-backwardCompatibleWith mx-rdf-range '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-bottomDataProperty '((mx-rdf-type . '(mx-rdf-owl2-DatatypeProperty .

'(mx-rdf-owl2-bottomDataProperty mx-rdf-domain '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-bottomDataProperty mx-rdf-range mx-rdf-Literal .

'(mx-rdf-owl2-bottomObjectProperty '((mx-rdf-type . '(mx-rdf-owl2-ObjectProperty .

'(mx-rdf-owl2-bottomObjectProperty mx-rdf-domain '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-bottomObjectProperty mx-rdf-range '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-cardinality '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-cardinality mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-cardinality mx-rdf-range xsd:nonNegativeInteger .

'(mx-rdf-owl2-complementOf '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-complementOf mx-rdf-domain '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-complementOf mx-rdf-range '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-datatypeComplementOf '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-datatypeComplementOf mx-rdf-domain mx-rdf-Datatype .

'(mx-rdf-owl2-datatypeComplementOf mx-rdf-range mx-rdf-Datatype .

'(mx-rdf-owl2-deprecated '((mx-rdf-type . '(mx-rdf-owl2-AnnotationProperty .

'(mx-rdf-owl2-deprecated mx-rdf-domain mx-rdfs-resource .

'(mx-rdf-owl2-deprecated mx-rdf-range mx-rdfs-resource .

'(mx-rdf-owl2-differentFrom '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-differentFrom mx-rdf-domain '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-differentFrom mx-rdf-range '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-disjointUnionOf '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-disjointUnionOf mx-rdf-domain '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-disjointUnionOf mx-rdf-range rdf:List .

'(mx-rdf-owl2-disjointWith '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-disjointWith mx-rdf-domain '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-disjointWith mx-rdf-range '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-distinctMembers '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-distinctMembers mx-rdf-domain '(mx-rdf-owl2-AllDifferent .

'(mx-rdf-owl2-distinctMembers mx-rdf-range rdf:List .

'(mx-rdf-owl2-equivalentClass '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-equivalentClass mx-rdf-domain 'mx-rdfs-class) .

'(mx-rdf-owl2-equivalentClass mx-rdf-range 'mx-rdfs-class) .

'(mx-rdf-owl2-equivalentProperty '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-equivalentProperty mx-rdf-domain rdf:Property .

'(mx-rdf-owl2-equivalentProperty mx-rdf-range rdf:Property .

'(mx-rdf-owl2-hasKey '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-hasKey mx-rdf-domain '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-hasKey mx-rdf-range rdf:List .

'(mx-rdf-owl2-hasSelf '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-hasSelf mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-hasSelf mx-rdf-range mx-rdfs-resource .

'(mx-rdf-owl2-hasValue '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-hasValue mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-hasValue mx-rdf-range mx-rdfs-resource .

'(mx-rdf-owl2-imports '((mx-rdf-type . '(mx-rdf-owl2-OntologyProperty .

'(mx-rdf-owl2-imports mx-rdf-domain '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-imports mx-rdf-range '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-incompatibleWith '((mx-rdf-type . '(mx-rdf-owl2-AnnotationProperty .

'(mx-rdf-owl2-incompatibleWith '((mx-rdf-type . '(mx-rdf-owl2-OntologyProperty .

'(mx-rdf-owl2-incompatibleWith mx-rdf-domain '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-incompatibleWith mx-rdf-range '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-intersectionOf '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-intersectionOf mx-rdf-domain 'mx-rdfs-class) .

'(mx-rdf-owl2-intersectionOf mx-rdf-range rdf:List .

'(mx-rdf-owl2-inverseOf '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-inverseOf mx-rdf-domain '(mx-rdf-owl2-ObjectProperty .

'(mx-rdf-owl2-inverseOf mx-rdf-range '(mx-rdf-owl2-ObjectProperty .

'(mx-rdf-owl2-maxCardinality '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-maxCardinality mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-maxCardinality mx-rdf-range xsd:nonNegativeInteger .

'(mx-rdf-owl2-maxQualifiedCardinality '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-maxQualifiedCardinality mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-maxQualifiedCardinality mx-rdf-range xsd:nonNegativeInteger .

'(mx-rdf-owl2-members '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-members mx-rdf-domain mx-rdfs-resource .

'(mx-rdf-owl2-members mx-rdf-range rdf:List .

'(mx-rdf-owl2-minCardinality '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-minCardinality mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-minCardinality mx-rdf-range xsd:nonNegativeInteger .

'(mx-rdf-owl2-minQualifiedCardinality '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-minQualifiedCardinality mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-minQualifiedCardinality mx-rdf-range xsd:nonNegativeInteger .

'(mx-rdf-owl2-onClass '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-onClass mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-onClass mx-rdf-range '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-onDataRange '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-onDataRange mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-onDataRange mx-rdf-range mx-rdf-Datatype .

'(mx-rdf-owl2-onDatatype '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-onDatatype mx-rdf-domain mx-rdf-Datatype .

'(mx-rdf-owl2-onDatatype mx-rdf-range mx-rdf-Datatype .

'(mx-rdf-owl2-oneOf '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-oneOf mx-rdf-domain 'mx-rdfs-class) .

'(mx-rdf-owl2-oneOf mx-rdf-range rdf:List .

'(mx-rdf-owl2-onProperty '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-onProperty mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-onProperty mx-rdf-range rdf:Property .

'(mx-rdf-owl2-onProperties '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-onProperties mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-onProperties mx-rdf-range rdf:List .

'(mx-rdf-owl2-priorVersion '((mx-rdf-type . '(mx-rdf-owl2-AnnotationProperty .

'(mx-rdf-owl2-priorVersion '((mx-rdf-type . '(mx-rdf-owl2-OntologyProperty .

'(mx-rdf-owl2-priorVersion mx-rdf-domain '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-priorVersion mx-rdf-range '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-propertyChainAxiom '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-propertyChainAxiom mx-rdf-domain '(mx-rdf-owl2-ObjectProperty .

'(mx-rdf-owl2-propertyChainAxiom mx-rdf-range rdf:List .

'(mx-rdf-owl2-propertyDisjointWith '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-propertyDisjointWith mx-rdf-domain rdf:Property .

'(mx-rdf-owl2-propertyDisjointWith mx-rdf-range rdf:Property .

'(mx-rdf-owl2-qualifiedCardinality '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-qualifiedCardinality mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-qualifiedCardinality mx-rdf-range xsd:nonNegativeInteger .

'(mx-rdf-owl2-sameAs '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-sameAs mx-rdf-domain '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-sameAs mx-rdf-range '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-someValuesFrom '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-someValuesFrom mx-rdf-domain '(mx-rdf-owl2-Restriction .

'(mx-rdf-owl2-someValuesFrom mx-rdf-range 'mx-rdfs-class) .

'(mx-rdf-owl2-sourceIndividual '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-sourceIndividual mx-rdf-domain '(mx-rdf-owl2-NegativePropertyAssertion .

'(mx-rdf-owl2-sourceIndividual mx-rdf-range '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-targetIndividual '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-targetIndividual mx-rdf-domain '(mx-rdf-owl2-NegativePropertyAssertion .

'(mx-rdf-owl2-targetIndividual mx-rdf-range '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-targetValue '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-targetValue mx-rdf-domain '(mx-rdf-owl2-NegativePropertyAssertion .

'(mx-rdf-owl2-targetValue mx-rdf-range mx-rdf-Literal .

'(mx-rdf-owl2-topDataProperty '((mx-rdf-type . '(mx-rdf-owl2-DatatypeProperty .

'(mx-rdf-owl2-topDataProperty mx-rdf-domain '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-topDataProperty mx-rdf-range mx-rdf-Literal .

'(mx-rdf-owl2-topObjectProperty '((mx-rdf-type . rdf:ObjectProperty .

'(mx-rdf-owl2-topObjectProperty mx-rdf-domain '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-topObjectProperty mx-rdf-range '(mx-rdf-owl2-Thing .

'(mx-rdf-owl2-unionOf '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-unionOf mx-rdf-domain 'mx-rdfs-class) .

'(mx-rdf-owl2-unionOf mx-rdf-range rdf:List .

'(mx-rdf-owl2-versionInfo '((mx-rdf-type . '(mx-rdf-owl2-AnnotationProperty .

'(mx-rdf-owl2-versionInfo mx-rdf-domain mx-rdfs-resource .

'(mx-rdf-owl2-versionInfo mx-rdf-range mx-rdfs-resource .

'(mx-rdf-owl2-versionIRI '((mx-rdf-type . '(mx-rdf-owl2-OntologyProperty .

'(mx-rdf-owl2-versionIRI mx-rdf-domain '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-versionIRI mx-rdf-range '(mx-rdf-owl2-Ontology .

'(mx-rdf-owl2-withRestrictions '((mx-rdf-type . rdf:Property .

'(mx-rdf-owl2-withRestrictions mx-rdf-domain mx-rdf-Datatype .

'(mx-rdf-owl2-withRestrictions mx-rdf-range rdf:List .
	
(defun (defun  Axiomatic Triples for the Datatypes

mx-xsd-anyURI '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-anyURI mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-base64Binary '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-base64Binary mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-boolean '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-boolean mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-byte '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-byte mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-dateTime '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-dateTime mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-dateTimeStamp '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-dateTimeStamp mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-decimal '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-decimal mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-double '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-double mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-float '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-float mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-hexBinary '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-hexBinary mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-int '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-int mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-integer '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-integer mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-language '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-language mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-long '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-long mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-Name '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-Name mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-NCName '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-NCName mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-negativeInteger '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-negativeInteger mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-NMTOKEN '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-NMTOKEN mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-nonNegativeInteger '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-nonNegativeInteger mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-nonPositiveInteger '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-nonPositiveInteger mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-normalizedString '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-normalizedString mx-rdfs-subClassOf mx-rdf-Literal .

rdf:PlainLiteral '((mx-rdf-type . mx-rdf-Datatype .

rdf:PlainLiteral mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-positiveInteger '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-positiveInteger mx-rdfs-subClassOf mx-rdf-Literal .

'(mx-rdf-owl2-rational '((mx-rdf-type . mx-rdf-Datatype .

'(mx-rdf-owl2-rational mx-rdfs-subClassOf mx-rdf-Literal .

'(mx-rdf-owl2-real '((mx-rdf-type . mx-rdf-Datatype .

'(mx-rdf-owl2-real mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-short '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-short mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-string '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-string mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-token '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-token mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-unsignedByte '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-unsignedByte mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-unsignedInt '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-unsignedInt mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-unsignedLong '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-unsignedLong mx-rdfs-subClassOf mx-rdf-Literal .

mx-xsd-unsignedShort '((mx-rdf-type . mx-rdf-Datatype .

mx-xsd-unsignedShort mx-rdfs-subClassOf mx-rdf-Literal .

rdf:XMLLiteral '((mx-rdf-type . mx-rdf-Datatype .

rdf:XMLLiteral mx-rdfs-subClassOf mx-rdf-Literal .
	
(defun (defun  Axiomatic Triples for the Facets

<rdf:langRange> <'((mx-rdf-type .> <'(mx-rdf-owl2-DatatypeProperty> .

<rdf:langRange> <mx-rdf-domain> <mx-rdfs-resource> .

<rdf:langRange> <mx-rdf-range> <mx-rdf-Literal> .

<mx-xsd-length> <'((mx-rdf-type .> <'(mx-rdf-owl2-DatatypeProperty> .

<mx-xsd-length> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-xsd-length> <mx-rdf-range> <mx-rdf-Literal> .

<mx-xsd-maxExclusive> <'((mx-rdf-type .> <'(mx-rdf-owl2-DatatypeProperty> .

<mx-xsd-maxExclusive> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-xsd-maxExclusive> <mx-rdf-range> <mx-rdf-Literal> .

<mx-xsd-maxInclusive> <'((mx-rdf-type .> <'(mx-rdf-owl2-DatatypeProperty> .

<mx-xsd-maxInclusive> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-xsd-maxInclusive> <mx-rdf-range> <mx-rdf-Literal> .

<mx-xsd-maxLength> <'((mx-rdf-type .> <'(mx-rdf-owl2-DatatypeProperty> .

<mx-xsd-maxLength> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-xsd-maxLength> <mx-rdf-range> <mx-rdf-Literal> .

<mx-xsd-minExclusive> <'((mx-rdf-type .> <'(mx-rdf-owl2-DatatypeProperty> .

<mx-xsd-minExclusive> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-xsd-minExclusive> <mx-rdf-range> <mx-rdf-Literal> .

<mx-xsd-minInclusive> <'((mx-rdf-type .> <'(mx-rdf-owl2-DatatypeProperty> .

<mx-xsd-minInclusive> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-xsd-minInclusive> <mx-rdf-range> <mx-rdf-Literal> .

<mx-xsd-minLength> <'((mx-rdf-type .> <'(mx-rdf-owl2-DatatypeProperty> .

mx-xsd-minLength mx-rdf-domain mx-rdfs-resource .

mx-xsd-minLength mx-rdf-range mx-rdf-Literal .

mx-xsd-pattern '((mx-rdf-type . '(mx-rdf-owl2-DatatypeProperty .

mx-xsd-pattern mx-rdf-domain mx-rdfs-resource .

mx-xsd-pattern mx-rdf-range mx-rdf-Literal .
	
(defun (defun  Additional Axiomatic Triples for Classes and Properties

<'mx-rdfs-class)> <mx-rdfs-subClassOf> <'(mx-rdf-owl2-Class> .

<mx-rdf-comment> <'((mx-rdf-type .> <'(mx-rdf-owl2-AnnotationProperty> .

<mx-rdf-comment> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-rdf-comment> <mx-rdf-range> <mx-rdf-Literal> .

<mx-rdf-Datatype> <mx-rdfs-subClassOf> <'(mx-rdf-owl2-DataRange> .

<mx-rdf-isDefinedBy> <'((mx-rdf-type .> <'(mx-rdf-owl2-AnnotationProperty> .

<mx-rdf-isDefinedBy> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-rdf-isDefinedBy> <mx-rdf-range> <mx-rdfs-resource> .

<mx-rdf-label> <'((mx-rdf-type .> <'(mx-rdf-owl2-AnnotationProperty> .

<mx-rdf-label> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-rdf-label> <mx-rdf-range> <mx-rdf-Literal> .

<mx-rdf-Literal> <'((mx-rdf-type .> <mx-rdf-Datatype> .

<rdf:Property> <mx-rdfs-subClassOf> <'(mx-rdf-owl2-ObjectProperty> .

<mx-rdfs-resource> <mx-rdfs-subClassOf> <'(mx-rdf-owl2-Thing> .

<mx-rdf-seeAlso> <'((mx-rdf-type .> <'(mx-rdf-owl2-AnnotationProperty> .

<mx-rdf-seeAlso> <mx-rdf-domain> <mx-rdfs-resource> .

<mx-rdf-seeAlso> <mx-rdf-range> <mx-rdfs-resource> .
(defun (defun  misc owl2								:rdf:
      ICEXT(I(ex:c1)) ⊆ ICEXT(I(ex:c2)) ∪ ICEXT(I(ex:c3)) . 
(defun (defun  owl2 basic gloss

      '(mx-rdf-owl2-AllDifferent 

      '(mx-rdf-owl2-AllDisjointClasses 

      '(mx-rdf-owl2-AllDisjointProperties 

      '(mx-rdf-owl2-allValuesFrom 

      '(mx-rdf-owl2-annotatedProperty 

      '(mx-rdf-owl2-annotatedSource 

      '(mx-rdf-owl2-annotatedTarget 

      '(mx-rdf-owl2-Annotation 

      '(mx-rdf-owl2-AnnotationProperty 

      '(mx-rdf-owl2-assertionProperty 

      '(mx-rdf-owl2-AsymmetricProperty 

      '(mx-rdf-owl2-Axiom 

      '(mx-rdf-owl2-backwardCompatibleWith 

      '(mx-rdf-owl2-bottomDataProperty 

      '(mx-rdf-owl2-bottomObjectProperty 

      '(mx-rdf-owl2-cardinality 

      '(mx-rdf-owl2-Class 

      '(mx-rdf-owl2-complementOf 

      '(mx-rdf-owl2-DataRange 

      '(mx-rdf-owl2-datatypeComplementOf 

      '(mx-rdf-owl2-DatatypeProperty 

      '(mx-rdf-owl2-deprecated 

      '(mx-rdf-owl2-DeprecatedClass 

      '(mx-rdf-owl2-DeprecatedProperty 

      '(mx-rdf-owl2-differentFrom 

      '(mx-rdf-owl2-disjointUnionOf 

      '(mx-rdf-owl2-disjointWith 

      '(mx-rdf-owl2-distinctMembers 

      '(mx-rdf-owl2-equivalentClass 

      '(mx-rdf-owl2-equivalentProperty 

      '(mx-rdf-owl2-FunctionalProperty 

      '(mx-rdf-owl2-hasKey 

      '(mx-rdf-owl2-hasSelf 

      '(mx-rdf-owl2-hasValue 

      '(mx-rdf-owl2-imports 

      '(mx-rdf-owl2-incompatibleWith 

      '(mx-rdf-owl2-intersectionOf 

      '(mx-rdf-owl2-InverseFunctionalProperty 

      '(mx-rdf-owl2-inverseOf 

      '(mx-rdf-owl2-IrreflexiveProperty 

      '(mx-rdf-owl2-maxCardinality 

      '(mx-rdf-owl2-maxQualifiedCardinality 

      '(mx-rdf-owl2-members 

      '(mx-rdf-owl2-minCardinality 

      '(mx-rdf-owl2-minQualifiedCardinality 

      '(mx-rdf-owl2-NamedIndividual 

      '(mx-rdf-owl2-NegativePropertyAssertion 

      '(mx-rdf-owl2-Nothing 

      '(mx-rdf-owl2-ObjectProperty 

      '(mx-rdf-owl2-onClass 

      '(mx-rdf-owl2-onDataRange 

      '(mx-rdf-owl2-onDatatype 

      '(mx-rdf-owl2-oneOf 

      '(mx-rdf-owl2-onProperty 

      '(mx-rdf-owl2-onProperties 

      '(mx-rdf-owl2-Ontology 

      '(mx-rdf-owl2-OntologyProperty 

      '(mx-rdf-owl2-priorVersion 

      '(mx-rdf-owl2-propertyChainAxiom 

      '(mx-rdf-owl2-propertyDisjointWith 

      '(mx-rdf-owl2-qualifiedCardinality 

      '(mx-rdf-owl2-ReflexiveProperty 

      '(mx-rdf-owl2-Restriction 

      '(mx-rdf-owl2-sameAs 

      '(mx-rdf-owl2-someValuesFrom 

      '(mx-rdf-owl2-sourceIndividual 

      '(mx-rdf-owl2-SymmetricProperty 

      '(mx-rdf-owl2-targetIndividual 

      '(mx-rdf-owl2-targetValue 

      '(mx-rdf-owl2-Thing 

      '(mx-rdf-owl2-topDataProperty 

      '(mx-rdf-owl2-topObjectProperty 

      '(mx-rdf-owl2-TransitiveProperty 

      '(mx-rdf-owl2-unionOf 

      '(mx-rdf-owl2-versionInfo 

      '(mx-rdf-owl2-versionIRI 

      '(mx-rdf-owl2-withRestrictions 

(defun (defun  About owl2 and axiomatic triples

lambda '((mx-rdf-type . '(mx-rdf-owl2-Class.

lambda '(mx-rdf-owl2-intersectionOf ( C1 … Cn ). 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Class.

lambda '(mx-rdf-owl2-unionOf ( C1 … Cn ). 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Class.

lambda '(mx-rdf-owl2-complementOf C. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Class.

lambda '(mx-rdf-owl2-oneOf ( a1 … an ). 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-allValuesFrom C .

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-someValuesFrom C .

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-hasValue a. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-hasSelf "true"^^mx-xsd-boolean. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-cardinality n. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-qualifiedCardinality n.

lambda '(mx-rdf-owl2-onClass C. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-maxCardinality n. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-maxQualifiedCardinality n.

lambda '(mx-rdf-owl2-onClass C. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-minCardinality n. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty P.

lambda '(mx-rdf-owl2-minQualifiedCardinality n.

lambda '(mx-rdf-owl2-onClass C. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty R.

lambda '(mx-rdf-owl2-allValuesFrom D. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty R.

lambda '(mx-rdf-owl2-someValuesFrom D. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty R.

lambda '(mx-rdf-owl2-hasValue v. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty R.

lambda '(mx-rdf-owl2-cardinality n. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty R.

lambda '(mx-rdf-owl2-qualifiedCardinality n.

lambda '(mx-rdf-owl2-onDataRange D. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty R.

lambda '(mx-rdf-owl2-maxCardinality n. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty R.

lambda '(mx-rdf-owl2-maxQualifiedCardinality n.

lambda '(mx-rdf-owl2-onDataRange D. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty R.

lambda '(mx-rdf-owl2-minCardinality n. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-Restriction.

lambda '(mx-rdf-owl2-onProperty R.

lambda '(mx-rdf-owl2-minQualifiedCardinality n.

lambda '(mx-rdf-owl2-onDataRange D. 

lambda '((mx-rdf-type . mx-rdf-Datatype.

lambda '(mx-rdf-owl2-datatypeComplementOf D. 

lambda '((mx-rdf-type . mx-rdf-Datatype.

lambda '(mx-rdf-owl2-intersectionOf (D1…Dn). 

lambda '((mx-rdf-type . mx-rdf-Datatype.

lambda '(mx-rdf-owl2-unionOf (D1…Dn). 

lambda '((mx-rdf-type . mx-rdf-Datatype.

lambda '(mx-rdf-owl2-oneOf ( v1 … vn ). 

lambda '((mx-rdf-type . mx-rdf-Datatype.

lambda '(mx-rdf-owl2-onDatatype DN.

lambda '(mx-rdf-owl2-withRestrictions (lambda1 ... lambdan).

lambdaj fj vj.      j=1…n 

C1 mx-rdfs-subClassOf C2. 

Cj '(mx-rdf-owl2-equivalentClass Cj+1. j=1…n-1 

C1 '(mx-rdf-owl2-disjointWith C2. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-AllDisjointClasses.

lambda '(mx-rdf-owl2-members ( C1 … Cn ). 

P1 mx-rdf-subPropertyOf P2. 

P '(mx-rdf-owl2-propertyChainAxiom (P1 … Pn). 

P mx-rdf-domain C. 

P mx-rdf-range C. 

Pj '(mx-rdf-owl2-equivalentProperty Pj+1. j=1…n-1 

P1 '(mx-rdf-owl2-propertyDisjointWith P2. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-AllDisjointProperties.

lambda '(mx-rdf-owl2-members ( P1 … Pn ). 

CN '(mx-rdf-owl2-disjointUnionOf ( C1 … Cn ).

P1 '(mx-rdf-owl2-inverseOf P2. 

P '((mx-rdf-type . '(mx-rdf-owl2-FunctionalProperty. 

P '((mx-rdf-type . '(mx-rdf-owl2-InverseFunctionalProperty. 

P '((mx-rdf-type . '(mx-rdf-owl2-ReflexiveProperty. 

P '((mx-rdf-type . '(mx-rdf-owl2-IrreflexiveProperty. 

P '((mx-rdf-type . '(mx-rdf-owl2-SymmetricProperty. 

P '((mx-rdf-type . '(mx-rdf-owl2-AsymmetricProperty. 

P '((mx-rdf-type . '(mx-rdf-owl2-TransitiveProperty. 

DN '(mx-rdf-owl2-equivalentClass D. 

aj '(mx-rdf-owl2-sameAs aj+1. j=1…n-1 

a1 '(mx-rdf-owl2-differentFrom a2. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-AllDifferent.

lambda '(mx-rdf-owl2-members (a1 … an). 

a '((mx-rdf-type . C. 

a1 PN a2. 

a R v. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-NegativePropertyAssertion.

lambda '(mx-rdf-owl2-sourceIndividual a1.

lambda '(mx-rdf-owl2-assertionProperty P.

lambda '(mx-rdf-owl2-targetIndividual a2. 

lambda '((mx-rdf-type . '(mx-rdf-owl2-NegativePropertyAssertion.

lambda '(mx-rdf-owl2-sourceIndividual a.

lambda '(mx-rdf-owl2-assertionProperty R.

lambda '(mx-rdf-owl2-targetValue v. 

C '(mx-rdf-owl2-hasKey (P1 … Pm R1 … Rn).

m+n>0 

CN '((mx-rdf-type . '(mx-rdf-owl2-Class. 

DN '((mx-rdf-type . mx-rdf-Datatype. 

PN '((mx-rdf-type . '(mx-rdf-owl2-ObjectProperty. 

R '((mx-rdf-type . '(mx-rdf-owl2-DatatypeProperty. 

A '((mx-rdf-type . '(mx-rdf-owl2-AnnotationProperty. 

aN '((mx-rdf-type . '(mx-rdf-owl2-NamedIndividual. 

@prefix p U. 

'((mx-rdf-type . '((mx-rdf-type . rdf:Property .

'((mx-rdf-type . mx-rdf-domain mx-rdfs-resource .

'((mx-rdf-type . mx-rdf-range 'mx-rdfs-class) .

mx-rdf-Datatype mx-rdfs-subClassOf 'mx-rdfs-class) .

mx-rdf-isDefinedBy mx-rdf-subPropertyOf mx-rdf-seeAlso .

I('((mx-rdf-type .) ∈ ICEXT(I(rdf:Property)) ,

IEXT(I('((mx-rdf-type .)) ⊆ ICEXT(I(mx-rdfs-resource)) × ICEXT(I('mx-rdfs-class))) ,

ICEXT(I(mx-rdf-Datatype)) ⊆ ICEXT(I('mx-rdfs-class))) ,

IEXT(I(mx-rdf-isDefinedBy)) ⊆ IEXT(I(mx-rdf-seeAlso)) . 

I('(mx-rdf-owl2-FunctionalProperty) ∈ IC 

'(mx-rdf-owl2-FunctionalProperty '((mx-rdf-type . 'mx-rdfs-class) .

ICEXT(I('(mx-rdf-owl2-FunctionalProperty)) ⊆ IP 

'(mx-rdf-owl2-FunctionalProperty mx-rdfs-subClassOf rdf:Property .

E '((mx-rdf-type . mx-rdf-Datatype .

E mx-rdfs-subClassOf mx-rdf-Literal .

I('(mx-rdf-owl2-disjointWith) ∈ IP 

'(mx-rdf-owl2-disjointWith '((mx-rdf-type . rdf:Property .

IEXT(I('(mx-rdf-owl2-disjointWith)) ⊆ IC × IC 

'(mx-rdf-owl2-disjointWith mx-rdf-domain '(mx-rdf-owl2-Class .

'(mx-rdf-owl2-disjointWith mx-rdf-range '(mx-rdf-owl2-Class .

E '((mx-rdf-type . '(mx-rdf-owl2-DatatypeProperty .

E mx-rdf-domain mx-rdfs-resource .

E mx-rdf-range mx-rdf-Literal .
(defun  sparql							 :sparql:rdf:
(defun (defun  DONE tracker-sparql					 :sparql:rdf:
(defun (defun  DONE tracker-sparql -q "SELECT ?cl WHERE { ?cl a 'mx-rdfs-class) }"
Results:
  http://www.w3.org/2001/XMLSchema#string
  http://www.w3.org/2001/XMLSchema#boolean
  http://www.w3.org/2001/XMLSchema#integer
  http://www.w3.org/2001/XMLSchema#double
  http://www.w3.org/2001/XMLSchema#date
  http://www.w3.org/2001/XMLSchema#dateTime
  http://www.w3.org/2000/01/rdf-schema#Resource
  http://www.w3.org/2000/01/rdf-schema#Class
  http://www.w3.org/1999/02/22-rdf-syntax-ns#Property
  http://www.w3.org/2000/01/rdf-schema#Literal
  http://www.tracker-project.org/ontologies/tracker#Namespace
  http://www.tracker-project.org/ontologies/tracker#Ontology
  http://www.semanticdesktop.org/ontologies/2007/08/15/nrl#InverseFunctionalProperty
  http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataObject
  http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataSource
  http://www.semanticdesktop.org/ontologies/2007/01/19/nie#InformationElement
  http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Tag
  http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Property
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Role
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Affiliation
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Contact
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactGroup
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactList
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactMedium
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#EmailAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAccount
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#OrganizationContact
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PersonContact
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PostalAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ModemNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#MessagingNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PagerNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Gender
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VoicePhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VideoTelephoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IsdnNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ParcelDeliveryAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#FaxNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CarPhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactListDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PcsNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#InternationalDeliveryAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#BbsNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CellPhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#DomesticDeliveryAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PresenceStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMCapability
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#AuthorizationStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Document
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Software
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Media
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Visual
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Image
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RasterImage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DataContainer
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemotePortAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaFileListEntry
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#VectorImage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Audio
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#CompressionType
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Icon
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#TextDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PlainTextDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HtmlDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#OperatingSystem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaList
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Executable
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Folder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Font
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Filesystem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareService
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareItem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Presentation
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemoteDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PaginatedTextDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Video
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Spreadsheet
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Trash
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileHash
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SourceCode
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Application
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#EmbeddedFileDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Attachment
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#ArchiveItem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Archive
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MindMap
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaStream
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#BookmarkFolder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FilesystemImage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HardDiskPartition
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Cursor
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Bookmark
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DeletedResource
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Website
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#WebHistory
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Note
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareCategory
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareApplication
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Orientation
  http://www.tracker-project.org/ontologies/poi#ObjectOfInterest
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Equipment
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HelpDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterest
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterestContent
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MimePart
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Multipart
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Message
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Email
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Attachment
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailAccount
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailboxDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MessageHeader
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#IMMessage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Conversation
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#CommunicationChannel
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PermanentChannel
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#TransientChannel
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Call
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#VOIPCall
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailFolder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#SMSMessage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessageFolder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#DeliveryStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#ReportReadStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MMSMessage
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#UnionParentClass
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifier
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttachmentEncoding
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#EventStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceFrequency
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attachment
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AccessClassification
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarDataObject
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#JournalStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifierRange
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeOrOrganizer
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AlarmAction
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceRule
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TodoStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimeTransparency
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalTimeEntity
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarScale
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeRole
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#BydayRulePart
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Weekday
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Trigger
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyType
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarUserType
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#ParticipationStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RequestStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalDateTime
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimezoneObservance
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Organizer
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attendee
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalPeriod
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Calendar
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyPeriod
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TriggerRelation
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Alarm
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Event
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Todo
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Freebusy
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Journal
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Timezone
  http://www.tracker-project.org/temp/scal#Calendar
  http://www.tracker-project.org/temp/scal#CalendarItem
  http://www.tracker-project.org/temp/scal#TransparencyValues
  http://www.tracker-project.org/temp/scal#Attendee
  http://www.tracker-project.org/temp/scal#AttendanceStatus
  http://www.tracker-project.org/temp/scal#AttendeeRole
  http://www.tracker-project.org/temp/scal#RSVPValues
  http://www.tracker-project.org/temp/scal#CalendarUserType
  http://www.tracker-project.org/temp/scal#Event
  http://www.tracker-project.org/temp/scal#Todo
  http://www.tracker-project.org/temp/scal#Journal
  http://www.tracker-project.org/temp/scal#EventStatus
  http://www.tracker-project.org/temp/scal#TodoStatus
  http://www.tracker-project.org/temp/scal#JournalStatus
  http://www.tracker-project.org/temp/scal#CalendarAlarm
  http://www.tracker-project.org/temp/scal#TimePoint
  http://www.tracker-project.org/temp/scal#AccessLevel
  http://www.tracker-project.org/temp/scal#RecurrenceRule
  http://www.semanticdesktop.org/ontologies/2007/05/10/nid3#ID3Audio
  http://www.tracker-project.org/temp/nmm#MusicPiece
  http://www.tracker-project.org/temp/nmm#MusicAlbum
  http://www.tracker-project.org/temp/nmm#MusicAlbumDisc
  http://www.tracker-project.org/temp/nmm#SynchronizedText
  http://www.tracker-project.org/temp/nmm#Video
  http://www.tracker-project.org/temp/nmm#Artist
  http://www.tracker-project.org/temp/nmm#Playlist
  http://www.tracker-project.org/temp/nmm#ImageList
  http://www.tracker-project.org/temp/nmm#Photo
  http://www.tracker-project.org/temp/nmm#Flash
  http://www.tracker-project.org/temp/nmm#MeteringMode
  http://www.tracker-project.org/temp/nmm#WhiteBalance
  http://www.tracker-project.org/temp/nmm#RadioStation
  http://www.tracker-project.org/temp/nmm#DigitalRadio
  http://www.tracker-project.org/temp/nmm#AnalogRadio
  http://www.tracker-project.org/temp/nmm#RadioModulation
  http://www.tracker-project.org/temp/mto#TransferElement
  http://www.tracker-project.org/temp/mto#Transfer
  http://www.tracker-project.org/temp/mto#UploadTransfer
  http://www.tracker-project.org/temp/mto#DownloadTransfer
  http://www.tracker-project.org/temp/mto#SyncTransfer
  http://www.tracker-project.org/temp/mto#State
  http://www.tracker-project.org/temp/mto#TransferMethod
  http://www.tracker-project.org/temp/mlo#GeoLocation
  http://www.tracker-project.org/temp/mlo#GeoPoint
  http://www.tracker-project.org/temp/mlo#GeoSphere
  http://www.tracker-project.org/temp/mlo#GeoBoundingBox
  http://www.tracker-project.org/temp/mlo#LocationBoundingBox
  http://www.tracker-project.org/temp/mlo#Route
  http://www.tracker-project.org/temp/mlo#LandmarkCategory
  http://www.tracker-project.org/temp/mlo#Landmark
  http://www.tracker-project.org/temp/mlo#PointOfInterest
  http://www.tracker-project.org/temp/mfo#FeedElement
  http://www.tracker-project.org/temp/mfo#FeedChannel
  http://www.tracker-project.org/temp/mfo#FeedMessage
  http://www.tracker-project.org/temp/mfo#Enclosure
  http://www.tracker-project.org/temp/mfo#FeedSettings
  http://www.tracker-project.org/temp/mfo#Action
  http://www.tracker-project.org/temp/mfo#FeedType
  http://www.tracker-project.org/temp/mtp#ScanType
  http://www.tracker-project.org/ontologies/tracker#Volume
  http://www.tracker-project.org/temp/slo#LandmarkCategory
  http://www.tracker-project.org/temp/slo#Landmark
  http://www.tracker-project.org/temp/slo#GeoLocation
  http://www.tracker-project.org/temp/slo#Route
  http://www.tracker-project.org/ontologies/osinfo#Installer

(defun (defun  DONE tracker-sparql -q "SELECT ?prefix ?ns WHERE {
   >                     ?ns a tracker:Namespace ;
   >                     tracker:prefix ?prefix
   >                 }"
Results:
  xsd, http://www.w3.org/2001/XMLSchema#
  rdf, http://www.w3.org/1999/02/22-rdf-syntax-ns#
  rdfs, http://www.w3.org/2000/01/rdf-schema#
  tracker, http://www.tracker-project.org/ontologies/tracker#
  nrl, http://www.semanticdesktop.org/ontologies/2007/08/15/nrl#
  dc, http://purl.org/dc/elements/1.1/
  nie, http://www.semanticdesktop.org/ontologies/2007/01/19/nie#
  nao, http://www.semanticdesktop.org/ontologies/2007/08/15/nao#
  nco, http://www.semanticdesktop.org/ontologies/2007/03/22/nco#
  nfo, http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#
  poi, http://www.tracker-project.org/ontologies/poi#
  nmo, http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#
  ncal, http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#
  scal, http://www.tracker-project.org/temp/scal#
  nid3, http://www.semanticdesktop.org/ontologies/2007/05/10/nid3#
  nmm, http://www.tracker-project.org/temp/nmm#
  mto, http://www.tracker-project.org/temp/mto#
  mlo, http://www.tracker-project.org/temp/mlo#
  mfo, http://www.tracker-project.org/temp/mfo#
  mtp, http://www.tracker-project.org/temp/mtp#
  fts, http://www.tracker-project.org/ontologies/fts#
  slo, http://www.tracker-project.org/temp/slo#
  osinfo, http://www.tracker-project.org/ontologies/osinfo#

(defun (defun  CONSTRUCT
    "The CONSTRUCT query form returns a single RDF graph
    specified by a graph template. The result is an RDF graph
    formed by taking each query solution in the solution
    sequence, substituting for the variables in the graph
    template, and combining the triples into a single RDF
    graph by set union."
(defvar begin_src sparql
CONSTRUCT {
    where xk:role ("?chapel" "?leader")
    '(mx-rdf-owl2-Exclusion "?anti-chapel"
    , '(mx-rdf-owl2-Related "?chancel"
    , '(mx-rdf-owl2-Members ("?altar" "?choir")
    }
(defvar end_src
(defun  elisp							      :elisp:
(defun  (if TRUE-OR-FALSE-TEST ACTION-TO-CARRY-OUT-IF-TEST-IS-TRUE)

(defvar BEGIN_SRC emacs-lisp
(if (> 5 4)                             ; if-part
    (message "5 is greater than 4!"))   ; then-part
(defvar END_SRC

(defvar BEGIN_SRC emacs-lisp
(defun type-of-animal (characteristic)
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger."
       (if (equal characteristic 'fierce)
           (message "It's a tiger!")))

(type-of-animal 'fierce)

(type-of-animal 'zebra)

(defvar END_SRC

(defvar BEGIN_EXAMPLE
(defun NAME-OF-FUNCTION (ARGUMENT-LIST)
       "DOCUMENTATION..."
       BODY...)
(defvar END_EXAMPLE

(defvar BEGIN_EXAMPLE
(defun type-of-animal (characteristic)
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger."
       BODY: THE `if' EXPRESSION)
(defvar END_EXAMPLE

(defun  (let VARLIST BODY)

(defvar begin_example
(let ((VARIABLE VALUE)
           (VARIABLE VALUE)
           ...)
       BODY...)
(defvar end_example

(defvar begin_src emacs-lisp
(let ((zebra 'stripes)
      (tiger 'fierce))
  (message "One kind of animal has %s and another is %s."
           zebra tiger))
(defvar end_src

(defun  TODO problems with macros					      :debug:
(defun (defun  repeated expansion (how many times is the macro expanded?)
Captured [2014-06-06 Fri 18:47]
  13.5.5 How Many Times is the Macro Expanded?
  --------------------------------------------
  
  Occasionally problems result from the fact that a macro call is
  expanded each time it is evaluated in an interpreted function, but is
  expanded only once (during compilation) for a compiled function.  If the
  macro definition has side effects, they will work differently depending
  on how many times the macro is expanded.
  
     Therefore, you should avoid side effects in computation of the macro
  expansion, unless you really know what you are doing.
  
     One special kind of side effect can't be avoided: constructing Lisp
  objects.  Almost all macro expansions include constructed lists; that is
  the whole point of most macros.  This is usually safe; there is just one
  case where you must be careful: when the object you construct is part
  of a quoted constant in the macro expansion.
  
     If the macro is expanded just once, in compilation, then the object
  is constructed just once, during compilation.  But in interpreted
  execution, the macro is expanded each time the macro call runs, and this
  means a new object is constructed each time.
  
     In most clean Lisp code, this difference won't matter.  It can matter
  only if you perform side-effects on the objects constructed by the macro
  definition.  Thus, to avoid trouble, (defun avoid side effects on objects
  constructed by macro definitions(defun .  Here is an example of how such side
  effects can get you into trouble:
  
       (defmacro empty-object ()
         (list 'quote (cons nil nil)))
  
       (defun initialize (condition)
         (let ((object (empty-object)))
           (if condition
               (setcar object condition))
           object))
  
  If `initialize' is interpreted, a new list `(nil)' is constructed each
  time `initialize' is called.  Thus, no side effect survives between
  calls.  If `initialize' is compiled, then the macro `empty-object' is
  expanded during compilation, producing a single "constant" `(nil)' that
  is reused and altered each time `initialize' is called.
(defun (defun  think of 'empty-object' as a funny kind of constant  
     One way to avoid pathological cases like this is to think of
  `empty-object' as a funny kind of constant, not as a memory allocation
  construct.  You wouldn't use `setcar' on a constant such as `'(nil)',
  so naturally you won't use it on `(empty-object)' either.
  
  [[info:elisp#Repeated%20Expansion][info:elisp#Repeated Expansion]]

empty-object is not a memory allocation construct

(defun (defun  evaluating macro arguments in expansion
Captured [2014-06-06 Fri 18:46]
  13.5.4 Evaluating Macro Arguments in Expansion
  ----------------------------------------------
  
  Another problem can happen if the macro definition itself evaluates any
  of the macro argument expressions, such as by calling `eval' ((defun note
  Eval::).  If the argument is supposed to refer to the user's variables,
  you may have trouble if the user happens to use a variable with the
  same name as one of the macro arguments.  Inside the macro body, the
  macro argument binding is the most local binding of this variable, so
  any references inside the form being evaluated do refer to it.  Here is
  an example:
  
       (defmacro foo (a)
         (list 'setq (eval a) t))
       (setq x 'b)
       (foo x) ==> (setq b t)
            => t                  ; and `b' has been set.
       ;; but
       (setq a 'c)
       (foo a) ==> (setq a t)
            => t                  ; but this set `a', not `c'.
  
     It makes a difference whether the user's variable is named `a' or
  `x', because `a' conflicts with the macro argument variable `a'.
  
     Another problem with calling `eval' in a macro definition is that it
  probably won't do what you intend in a compiled program.  The byte
  compiler runs macro definitions while compiling the program, when the
  program's own computations (which you might have wished to access with
  `eval') don't occur and its local variable bindings don't exist.
(defun (defun  don't evaluate an argument expression while computing the macro expansion  
       To avoid these problems, (defun don't evaluate an argument expression
    while computing the macro expansion(defun .  Instead, substitute the
    expression into the macro expansion, so that its value will be computed
    as part of executing the expansion.  This is how the other examples in
    this chapter work.
    
    [[info:elisp#Eval%20During%20Expansion][info:elisp#Eval During Expansion]]

(defun (defun  local variables in macro expansions
Captured [2014-06-06 Fri 18:45]
  13.5.3 Local Variables in Macro Expansions
  ------------------------------------------
  
  In the previous section, the definition of `for' was fixed as follows
  to make the expansion evaluate the macro arguments the proper number of
  times:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple for loop: (for i from 1 to 10 do (print i))."
         `(let ((,var ,init)
                (max ,final))
            (while (<= ,var max)
              ,@body
              (inc ,var))))
  
  The new definition of `for' has a new problem: it introduces a local
  variable named `max' which the user does not expect.  This causes
  trouble in examples such as the following:
  
       (let ((max 0))
         (for x from 0 to 10 do
           (let ((this (frob x)))
             (if (< max this)
                 (setq max this)))))
  
  The references to `max' inside the body of the `for', which are
  supposed to refer to the user's binding of `max', really access the
  binding made by `for'.
  
     The way to correct this is to use an uninterned symbol instead of
  `max' ((defun note Creating Symbols::).  The uninterned symbol can be bound
  and referred to just like any other symbol, but since it is created by
  `for', we know that it cannot already appear in the user's program.
  Since it is not interned, there is no way the user can put it into the
  program later.  It will never appear anywhere except where put by
  `for'.  Here is a definition of `for' that works this way:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple for loop: (for i from 1 to 10 do (print i))."
         (let ((tempvar (make-symbol "max")))
           `(let ((,var ,init)
                  (,tempvar ,final))
              (while (<= ,var ,tempvar)
                ,@body
                (inc ,var)))))
  
  This creates an uninterned symbol named `max' and puts it in the
  expansion instead of the usual interned symbol `max' that appears in
  expressions ordinarily.
  
  [[info:elisp#Surprising%20Local%20Vars][info:elisp#Surprising Local Vars]]

(defun (defun  evaluating macro arguments repeatedly
Captured [2014-06-06 Fri 18:44]
  File: elisp.info,  Node: Argument Evaluation,  Next: Surprising Local Vars,  Prev: Wrong Time,  Up: Problems with Macros
  
  13.5.2 Evaluating Macro Arguments Repeatedly
  --------------------------------------------
  
  When defining a macro you must pay attention to the number of times the
  arguments will be evaluated when the expansion is executed.  The
  following macro (used to facilitate iteration) illustrates the problem.
  This macro allows us to write a "for" loop construct.
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple \"for\" loop.
       For example, (for i from 1 to 10 do (print i))."
         (list 'let (list (list var init))
               (cons 'while
                     (cons (list '<= var final)
                           (append body (list (list 'inc var)))))))
  
       (for i from 1 to 3 do
          (setq square ((defun  i i))
          (princ (format "\n%d %d" i square)))
       ==>
       (let ((i 1))
         (while (<= i 3)
           (setq square ((defun  i i))
           (princ (format "\n%d %d" i square))
           (inc i)))
  
            -|1       1
            -|2       4
            -|3       9
       => nil
  
  The arguments `from', `to', and `do' in this macro are "syntactic
  sugar"; they are entirely ignored.  The idea is that you will write
  noise words (such as `from', `to', and `do') in those positions in the
  macro call.
  
     Here's an equivalent definition simplified through use of backquote:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple \"for\" loop.
       For example, (for i from 1 to 10 do (print i))."
         `(let ((,var ,init))
            (while (<= ,var ,final)
              ,@body
              (inc ,var))))
  
     Both forms of this definition (with backquote and without) suffer
  from the defect that FINAL is evaluated on every iteration.  If FINAL
  is a constant, this is not a problem.  If it is a more complex form,
  say `(long-complex-calculation x)', this can slow down the execution
  significantly.  If FINAL has side effects, executing it more than once
  is probably incorrect.
  
     A well-designed macro definition takes steps to avoid this problem by
  producing an expansion that evaluates the argument expressions exactly
  once unless repeated evaluation is part of the intended purpose of the
  macro.  Here is a correct expansion for the `for' macro:
  
       (let ((i 1)
             (max 3))
         (while (<= i max)
           (setq square ((defun  i i))
           (princ (format "%d      %d" i square))
           (inc i)))
  
     Here is a macro definition that creates this expansion:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple for loop: (for i from 1 to 10 do (print i))."
         `(let ((,var ,init)
                (max ,final))
            (while (<= ,var max)
              ,@body
              (inc ,var))))
  
     Unfortunately, this fix introduces another problem, described in the
  following section.
  
  [[info:elisp#Argument%20Evaluation][info:elisp#Argument Evaluation]]

(defun (defun  wrong time
Captured [2014-06-06 Fri 18:43]
  13.5.1 Wrong Time
  -----------------
  
  The most common problem in writing macros is doing some of the real
  work prematurely--while expanding the macro, rather than in the
  expansion itself.  For instance, one real package had this macro
  definition:
  
       (defmacro my-set-buffer-multibyte (arg)
         (if (fboundp 'set-buffer-multibyte)
             (set-buffer-multibyte arg)))
  
     With this erroneous macro definition, the program worked fine when
  interpreted but failed when compiled.  This macro definition called
  `set-buffer-multibyte' during compilation, which was wrong, and then
  did nothing when the compiled package was run.  The definition that the
  programmer really wanted was this:
  
       (defmacro my-set-buffer-multibyte (arg)
         (if (fboundp 'set-buffer-multibyte)
             `(set-buffer-multibyte ,arg)))
  
  This macro expands, if appropriate, into a call to
  `set-buffer-multibyte' that will be executed when the compiled program
  is actually run.
  [[info:elisp#Wrong%20Time][info:elisp#Wrong Time]]

(defun  kill ring concepts
Captured [2014-06-06 Fri 14:00]
  32.8.1 Kill Ring Concepts
  -------------------------
  
  The kill ring records killed text as strings in a list, most recent
  first.  A short kill ring, for example, might look like this:
  
       ("some text" "a different piece of text" "even older text")
  
  When the list reaches `kill-ring-max' entries in length, adding a new
  entry automatically deletes the last entry.
  
     When kill commands are interwoven with other commands, each kill
  command makes a new entry in the kill ring.  Multiple kill commands in
  succession build up a single kill ring entry, which would be yanked as a
  unit; the second and subsequent consecutive kill commands add text to
  the entry made by the first one.
  
     For yanking, one entry in the kill ring is designated the "front" of
  the ring.  Some yank commands "rotate" the ring by designating a
  [[info:elisp#Kill%20Ring%20Concepts][info:elisp#Kill Ring Concepts]]

(defun  (setq list (cons newelt list))
(defun  use of a special variable as a formal argument in a function 
     is discouraged.
(defun  resist the temptation to use error handling to transfer control
 Resist the temptation to use error handling to transfer control from
one part of the program to another; use `catch' and `throw' instead.
(defun Note Catch and Throw::.
(defun  TODO function definitions
     It is helpful to think of the five parts of a function definition
     as being organized in a template, with slots for each part:

       (defun FUNCTION-NAME (ARGUMENTS...)
       	 "OPTIONAL-DOCUMENTATION..."
       	 (interactive ARGUMENT-PASSING-INFO)     ; optional
       	 BODY...)

(defun (defun  the 5 parts
      function-name
      arguments
      optional-documentation
      argument-passing-info
      body

(defun  TODO errors						:elisp:debug:
(defun (defun  10.5.3.4 Error Symbols and Condition Names
Captured [2014-06-01 Sun 22:33]
  File: elisp.info,  Node: Error Symbols,  Prev: Handling Errors,  Up: Errors
  
  10.5.3.4 Error Symbols and Condition Names
  ..........................................
  
  When you signal an error, you specify an "error symbol" to specify the
  kind of error you have in mind.  Each error has one and only one error
  symbol to categorize it.  This is the finest classification of errors
  defined by the Emacs Lisp language.
  
     These narrow classifications are grouped into a hierarchy of wider
  classes called "error conditions", identified by "condition names".
  The narrowest such classes belong to the error symbols themselves: each
  error symbol is also a condition name.  There are also condition names
  for more extensive classes, up to the condition name `error' which
  takes in all kinds of errors (but not `quit').  Thus, each error has
  one or more condition names: `error', the error symbol if that is
  distinct from `error', and perhaps some intermediate classifications.
  
     In order for a symbol to be an error symbol, it must have an
  `error-conditions' property which gives a list of condition names.
  This list defines the conditions that this kind of error belongs to.
  (The error symbol itself, and the symbol `error', should always be
  members of this list.)  Thus, the hierarchy of condition names is
  defined by the `error-conditions' properties of the error symbols.
  Because quitting is not considered an error, the value of the
  `error-conditions' property of `quit' is just `(quit)'.
  
     In addition to the `error-conditions' list, the error symbol should
  have an `error-message' property whose value is a string to be printed
  when that error is signaled but not handled.  If the error symbol has
  no `error-message' property or if the `error-message' property exists,
  but is not a string, the error message `peculiar error' is used.  (defun Note
  Definition of signal::.
  
     Here is how we define a new error symbol, `new-error':
  
       (put 'new-error
            'error-conditions
            '(error my-own-errors new-error))
       => (error my-own-errors new-error)
       (put 'new-error 'error-message "A new error")
       => "A new error"
  
  This error has three condition names: `new-error', the narrowest
  classification; `my-own-errors', which we imagine is a wider
  classification; and `error', which is the widest of all.
  
     The error string should start with a capital letter but it should
  not end with a period.  This is for consistency with the rest of Emacs.
  
     Naturally, Emacs will never signal `new-error' on its own; only an
  explicit call to `signal' ((defun note Definition of signal::) in your code
  can do this:
  
       (signal 'new-error '(x y))
            error--> A new error: x, y
  
     This error can be handled through any of the three condition names.
  This example handles `new-error' and any other errors in the class
  `my-own-errors':
  
       (condition-case foo
           (bar nil t)
         (my-own-errors nil))
  
     The significant way that errors are classified is by their condition
  names--the names used to match errors with handlers.  An error symbol
  serves only as a convenient way to specify the intended error message
  and list of condition names.  It would be cumbersome to give `signal' a
  list of condition names rather than one error symbol.
  
     By contrast, using only error symbols without condition names would
  seriously decrease the power of `condition-case'.  Condition names make
  it possible to categorize errors at various levels of generality when
  you write an error handler.  Using error symbols alone would eliminate
  all but the narrowest level of classification.
  
     (defun Note Standard Errors::, for a list of the main error symbols and
  their conditions.
  
  [[info:elisp#Error%20Symbols][info:elisp#Error Symbols]]

(defun  Completion::M-TAB knows what you need

     Emacs would not be Emacs without completion, and Org mode uses it
     whenever it makes sense.  If you prefer an iswitchb- or ido-like
     interface for some of the completion prompts, you can specify your
     preference by setting at most one of the variables
     `org-completion-use-iswitchb' `org-completion-use-ido'.

     Org supports in-buffer completion.  This type of completion does not
     make use of the minibuffer.  You simply type a few letters into the
     buffer and use the key to complete text right there.

     `M-<TAB>'
     Complete word at point
          (defun  At the beginning of a headline, complete TODO keywords.

          (defun  After `\', complete TeX symbols supported by the exporter.

          (defun  After `(defun ', complete headlines in the current buffer so that
            they can be used in search links 
	    like `[[(defun find this headline]]'.

          (defun  After `:' in a headline, complete tags.  The list of tags is
            taken from the variable `org-tag-alist' (possibly set through
            the `(defvar TAGS' in-buffer option, (defun note Setting tags::), or it
            is created dynamically from all tags used in the current
            buffer.

          (defun  After `:' and not in a headline, complete property keys.  The
            list of keys is constructed dynamically from all keys used in
            the current buffer.

          (defun  After `[', complete link abbreviations 
	    ((defun note Link abbreviations::).

          (defun  After `(defvar ', complete the special keywords like `TYP_TODO' or
            `OPTIONS' which set file-specific options for Org mode.  When
            the option keyword is already complete, pressing `M-<TAB>'
            again will insert example settings for this keyword.

          (defun  In the line after `(defvar STARTUP: ', complete startup keywords,
            i.e., valid keys for this line.

          (defun  Elsewhere, complete dictionary words using Ispell.

(defun  (defun we discourage redefinition of primitive functions(defun 

(defun  catch and throw example
Captured [2014-06-06 Fri 11:26]
  (defun search-foo ()
         (catch 'loop
           (let ((i 0))
             (while (< i 10)
               (let ((j 0))
                 (while (< j 10)
                   (if (foo i j)
                       (throw 'loop (list i j)))
                   (setq j (1+ j))))
               (setq i (1+ i))))))
  [[info:elisp#Examples%20of%20Catch][info:elisp#Examples of Catch]]

(defun  xml and n3
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

introduce org-babel to mx-rdf xml n3

(defvar begin_src emacs-lisp :results silent
(require 'ob)
(add-to-list 'org-babel-interpreters "mx-rdf")  
(add-to-list 'org-babel-interpreters "xml")
(add-to-list 'org-babel-interpreters "n3")
(defvar end_src

inform org-babel-tangle of their existence and file extensions
(defvar begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
(defvar end_src

(defvar begin_src xml :tangle example
  <first>
  </first>
(defvar end_src

(defvar begin_src n3 :tangle example
  n3 stuff
(defvar end_src

(defun  custom query of user before evaluating code block
   :PROPERTIES:
   :DATE:     2012-02-08
   :END:
(defvar begin_src sh :eval (if (y-or-n-p "Run operation X?") "yes" "no")
  echo "Going ahead with operation X!"
(defvar end_src
(defun  call line which dumps out its own header argument info
   :PROPERTIES:
   :DATE:     2012-02-05
   :END:
This call line passes its in-buffer location to a code block.  Notice
that the call to =(point)= in the call line is saved into a header
argument named =:my-point= and is then retrieved by the variable
initialization.  This indirection is required because of /when/ and
/where/ the elisp forms in header arguments are evaluated, a simpler
call line like =(defvar call: show:((point))= would not work because the
form =(point)= would not be evaluated in the correct place.

(defvar call: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info)))) :special-header "foo"

The special header argument =:special-header= may be seen in the
output below.  The =results= variable is due to the way that call
lines are evaluated.  During evaluation a call line is converted into
a trivial elisp code block of the form
: (defvar begin_src emacs-lisp :var results=called-function()
:   results
: (defvar end_src
which is evaluated in place.

(defvar RESULTS: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info))))
| (:var results ((:var nil)) ((:colname-names)) ((:rowname-names)) ((:result-params replace)) ((:result-type . value)) ((:comments . )) ((:shebang . )) ((:cache . no)) ((:padline . )) ((:noweb . yes)) ((:tangle . no)) ((:exports . code)) ((:results . replace)) ((:padnewline . yes)) ((:hlines . no)) ((:session . none))) |
| (:colname-names)                                                                                                                                                                                                                                                                                                               |
| (:rowname-names)                                                                                                                                                                                                                                                                                                               |
| (:result-params replace)                                                                                                                                                                                                                                                                                                       |
| (:result-type . value)                                                                                                                                                                                                                                                                                                         |
| (:comments . )                                                                                                                                                                                                                                                                                                                 |
| (:shebang . )                                                                                                                                                                                                                                                                                                                  |
| (:cache . no)                                                                                                                                                                                                                                                                                                                  |
| (:padline . )                                                                                                                                                                                                                                                                                                                  |
| (:noweb . yes)                                                                                                                                                                                                                                                                                                                 |
| (:tangle . no)                                                                                                                                                                                                                                                                                                                 |
| (:exports . code)                                                                                                                                                                                                                                                                                                              |
| (:results . replace)                                                                                                                                                                                                                                                                                                           |
| (:special-header . foo)                                                                                                                                                                                                                                                                                                        |
| (:padnewline . yes)                                                                                                                                                                                                                                                                                                            |
| (:hlines . no)                                                                                                                                                                                                                                                                                                                 |
| (:session . none)                                                                                                                                                                                                                                                                                                              |

This code block visits the location of the call line, and calculates
the info using the same mechanisms used by =org-babel-lob-execute=.
(defvar name: show
(defvar begin_src emacs-lisp :var call-line-location=0
  (let ((call-info (save-excursion
                     (goto-char call-line-location)
                     (org-babel-lob-get-info))))
    (mapcar #'list
            (org-babel-process-params
             (org-babel-merge-params
              org-babel-default-header-args
              (org-babel-params-from-properties)
              (org-babel-parse-header-arguments
               (org-babel-clean-text-properties
                (concat ":var results="
                        (mapconcat #'identity (butlast call-info) " "))))))))
(defvar end_src
(defun  noweb insertion edge cases
   :PROPERTIES:
   :DATE:     2012-01-24
   :END:
The =cat= line below is dangerously close to a noweb reference.  The
space after test.org keeps it from being interpreted as a noweb
reference.

(defvar begin_src sh :tangle test.out :noweb yes
  <<task1>>
  <<b>>
  cat <<test.org >> test.out2
(defvar end_src

(defvar begin_src sh :noweb-ref task1
 echo "hello world"
(defvar end_src

(defvar BEGIN_SRC sh :noweb-ref b
 echo "b"
(defvar END_SRC

(defun  issues with call lines result insertion
   :PROPERTIES:
   :session:  (defun R-babel(defun 
   :DATE:     2012-01-24
   :END:
(defvar NAME: foo-for-R
(defvar HEADER: :var a="a1.png"
(defvar BEGIN_SRC R :results output silent
  cat("in foo-for-R block\n")
  cat.a <- function() { cat(a,"\n",sep="") }
  cat.a()
(defvar END_SRC

(defvar NAME: bar-for-R
(defvar begin_src R :results output raw replace :exports none
 cat.a()
(defvar end_src

Because there are three instances of the =bar-for-R()= call line, all
of their results are inserted into the same place in the file,
specifically the location of the =(defvar Results: bar-for-R()= line.  This
can be very confusing if you are expected each =bar-for-R()= line to
generate it's own results.

Should have all a1 stuff
(defvar call: foo-for-R(a="a1.png")
(defvar call: bar-for-R()

Should have all a2 stuff
(defvar call: foo-for-R(a="a2.png")
(defvar call: bar-for-R()

Should have all a3 stuff
(defvar call: foo-for-R(a="a3.png")
(defvar call: bar-for-R()

The solution demonstrated below is to add a nothing header argument to
each bar-for-R to make it unique.  Notice that the three =foo= lines
below don't include results, as their results are inserted at the
identical foo lines above.

Should have all a1 stuff
(defvar call: foo-for-R(a="a1.png")
(defvar call: bar-for-R[id=1]()

Should have all a2 stuff
(defvar call: foo-for-R(a="a2.png")
(defvar call: bar-for-R[id=2]()

Should have all a3 stuff
(defvar call: foo-for-R(a="a3.png")
(defvar call: bar-for-R[id=3]()

(defun  name src_emacs-lisp{org-current-export-file}
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
Fanciness with running code in header arguments.

One block to tangle.
(defvar BEGIN_SRC emacs-lisp :tangle yes
  (message "I am tangled")
(defvar END_SRC

One block to export.
(defvar BEGIN_SRC emacs-lisp :exports results :var foo=(org-babel-tangle)
  (message "I just tangled %S during export" foo)
(defvar END_SRC

(defun  inhibit some call line evaluation on export
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
A buffer in which we want =foo= to be run when called interactively
from /any/ call line, but to only be run by a single call line on
export.  Ensure this works by executing this buffer to html while
tracking =foo-called.times= with =tail -f /tmp/foo-called.times=.

(defvar NAME: foo
(defvar BEGIN_SRC sh :var id="foo"
  echo "called by $id at $(date +%s.%N)" |tee -a /tmp/foo-called.times
(defvar END_SRC

This will (defun not(defun  be run on export.
(defvar call: foo[:eval no-export]("bar")

This (defun will(defun  be run on export.
(defvar call: foo("baz")

(defun  code block export template
   :PROPERTIES:
   :DATE:     2012-01-14
   :END:

The =org-babel-exp-code-template= (see below for its documentation)
variable may be customized to control which information from code
blocks is exported.

- Example code block
  (defvar Name: foo
  (defvar BEGIN_SRC sh :bar baz
    echo qux
  (defvar END_SRC

- Evaluate this block to export (shows the export of the name).
  (defvar Name: do-export-name
  (defvar BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "\n=%name=:\n(defvar BEGIN_SRC %lang%flags\n%body\n(defvar END_SRC"))
      (org-export-as-html nil))
  (defvar END_SRC

- Evaluate this block to export (shows the export of header arguments).
  (defvar Name: do-export-header-arguments
  (defvar BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "Header arguments for =%name=.
    | header  | value    |
    |---------+----------|
    | bar     | %bar     |
    | results | %results |\n(defvar BEGIN_SRC %lang%flags\n%body\n(defvar END_SRC"))
      (org-export-as-html nil))
  (defvar END_SRC

: ,----[org-babel-exp-code-template]
: | org-babel-exp-code-template is a variable defined in `ob-exp.el'.
: | Its value is "(defvar BEGIN_SRC %lang%flags\n%body\n(defvar END_SRC"
: | 
: | Documentation:
: | Template used to export the body of code blocks.
: | This template may be customized to include additional information
: | such as the code block name, or the values of particular header
: | arguments.  The template is filled out using `org-fill-template',
: | and the following %keys may be used.
: | 
: |  lang ------ the language of the code block
: |  name ------ the name of the code block
: |  body ------ the body of the code block
: |  flags ----- the flags passed to the code block
: | 
: | In addition to the keys mentioned above, every header argument
: | defined for the code block may be used as a key and will be
: | replaced with its value.
: | 
: | You can customize this variable.
: `----

(defun  simple R session
   :PROPERTIES:
   :DATE:     2011-09-21
   :END:
(defvar begin_src R :session R
  paste("Yep!")
(defvar end_src

(defvar name:
: Yep!

(defun  should this throw an error for no variable definition
   :PROPERTIES:
   :DATE:     2011-09-15
   :END:
Evaluating this block should raise an error that there are
uninitialized variables.

(defvar name: add-column-in-table(table="", column="", something, type="", else, nullability)
(defvar begin_src sql
-- add column `$column' (if column does not exist yet)
IF NOT EXISTS (SELECT (defun 
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '$table'
               AND COLUMN_NAME = '$column')
BEGIN
    ALTER TABLE $table
    ADD $column $type $nullability
END
(defvar end_src

(defun  header arguments on call lines
   :PROPERTIES:
   :DATE:     2011-09-11
   :END:
(defvar name: simple-example
(defvar begin_src emacs-lisp
  "the result"
(defvar end_src

(defvar call: simple-example()

(defvar name: simple-example()
: the result

(defvar call: simple-example() :results raw

(defvar name: simple-example()
the result

(defun  removing result with a silent header argument
   :PROPERTIES:
   :DATE:     2011-09-07
   :END:
evaluating the following code block will remove the related result.

(defvar begin_src sh :results silent
  date +%Y-%m-%d
(defvar end_src

(defvar name:
: 2011-09-07

(defun  silent results in org but not in export
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
The results of the following code block will not be inserted during
interactive evaluation but will during export.

(defvar begin_src sh :results (if org-current-export-file "replace" "silent") :exports both
  echo  "I want to see this in HTML/PDF, but not in Org"
(defvar end_src

(defun  leading commas in code blocks
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
(defvar begin_src r :exports code
  a <- c(1
         , 2
         , 3)
(defvar end_src

(defvar begin_src org :exports code
  ,this one will have commas removed
  ,(defvar begin_src R
  ,  a <- c(1
  ,         , 2
  ,         , 3)
  ,(defvar end_src
(defvar end_src

(defun  returning file type to inline call line
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec
hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam
nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis
natoque penatibus et magnis dis parturient montes, nascetur ridiculus
mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non
turpis. call_nothing_to_something()[:results file] [[file:something.txt]]
Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan
nisl.

(defvar name: nothing_to_something
(defvar begin_src sh :file something.txt
  echo nothing
(defvar end_src

(defun  demarcation of indented blocks
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Demarcating a block with the point part-way in a line should indent
the remainder of the line in the second block.
    (defvar begin_src sh
      echo 1
      echo 2
      echo 3
      echo 4
    (defvar end_src

becomes

    (defvar begin_src sh :results silent :session something
      echo 1
      echo 2
      echo
    (defvar end_src
    
    (defvar begin_src sh :results silent :session something
           3
      echo 4
    (defvar end_src

(defun  simple indexing
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
(defvar name: list-o-numbers
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

(defvar begin_src sh :var column=list-o-numbers[,0]
  echo $column
(defvar end_src

(defvar name:
: 1 4 7

(defun  simple gnuplot plotting of Org-mode tables
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
(defvar tblname: gnuplot-testing
| x |  y |
|---+----|
| 1 |  2 |
| 2 |  4 |
| 3 |  6 |
| 4 |  8 |
| 5 | 10 |
| 6 | 12 |
| 7 | 14 |
| 8 | 16 |

(defvar begin_src gnuplot :var data=gnuplot-testing :file output.eps
set term postscript
set title "test"
set auto x
set style data histogram
set style fill solid border -1
set boxwidth 0.9
plot data using 2:xtic(1)
(defvar end_src

(defun  simple short R block
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
(defvar BEGIN_SRC R
c(1,23,54,5)
(defvar END_SRC

(defvar name:
|  1 |
| 23 |
| 54 |
|  5 |

(defun  convert results to all string
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
(defvar name: hetero-table
(defvar begin_src emacs-lisp
  '((1 2 3 4)
    ("a" "b" "c" "d"))
(defvar end_src

(defvar name: all-to-string
(defvar begin_src emacs-lisp :var tbl='()
  (defun all-to-string (tbl)
    (if (listp tbl)
        (mapcar #'all-to-string tbl)
      (if (stringp tbl)
          tbl
        (format "%s" tbl))))
  (all-to-string tbl)
(defvar end_src

(defvar begin_src emacs-lisp :var tbl=hetero-table
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
(defvar end_src

(defvar name:
| nil | nil | nil | nil |
| t   | t   | t   | t   |

(defvar begin_src emacs-lisp :var tbl=all-to-string(hetero-table)
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
(defvar end_src

(defvar name:
| t | t | t | t |
| t | t | t | t |

(defun  two blocks and a table
   :PROPERTIES:
   :DATE:     2011-08-28
   :END:

(defvar name: stuff
(defvar begin_src sh
  echo 1
  echo 2
  echo 3
(defvar end_src

(defvar name: last-of-stuff
(defvar begin_src sh :var input=stuff
  echo "$input" |tail -1
(defvar end_src

| one |
| two |
| 3   |
(defvar TBLFM: @3$1='(sbe last-of-stuff)

(defun  inheriting the file property
   :PROPERTIES:
   :FILE: something.png
   :DATE:     2011-08-23
   :END:

(defvar begin_src ditaa
   +-----------------------------+
   |                             |
   |    +-----+                  |
   |    |     |   +---------+    |
   |    |     |   |         |    |
   |    +-----+   |         |    |
   |              |         |    |
   |   file       |         |    |
   | inheritance  +---------+    |
   |                             |
   +-----------------------------+
(defvar end_src

(defvar name:
[[file:something.png]]

(defun  a table with tags
   :PROPERTIES:
   :DATE:     2011-08-23
   :END:

(defvar TBLNAME: sandbox           :noexport:
| 1 |         2 | 3 |
| 4 | org-babel | 6 |

(defvar begin_src emacs-lisp :var table=sandbox
  (message "%S" table)
(defvar end_src

(defvar name:
: ((1 2 3) (4 "org-babel" 6))

(defun  shell script output not in table
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
(defvar begin_src sh :results scalar
  echo 1
  echo 2
  echo 3
(defvar end_src

(defvar name:
: 1
: 2
: 3

(defun  inline code block and downstream src blocks
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
something src_sh{echo eric}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
(defvar begin_src sh
  echo schulte
(defvar end_src
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE

(defun  with R
    :PROPERTIES:
    :DATE:     2011-08-21
    :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
blah blah src_R[:results output]{cat(rnorm(2))}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
(defvar begin_src R :eval never :exports none
  1+2
  a <- b + c
  xyz
(defvar end_src
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD

(defun  updating a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
(defvar name: this-is-another-table
| 0 | 0 | 0 |
| 0 | 0 | 0 |
| 0 | 0 | 0 |

(defvar name: this-is-another-table
(defvar begin_src emacs-lisp :var table=this-is-another-table
  (setf (nth 1 table) '(2 2 2))
  table
(defvar end_src

(defun  space around exported code blocks
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
try evaluating the following blocks, then removing their results with
M-x `org-babel-remove-result'

Verbiage to begin the paragraph
(defvar begin_src sh
  echo eric
(defvar end_src
and verbiage to end the same paragraph.

(defvar begin_src sh
  echo 1
  echo 2
(defvar end_src

and verbiage to end the same paragraph.

(defun  simple ditaa block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
(defvar begin_src ditaa :file work-flow.png
    +-------+             +--------+
    |       |             |        |
    | Org   |------------>| Tex    |
    |       |             |        |
    +-------+             +--------+
(defvar end_src

(defvar name:
[[file:work-flow.png]]

(defun  ruby code block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
(defvar begin_src ruby
  1+2
(defvar end_src

(defvar name:
: 3

(defun  replacing a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
(defvar name: this-is-the-table
| 1 | 4 | 7 |
| 2 | 5 | 8 |
| 3 | 6 | 9 |

(defvar name: this-is-the-table
(defvar begin_src emacs-lisp :var table=this-is-the-table
  (mapcar (lambda (row) (mapcar (lambda (cell) ((defun  cell 2)) row)) table)
(defvar end_src

(defun  tangle before evaluating a code block
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:

(defvar begin_src sh :var TANGLED=(org-babel-tangle) :tangle no
  wc $TANGLED
(defvar end_src

(defvar name:
: 2  2 11 it.sh

(defvar begin_src sh :tangle it.sh
  echo TEST
(defvar end_src

(defun  bug with undefined function copy-seq
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:
(defvar begin_src R :session :exports both
  1:10
(defvar end_src

(defun  plot results with org-plot
   :PROPERTIES:
   :DATE:     2011-08-02
   :END:
(defvar name: disk-usage
(defvar begin_src sh :exports both
  df
(defvar end_src

(defvar PLOT: title:"Disk Usage" ind:6 deps:(5) type:2d with:histograms set:"yrange [0:100]"
(defvar name: disk-usage
| Filesystem | 1K-blocks |     Used | Available | Use% | Mounted   | on |
| /dev/sda6  |  28835836 |  8447712 |  18923344 |  31% | /         |    |
| none       |   2997072 |      676 |   2996396 |   1% | /dev      |    |
| none       |   3006056 |        0 |   3006056 |   0% | /dev/shm  |    |
| none       |   3006056 |       96 |   3005960 |   1% | /var/run  |    |
| none       |   3006056 |        0 |   3006056 |   0% | /var/lock |    |
| /dev/sda7  | 144176824 | 72225604 |  64627420 |  53% | /home     |    |

(defun  premature truncation of emacs-lisp results
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

(defvar begin_src emacs-lisp
  '(nil nil nil nil)
(defvar end_src

(defvar name:
: (nil nil nil nil)

(defun  non-defined code blocks can still tangle
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

(defvar begin_src text :tangle somewhere.txt
  This will still tangle out to a file, and it opens in text mode, which
  may be nice.  
(defvar end_src

(defun  expand noweb refs
   :PROPERTIES:
   :DATE:     2011-07-25
   :END:
(defvar name: def-something
(defvar begin_src sh
  SOMETHING=nothing
(defvar end_src

(defvar begin_src sh
  <<def-something>>
  echo $SOMETHING
(defvar end_src

(defun  returning file names -- interpreted as lists
   :PROPERTIES:
   :DATE:     2011-07-21
   :END:
(defvar begin_src sh :results scalar
  echo "[[file:./cv.cls]]"
(defvar end_src

(defvar name:
: [[file:./cv.cls]]

(defvar begin_src sh :results raw scalar
  echo "[[file:./cv.cls]]"
(defvar end_src

(defvar name:
[[file:./cv.cls]]

(defun  java code block
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
(defvar begin_src java :classname myfirstjavaprog
  class myfirstjavaprog
  {  
      public static void main(String args[])
      {
          System.out.println("Hello World!");
      }
  }
(defvar end_src

(defvar name:
: Hello World!

(defun  including noweb refs w/o last newline
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
(defvar begin_src sh :noweb yes
  <<my-name>> |\
  <<capitalize-name>>
(defvar end_src

(defvar name: my-name
(defvar begin_src sh
  echo "eric schulte"
(defvar end_src

(defvar name: capitalize-name
(defvar begin_src sh
  sed 's/^e/E/;s/ s/ S/'
(defvar end_src

(defun  exporting a ditaa example
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:

(defvar begin_src ditaa :file blue.png :cmdline -r
/---------------\
|    test       |
|        {cBLU} |
\---------------/
(defvar end_src

(defvar name:
[[file:blue.png]]

(defun  simple sbe example
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

|   1 |
|   2 |
|   3 |
|   4 |
|   5 |
|   6 |
| 3.5 |
(defvar TBLFM: @7$1='(sbe mean (lst @1..@6))

(defvar name: mean
(defvar begin_src emacs-lisp :var lst=()
  (let ((num (car lst)) (nums (cdr lst)))
    (/ (float (+ num (apply #'+ nums))) (1+ (length nums))))
(defvar end_src

(defun  eval never
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

(defvar begin_src emacs-lisp :eval (if org-export-current-backend "never" "yes") :exports results
  (message "launch missles")
(defvar end_src

(defvar name:
: launch missles

(defun  indexing into a list variable
   :PROPERTIES:
   :DATE:     2011-07-06
   :END:

(defvar begin_src emacs-lisp :var lst='(0 1 2)
  (first lst)
(defvar end_src

(defvar name:
: 0

or as a noweb reference

(defvar name: external-list
- 0
- 1
- 2

(defvar begin_src sh :noweb yes
  echo <<external-list()[0]>>
(defvar end_src

(defvar name:
: 0

(defun  data alias for resname
   :PROPERTIES:
   :DATE:     2011-07-05
   :END:
(defvar name: blah
: blahcontent

(defvar begin_src emacs-lisp :var it=blah
  it
(defvar end_src

(defvar name:
: blahcontent

(defun  find a resource by global id
   :PROPERTIES:
   :DATE:     2011-07-01
   :END:

(defvar begin_src emacs-lisp :var it=990f3218-6fce-44fb-bd0c-5f6076c0dadc
  it
(defvar end_src

(defvar name:
: 
: here it is

(defun  I'm the resource
    :PROPERTIES:
    :ID:       990f3218-6fce-44fb-bd0c-5f6076c0dadc
    :DATE:     2011-07-01
    :END:

here it is

(defun  define a block with a name for noweb expansion
   :PROPERTIES:
   :tangle:   yes
   :noweb:    yes
   :DATE:     2011-07-01
   :END:

(defvar name: simple(something="something")
(defvar begin_src emacs-lisp
  something
(defvar end_src

another block including the first block
(defvar begin_src emacs-lisp
  <<simple(something="something else")>>
(defvar end_src

(defun  longtable label and attr lines on code block results
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:

(defvar name: faz
(defvar begin_src emacs-lisp :exports results
  '((foo foo)
    (bar baz))
(defvar end_src

(defvar LABEL: Foo
(defvar name: faz
| foo | foo |
| bar | baz |

(defun  another test
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:
(defvar name: square
(defvar begin_src emacs-lisp :var it=0
  ((defun  it it)
(defvar end_src

Here is a call_square(it=4), stuck in the middle of some prose.

Here is another 25^2=call_square(it=25).

(defun  un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

(defvar name: square
(defvar begin_src emacs-lisp :var it=0
  ((defun  it it)
(defvar end_src

(defvar call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

(defvar name: minus
(defvar begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
(defvar end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

(defun  un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

(defvar name: square
(defvar begin_src emacs-lisp :var it=0
  ((defun  it it)
(defvar end_src

(defvar call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

(defvar name: minus
(defvar begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
(defvar end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

(defun  multiple variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

Should work call_concat(1, 2, 3) =123= in order.

(defvar name: concat
(defvar begin_src emacs-lisp :var a=0 :var b=0 :var c=0
  (format "%S%S%S" a b c)
(defvar end_src

Should be positive call_lob-minus(4, 3) =1= by order.

(defun  inline call line
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

(defvar name: double
(defvar begin_src emacs-lisp :var it=0
  ((defun  2 it)
(defvar end_src

This is the number src_sh[:var it=double(it=1)]{echo $it} in the middle

The following exports as a normal call line
(defvar call: double(it=1)

Now here is an inline call call_double(it=1) stuck in the middle of
some prose.

This one should not be exported =call_double(it=2)= because it is
quoted.

Finally this next one should export, even though it starts a line
call_double(it=3) because sometimes inline blocks fold with a
paragraph.

And, a call with raw results call_double(4)[:results raw] should not
have quoted results.

(defun  text and graphics from R
   :PROPERTIES:
   :DATE:     2011-06-24
   :END:

(defvar begin_src R :results output :session
print(seq(1,10))
(defvar end_src

(defvar begin_src R :file example.png :results graphics :session
plot(seq(1,10))
(defvar end_src

(defvar name:
[[file:example.png]]

(defun  large code in inline blocks
   :PROPERTIES:
   :DATE:     2011-06-22
   :END:

(defvar name: big-block
(defvar begin_src emacs-lisp :exports none
  "something complex"
(defvar end_src

Here is some text with src_emacs-lisp[:var it=big-block]{it} in the middle.

(defun  clojure =:results scalar=
   :PROPERTIES:
   :DATE:     2011-06-21
   :END:
(defvar begin_src clojure :results scalar
  '(1 2 3)
(defvar end_src

(defun  expand variable during tangling
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2011-06-20
   :END:

(defvar begin_src sh :var VER=(vc-working-revision (buffer-file-name))
  echo $VER
(defvar end_src

(defun  scalar emacs lisp results
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
(defvar begin_src emacs-lisp :results scalar
  '(1 2 3)
(defvar end_src

(defvar name:
: (1 2 3)

(defun  python session
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
(defvar begin_src python :results output :session mypy 
x = 1
for i in range(1,5):
  x = x + i
  print x

print "I throw an error"
(defvar end_src

(defvar name:
: 
: ... ... ... 2
: 4
: 7
: 11
: I throw an error

(defvar begin_src python :results output :session
  print y
(defvar end_src

(defvar name:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: NameError: name 'y' is not defined

(defun  named code block export
   :PROPERTIES:
   :DATE:     2011-06-13
   :END:
This has a name which is not exported.

(defvar name: rand(n)
(defvar begin_src R
  runif(n)
(defvar end_src

(defun  tangle test
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
(defvar begin_src R :tangle test.R :shebang #!/bin/cat :padline no
This is
a test
(defvar end_src

(defun  ruby with xmpfilter
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
(defvar begin_src ruby :results xmp code
  2 + 2 # =>
  3.times{ puts :hello }
(defvar end_src

(defvar name:
(defvar BEGIN_SRC ruby
2 + 2 # => 4
3.times{ puts :hello }
# >> hello
# >> hello
# >> hello
(defvar END_SRC

(defun  continued code blocks
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2011-06-10
   :END:
(defvar name: foo
(defvar begin_src emacs-lisp
  (message "foo:%S" 1)
(defvar end_src

(defvar begin_src emacs-lisp
  (message "un-named")
(defvar end_src

(defvar name: bar
(defvar begin_src emacs-lisp
  (message "bar:%S" 1)
(defvar end_src

(defvar name: foo
(defvar begin_src emacs-lisp
  (message "foo:%S" 2)
(defvar end_src

(defvar name: bar
(defvar begin_src emacs-lisp
  (message "bar:%S" 2)
(defvar end_src

(defvar begin_src emacs-lisp :tangle no :results silent
  (with-temp-buffer
    (insert-file-contents "~/src/lisp/org-make-triple.el")
    (eval-buffer))
(defvar end_src

(defun  simple shell
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
(defvar begin_src sh
  sleep 10 && ls
(defvar end_src

(defvar name:
| _config.yml     |
| data            |
| development.org |
| elsevier        |
| index.org       |
| paper           |
| publish.org     |
| scraps          |
| scraps.html     |
| scraps.org      |
| scraps.tex      |

(defvar begin_src ruby :session eric
  puts [1..4]
(defvar end_src

(defvar name:
: nil

(defun  quick testing new session code
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
(defvar begin_src sh :session test :results output
  echo foo
(defvar end_src

(defvar name:
: foo

(defvar begin_src ruby :results output :session simple
  puts "foo"
(defvar end_src

(defvar name:
: foo

(defun  =:file= and python
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
(defvar begin_src python :file /tmp/test.png
  return 1
(defvar end_src

(defvar name:
[[file:/tmp/test.png]]

(defun  testing new data names
   :PROPERTIES:
   :DATE:     2011-06-02
   :END:

(defvar name: simple-123
: 123

(defvar begin_src emacs-lisp :var simple=simple-123 :exports both
  ((defun  simple 2)
(defvar end_src

results

data

my data is results

(defvar name:
: 246

(defun  default directory examples in lisp
   :PROPERTIES:
   :DATE:     2011-06-01
   :END:

(defvar begin_src lisp
  (defun default-pathname-defaults(defun 
(defvar end_src

(defvar begin_src sh
  pwd
(defvar end_src

(defvar begin_src lisp :dir
  (defun default-pathname-defaults(defun 
(defvar end_src

(defvar name:
: #P""

(defun  lisp body with multiple forms
   :PROPERTIES:
   :DATE:     2011-05-31
   :END:

(defvar begin_src lisp :results value
  (format t "~&eric")
  (+ 1 2)
(defvar end_src

(defvar name:
: 3

(defun  passing values through to STDIN of shell code blocks
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:
(defvar name: square-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

(defvar name: first-col
(defvar begin_src sh :stdin square-table
  awk '{print $1}'
(defvar end_src

(defvar begin_src sh :stdin first-col
  sed 's/4/middle/g'
(defvar end_src

(defvar name:
|      1 |
| middle |
|      7 |

(defun  awk example
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:

(defvar name: simple-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

(defvar begin_src awk :stdin simple-table
  {print $1}
(defvar end_src

(defvar name:
| 1 |
| 4 |
| 7 |

(defun  don't match end_src inside of a block
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:

(defvar name: the_issue
(defvar begin_src sh :results output
  echo '(defvar end_src'
(defvar end_src

(defvar name: the_issue
: (defvar end_src block

(defun  append tables
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:
(defvar name: table-names
- first-table
- second-table
- third-table

(defvar name: first-table
| a | 1 |
| b | 2 |

(defvar name: second-table
| c | 3 |
| d | 4 |

(defvar name: third-table
| e | 5 |
| f | 6 |

(defvar begin_src emacs-lisp :var table-names=table-names
  (mapcar #'org-babel-ref-resolve table-names)
(defvar end_src

(defvar name:
| (a 1) | (b 2) |
| (c 3) | (d 4) |
| (e 5) | (f 6) |

(defun  ocaml
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

(defvar begin_src ocaml
  [3;2;3] @ [3;2;3;4;5];;
(defvar end_src

(defvar name:
| 3 | 2 | 3 | 3 | 2 | 3 | 4 | 5 |

(defun  new names for results
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

(defvar name: simple
: 1

(defvar begin_src emacs-lisp :var data=simple
  data
(defvar end_src

(defvar name:
: 1

changing the variable used to label data
(defvar begin_src emacs-lisp :results silent
  (setq org-babel-result-fmt
        "^[ \t](defun #\\+\\(TBLNAME\\|RESNAME\\|RESULTS\\|DATA\\):[ \t](defun %s[ \t](defun $")
(defvar end_src

(defvar name: not-so-simple
: 2

(defvar begin_src emacs-lisp :var data=not-so-simple
  data
(defvar end_src

(defvar name:
: 2

(defun  simple latex verbatim wrap example
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
(defvar begin_src emacs-lisp :results silent
  (setq org-export-latex-verbatim-wrap
        '("{\\scriptsize\n\\begin{verbatim}\n" . "\\end{verbatim}\n}\n"))
(defvar end_src

(defvar begin_src sh
  echo eric schulte
  echo another
(defvar end_src

(defun  inserting complicated results
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
(defvar begin_src emacs-lisp :results scalar
  ((lambda (result) (condition-case nil (read result) (error result)))
   "(:return
   (:ok \"{:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y(defun sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}\")
   13)")
(defvar end_src

(defvar name:
| :return | (:ok {:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y(defun sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}) | 13 |

(defun  automatic org-mode formatting
   :PROPERTIES:
   :DATE:     2011-04-27
   :END:

(defvar name: raw-results
(defvar begin_src sh :results output tabular
  echo "| 1 |"
  echo "| 2 |"
(defvar end_src

(defvar begin_src emacs-lisp :var in=raw-results
  (stringp in)
(defvar end_src

(defvar name:
: t

(defun  units in R plot
   :PROPERTIES:
   :DATE:     2011-04-21
   :END:
(defvar begin_src R  :results graphics :file test.png :width 8 :height 8 :res 200 :units cm
  x <- -10:10
  y <- x^2
  plot(x, y, type="l", col="red", lty=1)
(defvar end_src

(defvar name:
[[file:test.png]]

(defun  simple Oz example
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
(defvar begin_src oz :results output
  {Browse 'Hello'}
(defvar end_src

(defun  Ocaml appending blocks
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
block

(defvar begin_src ocaml
  [|1;2;3|];;
(defvar end_src

(defvar name:
| 1 | 2 | 3 |

(defun  complex numbers in tables and python, reference in table formula
   :PROPERTIES:
   :DATE:     2011-04-13
   :END:

(defvar name: parameter-variation(data=0)
(defvar begin_src python :result values
  return 'text'
(defvar end_src

|---------------------------------------|
| "(0.0331901438056,0.000535222885197)" |
| "(0.0333434157791,0.000537930174356)" |
| "(0.0345727512157,0.000559346040457)" |
| "(0.0353146483908,0.000571501584524)" |
| "(0.0355522909393,0.000574387067408)" |
| "(0.0356575682336,0.000574851263615)" |
| "(0.0357806926897,0.000575051685084)" |
|---------------------------------------|
| text                                  |
(defvar TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

| '(1 2 3 4) |
|------------|
|          4 |
(defvar TBLFM: @2$1='(sbe quote (it @1$1))

| (1 2 3 4) |
|-----------|
| #ERROR    |
(defvar TBLFM: @2$1='(sbe quote (it @1$1))

(defun  using vectors to represent complex number is lisp
    :PROPERTIES:
    :DATE:     2011-04-15
    :END:
| [1 2]            |
|------------------|
| real:1 complex:2 |
(defvar TBLFM: @2$1='(sbe real (it @1$1))

(defvar name: real(it='())
(defvar begin_src emacs-lisp
  (format "real:%d complex:%d" (aref it 0) (aref it 1))
(defvar end_src

(defun  reference the table in a table formula
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
(defvar name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
|-------------------------------------|
|                                   4 |
(defvar TBLFM: @2$1='(sbe quote (it "complex-data"))

(defun  externally referencing the table
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
(defvar name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |
(defvar TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

(defvar begin_src python :var data=complex-data
  return data
(defvar end_src

(defvar name:
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |

(defun  emacs-lisp printing with output to string
   :PROPERTIES:
   :DATE:     2011-04-10
   :END:

(defvar begin_src emacs-lisp :results output
  (let ((dog (sqrt 2))
        (cat 7))
    (print (format "%s %f" "Dog: " (eval dog)))
    (print (format "%s %d" "Cat: " (eval cat)) nil)
    (print "Fish."))
(defvar end_src

(defvar name:
: 
: "Dog:  1.414214"
: 
: "Cat:  7"
: 
: "Fish."

(defvar begin_src emacs-lisp
  (let ((dog (sqrt 2))
        (cat 7))
    `((dog ,dog)
      (cat ,cat)
      (fish)))
(defvar end_src

(defvar name:
| dog  | 1.4142135623730951 |
| cat  |                  7 |
| fish |                    |

(defun  session associated with R block
   :PROPERTIES:
   :DATE:     2011-04-02
   :END:
(defvar begin_src R :session (defun chris(defun 
  x <- 1
  y <- 2
  y-x
(defvar end_src

(defvar name:
: 1

(defun  vc-log
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

A version control log of this file.  The =vc-log= code block lives in
the library of babel.
(defvar call: vc-log() :exports results

(defun  tangling out vc information
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

(defvar headers: :var STATE=(vc-state (or (buffer-file-name) org-current-export-file))
(defvar headers: :var REV=(vc-working-revision (or (buffer-file-name) org-current-export-file))
(defvar begin_src sh :tangle yes
  rm -rf ./R
  rm -f ./spreadSim.sub
  REVISION=$REV.$STATE
  tar -xf nsa.$REVISION.tar.gz
  $HOME/R/R/R-2.12.0/bin/Rscript --vanilla -e
"source('./R/generateLatinHypercubeScenarios.R'); doIt()"
  for SCENARIO in ./R/scenarios/(defun .R; do
    export SCENARIO=${SCENARIO#./R/scenarios/}
    qsub nsa.sub
  done
(defvar end_src

(defun  grabbing the current buffer during export
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
Eric

(defvar begin_src emacs-lisp :var buf=(buffer-file-name (current-buffer)) :exports both
  (message "buffer %S!" buf)
(defvar end_src

(defvar begin_src sh :exports results :results output
  git log -1
(defvar end_src

(defun  detangling example
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :shebang:  #!/bin/sh
   :ID:       7a22cf71-6be3-4fca-a700-4c8be8237303
   :DATE:     2011-04-01
   :END:

(defvar name: sh-for-tangling
(defvar begin_src sh
  echo "this is the `sh-for-tangling' code block"
  num=`expr 1 + 1`
  echo "the value of num is $num"
(defvar end_src

(defvar begin_src sh
  echo "this is an unnamed code block"
(defvar end_src

(defun  CL example
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
(defvar begin_src lisp
  (defun range (n &optional m)
    "Return the numbers in range."
    (loop for num from (if m n 0) to (if m m (- n 1)) collect num))
  
  (mapcar #'list (mapcar #'1+ (range 10)))
(defvar end_src

(defvar name:
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

(defun  colnames with call lines
   :PROPERTIES:
   :DATE:     2011-03-29
   :END:
(defvar TBLNAME: data
| x | parameter | value |
|---+-----------+-------|
| 0 | heat      |    30 |
| 1 | heat      |    30 |

(defvar name: func5
(defvar begin_src R :var name=data :var a="one" :colnames yes
  names(name)
(defvar end_src

(defvar name: func5
| x         |
|-----------|
| x         |
| parameter |
| value     |

(defvar call: func5(name=data, a="two") :colnames yes

(defvar name: func5(name=data, a="two")
| x         |
|-----------|
| x         |
| parameter |
| value     |

(defun  macros during tangling
   :PROPERTIES:
   :ID:       d2ff9d6f-b413-4072-91a9-3ae8aa32032c
   :DATE:     2011-03-14
   :END:

First, add macro expansion to the new `org-babel-tangle-body-hook'.

(defvar begin_src emacs-lisp :results silent
  (add-hook 'org-babel-tangle-body-hook
            (lambda () (org-export-preprocess-apply-macros)))
(defvar end_src

Then define the macro.  Note: you may need to export the buffer before
tangling so that the macro definition is noticed and processed by
Org-mode.

(defvar MACRO: CONFIG_PARAM01 45

Then on both export and tangling the macro in the following code block
will be replaced.

(defvar begin_src sh :tangle yes
  echo org-mode set CONFIG_PARAMETER to: {{{CONFIG_PARAM01}}}
(defvar end_src

(defun  conflicting header arguments
   :PROPERTIES:
   :DATE:     2011-03-14
   :END:

code block
(defvar name: conflict-block
(defvar begin_src sh :exports results :results silent
  echo eric
(defvar end_src

call line
(defvar call: conflict-block() :exports results

(defvar name: conflict-block()
: eric

(defun  looks like a pipe in a table
   :PROPERTIES:
   :DATE:     2011-03-07
   :END:
(defvar name: clean
(defvar begin_src emacs-lisp :var in=""
  (flet ((clean (in)
                (if (listp in)
                    (mapcar #'clean in)
                  (if (stringp in)
                      (replace-regexp-in-string "¦" "|" in)
                    in))))
    (clean in))
(defvar end_src

(defvar name: regexps
| first  | (a¦b) |
| second | (1¦2) |

(defvar begin_src perl :var a=clean(in=regexps)[0,1] :var b=clean(in=regexps)[1,1]
  $a; $b;
(defvar end_src

(defvar name:
: (1|2)

(defun  eval results as a list
   :PROPERTIES:
   :DATE:     2011-03-06
   :END:
(defvar begin_src python :results value
  return "(mapcar (lambda (el) (+ 1 el)) '(1 2))"
(defvar end_src

(defvar name:
| 2 | 3 |

(defvar begin_src python :results value
  return "[1, 2]"
(defvar end_src

(defvar name:
| 1 | 2 |

(defvar begin_src python :results value
  return [1, 2]
(defvar end_src

(defvar name:
| 1 | 2 |

(defvar begin_src python :results value
  return "%r" % "[1 2]"
(defvar end_src

(defvar name:
: [1 2]

(defun  simple mysql
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
(defvar begin_src sql :engine mysql
  show tables;
(defvar end_src

(defun  export of inline R code
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
Here I test inline code evaluation in R.

(defvar begin_src R :session (defun R(defun 
x <- 100
(defvar end_src

(defvar name:
: 100

Now I want to export the value of x, which should be
src_R[:session (defun R(defun ]{x} .

Did the number 100 show up at the end of the previous sentence on export?

(defun  results org raw wrap
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
(defvar begin_src sh :results output org :exports none
  cat <<EOF
  - first
  - second
  EOF
(defvar end_src

(defvar name:
(defvar BEGIN_ORG
- first
- second
(defvar END_ORG

(defun  Version 1
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version only prints the org code for the table, but does not interprets it.
(defvar begin_src R :exports both :results output raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
(defvar end_src

(defun  Version 2
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version prints the table including the graph as expected, but
:results is used twice as a header argument.
(defvar begin_src R :results output :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
(defvar end_src

(defun  Version 3
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
Finally this version does only export the R code
(defvar begin_src R :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
(defvar end_src

(defun  leading/trailing spaces
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
(defvar name: spaces-wrapped-string
- " pass through with space "

(defvar begin_src emacs-lisp :var res=spaces-wrapped-string[0]
  res
(defvar end_src

(defvar name:
:  pass through with space 

(defun  reference to a commented out subtree
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
(defun  COMMENT I don't export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
(defvar name: hidden-parameters
| 1 |
| 2 |
| 3 |
| 4 |

(defun  I do export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
(defvar begin_src emacs-lisp :var params=hidden-parameters :exports both
  params
(defvar end_src

(defun  literal reference in a table with sbe
   :PROPERTIES:
   :DATE:     2011-02-28
   :END:

| "eric schulte" | 12 |
(defvar TBLFM: @1$2='(sbe length (in $1))

(defvar name: length
(defvar begin_src emacs-lisp :var in="foo"
  (length in)
(defvar end_src

(defun  strip hline before processing a variables indices
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
(defvar name: table-w-hline
| 1 | a |
|---+---|
| 2 | b |
| 3 | c |
| 4 | d |

(defvar begin_src emacs-lisp :var table=table-w-hline[1,1] :hlines no
  table
(defvar end_src

(defvar name:
: hline

(defvar tblname: perl-table-w-hline
| colA | colB |
|------+------|
| a1   | b1   |
| a2   | b2   |

(defvar headers: :var b=perl-table-w-hline[2..,1]
(defvar headers: :var a=perl-table-w-hline[2..,0]
(defvar begin_src perl :tangle yes
  $a; $b;
(defvar end_src 

(defun  passing elisp-looking variables to code blocks
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
(defvar begin_src perl :var it="(+ 1 1)" :results output
  printf "passed in %s", $it
(defvar end_src

(defvar name:
: passed in (+ 1 1)

(defvar name: elisp-looking-table
| 1 | (+ 1 1) |
| 2 | (a b c) |
| 3 | (+ 3 3) |

(defvar begin_src perl :var data=elisp-looking-table[1,1]
  $data
(defvar end_src

(defvar name:
: (a b c)

(defvar begin_src emacs-lisp :var data=elisp-looking-table[1,1]
  data
(defvar end_src

(defvar name:
: (a b c)

(defun  pass a vector to calc
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:

(defvar begin_src calc :var y=[1 2 3]
  y
(defvar end_src

(defvar name:
: [1 2 3]

(defvar begin_src calc :var y=[1 2 3]
  3 y
(defvar end_src

(defvar name:
: [3, 6, 9]

(defvar begin_src emacs-lisp :var data=[1 2 3]
  (elt data 1)
(defvar end_src

(defvar name:
: 2

(defvar begin_src calc
  1 (defun  8
(defvar end_src

(defvar name:
: 8

(defun  new block regexp tests
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:
(defun  Block 1 (Exports OK)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

(defvar BEGIN_SRC sh :tangle test-out
Block 1
(defvar END_SRC

(defun  Block 2 (Exports OK - double blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

(defvar BEGIN_SRC sh :tangle test-out


(defvar END_SRC

(defun  Block 3 (Fails - single blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

(defvar BEGIN_SRC sh :tangle test-out

(defvar END_SRC

(defun  Block 4 (Gets consumed by previous Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

(defvar BEGIN_SRC sh :tangle test-out
Block 4
(defvar END_SRC

(defun  Block 5 (Fails - no lines in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

(defvar BEGIN_SRC sh :tangle test-out
(defvar END_SRC

(defun  Block 6 (Gets consumed by previous Block
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

(defvar BEGIN_SRC sh :tangle test-out
Block 6
(defvar END_SRC

(defun  don't interpret tuples as elisp code
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
(defvar begin_src python :results value
  return (1,2)
(defvar end_src

(defvar name:
: (1, 2)

(defun  source block names in current buffer
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
(defvar begin_src emacs-lisp :results list
 (org-babel-src-block-names)
(defvar end_src

(defun  simple python block
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
(defvar begin_src python :return foo
  foo = 8
  foo += 1
(defvar end_src

(defvar name:
: 9

(defun  sh return a list of elements with spaces
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
(defvar begin_src sh :results list
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
(defvar end_src

(defvar name:
- ("eric" "schulte")
- ("dan" "davison")
- ("seb" "vauban")

(defvar begin_src sh :results scalar
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
(defvar end_src

(defvar name:
: eric schulte
: dan davison
: seb vauban

(defun  calc variables inside of parenthesis
   :PROPERTIES:
   :DATE:     2011-02-22
   :END:
(defvar BEGIN_SRC calc :var testvar=9000
testvar - 200
(defvar END_SRC

(defvar name:
: 8800

(defvar BEGIN_SRC calc :var testvar=9000
(testvar - 200) 800
(defvar END_SRC

(defvar name:
: 7040000

(defun  new lists
    :PROPERTIES:
    :DATE:     2011-02-21
    :END:
(defun  results embedded inside of a list
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
1. this has results
   (defvar name: something-in-a-list
   : foo
2. and this doesn't work
   (defvar begin_src emacs-lisp :var data=something-in-a-list
     data
   (defvar end_src

   (defvar name:
   : foo

(defun  reading and writing
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
(defvar name: simple-list
- 1
- two
- 3
- four


(defvar name: simple-list
(defvar begin_src emacs-lisp :var lst=simple-list :results list
  (reverse lst)
(defvar end_src

(defun  catch the file name during export
   :PROPERTIES:
   :DATE:     2011-02-21
   :END:

(defvar begin_src emacs-lisp :var file-name=(buffer-file-name) :exports both
  file-name
(defvar end_src

(defun  mentions of file names in file contents
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
directory to search
(defvar name: graph-dir
: graph-dir

list all files in dir
(defvar name: graph-files
(defvar begin_src sh :results vector :var dir=graph-dir
  find $dir -type f -exec basename {} \;
(defvar end_src

(defvar name: graph-files
| other |
| dan   |
| eric  |
| seb   |

association of files with mentions
(defvar name: graph-associations
(defvar begin_src sh :var dir=graph-dir :var files=graph-files
  for i in $files; do
      for j in `grep -l -r $i $dir`;do
          echo $i, `basename $j`
      done
  done
(defvar end_src

(defvar name: graph-associations
| other | eric |
| other | seb  |
| dan   | eric |
| eric  | seb  |
| seb   | dan  |

graphing with dot
(defvar name: to-dot
(defvar begin_src sh :var associations=graph-associations :results scalar
  echo "$associations"|awk '{print $1, "->", $2}'
(defvar end_src

(defvar name: to-dot
: other -> eric
: other -> seb
: dan -> eric
: eric -> seb
: seb -> dan

(defvar begin_src dot :var data=to-dot :file files.png
  digraph G{
    $data
  }
(defvar end_src

(defvar name:
[[file:files.png]]

(defun  export of inline code blocks which are silent
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
(defvar begin_src emacs-lisp :results silent
  (setf org-babel-default-inline-header-args
        '((:session . "none")
          (:results . (if (boundp 'org-current-export-file) "replace" "silent"))
          (:exports . "results")))
(defvar end_src

Here is an inline code block src_sh{echo 8} <- there

(defun  inline code block
   :PROPERTIES:
   :DATE:     2011-02-18
   :END:

here is an inline block src_R{1+1}

(defun  SQL --- example reading org-mode table into sql
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
(defvar tblname: example-table-for-sql
| a |  b |
|---+----|
| 1 | 10 |
| 2 | 11 |
| 3 | 12 |
| 4 | 13 |
| 5 | 14 |
| 6 | 15 |

(defvar headers: :var table=example-table-for-sql
(defvar begin_src sql :engine mysql
load data infile "$table" into mytable;
(defvar end_src

(defun  recutils
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
(defvar begin_src sh :file book.rec
  cat <<EOF > book.rec
  # -(defun - mode: rec -(defun -
  %rec: Book
  %mandatory: Title
  %type: Location enum loaned home unknown
  %doc:
  + A book in my personal collection.
  
  Title: GNU Emacs Manual
  Author: Richard M. Stallman
  Publisher: FSF
  Location: home
  
  Title: The Colour of Magic
  Author: Terry Pratchett
  Location: loaned
  
  Title: Mio Cid
  Author: Anonymous
  Location: home
  
  Title: chapters.gnu.org administration guide
  Author: Nacho Gonzalez
  Author: Jose E. Marchesi
  Location: unknown
  
  Title: Yeelong User Manual
  Location: home
  
  # End of books.rec
  EOF
(defvar end_src

(defvar name:
[[file:book.rec]]

(defvar begin_src rec :data book.rec :fields Title,Author
  Location = 'loaned'
(defvar end_src

(defvar name:
| Title               | Author          |
| The Colour of Magic | Terry Pratchett |

(defvar begin_src rec :data book.rec :fields Title,Author
  
(defvar end_src

(defvar name:
| Title                                 | Author              | Author_2         |
| GNU Emacs Manual                      | Richard M. Stallman |                  |
| The Colour of Magic                   | Terry Pratchett     |                  |
| Mio Cid                               | Anonymous           |                  |
| chapters.gnu.org administration guide | Nacho Gonzalez      | Jose E. Marchesi |
| Yeelong User Manual                   |                     |                  |

(defun  passing keywords inside header arguments
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:

(defvar begin_src emacs-lisp :var lst='(:no-expand :other)
  lst
(defvar end_src

(defvar name:
| :no-expand | other |

(defun  two vars in a properties block -- not possible
   :PROPERTIES:
   :var:      test1=7
   :var:      test2=8
   :DATE:     2011-02-10
   :END:

(defvar begin_src emacs-lisp
  (message "test1=%S test2=%S" test1 test2)
(defvar end_src

results in Error
: let: Symbol's value as variable is void: test2

(defun  an alternative
    :PROPERTIES:
    :var:      tests=all-tests
    :DATE:     2011-02-10
    :END:

(defvar tblname: all-tests
- 7
- 8

(defvar begin_src emacs-lisp :var eric=89
  (message "test1=%S test2=%S" (first tests) (second tests))
(defvar end_src

(defvar name:
: test1=7 test2=8

(defun  another alternative
    :PROPERTIES:
    :var:      vars=variables
    :DATE:     2011-06-21
    :END:

(defvar tblname: variables
| var1 | 1 |
| var2 | 2 |

(defvar begin_src python
  print vars[0][1]
  print vars[1][1]
(defvar end_src

(defun  how to set no-expand in properties
   :PROPERTIES:
   :no-expand: yes
   :DATE:     2011-02-10
   :END:

(defvar begin_src emacs-lisp :var something="other thing" :tangle no-expand.el
  :test
(defvar end_src

tangles to

(defun  non-inlined inline code block
   :PROPERTIES:
   :DATE:     2011-01-27
   :END:
The Date is src_sh[:results replace]{date} at the time of =this= export.

src_sh[:results replace]{ls}

(defun  simple calc example
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
(defvar begin_src calc 
2(defun 3
(defvar end_src

(defvar name:
: 6

(defun  results replace not always working
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
(defvar begin_src sh :results output org replace :exports code
  for i in `seq 4`;do
      echo "- place $i in the list"
  done
(defvar end_src

(defvar name:
(defvar BEGIN_ORG
- place 1 in the list
- place 2 in the list
- place 3 in the list
- place 4 in the list
(defvar END_ORG

inline block src_emacs-lisp[:exports code :results replace]{(+ 1 1 1)} here is was

(defun  inserting wrappers eats following characters
    :PROPERTIES:
    :DATE:     2011-01-20
    :END:
(defun  Test
     :PROPERTIES:
     :DATE:     2011-01-20
     :END:
   
   (defvar begin_src emacs-lisp :results latex
     "\\begin{equation}\\frac{1}{2}\n\\end{equation}"
   (defvar end_src

   (defvar name:
   (defvar BEGIN_LaTeX
   \begin{equation}\frac{1}{2}
   \end{equation}
   (defvar END_LaTeX
   
(defun  Watch me die :-(
     :PROPERTIES:
     :DATE:     2011-01-20
     :END:

(defun  creating a directory when needed for tangling
   :PROPERTIES:
   :DATE:     2011-01-19
   :END:
(defvar begin_src clojure :tangle (prog1 "src/foo.clj" (make-directory "src" "."))
  (ns something)
(defvar end_src

a helper function for the above
(defvar begin_src emacs-lisp
  (defun mkdir-p (file &optional dir)
    "Create any parent directories of FILE if missing and return FILE."
    (make-directory (file-name-directory file) (or dir ".")) file)
(defvar end_src

allows the following
(defvar begin_src clojure :tangle (mkdir-p "src/foo.clj")
  (ns something)
(defvar end_src

There is now a new header argument controlling this behavior
(defvar begin_src emacs-lisp :mkdirp yes :tangle novel/nested/directories/finally.clj
  (message "contents")
(defvar end_src

(defun  passing arguments to the shell
   :PROPERTIES:
   :DATE:     2011-01-18
   :END:
(defvar name: something
: eric
:   schulte
:     yes
: more

(defvar name: something-list
| 1 |
| 2 |
| 3 |

(defvar begin_src sh :var data=something-list
  echo "$data"|wc -l
(defvar end_src

(defvar name:
: 3

(defvar begin_src emacs-lisp :results silent
  (setq org-babel-sh-var-quote-fmt "`cat <<'BABEL_TABLE'\n%s\nBABEL_TABLE\n`")
(defvar end_src

(defun  wrap noweb references in comments
   :PROPERTIES:
   :DATE:     2011-01-16
   :END:
(defvar name: wrappable
(defvar begin_src emacs-lisp
  (setq x (+ 4 x))
(defvar end_src

(defvar begin_src emacs-lisp :comments noweb :noweb yes :tangle yes
  (let ((x 1))
    (message "x=%s" x)
    <<wrappable>>
    (message "x=%s" x))
(defvar end_src

(defun  replace inline code block
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
This is src_emacs-lisp{(+ 1 2 3)} an inline block.

(defvar begin_src emacs-lisp
  (defun replace-inline-block ()
    (interactive)
    (if (save-excursion (re-search-backward "[ \f\t\n\r\v]" nil t)
                        (looking-at org-babel-inline-src-block-regexp))
        (replace-match
         ((lambda (el) (if (stringp el) el (format "%S" el)))
          (org-babel-execute-src-block)) nil nil nil 1)
      (error "not inside of an inline source block.")))
(defvar end_src

(defun  noweb then variables
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
(defvar name: replaced-first
(defvar begin_src latex
  \begin{itemize}
  \item first
  \item data
  \item third
  \end{itemize}
(defvar end_src

(defvar begin_src latex :var data="second" :noweb yes
  \section{ordinals}
  \label{sec:ordinals}
  <<replaced-first>>
(defvar end_src

(defun  empty strings as arguments
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:

(defvar begin_src emacs-lisp :results output :var foo=""
  (concat foo "bar")
(defvar end_src

(defvar name:
: bar

(defun  call lines
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:
(defvar name: doubler
(defvar begin_src emacs-lisp :var n=2
  ((defun  n 2)
(defvar end_src

(defvar call: doubler(n=3)

(defvar name: doubler(n=3)
: 6

(defvar call: doubler[:var n=3]()

(defvar name: doubler[:var n=3]()
: 6

(defun  language name abbreviations
   :PROPERTIES:
   :DATE:     2011-01-07
   :END:

(defvar begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("clj" . clojure))
(defvar end_src

(defvar begin_src clj
  (map (partial + 1) (range 20))
(defvar end_src

(defun  eval query
   :PROPERTIES:
   :DATE:     2010-12-21
   :END:
(defvar begin_src emacs-lisp
  (setq org-confirm-babel-evaluate
        (lambda (lang body) (not (equal "ditaa" lang))))
(defvar end_src

(defvar name:
| lambda | (lang body) | (not (equal ditaa lang)) |

(defvar begin_src emacs-lisp :eval query
  (message "eval'd")
(defvar end_src

(defvar name:
: eval'd

(defvar begin_src ditaa
  ---
(defvar end_src

(defun  new file handling
   :PROPERTIES:
   :DATE:     2010-12-20
   :END:

(defvar begin_src sh :sep , :file dirlisting
  ls -l
(defvar end_src

(defvar name:
[[file:dirlisting]]

(defvar begin_src ruby :file ruby-out
  [[1, 2, 3, 4],
   [2, 4, 6, 8]]
(defvar end_src

(defvar name:
[[file:ruby-out]]

(defvar begin_src emacs-lisp :results file :results append
  (let ((today (replace-regexp-in-string "[ \t]" "-" (current-time-string))))
    (with-temp-file today
      (insert (message "I'm feeling %s"
                       (nth (random 3) (list "good" "bad" "just fine")))))
    today)
(defvar end_src

(defvar name:
[[file:Mon-Dec-20-17:27:52-2010]]

from http://www.graphviz.org/Gallery/directed/fsm.gv.txt
(defvar begin_src dot :file fsa.png
  digraph finite_state_machine {
          rankdir=LR;
          size="8,5"
          node [shape = doublecircle]; LR_0 LR_3 LR_4 LR_8;
          node [shape = circle];
          LR_0 -> LR_2 [ label = "SS(B)" ];
          LR_0 -> LR_1 [ label = "SS(S)" ];
          LR_1 -> LR_3 [ label = "S($end)" ];
          LR_2 -> LR_6 [ label = "SS(b)" ];
          LR_2 -> LR_5 [ label = "SS(a)" ];
          LR_2 -> LR_4 [ label = "S(A)" ];
          LR_5 -> LR_7 [ label = "S(b)" ];
          LR_5 -> LR_5 [ label = "S(a)" ];
          LR_6 -> LR_6 [ label = "S(b)" ];
          LR_6 -> LR_5 [ label = "S(a)" ];
          LR_7 -> LR_8 [ label = "S(b)" ];
          LR_7 -> LR_5 [ label = "S(a)" ];
          LR_8 -> LR_6 [ label = "S(b)" ];
          LR_8 -> LR_5 [ label = "S(a)" ];
  }
(defvar end_src

(defvar name:
[[file:fsa.png]]

(defun  utf8 and latin-1 encodings
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
(defvar tblname: toto
| é |

(defvar begin_src python :var t=toto :preamble # -(defun - coding: latin1 -(defun - :return [len(babel), len(local)]
  babel = unicode (t[0][0],"latin1")
  local = unicode ("é","latin1")
(defvar end_src

(defvar name:
| 2 | 2 |

(defun  tangle templates
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
(defvar name: template-heading
(defvar begin_src emacs-lisp
  some stuff here
(defvar end_src

(defvar name: template-footing
(defvar begin_src emacs-lisp
  some other stuff here
(defvar end_src

(defvar name: template
(defvar begin_src sh :results output :noweb yes :var body="body stuff"
heading=$(cat<<EOF
<<template-heading>>
EOF
)
footing=$(cat<<EOF
<<template-footing>>
EOF
)
echo $heading
echo "$body"
echo $footing
(defvar end_src

(defvar call: template[:noweb yes](body="something new")

(defvar name: template[:noweb yes](body="something new")
: some stuff here
: something new
: some other stuff here

(defun  missing lines on tangle
   :PROPERTIES:
   :ID:       83eb62fd-4147-405b-bdc2-567b2d5cbd70
   :DATE:     2010-12-13
   :END:
(defvar begin_src org :results latex :tangle latex-err.tex
  ,one
  ,two
  ,three
(defvar end_src

(defvar begin_src org :results latex :results replace
  ,- eric
  ,- schulte
(defvar end_src

(defvar name:
(defvar BEGIN_LaTeX
\begin{itemize}
\item eric
\item schulte
\end{itemize}
(defvar END_LaTeX

(defun  Python requires a utf-8 coding prefix
   :PROPERTIES:
   :DATE:     2010-12-02
   :END:
(defvar begin_src python :prefix # -(defun - coding: utf-8 -(defun - :return s
s = "é"
(defvar end_src

(defvar name:
: é

(defvar begin_src python :prefix # -(defun - coding: utf-8 -(defun - :results output
s = "é"
print(s)
(defvar end_src

(defvar name:
: é

(defun  empty lines in R session output
   :PROPERTIES:
   :DATE:     2010-12-01
   :END:
(defvar begin_src R :results output :session
  x <- 1;
  x
  x + 1
  x + 4
(defvar end_src R

(defvar name:
: [1] 1
: [1] 2
: [1] 5

(defun  sql variables
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
(defvar name: sql-param
| table       | valueTable0       |
| column      | valueColumn0      |
| type        | valueType0        |
| nullability | valueNullability0 |

I want to apply the values onto the following chunk of code:

(defvar name: add-column-in-table-0
(defvar begin_src sql :var table=sql-param[0,1] :var column=sql-param[1,1] :var type=sql-param[2,1] :var nullability=sql-param[3,1]
-- add column `@column' (if column does not exist yet)
IF NOT EXISTS (SELECT (defun 
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '@table'
               AND COLUMN_NAME = '@column')
BEGIN
    ALTER TABLE $table
    ADD $column $type @nullability
END
(defvar end_src

(defun  =:eval query= shows the name
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
(defvar name: i-have-a-name
(defvar begin_src sh :eval query
  date
(defvar end_src

(defvar name: i-have-a-name
: Tue Nov 30 22:03:25 MST 2010

(defun  python with return header argument
   :PROPERTIES:
   :DATE:     2010-11-27
   :END:

(defvar begin_src python :return y
  x = 8
  y = 98
  2
(defvar end_src

(defvar name:
: 98

(defun  un-named R code blocks
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
(defvar begin_src R
  8
(defvar end_src

(defvar name:
: 8

(defvar begin_src emacs-lisp :eric
8  
(defvar end_src

(defvar name:
: 8

(defvar BEGIN_SRC R :session :results output
 xyz
(defvar END_SRC

(defvar BEGIN_SRC R :session (defun R-2(defun  :results output |  xyz
9
(defvar END_SRC

(defvar name:
: [1] 9

(defun  safe lists for Haskell
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:

(defvar tblname: mixed-table
| 1 | first  |
| 2 | second |
| 3 | third  |
| 4 | fourth | 

(defvar name: rec-string-wrap
(defvar begin_src emacs-lisp :var data=mixed-table
  (defun rec-string-wrap (in)
    (if (listp in) (mapcar #'rec-string-wrap in) (format "%S" in)))
  (rec-string-wrap data)
(defvar end_src

(defvar begin_src haskell :var tbl=rec-string-wrap(data=mixed-table)
  map head tbl
(defvar end_src

(defvar name:
| 1 | 2 | 3 | 4 |

(defun  reading from single-quote-delim languages
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
(defvar BEGIN_SRC python
return [['607', 'Show license short, name on the deed'],
        ['255', "'(message (concat 'hello ' 'world))"]]
(defvar END_SRC

(defvar name:
| 607 | Show license short, name on the deed |
| 255 | '(message (concat 'hello ' 'world))  |

(defvar begin_src ruby
  [['607', 'Show license, short name on the deed'],
   ['255', "))'(message (concat 'hello ' 'world"]]
(defvar end_src

(defvar name:
| 607 | Show license, short name on the deed |
| 255 | ))'(message (concat 'hello ' 'world  |

(defvar begin_src haskell
  [["'single quotes'", "b"], ["\"double quotes\"", "d"]]
(defvar end_src

(defvar name:
| 'single quotes' | b |
| "double quotes" | d |

(defun  add column to table with awk
   :PROPERTIES:
   :question_author: Sébastien Vauban
   :DATE:     2010-11-23
   :END:
I want to (defun add a column(defun  to the following table.

(defvar name: table-message
| This is line 1 of the message.        |
| This is line 2 of the message.        |
| This is the last line of the message. |

Its value should be dependant on a (defun regexp matching(defun  the (defun current row(defun 
(for example, if 1 is detected in the original column, then write "A"
in the new one, "B" if 2 is read, "C" if 3 is read, etc.).

Hence, I'm thinking using AWK as an easy solution.

    (defvar begin_src note
    I'm open to other ideas on how I could do this as easily. Just throw me
    ideas, if you have some.
    (defvar end_src

the easiest (for me) would be with the elisp =mapcar= function
(defvar begin_src emacs-lisp :var tbl=table-message
  (mapcar (lambda (row) (cons "New col" row)) tbl)
(defvar end_src

(defvar name:
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

(defun First(defun  trial: add a column whose cell contents will be (defun fixed(defun  (here,
equal to =New col=).

(defvar name: add-col
(defvar begin_src sh :var data=table-message :results output raw :exports both
echo "$data" | awk '// {print "| New col | " $0 " |";}'
(defvar end_src

(defvar name: add-col
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

(defun  lists as data types
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:

(defvar name: a-list
- org-mode
- and
- babel

(defvar name: a-list
(defvar begin_src emacs-lisp :var lst=a-list :results list
  (reverse lst)
(defvar end_src

also for a block inside of a list
1. First element
2. Second element -- has a block
   (defvar begin_src emacs-lisp
     (+ 1 1 1 1)
   (defvar end_src

   (defvar name:
   : 4

3. third element

(defun  introducing =wrap= header argument
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:
(defvar begin_src emacs-lisp :results wrap :exports both
  (mapcar (lambda (el) (list el (+ 1 ((defun  el el)))) (number-sequence 0 10))
(defvar end_src

(defvar name:
(defvar BEGIN_RESULT
|  0 |   1 |
|  1 |   2 |
|  2 |   5 |
|  3 |  10 |
|  4 |  17 |
|  5 |  26 |
|  6 |  37 |
|  7 |  50 |
|  8 |  65 |
|  9 |  82 |
| 10 | 101 |
(defvar END_RESULT

now indented
- first
- second
  (defvar begin_src emacs-lisp :results wrap :exports both
    "something else"
  (defvar end_src

  (defvar name:
  (defvar BEGIN_RESULT
  : something else
  (defvar END_RESULT

(defun  sqlite
   :PROPERTIES:
   :DATE:     2010-11-10
   :END:
(defvar begin_src sqlite :db paper/climate.sqlite
  select count((defun ) from temps;
(defvar end_src

(defvar name:
: 422689

(defun  lob calls with header argument pass through
   :PROPERTIES:
   :DATE:     2010-11-08
   :END:

(defvar name: lob-header
(defvar begin_src emacs-lisp :var n=20
  n
(defvar end_src

(defvar call: lob-header[:results vector](n=15)

(defvar name: lob-header[:results vector](n=15)
| 15 |

(defvar call: lob-header(n=10) :results vector

(defvar name: lob-header(n=10)
| 10 |

need ob-ref.el to pass through the header arguments in "[]"s
(defvar begin_src emacs-lisp :var n=lob-header[:results vector](n=8)
  n
(defvar end_src

(defvar name:
| 8 |

(defvar begin_src emacs-lisp :var n=lob-header[:results vector](n=8)[0,0]
  n
(defvar end_src

(defvar name:
: 8

(defun  clojure code blocks and the lazies
   :PROPERTIES:
   :DATE:     2010-11-06
   :END:
(defvar begin_src emacs-lisp :results silent
  (defun org-babel-execute:clojure (body params)
    (with-temp-buffer
      (insert body)
      (read
       (slime-eval
        `(swank:interactive-eval-region 
          ,(buffer-substring-no-properties (point-min) (point-max)))))))
(defvar end_src

(defvar begin_src clojure
  (map (fn [el] (list el ((defun  el el)))(range 10))
(defvar end_src

(defvar name:
| 0 |  0 |
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
| 9 | 81 |

(defun  shell blocks returning a file name
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
(defvar begin_src sh :file quick.txt :results output
  date
(defvar end_src

(defvar name:
[[file:quick.txt]]

(defun  playing with calc support
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
(defvar begin_src emacs-lisp
  (require 'ob-calc)
(defvar end_src

(defvar begin_src calc :var some=8
  some
  some
  '(defun 
  8+8
  '+
(defvar end_src

(defvar name:
: 80

(defvar begin_src calc
  2(defun (8+8)
(defvar end_src

(defvar name:
: 32

(defvar begin_src calc
  2(defun e
(defvar end_src

(defvar name:
: 5.43656365692

(defvar begin_src calc :var something=9
  2(defun something
(defvar end_src

(defvar name:
: 18

(defun  passing arguments through call lines
   :PROPERTIES:
   :DATE:     2010-10-29
   :END:

(defvar name: test
(defvar begin_src R :session :file test.pdf :var myarg="bla"
  plot(1:10, main=myarg)
(defvar end_src

(defvar name: test
[[file:test.pdf]]

(defvar call: test(myarg="hiho")

(defvar name: test(myarg="hiho")
: test.pdf

(defun  simple gnuplot tests
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:
(defvar name: some-more-gnuplot
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
(defvar TBLFM: $2=$1(defun $1

(defvar begin_src gnuplot :var data=some-more-gnuplot
  plot "$data"
(defvar end_src

(defvar name:

Plotting data points from a table could look like this:
(defvar tblname: basic-plot
|   x |         y1 |         y2 |
|-----+------------+------------|
| 0.1 |      0.425 |      0.375 |
| 0.2 |     0.3125 |     0.3375 |
| 0.3 | 0.24999993 | 0.28333338 |
| 0.4 |      0.275 |    0.28125 |
| 0.5 |       0.26 |       0.27 |
| 0.6 | 0.25833338 | 0.24999993 |
| 0.7 | 0.24642845 | 0.23928553 |
| 0.8 |    0.23125 |     0.2375 |
| 0.9 | 0.23333323 |  0.2333332 |
|   1 |     0.2225 |       0.22 |

(defvar begin_src gnuplot :var data=basic-plot :exports code :file basic-plot.png
set title "Putting it All Together"

set xlabel "X"
set xrange [0:1]
set xtics 0,0.1,1

set ylabel "Y"
set yrange [0.2:0.5]
set ytics 0.2,0.05,0.5

plot data u 1:2 w p lw 2 title 'x vs. y1', \
     data u 1:3 w lp lw 1 title 'x vx. y2'
(defvar end_src

(defvar name:
[[file:basic-plot.png]]

(defun  latex headers in latex code blocks
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

(defvar begin_src latex :headers \usepackage{lmodern} :file name1.pdf
  Eric Schulte
(defvar end_src

(defvar name:
[[file:name1.pdf]]

(defvar begin_src latex :headers '("\\usepackage{mathpazo}" "\\usepackage{fullpage}") :file name2.pdf
  Eric Schulte
(defvar end_src

(defvar name:
[[file:name2.pdf]]

(defun  export-specific header arguments
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

(defvar headers: :var out=(if (and (boundp 'latexp) latexp) "latex" "not latex") 
(defvar begin_src emacs-lisp
  out
(defvar end_src

(defvar name:
: not latex

(defun  security problem with elisp in header arguments
   :PROPERTIES:
   :DATE:     2010-10-14
   :END:
(defvar begin_src emacs-lisp :var data=(setq org-confirm-babel-evaluate nil) :results silent
  (+ 1 1)
(defvar end_src

(defun  weaving with noweb links
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-10-13
   :END:

(defvar name: name
(defvar begin_src emacs-lisp
  (message "eric")
(defvar end_src

(defvar begin_src emacs-lisp :noweb tangle
  ;; name
  <<name>>
(defvar end_src

(defun  very very large numbers
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
(defvar tblname: numbers
|                           1 |
|                           2 |
|                          12 |
|                          45 |
|                         166 |
|                    12567890 |
| 231231282371983279389999999 |

(defvar begin_src emacs-lisp :var numbers=numbers
  (mapcar
   (lambda (line)
       (let ((number (car line)))
         (list number (type-of number))))
     numbers)
(defvar end_src

(defvar name:
|                      1 | integer |
|                      2 | integer |
|                     12 | integer |
|                     45 | integer |
|                    166 | integer |
|               12567890 | integer |
| 2.3123128237198328e+26 | float   |

(defun  preceding blank lines on tangle
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
(defvar begin_src emacs-lisp :results silent
  (setq org-babel-tangle-pad-newline nil)
(defvar end_src

(defvar begin_src sh :tangle something.reg
  # something
  echo "else"
(defvar end_src

(defun  index into a scalar
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
(defvar tblname: short-list
| a |
| b |

(defvar begin_src emacs-lisp :var scalar=short-list[0,0]
  scalar
(defvar end_src

(defvar name:
: a

(defun  cycle -- the input is the output
   :PROPERTIES:
   :DATE:     2010-09-29
   :END:
and the rhythm is the base and the base is the treble

(defvar name: cycle
| one   |
| two   |
| three |

(defvar name: cycle
(defvar begin_src emacs-lisp :var table=cycle
  (append (last table) (butlast table))
(defvar end_src

(defvar begin_src emacs-lisp :exports results
  (+ 1 1 1)
(defvar end_src

(defun  Letter
   :PROPERTIES:
   :DATE:     2010-09-21
   :END:

(defvar name: body
(defvar begin_src org :results latex
  ,My body includes a list:
  
  ,- one
  ,- two
  
  ,and a small table:
  
  ,| first | second |
  ,| other | last   |
  
  ,Not more.
(defvar end_src

(defvar begin_src latex :noweb yes :tangle yes
\documentclass[11pt]{isodoc}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\setupdocument{
    to = {Eric},
    subject = {Tough to understand what to do...},
    opening = {Hi},
    closing = {Best}
}

\begin{document}
\letter{%
<<body()>>
}
\end{document}
(defvar end_src

(defun  splitting code blocks
   :PROPERTIES:
   :DATE:     2010-09-19
   :END:
- with indentation
  (defvar begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-previous-src-block (&optional arg)
      "Jump to the previous source block.
    With optional prefix argument ARG, jump backward ARG many source blocks."
      (interactive "P")
      (condition-case nil
          (re-search-backward org-babel-src-block-regexp nil nil (or arg 1))
        (error (error "No previous code blocks")))
      (goto-char (match-beginning 0)) (org-show-context))
  (defvar end_src
  
  (defvar begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-split-block-maybe (&optional arg)
      "Split the current source code block on the cursor."
      (interactive "p")
      ((lambda (info)
         (if info
             (let ((lang (nth 0 info))
                   (indent (nth 6 info))
                   (stars (make-string (org-current-level) ?(defun )))
               (insert (concat (if (looking-at "^") "" "\n")
                               (make-string indent ? ) "(defvar end_src\n"
                               (if arg stars (make-string indent ? )) "\n"
                               (make-string indent ? ) "(defvar begin_src " lang
                               (if (looking-at "[\n\r]") "" "\n  "))))
           (message "Not in src block.")))
       (org-babel-get-src-block-info)))
    
    ;; other stuff
  (defvar end_src

(defun  header arguments on call line
   :PROPERTIES:
   :DATE:     2010-09-09
   :END:
(defvar name: eight
(defvar begin_src R
  8
(defvar end_src

(defvar call: eight() :results vector

(defvar name: eight()
| 8 |

maybe the following with the new proposed header arguments

(defvar call: eight[:session (defun R(defun ]() :results vector

(defun  empty-string results
   :PROPERTIES:
   :DATE:     2010-09-08
   :END:
test me one two 3

(defvar begin_src emacs-lisp
(defvar end_src

More test

(defvar begin_src emacs-lisp
  (mapcar
   (lambda (pair)
     (list (car pair) (cdr pair)))
   params)
(defvar end_src

(defvar name:
| :cache    | no      |
| :colnames | no      |
| :comments |         |
| :exports  | code    |
| :hlines   | yes     |
| :noweb    | no      |
| :results  | replace |
| :session  | none    |
| :shebang  |         |
| :tangle   | no      |

(defun  tangle org-mode block
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
(defvar name: org-list
(defvar begin_src org :results latex
  - one
  - two
  - three
(defvar end_src

(defvar begin_src emacs-lisp :tangle example.tangled :noweb yes
  "
  <<org-list()>>
  "
(defvar end_src

(defun  remove results when nil is returned
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
(defvar begin_src emacs-lisp
  (progn (+ 1 1) nil)
(defvar end_src

(defvar name:

(defun  comparative speed of python evaluation
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
(defvar begin_src python :session test
  2+2
(defvar end_src

(defvar name:
: 4

(defvar begin_src python
  return 2+2
(defvar end_src

(defvar name:
: 4

(defvar begin_src python :session test
def add(a,b):
   return a+b
def sub(a,b):
   return a-b
add(sub(10,1),sub(10,2))
(defvar end_src

(defvar name:
: org_babel_python_eoe

(defun  customizable comment formats
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2010-09-05
   :END:

(defvar begin_src emacs-lisp :results silent
  (setq org-babel-tangle-comment-format-beg "{-# LINE %start-line \"%file\" #-}"
        org-babel-tangle-comment-format-end ""
        org-babel-tangle-pad-newline)
(defvar end_src

(defvar begin_src haskell :tangle Main.hs
  test = length
  main = print $ test [1,2,3]
(defvar end_src

I would like the following output in the tangled file Main.hs:

: {-# LINE 4 "Haskell.org" #-}
: test = length
: main = print $ test [1,2,3]

(defun  tangling with full comments
   :PROPERTIES:
   :comments: org
   :tangle:   full-comments.el
   :DATE:     2010-09-04
   :END:
The top block
(defvar begin_src emacs-lisp
  (message "first block")
(defvar end_src

here's some text which won't be tangled

(defun  subheading
    :PROPERTIES:
    :DATE:     2010-09-04
    :END:
another block
| 1 | first  |
| 2 | second |
(defvar begin_src emacs-lisp
  (message "second")
(defvar end_src

and finally a block with a =:noweb= header argument
(defvar begin_src emacs-lisp :noweb yes
  (progn
    <<tangle-el-the-second>>)
(defvar end_src

(defun  :var (buffer-file-name)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
during export (buffer-file-name) will return nil because the temporary
export buffer is not visiting any file.

/file=(vc-working-revision (buffer-file-name))/
(defvar begin_src sh :var file=(vc-working-revision (or (buffer-file-name) "")) :exports results
  echo $file Revision
(defvar end_src

/file=(vc-working-revision (or (buffer-file-name) org-current-export-file))/
(defvar begin_src sh :var file=(vc-working-revision (or (buffer-file-name) org-current-export-file)) :exports results
  echo $file Revision
(defvar end_src

(defun  quoting header args (e.g. :cmdline)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
(defvar begin_src C :cmdline 1 2 3 4 5 :includes <stdio.h>
  int main(int argc, char (defun argv){
    printf("argv[1] %s\n", argv[1]);
    return 0;
  }
(defvar end_src

(defvar name:
: argv[1] 1

(defun  :session evaluation on export
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
This first block is evaluated but /doesn't/ appear in export.

/:session (defun R(defun  :exports none/
(defvar begin_src R :session (defun R(defun  :exports none
  x <- 8
(defvar end_src

This second block /does/ appear in export.

(defvar begin_src R :session (defun R(defun  :exports results
  x
(defvar end_src

(defun  ditaa with tilda in path
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
(defvar begin_src ditaa :file example.png
    +--------------+
    |              |
    |              |
    |              |
    |              |
    |              |
    +--------------+
(defvar end_src

(defun  scheme sessions
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
(defvar begin_src scheme :var number=9 :session (defun scheme(defun  :scheme guile
  (+ number 0)
(defvar end_src

(defvar name:
: 9

(defvar begin_src scheme :var number=9 :session (defun scheme(defun  :scheme racket
  (+ number 1)
(defvar end_src

(defvar name:
: 10

(defun  conditional tangling
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
(defvar begin_src emacs-lisp :results silent
  (setq tangle-tag "right")
(defvar end_src

(defun  first subheading						       :left:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
(defvar begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "first"
(defvar end_src

(defun  second subheading						      :right:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
(defvar begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "second"
(defvar end_src

(defun  pulling information from tags				       :blue:
   :PROPERTIES:
   :DATE:     2010-08-30
   :END:

(defvar begin_src R :var color=(car (org-get-tags-at (point))) :tangle example.R
  color
(defvar end_src

(defvar name:
: blue

(defun  initial scheme support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
(defvar name: numbers
(defvar begin_src scheme
  (map (lambda (el) (+ el 1)) '(1 2 3))
(defvar end_src

(defvar name:
| 2 | 3 | 4 |

(defvar begin_src scheme :var numbers=numbers
  (map (lambda (el) (- el 1)) numbers)
(defvar end_src

(defvar name:
| 1 | 2 | 3 |

(defun  initial javascript support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
using node.js

(defvar begin_src js
  var n = 0;
  n = n+1;
  return n
(defvar end_src

(defvar name:
: 1

(defvar name: cars
(defvar begin_src js
  var cars = ["Saab","Volvo","BMW"];
  return cars;
(defvar end_src

(defvar name: cars
| Saab | Volvo | BMW |

(defvar begin_src js :var cars=cars
  return cars[0][0];
(defvar end_src

(defvar name:
: Saab

(defvar begin_src js :var cars=cars
  return cars[0].length;
(defvar end_src

(defvar name:
: 3

(defun  wrapping up raw/org results
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
(defvar begin_src emacs-lisp :results org :exports results
  "- first
  - second
  - third
  "
(defvar end_src

(defvar name:
(defvar BEGIN_SRC org
- first
- second
- third
(defvar END_SRC

(defun  trying out plantuml
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
setup
(defvar begin_src emacs-lisp :results silent
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path "~/src/org/contrib/scripts/plantuml.jar")
(defvar end_src

usage -- sequence diagram
(defvar begin_src plantuml :file tryout.png
  Alice -> Bob: synchronous call
  Alice ->> Bob: asynchronous call
(defvar end_src

(defvar name:
[[file:tryout.png]]

(defun  eval for side effect on export
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
- one plus one
  (defvar name: one-plus-one
  (defvar begin_src emacs-lisp :exports none :results silent
    (+ 1 1)
  (defvar end_src
- plus one is
  (defvar begin_src emacs-lisp :var two=one-plus-one :exports both
    (+ 1 two)
  (defvar end_src

(defun  eval and noeval
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
date, should export both, but won't output results because of presence
of the =:noeval= header argument.
(defvar begin_src sh :noeval :exports both
  date
(defvar end_src

should export code, so no need to do anything
(defvar begin_src sh
  date
(defvar end_src

should export nothing, and should not query
(defvar name: this-is-ls
(defvar begin_src sh :eval query :exports code
  date
(defvar end_src

should export results, and should trigger query above
(defvar begin_src emacs-lisp :var ls=this-is-ls :exports results
  ls
(defvar end_src

(defun  duplicate results on execute subtree
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
(defvar begin_src emacs-lisp :results org :exports results
  "- first
- second
- third
"
(defvar end_src

(defvar name:
(defvar BEGIN_SRC org
- first
- second
- third
(defvar END_SRC

(defun  issues with shell evaluation
   :PROPERTIES:
   :DATE:     2010-08-25
   :END:
(defvar begin_src sh :results silent
  cd ~/src/org/
  make
(defvar end_src

(defun  org results and replace
   :PROPERTIES:
   :DATE:     2010-08-18
   :END:

(defvar begin_src emacs-lisp :results org
  "| 1 | 2 |
| 2 | 3 |"
(defvar end_src

(defvar name:
| 1 | 2 |
| 2 | 3 |

(defvar begin_src R
  rnorm(1)
(defvar end_src

(defvar begin_src R
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
(defvar end_src

(defvar name:
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

(defvar begin_src R :colnames yes
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
(defvar end_src

(defvar name:
| V1 | V2 | V3 |
|----+----+----|
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

(defun  ledger example output text
   :PROPERTIES:
   :DATE:     2010-08-13
   :END:
(defvar name: ledger-stuff
(defvar begin_example
09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
(defvar end_example

(defvar begin_src sh :var stuff=ledger-stuff
  echo "$stuff"
(defvar end_src

(defun  tangle R and load
  :PROPERTIES:
  :tangle:   to-load.r
  :DATE:     2010-08-12
  :END:

evaluate this
(defvar begin_src emacs-lisp :results silent :tangle no
  (setq org-babel-post-tangle-hook nil)
  (add-hook 'org-babel-post-tangle-hook
            (lambda () (ess-load-file (buffer-file-name))))
(defvar end_src

then tangle

(defvar begin_src R :comments yes
x <- 10
(defvar end_src

(defvar begin_src R
 y <- 9
(defvar end_src

(defvar begin_src R :tangle file2.R
 y <- 9
(defvar end_src

(defun  lob -- writing results out to files
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
(defvar name: table
(defvar begin_src emacs-lisp
  (mapcar
   (lambda (el) (number-sequence el (+ el 3)))
   (number-sequence 0 4))
(defvar end_src

writes the results out as csv file
(defvar call: write(data=table, file="~/Desktop/example.csv") :results silent

writes the results out as tab separated file
(defvar call: write(data=table, file="~/Desktop/example.tsv") :results silent

write the results out as a normal org-mode file
(defvar call: write(data=table, file="~/Desktop/example.org") :results silent

(defun  lisp
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

(defvar begin_src lisp :var n=5
  (mapcar (lambda (el) ((defun  el el)) (append '(1 7 3 4) (list n)))
(defvar end_src

(defvar name:
| 1 | 49 | 9 | 16 | 25 |

(defvar name: short-list
| 1 |
| 2 |
| 3 |

(defvar begin_src lisp :var lst=short-list :session t
  (+ 1 (length lst))
(defvar end_src

(defvar name:
: 4

(defun  importing the output of ledger
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
(defvar name: ledger-output
(defvar begin_example 
  09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
  09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
  09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
(defvar end_example

(defvar begin_src emacs-lisp :var ledger=ledger-output
  (with-temp-buffer
    (insert ledger)
    (message ledger)
    (org-table-convert-region (point-min) (point-max) 2)
    (org-table-to-lisp))
(defvar end_src

(defvar name:
| 09-Aug-21 CHEQUE : 9953055                | Expenses:Unknown | 166.70 EUR  | 166.70 EUR  |
| 09-Sep-17 CHEQUE : 7691785                | Expenses:Unknown | 100.00 EUR  | 266.70 EUR  |
| 09-Oct-16 REMISE CHEQUE N 8686318 001 105 | Expenses:Unknown | -525.00 EUR | -258.30 EUR |

(defun  comments in R blocks
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

(defvar begin_src R :session (defun R(defun  :results output
  # this is a comment
  x <- rnorm(1)
  # this is another comment
  x
(defvar end_src

(defvar name:
: 
: [1] 1.320853

(defun  colnames to specific variables
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

(defvar tblname: spec-colnames
| one | two | thee |
|-----+-----+------|
| 1   | 2   | 3    |

(defvar tblname: nospec-colnames
| three | two | one |
|-------+-----+-----|
|     3 |   2 |   1 |

(defvar begin_src python :var nospec=nospec-colnames :var spec=spec-colnames :colnames '(spec)
  return nospec
(defvar end_src

(defvar name:
| one   | two | thee |
|-------+-----+------|
| three | two | one  |
| 3     | 2   | 1    |

(defun  caption on code block
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

(defvar caption: Examples of variable declaration.
(defvar label: sql-block
(defvar begin_src sql
SELECT 6(defun 9;
(defvar end_src

(defun  palendromic primes
   :PROPERTIES:
   :DATE:     2010-07-20
   :END:
Note that because Haskell is funny about what can be typed into the
interpreter, the following should be loaded with
=org-babel-load-in-session=.
(defvar begin_src haskell
  palendromic_primes = [x | x <- [1..], prime x, palendrome x]
      where
        factors n = [x | x <- [1..floor(sqrt(fromIntegral(n)))], n `mod` x == 0]
        prime n = factors n == [1]
        primes = [x | x <- [2..], prime x]
        palendrome n = show(n) == reverse(show(n))
  
  palendromic_prime_distances = map (\(x,y)-> y-x) neighbors
      where
        neighbors = (zip palendromic_primes (tail palendromic_primes))
(defvar end_src

(defvar name: palendromic_prime_distances
(defvar begin_src haskell
  take 180 (zip [1..] palendromic_prime_distances)
(defvar end_src

For high-quality png output from gnuplot, the following sequence of
graphing to a =.eps= file, and then converting to a =.png= can be
useful.
(defvar name: dist-graph
(defvar begin_src gnuplot :var data=palendromic_prime_distances :file pps.eps
  set term postscript landscape color enhanced
  set log y
  set title "distance between consecutive palendromic primes"
  plot "$data" with fs notitle
(defvar end_src

The =convert= command is part of the [[http://www.imagemagick.org/script/index.php][imagemagick]] suite.
(defvar begin_src sh :var input=dist-graph :results file
  convert -depth 300 -rotate 90 $input pps.png
  echo "pps.png"
(defvar end_src

(defun  input from an example block
   :PROPERTIES:
   :DATE:     2010-07-13
   :END:
(defvar name: lorem
(defvar begin_example 
  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
  eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
  enimad minim veniam, quis nostrud exercitation ullamco laboris nisi
  ut aliquip ex ea commodo consequat. Duis aute irure dolor in
  reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
  pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
  culpa qui officia deserunt mollit anim id est laborum.
(defvar end_example

(defvar begin_src emacs-lisp :var lorem=lorem
  (message "%d words in Lorem" (length (split-string lorem)))
(defvar end_src

(defvar name:
: 68 words in Lorem

(defvar name: 1D
| 1 |
| 2 |
| 3 |
| 4 |

(defvar begin_src emacs-lisp :var lst=1D[:,0]
  lst
(defvar end_src

(defvar name:
: 1

(defun  example w/o source name
   :PROPERTIES:
   :DATE:     2010-07-12
   :END:

delete emacs-lisp below for errors
(defvar begin_src emacs-lisp
  ((defun  (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1))
(defvar end_src

(defun  tangle R and load
   :PROPERTIES:
   :tangle:   with-comments.r
   :comments: yes
   :DATE:     2010-07-09
   :END:

(defvar begin_src R :tangle no
  z <- 0
(defvar end_src

(defvar begin_src R
  x <- 8
(defvar end_src

(defvar begin_src R
  y <- 9
(defvar end_src

(defvar name: i-have-a-name
(defvar begin_src R 
  x+y+z
(defvar end_src

(defun  export blocks w/o languages
   :PROPERTIES:
   :DATE:     2010-07-09
   :END:
should raise an error

source
(defvar begin_src emacs-lisp
  ;; this is a comment
  (+ 1 1 1)
(defvar end_src

broken source
(defvar begin_src 
  (+ 2 2 2)
(defvar end_src

example
(defvar begin_example 
  this is exampled
(defvar end_example

(defvar begin_src ruby
  # this is the first
  [1, 2, 3, 4, 5].map{|r| r+1}
(defvar end_src

(defun  scratch
   :PROPERTIES:
   :DATE:     2010-07-08
   :END:

(defvar begin_src emacs-lisp :exports results
  (+ 1 1 1 1)
  (setq org-export-babel-evaluate t)
(defvar end_src

and now for src_emacs-lisp{87} an inline block

looking at paths
(defvar begin_src emacs-lisp
  (buffer-file-name)
(defvar end_src

(defun  Tom found a bug
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:

(defvar begin_src emacs-lisp :tangle something.el
  (list 1 (+ 2 3))
(defvar end_src

(defvar name:
| 1 | 5 |

(defun  dot
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:
(defvar begin_src dot :file models.png :cmdline -Tpng
  digraph data_relationships {
    "data_requirement" [shape=Mrecord, label="{DataRequirement|description\lformat\l}"]
    "data_product" [shape=Mrecord, label="{DataProduct|name\lversion\lpoc\lformat\l}"]
    "data_requirement" -> "data_product"
  }
(defvar end_src

(defvar name:
[[file:models.png]]

(defun  python errors
   :PROPERTIES:
   :DATE:     2010-07-04
   :END:
(defvar begin_src python :session :results value
  [1, [2], 3, 4]
(defvar end_src

(defvar name:
| 1 | (2) | 3 | 4 |

(defvar begin_src ruby :results output :session
  [1, 2, 3, 4, 6].map{|n| puts n}
(defvar end_src

(defvar name:
: 1
: 2
: 3
: 4
: 6

(defvar begin_src python :session :results output
  print 9
(defvar end_src

(defvar name: R-with-colnames
| one |
|-----|
| 1   |

(defvar begin_src R :results output
  "something"
(defvar end_src

(defvar name:
: [1] "something"

(defvar begin_src R :session (defun R(defun  :results output
  1
  2
  3
  4
(defvar end_src

(defvar name:
: [1] 1
: [1] 2
: [1] 3
: [1] 4

(defvar begin_src perl :results output
  print "8\n";
  print "9\n";
(defvar end_src

(defvar name:
: 8
: 9

(defvar begin_src clojure
  (+ 8 7)
(defvar end_src

(defvar name:
: 15

(defvar begin_src clojure :session (defun clj(defun 
  (println "eric")
(defvar end_src

(defvar name:
: nil

(defvar begin_src perl :results value
  8
(defvar end_src

(defvar name:
: 8

(defvar begin_src c++ :includes '(<stdio.h> <math.h> <cstdlib> <time.h>)
  printf("eric schulte\n");
(defvar end_src

(defvar name:
: eric schulte

(defvar begin_src sh
  echo 78
(defvar end_src

(defvar name:
: 78

(defun  table comment issue
   :PROPERTIES:
   :DATE:     2010-06-30
   :END:
(defvar BEGIN_changemargin {-4.2cm}{0cm}
  (defvar TBLNAME: AutresFPNVE
  (defvar ATTR_LaTeX: align=lrrrrr
  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Total                                    |                      |                 |                |            |    1062.02 |
  | ^ |                                          |                      |                 |                |            |      Total |
  (defvar tblfm: $7=$3(defun $4(defun $5(defun $6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12(defun 13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
(defvar END_changemargin

save me!

(defvar begin_src org
  ,  (defvar TBLNAME: AutresFPNVE
  ,  (defvar ATTR_LaTeX: align=lrrrrr
  ,  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  ,  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  ,  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  ,  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  ,  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Total                                    |                      |                 |                |            |    1062.02 |
  ,  | ^ |                                          |                      |                 |                |            |      Total |
  ,  (defvar TBLFM: $7=$3(defun $4(defun $5(defun $6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12(defun 13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
(defvar end_src

(defvar begin_example 
(defvar tblname: example
| 1 | 2 |
(defvar end_example

(defun  latex literals in export
    :PROPERTIES:
    :DATE:     2010-06-30
    :END:

   (defvar ATTR_LaTeX: width=\textwidth
   [[./composite-pattern.png]]

(defun  captions
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:

(defvar caption: I'm not removed from export
(defvar label: also-not-removed
| A | B |
| 1 | 2 |

(defun  booktabs
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:
(defvar tblname: months
| num | Abbrev. |
|-----+---------|
|   1 | Jan.    |
|   2 | Feb.    |
|   3 | Mar.    |

(defvar call: booktabs(table=months, align="r|l") :results latex :exports results

(defun  table-label
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
(defvar label: bam
| 1 |
| 2 |
| 3 |

(defun  haskell issues
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:

(defvar begin_src haskell
  length [1, 2]
(defvar end_src

(defvar name:
: 2

(defvar tblname: example-4-haskell
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |

(defvar begin_src haskell :var this=example-4-haskell
  length this
(defvar end_src

(defvar name:
: 7

(defun  complex
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
(defvar name: raw-data
(defvar begin_src sh :results scalar
  wget --quiet -qO- "http://ogdi.cloudapp.net/v1/dc/RecreationParks?format=json"
(defvar end_src

(defvar name: dc-parks
(defvar begin_src emacs-lisp :var keys='(ward area) :var data=raw-data
  (mapcar
    (lambda (lis) (mapcar (lambda (key) (cdr (assoc key lis))) keys))
    (cdr (car (with-temp-buffer
                (insert data) (goto-char (point-min))
                (json-read)))))
(defvar end_src

(defvar name: dc-parks-metric
(defvar begin_src ruby :var data=dc-parks
  data.map{|f| [f[0], 2.59 (defun  f[1]]}
(defvar end_src

(defvar begin_src R :var parkData=dc-parks-metric :file parks.png :session (defun R(defun 
  plot(parkData)
  title(main="Park size by Ward")
(defvar end_src

(defvar name:
[[file:parks.png]]

(defun  possible prefixes
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

| prefix   | remaining characters |
|----------+----------------------|
| ob-      |                    5 |
| org-b-   |                    2 |
| orgb-    |                    3 |
| org-bbl- |                    0 |
| bbl-     |                    4 |
| babel-   |                    2 |
(defvar TBLFM: $2='(sbe leftover (prefix $$1))

(defvar name: leftover
(defvar begin_src emacs-lisp :var prefix=""
  (-
   ;; length w/o .el
   (- 13 (length ".el"))
   ;; length of prefix
   (length prefix))
(defvar end_src

(defun  hlines in python
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

(defvar tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

(defvar name: echo-table
(defvar begin_src python :var tab=many-cols :hlines yes :exports both :session
  return tab
(defvar end_src

(defvar begin_src emacs-lisp :var table=echo-table :exports none
  (butlast (apply #'append (mapcar (lambda (el) (list el 'hline)) table)))
(defvar end_src

(defvar call: echo-table(tab=many-cols)

(defvar begin_src python :exports results
  return [['foo', 'bar', 'baz'], ["a", "b", "None of the above"], ['1', 2, 3]]
(defvar end_src

(defvar begin_src emacs-lisp :exports results
  (message "Exist")
(defvar end_src

(defun  protecting block bodies
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
neither of these work as expected

(defvar begin_src org
  ,(defvar TITLE: stuff
  
  ,(defvar begin_src emacs-lisp
  ,  (message "something")
  ,(defvar end_src
  
  ,more stuffs
  
  ,(defvar resname: something
  ,: value
  
  ,# and a comment
(defvar end_src

(defvar begin_src org
  ,(defun  example org
  
  ,# this is a comment
  ,this is not a comment
(defvar end_src


(defvar begin_src org
  ,(defun  escaped org-mode markup
  
  ,this should be exported as is
  ,(defvar results: escaping-example
  ,: 24
(defvar end_src


(defvar begin_html 
<pre>
#comment
(defvar end_src
</pre>
(defvar end_html
final

(defun  multiple evals for refs
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
(defvar begin_src emacs-lisp
  (setq counter 0)
(defvar end_src

(defvar name:
: 0

(defvar name: counter
(defvar begin_src emacs-lisp
  (setq counter (+ 1 counter))
  counter
(defvar end_src

(defvar begin_src emacs-lisp :var counter_val=counter
  counter_val
(defvar end_src

(defvar name:
: 3

(defun  tangling
   :PROPERTIES:
   :DATE:     2010-06-17
   :END:

(defvar begin_src sh :shebang #!/bin/sh :tangle yes
  date
(defvar end_src

(defvar begin_src sh :shebang #!/bin/bash :tangle whoisme :exports both
  echo $USER
(defvar end_src

(defvar begin_src emacs-lisp :tangle yes :comments yes
  (message "BAM")
(defvar end_src

(defvar begin_src fortran :exports both
  1+8
(defvar end_src

(defun  foo org
   :PROPERTIES:
   :session:  (defun R(defun 
   :DATE:     2010-06-16
   :END:
Figure \ref{fig:one} (p. \pageref{fig:one}) is produced by the following code
(defvar BEGIN_SRC R 
plot(x, y)
abline(out1)
(defvar END_SRC
Note that =x=, =y=, and =out1= are remembered from the preceding code
chunk.  We don't have to regenerate them.  All code chunks are part of
one R "session".
and more stuff here and then the results
(defvar attr_latex: width=0.8\textwidth,placement=[p]
(defvar label: fig:one
(defvar caption: Scatter Plot with Regression Line
[[file:fig1.pdf]]

(defun  comments not commented
   :PROPERTIES:
   :DATE:     2010-06-16
   :END:

# $some stuff
# some more stuff$ -- I should be a comment line

1) a source block inside of an =enumerate=
   (defvar name: plotxy
   (defvar begin_src emacs-lisp :exports results
     (message "I think so")
   (defvar end_src
   (defvar begin_src emacs-lisp
     (message "don't eat me")
   (defvar end_src
   

   can cause problems

2) how about this one...

(defun  don't eat me!
   :PROPERTIES:
   :DATE:     2010-06-15
   :END:
1) a source block inside of an =enumerate=
   (defvar begin_src emacs-lisp :exports results
     (list (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry"))
   (defvar end_src

   (defvar name:
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |

   (defvar begin_src emacs-lisp
     (message "don't eat me")
   (defvar end_src

   can cause problems

2) source blocks should be able to be on adjacent lines

(defun  simple reference
   :PROPERTIES:
   :DATE:     2010-06-13
   :END:
(defvar tblname: table-the-first
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

(defvar begin_src emacs-lisp :var data=table-the-first[1,1]
  data
(defvar end_src

(defvar name:
: 5

(defun  exporting with call lines
   :PROPERTIES:
   :DATE:     2010-06-11
   :END:
(defvar name: rpn-to-alg(alg)
(defvar begin_src clojure :results output :var alg="00+"
  (def binary-operators '(\+ \- \(defun  \/))
  (def unary-operators '(\s))
  (defn rpn-to-alg [chars stack]
    (if (> (.size chars) 0)
      (let [el (first chars)]
        (if (some #{el} binary-operators)
          (rpn-to-alg (rest chars)
                      (cons
                       (apply str "(" (or (second stack) 1) " " el " " (or (first stack) 1) ")")
                       (rest (rest stack))))
          (if (some #{el} unary-operators)
            (rpn-to-alg (rest chars)
                        (cons
                         (apply str "(" el " " (or (first stack) 1) ")")
                         (rest (rest stack))))
            (rpn-to-alg (rest chars) (cons el stack)))))
      (first stack)))
  (println (apply str (rpn-to-alg (seq alg) '())))
(defvar end_src

(defvar name: distributed-best
: 73(defun x11/+4/++51xxx13(defun y/++6y5(defun 6/6-+xx+(defun 

(defvar call: rpn-to-alg(alg=distributed-best)
 
(defun  can't open indented results
    :PROPERTIES:
    :DATE:     2010-06-11
    :END:

    (defvar begin_src latex :packages '(("" "tikz") ("active,tightpage" "preview")) :file recursion.pdf
      \begin{preview}
      \ovalbox{
      \begin{tikzpicture}
      \node{$n$}
       	child {
          node{$\left(\frac{n}{2}\right)^2$}
            child{
              node{$\left(\frac{n}{4}\right)^2$}
              node{$\left(\frac{n}{4}\right)^2$}
            }
          }
       	child{
          node{$\left(\frac{n}{2}\right)^2$}
          child{
            node{$\left(\frac{n}{4}\right)^2$}
            node{$\left(\frac{n}{4}\right)^2$}
          }
       	};
      \end{tikzpicture}
      }
      \end{preview}
    (defvar end_src

    (defvar name:
    [[file:recursion.pdf]]

(defun  indented source-code blocks and indented results
    :PROPERTIES:
    :DATE:     2010-06-10
    :END:

     (defvar name: time
     (defvar begin_src emacs-lisp :results append
       ;; (list (list (current-time-string)))
       (current-time-string)
     (defvar end_src

     (defvar name: time
     | 1 | 2 | 3 |


         (defvar call: time() :results prepend

         (defvar name: time()
         | 1 | 2 | 3 |
         : Thu Jun 10 14:13:21 2010
         : Thu Jun 10 14:13:21 2010
         : : Thu Jun 10 14:13:21 2010
         : : Thu Jun 10 14:13:21 2010
         : : Thu Jun 10 14:13:21 2010
         : nil
         : nil
         : Thu Jun 10 14:11:22 2010
         : Thu Jun 10 14:11:20 2010
         : nil
         : nil
         : Thu Jun 10 14:06:04 2010
         : Thu Jun 10 14:06:03 2010
         : Thu Jun 10 14:05:51 2010
         : Thu Jun 10 14:05:57 2010
         : Thu Jun 10 14:06:00 2010

(defun  not expand inlines in examples
   :PROPERTIES:
   :DATE:     2010-06-08
   :END:

: src_emacs-lisp{(+ 1 2 3)}

(defvar begin_example 
  src_emacs-lisp{(+ 1 2 3)}
(defvar end_example

src_emacs-lisp{(+ 1 2 3)}

(defvar begin_example 
  src_emacs-lisp{(+ 1 2 3)}
(defvar end_example

(defun  updating results "in-situ"
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

(defvar name: in-situ
: update me in place please -- Mon Jun  7 16:44:44 2010
: update me in place please -- Mon Jun  7 16:44:43 2010
: update me in place please -- Mon Jun  7 16:44:42 2010
: update me in place please -- Mon Jun  7 16:44:37 2010
: update me in place please -- Mon Jun  7 16:42:14 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:44:59 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:00 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:02 2010

the results should be (defun above(defun  the block

(defvar name: in-situ
(defvar begin_src emacs-lisp :results prepend
  (format "update me in place please -- %s"
          (current-time-string))
(defvar end_src

(defvar name: in-situ
(defvar begin_src emacs-lisp :results append
  (format "update me in place please (at the bottom) -- %s"
          (current-time-string))
(defvar end_src

(defun  unwind-protect with narrowing
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

I'm not in the subtree

(defun  I'm in the subtree
    :PROPERTIES:
    :DATE:     2010-06-07
    :END:
(defvar begin_src emacs-lisp
  (+ 6 "I'm not a number!!")
(defvar end_src

(defun  stripping existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
(defvar name: trickily-located-somehwere-else
: I shouldn't be exported

Neither of the result strings for the following two code blocks should
be included in the export.  And only one of the bodies should be
included...

(defvar begin_src emacs-lisp :exports code
  (+ 1 1 1 1)
(defvar end_src

(defvar name:
: don't include me in the export!!!!!!!

(defvar name: trickily-located-somehwere-else
(defvar begin_src emacs-lisp :exports none
  (message "I shouldn't be exported")
(defvar end_src

(defun  non-empty comint prompt
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

(defvar begin_src ruby :session eric
  8 + 9
(defvar end_src

(defun  inhibiting evaluation on export
   :PROPERTIES:
   :noeval:   don't do it
   :DATE:     2010-06-07
   :END:

(defvar begin_src clojure :session eric :exports none
  (+ 1 1 1 1)
  (error)
(defvar end_src

(defun  indented source names
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

   (defvar name: i-am-indented
   (defvar begin_src emacs-lisp 
     (message "i am indented")
   (defvar end_src

(defvar name: i-am-indented
: i am indented

(defvar begin_src emacs-lisp :var output=i-am-indented
  (length output)
(defvar end_src

(defvar name:
: 13

  (defvar name:
  : eric

(defun  export with existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

(defvar begin_src emacs-lisp :exports none :results silent
  '((1 2) (3 4))
(defvar end_src

(defvar name:
| 1 | 2 |
| 3 | 4 |

(defvar begin_src ditaa :file /tmp/eric.png :exports none :results silent
    +---------------+
    |               |
    |               |
    |               |     +-----------------+
    |    Eric       |     |                 |
    |               |     |    Schulte      |
    |               |     |                 |
    |               |     +-----------------+
    +---------------+
(defvar end_src

(defvar name:
[[file:/tmp/eric.png]]

(defun  executing emacs-lisp on export
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

(defvar begin_src emacs-lisp
  (error "eric")
(defvar end_src

(defun  commas on tangling test
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
test comma protection on tangling

(defvar begin_src emacs-lisp :results silent
  (org-babel-add-interpreter "org")
  (add-to-list 'org-babel-tangle-langs '("org" "org"))
(defvar end_src

(defvar begin_src org :tangle commas.org
  ,(defun  org-mode
  ,  :PROPERTIES:
  ,  :CUSTOM_ID: comma-protect
  ,  :END:
  
  ,(defvar begin_src emacs-lisp
  ,  protected?
  ,(defvar end_src
(defvar end_src

(defvar begin_example 
  ,(defun  this should be
  # commented out
  
  and maybe not this...
(defvar end_example

(defun  simple table
   :PROPERTIES:
   :DATE:     2010-06-06
   :END:
(defvar begin_src emacs-lisp
  '((1 2 3) (4 5 6) (7 8 900))
(defvar end_src

(defvar name:
| 1 | 2 |   3 |
| 4 | 5 |   6 |
| 7 | 8 | 900 |

(defun  inline expressions
   :PROPERTIES:
   :session:  'default
   :DATE:     2010-06-06
   :END:

(defvar begin_src R :exports code :results silent
  x<-4
(defvar end_src

the sum of 1 and x is equal to src_R{x+1}, now I'll sneakily reset
this value in a hidden inline block src_R[:exports none]{x<-2}, so
it's value is now src_R{x}.

(defun  adding file names to literal values on export
   :PROPERTIES:
   :DATE:     2010-06-01
   :END:

(defvar name: three
: 9

(defvar begin_src R :var num=three :exports results
runif(n=num, min=0, max=1)
(defvar end_src

(defvar begin_src R :var num=3 :exports results
runif(n=num, min=0, max=1)
(defvar end_src

(defun  appending tangle
   :PROPERTIES:
   :tangle:   appended.el
   :DATE:     2010-05-28
   :END:
append all these block

(defvar begin_src emacs-lisp
  (message "block %d" 1)
(defvar end_src

(defvar begin_src emacs-lisp
  (message "block %d" 2)
(defvar end_src

(defvar begin_src emacs-lisp
  (message "block %d" 3)
(defvar end_src

(defun  visibility affecting execution
    :PROPERTIES:
    :DATE:     2010-05-27
    :END:

(defun  folding
    :PROPERTIES:
    :DATE:     2010-05-27
    :END:
lets test folding

(defun (defun  folded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
(defvar begin_src emacs-lisp
  (message "folded1")
(defvar end_src

(defvar name:
: folded1

(defvar begin_src emacs-lisp
  (message "folded2")
(defvar end_src

(defvar name:
: folded2
(defun (defun  unfolded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
(defvar begin_src emacs-lisp
  (message "unfolded1")
(defvar end_src

(defvar name:
: unfolded1
(defvar begin_src emacs-lisp
  (message "unfolded2")
(defvar end_src

(defvar name:
: unfolded2

(defun  empty code blocks -- and latex vs. LaTeX
   :PROPERTIES:
   :DATE:     2010-05-26
   :END:
eric
(defvar begin_src latex
  
(defvar end_src

michael
(defvar begin_src LaTeX
  
(defvar end_src

schulte
(defvar begin_src emacs-lisp
  (message "error")
(defvar end_src

(defun  colnames
   :PROPERTIES:
   :DATE:     2010-05-04
   :END:

(defvar tblname: A
| a | b | c |
|---+---+---|
| d | e | f |
| g | h | i |

(defvar begin_src python :var tab=A :colnames yes
return [[val + '(defun ' for val in row] for row in tab]
(defvar end_src

(defvar name:
| a  | b  | c  |
|----+----+----|
| d(defun  | e(defun  | f(defun  |
| g(defun  | h(defun  | i(defun  |

(defvar tblname: A
| a | b | c |
| d | e | f |
| g | h | i |

(defvar begin_src ruby :var tab=A :colnames yes
tab.map{|r| r.map{|e| e+"(defun "} }
(defvar end_src

(defvar name:
| a  | b  | c  |
|----+----+----|
| d(defun  | e(defun  | f(defun  |
| g(defun  | h(defun  | i(defun  |

(defun  lisps not fully eval'd
   :PROPERTIES:
   :DATE:     2010-04-30
   :END:

(defvar begin_src emacs-lisp
  (message "one")
  (message "two")
(defvar end_src

(defvar name:
: two

(defvar begin_src clojure :session :default
  (println "one")
  (println "two")
  (+ 1 2)
(defvar end_src

(defvar name:
: 3

(defun  tangling org
   :PROPERTIES:
   :DATE:     2010-04-27
   :END:

(defvar begin_src org :tangle ~/Desktop/test.org
  ,(defun  first
  ,| eric   | me     |
  ,| patton | my dog |
  
  ,(defun  second
  
  ,some more stuff...
  
  ,(defvar HTML: <b>I bet this is quoted</b>
(defvar end_src

(defvar begin_src ruby :tangle ~/Desktop/test.rb
  # this is a comment
  eric.map{|l| puts l}
(defvar end_src

(defun  variable indexing
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
(defvar TBLNAME: MyTable
 |   X |  Y |
 |-----+----|
 |   0 |  0 |
 |   1 |  1 |
 |   2 |  4 |
 |   3 |  9 |
 |   4 | 16 |
 |   5 | 25 |
 |-----+----|
 | Sum | 55 |
 (defvar TBLFM: $2=$1(defun $1::@8$2=vsum(@2..@-1)

(defvar begin_src python :var sum=MyTable[2:7,1] :exports none
   return sum
(defvar end_src

(defvar name:
| 0 | 1 | 4 | 9 | 16 | 25 |

(defvar begin_src python :var sum=MyTable[9,1] :exports none
   return sum
(defvar end_src

(defvar name:
: 55

(defvar begin_src gnuplot :var data=MyTable[1:-2] :var sum=MyTable[7,1]
:results silent :exports none
  reset
  set label "Sum: %.0f",sum at graph 0.03, graph 0.93
  plot data with linespoints
(defvar end_src

(defun  colnames mismatched sizes
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
(defvar tblname: mismatch-colnames
| a |  b |
|---+----|
| 1 |  8 |
| 2 |  9 |
| 3 | 10 |
| 4 | 11 |

(defvar begin_src python :var tab=mismatch-colnames
  return [[1, 2, 3]]
(defvar end_src

(defvar name:
| 1 | 2 | 3 |

(defvar begin_src python :var tab=mismatch-colnames
  return [[1, 2]]
(defvar end_src

(defvar name:
| a | b |
|---+---|
| 1 | 2 |

(defvar begin_src python :var tab=mismatch-colnames :colnames yes
  return [1,2]
(defvar end_src

(defvar name:
| 1 | 2 |

(defun  test gnuplot
   :PROPERTIES:
   :DATE:     2010-04-17
   :END:

(defvar begin_src gnuplot
  plot sin(x), x+5
(defvar end_src

(defun  hline processing
   :PROPERTIES:
   :DATE:     2010-04-12
   :END:
(defvar tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

(defvar tblname: less-cols
| 1 |
|---|
| 2 |
| 3 |

(defvar tblname: less-cols2
| 1 | 2 | 3 |

(defvar begin_src emacs-lisp :var tab=many-cols
  (message "%S" tab)
  ;; (remove 'hline tab)
  ;; (flet ((rem-hline (el)
  ;;                   (if (listp el)
  ;;                       (remove nil (mapcar #'rem-hline el))
  ;;                     (if (equal 'hline el) nil el))))
  ;;   (rem-hline tab))
(defvar end_src

(defvar begin_src ruby :var tab=less-cols
  tab
(defvar end_src

(defvar name:
| 1 |
|---|
| 2 |
| 3 |

(defvar begin_src ruby :var one=2
  1 + 2
(defvar end_src

(defvar name:
: 3

(defvar begin_src python :var tab=less-cols
  return tab
(defvar end_src

(defvar name:
| 1 |
|---|
| 2 |
| 3 |

(defvar begin_src ruby :var tab=less-cols :colnames no
  tab
(defvar end_src

(defvar name:
| 1 |
| 2 |
| 3 |

(defvar begin_src emacs-lisp :var tab=row-and-col-names
   (message "%S" tab)
(defvar end_src

(defvar name:
: (("" "c1" "c2" "c3") hline ("r1" 1 4 7) ("r2" 2 5 8) ("r3" 3 6 9))

(defvar tblname: row-and-col-names
|    | c1 | c2 | c3 |
|----+----+----+----|
| r1 |  1 |  4 |  7 |
| r2 |  2 |  5 |  8 |
| r3 |  3 |  6 |  9 |

functions
(defvar begin_src emacs-lisp
  (defun org-babel-del-hlines (table)
    "Remove all 'hlines from TABLE."
    (remove 'hline table))
  
  (defun org-babel-get-colnames (table)
    "Return a cons cell, the `car' of which contains the TABLE
        less colnames, and the `cdr' of which contains a list of the
        column names"
    (if (equal 'hline (second table))
        (cons (cddr table) (car table))
      table))
    
  (defun org-babel-get-rownames (table)
    "Return a cons cell, the `car' of which contains the TABLE less
     colnames, and the `cdr' of which contains a list of the column
     names.  Note: this function removes any hlines in TABLE"
    (flet ((trans (table) (apply #'mapcar(defun  #'list table)))
      (let ((table (trans (remove 'hline table))))
        (cons (cdr table) (car table)))))
  
  (defun org-babel-put-colnames (table colnames)
    "Add COLNAMES to TABLE if they exist."
    (if colnames (apply 'list colnames 'hline table) table))
  
  (defun org-babel-put-rownames (table rownames)
    "Add ROWNAMES to TABLE if they exist."
    (if rownames
        (mapcar (lambda (row)
                  (if (listp row)
                      (cons (or (pop rownames) "") row)
                    row)) table)
      table))
(defvar end_src

(defun  evaluate references
   :PROPERTIES:
   :DATE:     2010-04-09
   :END:

(defvar begin_src emacs-lisp :var var=`(+ 9 ,(- 19 7)) :tangle yes
  (message "var is %S" var)
(defvar end_src

(defvar begin_src emacs-lisp
  (+ 1 2)
(defvar end_src

(defvar name:
: 3

(defvar begin_src ruby
  + 1 2
(defvar end_src

(defvar name:
: nil

(defun  tangling and variable resolution
  :PROPERTIES:
  :ID:       18b4f1be-bb1d-49bc-a651-c97406a35bdd
  :tangle:   yes
  :DATE:     2010-03-31
  :END:

(defvar name: A
(defvar begin_src emacs-lisp :eval no :expand yes :var id=(org-entry-get nil "ID" t) :var two=2
  (concat "This is the entry ID: " id)
(defvar end_src

(defvar name: A
: This is the entry ID: 18b4f1be-bb1d-49bc-a651-c97406a35bdd

(defun  latex attributes
   :PROPERTIES:
   :DATE:     2010-03-23
   :END:

(defvar ATTR_LaTeX: width=0.38\textwidth wrap placement={r}{0.4\textwidth}
(defvar begin_src ditaa :file=scrap.png
  +---------------------------+
  |                           |
  |       latex               |
  |                           |
  |      +------------+       |
  |      |            |       |
  |      |            |       |
  |      |       cBLU |       |
  |      +------------+       |
  |                      cPNK |
  +---------------------------+
(defvar end_src

(defun  access to variables set in property drawers
   :PROPERTIES:
   :special:  89
   :text: schulte
   :DATE:     2010-03-22
   :END:

: "(org-entry-get nil "special" t)"

(defvar begin_src emacs-lisp :var special=(string-to-number (org-entry-get nil "special" t))
  (+ special 1)
(defvar end_src

(defvar name:
: 90

(defvar begin_src emacs-lisp :var special=(org-entry-get nil "text" t)
  special  
(defvar end_src

(defvar name:
: schulte

(defun  variables into shell scripts
   :PROPERTIES:
   :DATE:     2010-02-23
   :END:
(defvar name: into-shell-scripts
| username | guest   |
| password | nothing |

(defvar begin_src sh :var username=into-shell-scripts[0,0] :var password=into-shell-scripts[1,1] :results output
  echo "$username -p $password"
(defvar end_src

(defvar name:
: username -p nothing

(defvar name: number-into-shell
: 9

(defvar begin_src sh :var num=number-into-shell
  for i in `seq $num`; do
      echo $i
  done
(defvar end_src

(defvar name:
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

(defun  results lines for function calls
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

(defvar call: fibonacci(input=5) :resname eric

(defvar name:
: 8

(defvar begin_src emacs-lisp :var fib=fibonacci(input=5)
  (message "fib(5)=%d" fib)
(defvar end_src

(defvar name:
: fib(5)=8

(defun  haskell variables
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

playing with Haskell

(defvar name: haskell-stuff
: 9

(defvar begin_src haskell :var num=haskell-stuff
  num + 1
(defvar end_src

(defvar begin_src ruby :var num=haskell-stuff
  num + 1
(defvar end_src

(defvar name:
: 10

(defun  list index w/function style name
   :PROPERTIES:
   :DATE:     2010-02-14
   :END:

(defvar name: function-style-index
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

(defvar name: function-style-indexing(data=function-style-index[1:4,0])
(defvar begin_src emacs-lisp
  (message "%S" data)
(defvar end_src

(defvar name: function-style-indexing
: ((1) (2) (3) (4))

(defun  looking at source name exports
   :PROPERTIES:
   :DATE:     2010-02-09
   :END:

(defvar name: fibonacci
(defvar begin_src emacs-lisp :var input=0
  (defun fib (n)
    (if (> n 1)
        (+ (fib (- n 1)) (fib (- n 2)))
        1))
  (fib input)
(defvar end_src

(defvar name: fibonacci
: 1

now applying our Fibonacci function

(defvar call: fibonacci(input=5)

(defun  short shell test
   :PROPERTIES:
   :DATE:     2010-02-07
   :END:

(defvar begin_src sh
  date
(defvar end_src

(defvar name:
: Sun Feb  7 10:17:44 MST 2010

(defvar tblname: fibs
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

(defvar begin_src sh :var table=fibs
  echo "$table" |wc
(defvar end_src

(defvar name:
: 6      12      24

(defvar begin_src sh :var table=fibs
  echo "$table"
(defvar end_src

(defvar name:
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

(defvar begin_src sh :var table=fibs :separator --
  echo "$table" | head -1
(defvar end_src

(defvar name:
: 1--1

(defun  tables to shell scripts ideas
   :PROPERTIES:
   :DATE:     2010-02-06
   :END:

(defvar tblname: sec
| Hello | World |


1) allowing the user to specify a separator with a header argument as
   follows
   (defvar begin_src sh :var table=sec :separator ,
     cat <<EOF
     $table
     EOF
   (defvar end_src
   
   which would result in something like

   : "Hello, World"

2) writing the table to a tab or comma separated file and then
   replacing =$table= in the source block body with the path to the
   file name, s.t. something like
   
   (defvar begin_src sh :var table=data
     wc $table
   (defvar end_src

   would return reasonable results

(defun  tangling w/o comments and shebang
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-02-05
   :END:

(defvar begin_src emacs-lisp :comments no :shebang (identity my-shebang)
  (message "I should have no comments")
(defvar end_src

(defvar begin_src emacs-lisp :comments no
  (setq my-shebang "foo")
(defvar end_src

(defvar name:
: foo

(defvar begin_src ruby :shebang #!/usr/bin/ruby
  puts :nonstandard_shebang
(defvar end_src

(defun  exporting to a file
   :PROPERTIES:
   :EXPORT_FILE_NAME: simple
   :EXPORT_TITLE: testing file export
   :DATE:     2010-02-03
   :END:

this is the contents

and a block
(defvar begin_src clojure
  (println "is a nice lisp")
(defvar end_src

ah, it works!

(defun  babel block overwrite
   :PROPERTIES:
   :DATE:     2010-01-18
   :END:

The first block overwrites
(defvar begin_src clojure
  (def overwriter "I'll show up everywhere")
(defvar end_src

this second block
(defvar begin_src diff
  3719d3718
  <       movl    $1024, 8(%esp)
(defvar end_src

(defun  load to session
   :PROPERTIES:
   :DATE:     2010-01-11
   :END:
(defvar begin_src clojure :session asm-gp
  (in-ns 'asm-gp)
(defvar end_src

(defvar begin_src ruby :session
  puts :eric
(defvar end_src

(defvar begin_src python :session
  5 + 1 
(defvar end_src

(defvar begin_src R :session
  6 + 1
(defvar end_src

(defvar begin_src sh :session
  date
(defvar end_src

(defvar begin_src ocaml :session
  eric
(defvar end_src

(defvar begin_src gnuplot :session
  plot sin(x)
(defvar end_src

(defun  links
   :PROPERTIES:
   :DATE:     2010-01-06
   :END:

can LaTeX link itself to the middle of a paragraph with a simple
inline link like <<keystone>> if not then we would probably need to
wrap source-code blocks in figures to make them referable.

how about a link back to [[keystone]]

The above appears to work in LaTeX, but not in HTML.

(defun  fancier export
   :PROPERTIES:
   :DATE:     2010-01-05
   :END:

(defvar name: square
(defvar begin_src emacs-lisp :var input=1
  ((defun  input input)
(defvar end_src

(defun  exporting org-source
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:

(defvar begin_src org
  ,lets see how this org-mode code exports to html
  
  ,is this [[link]] blue?
  
  ,(defvar begin_src emacs-lisp
  ,  (+ 1 2)
  ,(defvar end_src
(defvar end_src

(defun  exporting and caching
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:
(defvar begin_src ditaa :file data/example.png :exports none
    +------------------+
    |  ditaa example   |
    |                  |
    |                  |
    +------------------+
(defvar end_src

(defvar name:
[[file:data/example.png]]

(defun  no noweb by default
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

(defvar name: sample
(defvar begin_src emacs-lisp 
  (message "sample")
(defvar end_src

(defvar begin_src emacs-lisp :noweb no
  <<sample>>
(defvar end_src

(defvar name:
: sample

(defun  looking at double quotes
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

(defvar tblname: double-quote-test-input
| test | this | 8 | 9 |

(defvar name: double-quote-test-output
(defvar begin_src python :var data=double-quote-test-input
  return data
(defvar end_src

(defvar name: double-quote-test-output
| test | this | 8 | 9 |

(defun  quoted session name
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:

(defvar begin_src sh :session "eric"
  echo 'name-me'
(defvar end_src

(defvar name:
: name-me

(defun  eval-buffer
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:
(defvar begin_src emacs-lisp
  (+ 1 2)
(defvar end_src

(defvar name:
: 3

(defvar begin_src emacs-lisp
  (+ 3 4)
(defvar end_src

(defvar name:
: 7

(defun  sql exports to latex
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
example from email list
(defun  ECM
    :PROPERTIES:
    :DATE:     2009-11-30
    :END:

   - faire un script Bash (et =isql=) envoyant un /listing/ de stagiaires;

(defvar name: envoi-stg
   (defvar begin_src sql
       DECLARE @dateFmtStyleIn int; SET @dateFmtStyleIn = 120 -- ODBC canonical
       DECLARE @dateFmtStyleOut int; SET @dateFmtStyleOut = 103 -- French dd/mm/yyyy

       DECLARE @firstDayOfThisMonth smalldatetime
       SET @firstDayOfThisMonth = CONVERT(smalldatetime,
                                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                                          + '01' + ' 00:00:00',
                                          @dateFmtStyleIn)

       DECLARE @now smalldatetime
       SET @now = CONVERT(smalldatetime,
                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                          + CAST(DAY(GETDATE()) AS char(2)) + ' '
                          + CAST(DATEPART(hh, GETDATE()) AS char(2)) + ':'
                          + CAST(DATEPART(mi, GETDATE()) AS char(2)) + ':'
                          + '00',
                          @dateFmtStyleIn)

       SELECT pfiID
       FROM dossier
(defvar end_src

(defun  gnuplot variable expansion
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:

(defvar name: simple-function
(defvar begin_src emacs-lisp
  "sin(x)"
(defvar end_src

(defvar begin_src gnuplot :var fun=simple-function
  plot $fun
(defvar end_src

(defun  debug hints
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
from mailing list

- edebug-defun: (in emacs-lisp mode, C-u C-M-x) will mark the function
  so that when it is called, the interpreter stops and you can then
  single-step through it with <SPACE>. At each point, you can press
  "e" and evaluate variables (actually arbitrary expressions).
- Insert a strategically placed (debug) call and then call the
  function.  If/when the debug call is executed, you are dropped into
  the debugger and you can then evaluate arbitrary expressions.

(defun  whitespace/newline results issues
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

(defvar begin_src sh
  echo output
(defvar end_src

This
(defvar begin_src sh
  echo output
(defvar end_src
text here

results in

t(defvar results:
: output
ext here

(defvar begin_src emacs-lisp
  (+ 1 1)
(defvar end_src

(defvar name:
: 2

(defun  sh with sessions
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

(defvar begin_src sh :session eric
  cd ~/Desktop
(defvar end_src

(defvar begin_src sh :session eric
  cd ~/Desktop/clj/
  ls (defun .clj
(defvar end_src

(defvar name:
| "ants.clj" | "" | "concurrent.clj" | "" | "hello.clj" | "" | "spell-checker.clj" |

(defun  xml and n3
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

introduce org-babel to =xml= and =n3=
(defvar begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
(defvar end_src

inform org-babel-tangle of their existence and file extensions
(defvar begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
(defvar end_src

(defvar begin_src xml :tangle example
  <first>
  </first>
(defvar end_src

(defvar begin_src n3 :tangle example
  n3 stuff
(defvar end_src

(defun  unresolved noweb references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src emacs-lisp :results silent
  (setq org-babel-noweb-error-langs '("ruby"))
(defvar end_src

(defvar name: i-have-a-name
(defvar begin_src ruby 
  1 + 2
(defvar end_src


(defvar begin_src ruby :noweb
  <<i-have-a-name>> + 3
(defvar end_src

(defvar resname:
: 6

(defun  =:table= results param
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src emacs-lisp :results table
  8
(defvar end_src

(defvar resname:
| 8 |

(defun  switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
(defvar end_src

(defvar resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

(defvar begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
(defvar end_src

(defvar resname: eric
: imp

(defun  switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
(defvar end_src

(defvar resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

(defvar begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
(defvar end_src

(defvar resname: eric
: imp

(defun  simple scalar
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src emacs-lisp
  (+ 1 3)
(defvar end_src

(defvar resname:
: 4

(defun  simple R
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src R :session R
8
(defvar end_src

(defvar resname:
: 8

(defun  show all
   CLOCK: [2009-09-15 Tue 07:51]--[2009-09-15 Tue 08:51] =>  1:00
   :PROPERTIES:
   :exports:  both
   :DATE:     2009-11-20
   :END:

(defvar begin_src ditaa :file blue.png
   +----------------------+
   |                      |
   |                      |
   |          +-----------+
   |          |           |
   |          |           |
   |          |           |
   |          +-----------+
   |                      |
   +----------------------+
(defvar end_src

(defun  results switches
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src ruby :results output :results_switches -n
  10.times do |n|
    puts "-"(defun n
  end
(defvar end_src

(defvar resname:
(defvar begin_example -n

-
--
---
----
-----
------
-------
--------
---------
(defvar end_example

(defvar begin_src ruby :results output
  10.times do |n|
    puts "-"(defun n
  end
(defvar end_src

(defvar resname:
(defvar begin_example
  -
  --
  ---
  ----
  -----
  ------
  -------
  --------
  ---------
(defvar end_example

(defun  reference parts of tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar TBLNAME: squares
|  1 |   1 |
|  2 |   4 |
|  3 |   9 |
|  4 |  16 |
|  5 |  25 |
|  6 |  36 |
|  7 |  49 |
|  8 |  64 |
|  9 |  81 |
| 10 | 100 |
| 11 | 121 |
| 12 | 144 |
| 13 | 169 |
| 14 | 196 |
| 15 | 225 |
| 16 | 256 |
| 17 | 289 |
| 18 | 324 |
(defvar TBLFM: $2=$1(defun $1

(defvar begin_src gnuplot :var data=squares
set title "Implementing Gnuplot"
plot data using 1:2 with lines
(defvar end_src

(defun  quoted latex
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

The following latex isn't exported correctly

(defvar begin_latex
  \begin{code}
  data BTree = Leaf a
             | Node Tree Tree
  \end{code}
(defvar end_latex

(defvar begin_src haskell
  data BTree = Leaf a
             | Node Tree Tree
(defvar end_src

(defun  pretty print
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src emacs-lisp :results scalar
  '(1 2 3 4)
(defvar end_src

(defun  =pp= results
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
(defun  python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
(defvar begin_src python :results pp :session
  ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']
(defvar end_src

(defvar resname:
: ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']

(defun  ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
(defvar begin_src ruby :results pp
  class Schulte
    attr_accessor :name, :age
  end
  
  eric = Schulte.new
  eric.name = "eric"
  eric.age = 27
  
  eric
(defvar end_src

(defvar resname:


(defvar begin_src ruby :results pp
  a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
  a
(defvar end_src

(defvar resname:
(defvar begin_example
[1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3]
(defvar end_example

(defun  persistent python
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src python :session :results silent
  import types
(defvar end_src

(defvar begin_src python :session
  types.FunctionType
(defvar end_src

(defvar resname:
: function

(defun  more persistent python
    :PROPERTIES:
    :session:  default
    :DATE:     2009-11-20
    :END:

(defvar begin_src python :results silent
  import types
(defvar end_src

(defvar begin_src python
  types.FunctionType
(defvar end_src

(defvar resname:
: function

(defun  noweb referernces
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar name: noweb-example
(defvar begin_src ruby 
  a = 28
(defvar end_src

(defvar begin_src ruby :noweb
  # <<noweb-example>>
  a + 4
(defvar end_src

(defvar resname:
: 32

(defun  multiple arguments
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src emacs-lisp :var first=9 :var second=10
  (+ first second)
(defvar end_src

(defvar resname:
: 19

(defun  lua export
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar name: determine the neighbors of the segments that the bisector hits
(defvar begin_src lua :tangle no :exports code
  local s1, s2 = intersecting_segs[1], intersecting_segs[2]
  local n1 = table_find_segment(cell.neighbors, s1)
  local n2 = table_find_segment(cell.neighbors, s2)
(defvar end_src

I got:
(defvar begin_example
\lstset{language=lua}
\begin{lstlisting}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{lstlisting}
(defvar end_example

Emacs -Q got:
(defvar begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
(defvar end_example

Emacs -Q + Org-babel got:
(defvar begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
(defvar end_example

(defun  latex pngs
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
$x \mapsto y$

(defun  Theorem
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
$|consts(t)| \leq sizes(t)$

- by induction on the structure of t
- base cases are $t \in [true, false, 0]$: 
  - $|consts(t)| = |[t]| = 1 = size(t)$
- inductive size
  - $t \in [succ(t_1), pred(t_1), iszero(t_1)]$:
    - $|consts(t)| = |consts(t_1)| = |[t]| \leq size(t_1) < size(t)$
  - $t = if\, t_1 \, then \, t_2 \, else t_3$
    - $|consts(t)| = |consts(t_1) \cup consts(t_1) \cup consts(t_1)|$
    - $\leq |consts(t_1)| + |consts(t_1)| + |consts(t_1)|$
    - $\leq size(t_1) + size(t_1) + size(t_1)$
    - $< size(t)$

(defun  later
   CLOCK: [2009-09-15 Tue 09:41]--[2009-09-15 Tue 09:51] =>  0:10
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
stuff here

(defun  indexing into results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar name: indexable-table
| eric    |
| michael |
| schulte |
| is      |
| my      |
| name    |

(defvar begin_src emacs-lisp :var data=indexable-table[2:4]
   data
(defvar end_src

(defvar name:
| schulte |
| is      |
| my      |

(defvar tblname: multidimensional-indexing
| 1 |  2 |
| 3 |  4 |
| 5 |  6 |
| 7 |  8 |
| 9 | 10 |

(defvar begin_src emacs-lisp :var data=multidimensional-indexing[0:-2]
   data
(defvar end_src

(defvar resname:
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
| 7 | 8 |

(defun  indexing into gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar tblname: squares
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |

(defvar begin_src gnuplot :var data=squares :results silent
plot data using 1:2 with lines
(defvar end_src

(defvar tblname: squares-with-sum
|  1 |  1 |
|  2 |  4 |
|  3 |  9 |
|  4 | 16 |
|  5 | 25 |
|  6 | 36 |
|----+----|
| 21 | 91 |

(defvar begin_src gnuplot :var data=squares-with-sum[0:-3] :results silent
  plot data using 1:2 with lines
(defvar end_src

(defun  indented
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   (defvar begin_src emacs-lisp
     (message "I ran!!")   
   (defvar end_src

(defvar resname:
: I ran!!

(defun  indentation
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src python
          9
(defvar end_src

(defun  hiding results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src emacs-lisp
  (mapcar (lambda (el) (list el)) (number-sequence 0 20))
(defvar end_src

(defvar name:
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |

(defun  haskell
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src haskell
  powerSet :: [a] -> [[a]]
  powerSet = foldr (\ x ps -> map (\ y -> x : y) ps ++ ps ) [[]]
(defvar end_src

(defvar begin_src haskell
  powerSet [1, 2, 3]
(defvar end_src

(defun  haskell and tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src haskell
  sumListCond :: Int -> Int -> [Int] -> Int
  sumListCond l n xs
      | foldl (+) 0 (take l xs) <= n = sumListCond (l + 1) n xs
      | otherwise = foldl (+) 0 (take (l - 1) xs)
(defvar end_src
(defvar begin_src oz
  
(defvar end_src

(defun  gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src gnuplot
plot cosx
(defvar end_src


(defvar end_src
      
(defun  empty =output= results for emacs-lisp
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src emacs-lisp :results output
   8
(defvar end_src

(defvar resname:

(defun  elisp variables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src ditaa :file (format "%d.png" 45)
      +-----------+
      |           |
      |           |
      |           |
      |           |
      +-----------+
(defvar end_src

(defvar name:
[[file:45.png]]

(defun  elisp references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src emacs-lisp :results silent
   (setq first 10)
(defvar end_src

(defvar name: resolve(name=nil)
(defvar begin_src emacs-lisp :results silent
  (eval (intern name))
(defvar end_src

(defvar begin_src python :var a=resolve(name="first")
  return a + 10
(defvar end_src

(defun  dynamic table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar TBLNAME: todays-clock
(defvar BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
Clock summary at [2009-09-15 Tue 08:51], for Tuesday, September 15, 2009.

| L | Headline     | Time   |      |
|---+--------------+--------+------|
|   | (defun Total time(defun  | (defun 1:10(defun  |      |
|---+--------------+--------+------|
| 1 | [[file:/Users/eschulte/Desktop/test.org::top][top]]          | 1:10   |    1 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]     |        | 1:00 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::later][later]]        |        | 0:10 |
(defvar END: clocktable

(defvar begin_src emacs-lisp :var data=todays-clock(1,1)
(message "table is %S" data)
(defvar end_src

(defvar resname:
: table is (("L" "Headline" "Time" "") hline ("" "(defun Total time(defun " "(defun 1:10(defun " "") hline (1 "[[file:/Users/eschulte/Desktop/test.org::top][top]]" "1:10" 1) (2 "[[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]" "" "1:00") (2 "[[file:/Users/eschulte/Desktop/test.org::later][later]]" "" "0:10"))

(defvar begin_src R :session R-pie-example :var times=todays-clock :results silent
pie(times[2:length(times),4], labels = times[2:length(times),2])
(defvar end_src

(defun  code results
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
(defun  emacs lisp
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
(defvar begin_src emacs-lisp :results code
  (mapcar (lambda (el) (lambda (item) (+ item el))) '(1 2 3 4 5))
(defvar end_src

(defvar resname:
(defvar BEGIN_SRC emacs-lisp
((lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el)))
(defvar END_SRC

(defvar begin_src emacs-lisp :results code
  (mapcar (lambda (el) ((defun  el el)) '(1 2 3 89))
(defvar end_src

(defvar resname:
(defvar BEGIN_SRC emacs-lisp
(1 4 9 7921)
(defvar END_SRC

(defun  ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

(defvar begin_src ruby :results code
  [1, 2, 33, 4].map{|n| "the number #{n}"}
(defvar end_src

(defvar resname:
(defvar BEGIN_SRC ruby
  ["the number 1", "the number 2", "the number 33", "the number 4"]
(defvar END_SRC

(defvar begin_src ruby :session :results code 
  [1, 2, 33, 4].map{|n| n + 10 }
(defvar end_src

(defvar resname:
(defvar BEGIN_SRC ruby
[11, 12, 43, 14]
(defvar END_SRC

(defun  python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

(defvar begin_src python :results code
  ['one', 'two', 'three']
(defvar end_src

(defvar resname:
(defvar BEGIN_SRC python
['one', 'two', 'three']
(defvar END_SRC

(defvar begin_src python :results code
  [1, 2, 33, 4]
(defvar end_src

(defvar resname:
(defvar BEGIN_SRC python
[1, 2, 33, 4]
(defvar END_SRC

(defvar begin_src python :session :results code 
  [1, 2, 33, 4]
(defvar end_src

(defvar resname:
(defvar BEGIN_SRC python
[1, 2, 33, 4]
(defvar END_SRC

(defun  clojure
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src clojure :results silent
  (list 8 9)
(defvar end_src

(defun  changing source name
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar name: emacs-nine
(defvar begin_src emacs-lisp
  8
(defvar end_src

(defvar resname: emacs-nine
: 8

(defvar resname: emacs-eight
: 8

(defun  asymptote
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

(defvar begin_src asymptote :file asymptote-test.png :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return 1+cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(a,0)$",(1,0),N);
  dot("$(2a,0)$",(2,0),N+E);
(defvar end_src

(defvar resname:
[[file:asymptote-test.png]]

(defun  asymptote cosine
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
(defvar begin_src asymptote :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  for(int i=0; i < 8; ++i) {
    real j = 0.125 + 0.125(defun i;
    real h(real t) {return j;};
    path k=polargraph(h, -(acos(j)), acos(j), operator ..);
    draw(k,blue);
  }
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(pi,0)$",(1,0),N);
(defvar end_src

(defun  and then more
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
and more stuffs here

(defun  advanced table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   | DATA             | WHAT       | WHERE       | HOW MUCH |
   |------------------+------------+-------------+----------|
   | [2009-09-25 Fri] |            |             |    28.95 |
   |------------------+------------+-------------+----------|
   |                  | food       | supermarket |     7.85 |
   |                  | ticket bus |             |      2.3 |
   |                  | tea + ice  | ice uno     |      4.4 |
   |                  | ticket     |             |     14.4 |
   |------------------+------------+-------------+----------|
   | [2009-09-26 Sat] |            |             |       41 |

(defvar begin_src emacs-lisp
  (let ((total 0) (responding t) purchases)
    (while responding
      (setq purchases
            (cons
             (list ""
                   (read-from-minibuffer "What: ")
                   (read-from-minibuffer "Where: ")
                   (read-minibuffer "How Much: "))
             purchases))
      (setq responding (y-or-n-p "more? ")))
    (append 
     purchases
     (list
      (list
       (format-time-string "%Y-%m-%d" (current-time))
       "" "" (progn
               (mapc (lambda (purchase)
                       (setq total (+ total (fourth purchase))))
                     purchases)
               total)))))
(defvar end_src

(defvar resname:
| ""           | "fish and chips" | "diner"  |  9.78 |
| ""           | "food"           | "subway" |  5.45 |
| "2009-09-29" | ""               | ""       | 15.23 |


(defun  "Languages and Machines" 
(defun  intro 
(defun  Church-Turing thesis
(defun  Turing machines
(defun  analysis of effective computation 

(defun  deterministic finite automata
     
     src blocks are an easy derivation of this

(defun (defun  properties
      read-once
      state and input symbol determine instruction to execute

(defun (defun  application examples
      switching circuits
      lexical analysis of programming languages

(defun  language definition and effective computation 
   "Language definition and computibility are not two unrelated topics
   that fall under the broad heading of computer science theory, but
   rather are inextricably intertwined. the computations of a machine
   can be used to recognize a language; an input string is accepted by
   the machine if the computation initiated with the string indicates
   it's syntactic correctness. Thus each machine has an associated
   language, the set of strings accepted by the machine. The
   computational capabilities of each family of abstract machines is
   characterized by the languages accepted by the machines in the
   family. With this in mind, we begin our investigations into the
   related topics of language definition and effective computation."
   -- T. Sudkamp, "Languages and Machines"   

(defun  foundations 
(defun  intro
(defun  theoretical computer science
     explores 
     the capabilities and limitations 
     of algorithmic problem solving

(defun  formal language theory
     provides the foundation 
     for the definition 
     of programming languages
     and compiler design
     
(defun (defun  roots
      linguistics
      mathematical logic
      computer science

(defun  abstract machines
     are built to recognize
     the syntactic properties
     of languages
     and to compute functions

(defun  the relationship between 
     the grammatical generation of languages 
     and the recognition of languages
     by automata
     is a central theme
     of "Languages and Machines"

(defun (defun  grammars were developed
      to provide a mechanism
      for describing
      natural (spoken and written) languages
      and have become the primary tool
      for the formal specification
      of programming languages

(defun  set-theoretic definition of language
     sufficiently broad to include
     both natural and formal languages
     but generality is gained
     at the expense
     of not providing a technique
     for mechanically generating
     the strings of the language

(defun (defun  to overcome this shortcoming
      recursive definitions
      and set operations
      are used to give 
      finite specifications
      of languages

(defun  development of the regular sets
     a family of languages
     that arises 
     in automata theory
     formal language theory
     switching circuits
     and neural networks
     
(defun  mathematical preliminaries
(defun  set-theory
(defun  cartesian product, relations and functions
(defun  equivalence relations
(defun  countable and uncountable sets
(defun  recursive definitions
(defun  mathematical induction					       :@doc:
     
     Establishing the relationships between the elements of sets and
     operations on the sets requires the capability of constructing
     proofs to verify the hypothesized properties.
     
     It is impossible to prove that a property holds for every member
     in an infinite set by considering each element individually. 

     The principle of mathematical induction gives sufficient
     conditions for proving that a property holds for every element in
     a recursively defined set. 

     Induction uses the family of nested sets generated by the
     recursive process to extend a property from the basis to the
     entire set.

(defun (defun  principle of mathematical induction

      Let x be a set defined by recursion from the basis
      X(subscript 0) and let X(subscript 0...i,...) be the sequence of
      sets generated by the recursive process.

      Also let P be a property defined on the elements of X.

      If it can be shown that
      
      i) P holds for each element in X(subscript 0),
      
      ii) whenever P holds for every element in the sets X(subscript
      0...i,...), P also holds for every element in X(subscript (i +
      1)),

      then, by the principle of mathematical induction, P holds for
      every element in X.

      The soundness of the principle of mathematical induction can be
      intuitively exhibited using the sequence of sets constructed by
      a recursive definition. 

      Shading the circle X(subscript i) indicates that P holds for
      every element of X(subscript i).

      The first condition requires that the interior set be
      shaded. 

      Condition (ii) states that the shading can be extended from any
      circle to the next concentric circle. 

      (Fig. 1.3) illustrates how this process eventually shades the
      entire set X.

      Figure 1.3 Principle of mathematical induction.

      The justification for the principle of mathematical induction
      should be clear from the preceeding argument. 

      Another justification can be obtained by assuming that
      conditions (i) and (ii) are satisfied but P is not true for
      every element in X.

      If P does not hold for all elements of X, then there is at least
      one set X(subscript i) for which P does not universally hold.

      Let X(subscript j) be the first such set.

      Since condition (i) asserts that P holds for all elements of
      X(subscript 0), j cannot be zero.

      Now P holds for all elements of X(subscript j-1) by our choice
      of j.

      Condition (ii) then requires that P hold for all elements in
      X(subscript j).

      This implies that there is no first set in the sequence for
      which the property P fails.

      Consequently, P must be true for all the X(subscript i)'s, and
      therefore for X.

      An inductive proof consists of three distinct steps. 

      The first step is proving that the property P holds for each
      element of a basis set. 

      This corresponds to establishing condition (i) in the definition
      of the principle of mathematical induction. 

      The second step is the statement of the inductive
      hypothesis. 

      The inductive hypothesis is the assumption that the property P
      holds for every element in the sets X(subscript 0...n). 

      The inductive step then proves, using the inductive hypothesis,
      that P can be extended to each element in X(subscript (n +
      1)). 

      Completing the inductive stepsatisfies the requirement of the
      principle of mathematical induction. 

      Thus, it can be concluded that P is true for all elements of X.

(defun  directed graphs						       :@doc:
     A mathematical structure consists of functions and relations on a
     set or sets and distinguished elements from the sets. A
     distinguished element is an element of a set that has special
     properties that distinguish it from the other elements. The
     natural numbers as defined in Definitions 1.5.1, can be expressed
     as a structure (N, s, 0). The set N contains that natural
     numbers, s is a unary function on N, and 0 is a distinguished
     element of N. Zero is distinguished because of its explicit role
     in the definition of the natural numbers. 

     (search lisp intro for comments on 'empty-object' being a 'funny
     kind of constant' rather than a memory allocation construct)

     Graphs are frequently used in both formal language theory and
     automata theory because they provide the ability to portray the
     essential features of a mathematical entity in a diagram, which
     aids the intuitive understanding of the concept. Formally, a
     directed graph is a mathematical structure consisting of a set N
     and a binary relation A on N. The elements of N are called the
     nodes, or vertices, of the graph, and the elements of A are
     called arcs, or edges. The relation A is referred to as the
     adjacency relation. A node y is said to be adjacent to x when
     ( [ x , y ] memberOf A ). An arc from x to y in a directed graph
     is depicted by an arrow from x to y. Using the arrow metaphor, y
     is called the head of the arc and x the tail. The in-degree of a
     node x is the number of arcs with x as the head. The out-degree
     of x is the number of arcs with x as the tail. Node a in Figure
     1.4 has in-degree two and out-degree one.

     A path of length n from x to y in a directed graph is a sequence
     of nodes x(subscript 0...n) satisfying

     N = { a, b, c, d} 
     A = { [ a , b ], [ b , a ], [ b , c ],
           [ b , d ], [ c , b ], [ c , d ],
	   [ d , a ], [ d , d ] }

     | node-vertice x | in-degree arc-edges | out-degree arc-edges |
     | node-vertice a | 2 arc-edge          | 1 arc-edge           |
     | node-vertice b | 2 arc-edge          | 3 arc-edge           |
     | node-vertice c | 1 arc-edge          | 2 arc-edge           |
     | node-vertice d | 3 arc-edge          | 2 arc-edge           |

(defun  languages
    
    The concept of languages includes a variety of seemingly distinct
    catagories: natural languages, computer languages, and
    mathematical languages. A general definition of language must
    encompass these various types of languages. In this chapter, a
    purely set-theoric definition of language is given: A language is
    a set of strings over an alphabet. This is the broadest possible
    definition, there are no inherent restrictions on the form of the
    strings that constitute a language.

    Languages of interest are not made of up arbitrary strings, but
    rather strings that satisfy certain properties. These properties
    define the syntax of the language. Recursive definitions and set
    operations are used to enforce syntactic restrictions on the
    strings of a language. The chapter concludes with the introduction
    of a faily of languages known as the regular sets. A regular set
    is constructed recursively from the empty set and singleton
    sets. Although we introduce the regular sets via a set-theoric
    construction, as we progress we will see that they occur naturally
    as the languages generated by regular grammars and recognized by
    finite-state machines.

(defun  strings and languages
(defun  finite specification of languages
(defun  regular set and expressions
(defun  context-free grammars and parsing 

   The syntax of a language specifies the permissible forms of the
   strings of the language. In chapter 2, set theoric operations and
   recursive definitions were used to construct the strings of a
   language. These string building tools, although, primative, were
   adequate for enforcing simple constraints  on the order and number
   of elements in a string. In this section we introduce a formal
   system for string generation known as a context-free grammar. An
   element of the language is constructed from the start symbol of the
   grammar using rules that define permissable string
   transformations. The derivation of a string consists of a sequence
   of acceptable transformations.

   Context-free grammars, like recursive definitions, generate the
   strings of a language. The flexibility provided by the rules of a
   context-free grammar has proven well suited for defining the syntax
   of programming languages. The grammar that generates the
   programming language Pascal is used to demonstrate the context-free
   definition of several common programming language constructs.

   The process of analyzing a string for syntactic correctness is
   known as parsing. Defining the syntax of a language by a set of
   context-free rules facilitates the development of parsing
   algorithms. Several simple parsers, based on algorithms for
   traversing directed graphs, are presented in chapter 4. These
   algorithms systematically examine derivations to determine if a
   string is derivable from the start symbol of the grammar.

   Context-free grammars are members of a family of the string
   generation systems known as phrase-structure grammars. Another
   family of grammars, the regular grammars, is introduced as a
   special case of context-free grammars. These two types of grammars,
   along with two additional types of grammars, make up the sequence
   of increasingly powerful string generation systems known as the
   Chomsky hierarchy of grammars. The relationships between the
   grammars of the Chomsky hierarchy will be examined in chapter 10.

(defun  context-free grammars

     1. <sentence>        --> <noun-phrase> <verb-phrase>
     2. <sentence>        --> <noun-phrase> <verb> <direct-object-phrase>
     3. <noun-phrase>     --> <proper-noun>
     4.                   --> <determiner> <common-noun>
     5. <proper-noun>     --> John
     6.                   --> Jill
     7. <common-noun>     --> car
     8.                   --> hamburger
     9. <determiner>      --> a
    10.                   --> the
    11. <verb-phrase>     --> <verb> <adverb>
    12.                   --> <verb>
    13. <verb>            --> drives
    14.                   --> eats
    15. <adverb>          --> slowly
    16.                   --> frequently
    17. <adjective-list>  --> <adjective> <adjective-list>
    18.                   --> null sting, the lambda, that funny kind of constant
    19. <adjective>       --> big
    20.                   --> juicy
    21.                   --> brown

    The definition of <adjective-list> follows the standard recursive
    pattern. Rule 17 defines <adjective-list> in terms of itself while
    Rule 18 provides the basis of the recursive definition. The null sting
    on the right hand side of Rule 18 indicates that the application
    of this rule replaces <adjective-list> with the null
    sting. Repeated applications of Rule 17 generate a sequence of
    adjectives. Rules for <direct-object-phrase> are constructed using
    <adjective-list>: 

    22. <dir-obj-phrase> --> <adjective-list> <proper-noun>
    23.                  --> <determiner> <adjective-list> <common-noun>

    The sentence 'John eats a big juicy hamburger' can be derived by
    the following sequence of rule applications:

    Derivation                                                     Rule Applied
    >> <noun-phrase> <verb> <direct-object-phrase>                   2
    >> <proper-noun> <verb> <direct-object-phrase>                   3
    >> John <verb> <direct-object-phrase>                            5
    >> John eats <direct-object-phrase>                             14
    >> John eats <determiner> <adjective-list> <common-noun>        23
    >> John eats a <adjective-list> <common-noun>                    9
    >> John eats a <adjective> <adjective-list> <common-noun>       17
    >> John eats a big <adjective-list> <common-noun>               19 
    >> John eats a big <adjective> <adjective-list> <common-noun>   17
    >> John eats a big juicy <adjective-list> <common-noun>         20
    >> John eats a big juicy <common-noun>                          18
    >> John eats a big juicy hamburger                               8

    The generation of sentences is strictly a function of the
    rules. The string 'the car eats slowly' is a sentence in the
    language since it has the form <noun-phrase> <verb-phrase>
    outlined by Rule 1. This illustrates the important distinction
    between syntax and semantics;

    the generation of sentences is concerned with the form of the
    derived string without regard to any underlying meaning that may
    be associated with the terminal symbols.

    By Rules 3 and 4, a noun phrase consists of a proper noun or a
    common noun preceeded by a determiner. The variable
    <adjective-list> may be incorporated into the <noun-phrase> rules,
    permitting adjectives to modify a noun:

    3'. <noun-phrase>  --> <adjective-list> <proper-noun>
    4'.                --> <determiner> <adjective-list> <common-noun>

    With this modification, the string 'big John eats frequently' can
    be derived from the variable <sentence>.
 
(defun  context-free grammars and languages
(defun  examples of grammars and languages
(defun  regular grammars
(defun  grammars and languages revisited
(defun  a context-free grammar for pascl
(defun  arithmetic expressions
(defun  parsing: an introduction
(defun  leftmost derivations and ambiguity
(defun  the graph of a grammar
(defun  a breadth-first top-down parser
(defun  a depth-first top-down parser
(defun  bottom-up parsing
(defun  a depth-first bottom-up parser
(defun  normal forms
(defun  elimination of lambda rules
(defun  elimination of chain rules
(defun  useless symbols
(defun  Chomsky normal form
(defun  removal of direct left recursion
(defun  Greibach normal form
(defun  automata and languages 
(defun  finite automata
(defun  a finite state machine
(defun  deterministic finite automata
(defun  state diagrams and examples
(defun  nondeterministic finite automata
(defun  lambda transitions
(defun  removing nondeterminism
(defun  dfa minimization
(defun  regular languages and sets
(defun  finite automata and regular sets
(defun  expression graphs
(defun  regular grammars and finite automata
(defun  closure properties of regular languages
(defun  a nonregular language
(defun  the pumping lemma for regular languages
(defun  the Myhill-Nerode Theorem
(defun  pushdown automata and context-free languages
(defun  pushdown automata
(defun  variations on the pda theme
(defun  pushdown automata and context-free languages
(defun  the pumping lemma for context-free languages
(defun  closure properties of context-free languages
(defun  a two-stack automaton
(defun  Turing machines
(defun  the standard Turing machine
(defun  Turing machines as language acceptors
(defun  alternative acceptance criteria
(defun  multitrack machines
(defun  two-way tape machines
(defun  multitape machines
(defun  nondeterministic Turing machines
(defun  Turing machines as language enumerators
(defun  the Chomsky hierarchy
(defun  unrestricted grammars
(defun  context-sensitive grammars
(defun  linear-bounded automata
(defun  the Chomsky hierarchy
(defun  decidability and computability 
(defun  decidability
(defun  decision problems
(defun  the Church-Turing thesis
(defun  the halting problem for Turing machines
(defun  a universal machine
(defun  reducibility
(defun  Rice's theorem
(defun  an unsolvable word problem
(defun  the post correspondence problem
(defun  undecidable problems in context-free grammars
(defun  numeric computation
(defun  computation of functions
(defun  numeric computation
(defun  sequential operation of Turing machines
(defun  composition of functions
(defun  toward a programming language
(defun  mu-recursive functions
(defun  primitive recursive functions
(defun  some primitive recursive functions
(defun  bounded operators
(defun  division functions
(defun  Godel numbering and course-of-value recursion
(defun  computable partial functions
(defun  Turing computability and mu-recursive functions
(defun  the Church-Turing thesis revisited
(defun  computational complexity 
(defun  time complexity of a Turing machine
(defun  linear speedup
(defun  rates of growth
(defun  complexity and Turing machine variations
(defun  properties of time complexity
(defun  nondeterministic complexity
(defun  space complexity
(defun  tractibility and NP-complete problems
(defun  tractible and intractible decision problems
(defun  the class NP
(defun  P = NP?
(defun  the satisfiability problem
(defun  additional NP-complete problems
(defun  derivative complexity classes
(defun  deterministic parsing 
(defun  LL(k) grammars
(defun  lookahead in context-free grammars
(defun  FIRST, FOLLOW and lookahead sets
(defun  strong LL(k) grammars
(defun  construction of FIRST(k) sets
(defun  construction of FOLLOW(k) sets
(defun  a strong LL(1) grammar
(defun  a strong LL(k) parser
(defun  LL(k) grammars
(defun  LR(k) grammars
(defun  LR(0) contexts
(defun  an LR(0) parser
(defun  the LR(0) machine
(defun  acceptance by the LR(0) machine
(defun  LR(1) grammars
(defun  index of notation
(defun  the greek alphabet
(defun  Backus-Naur definition of pascal
(defun  subject index 



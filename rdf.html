<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>rdf</title>
<!-- 2014-05-25 Sun 17:02 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Donald Lindsay" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">rdf</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. rdf&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a></li>
<li><a href="#sec-2">2. <span class="todo TODO">TODO</span> selectOneOf&#xa0;&#xa0;&#xa0;<span class="tag"><span class="quicksort">quicksort</span>&#xa0;<span class="prolog">prolog</span>&#xa0;<span class="debug">debug</span></span></a>
<ul>
<li><a href="#sec-2-1">2.1. quicksort</a></li>
</ul>
</li>
<li><a href="#sec-3">3. owl&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="owl">owl</span></span></a>
<ul>
<li><a href="#sec-3-1">3.1. owl2 in triples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="owl">owl</span></span></a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. <span class="done DONE">DONE</span> load these triples into the ts triple-store</a></li>
<li><a href="#sec-3-1-2">3.1.2. Annotations</a></li>
<li><a href="#sec-3-1-3">3.1.3. owl2 in turtle</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. misc owl2&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-3-3">3.3. owl2 basic gloss</a></li>
<li><a href="#sec-3-4">3.4. About owl2 and axiomatic triples</a></li>
</ul>
</li>
<li><a href="#sec-4">4. prolog&#xa0;&#xa0;&#xa0;<span class="tag"><span class="prolog">prolog</span></span></a>
<ul>
<li><a href="#sec-4-1">4.1. Allegro Prolog&#xa0;&#xa0;&#xa0;<span class="tag"><span class="prolog">prolog</span>&#xa0;<span class="lisp">lisp</span>&#xa0;<span class="gruff">gruff</span></span></a>
<ul>
<li><a href="#sec-4-1-1">4.1.1. User Documentation</a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2. Built-in Prolog Functors</a></li>
<li><a href="#sec-4-3">4.3. allegro-prolog functors</a></li>
<li><a href="#sec-4-4">4.4. ! is the Prolog cut.</a></li>
<li><a href="#sec-4-5">4.5. The Prolog Top Level</a></li>
<li><a href="#sec-4-6">4.6. the ?- macro</a></li>
<li><a href="#sec-4-7">4.7. Defined Lisp Operators</a></li>
<li><a href="#sec-4-8">4.8. The Programming Interface between Prolog and Common Lisp</a>
<ul>
<li><a href="#sec-4-8-1">4.8.1. Prolog Functor                                Description</a></li>
<li><a href="#sec-4-8-2">4.8.2. Lisp Operator                           Description</a></li>
</ul>
</li>
<li><a href="#sec-4-9">4.9. Prolog and Dynamic Extent</a></li>
<li><a href="#sec-4-10">4.10. Tail Call Elimination</a></li>
<li><a href="#sec-4-11">4.11. The Prolog Stack</a>
<ul>
<li><a href="#sec-4-11-1">4.11.1. Lisp Name                             Description</a></li>
</ul>
</li>
<li><a href="#sec-4-12">4.12. I/O Functors</a>
<ul>
<li><a href="#sec-4-12-1">4.12.1. Lisp Name                             Description</a></li>
<li><a href="#sec-4-12-2">4.12.2. Unification with standard-objects.</a></li>
</ul>
</li>
<li><a href="#sec-4-13">4.13. The Prolog `Database' and Generators.</a></li>
<li><a href="#sec-4-14">4.14. AllegroCache Object Database</a>
<ul>
<li><a href="#sec-4-14-1">4.14.1. Prolog Functor                           Description</a></li>
<li><a href="#sec-4-14-2">4.14.2. Prolog Functor                           Description</a></li>
<li><a href="#sec-4-14-3">4.14.3. Prolog Functor                                           Description</a></li>
</ul>
</li>
<li><a href="#sec-4-15">4.15. prolog lattice</a></li>
<li><a href="#sec-4-16">4.16. The Interface to AllegroCache</a>
<ul>
<li><a href="#sec-4-16-1">4.16.1. SeeAlso AllegroGraph, Gruff</a></li>
<li><a href="#sec-4-16-2">4.16.2. Prolog Functor                          Description</a></li>
</ul>
</li>
<li><a href="#sec-4-17">4.17. Known Issues.</a></li>
<li><a href="#sec-4-18">4.18. Example: the zebra problem</a>
<ul>
<li><a href="#sec-4-18-1">4.18.1. /* -*- Mode: prolog -*-</a></li>
<li><a href="#sec-4-18-2">4.18.2. This file for benchmarking against SWI Prolog.</a></li>
<li><a href="#sec-4-18-3">4.18.3. nextto(X, Y, List) :- iright(X, Y, List).</a></li>
<li><a href="#sec-4-18-4">4.18.4. nextto(X, Y, List) :- iright(Y, X, List).</a></li>
<li><a href="#sec-4-18-5">4.18.5. iright(Left, Right, [Left, Right | _]).</a></li>
<li><a href="#sec-4-18-6">4.18.6. iright(Left, Right, [_ | Rest]) :- iright(Left, Right, Rest).</a></li>
<li><a href="#sec-4-18-7">4.18.7. zebra(H, W, Z) :-</a></li>
<li><a href="#sec-4-18-8">4.18.8. member(house(_, _, _, coffee, green), H),</a></li>
<li><a href="#sec-4-18-9">4.18.9. member(house(ukrainian, _,  _, tea, _), H),</a></li>
<li><a href="#sec-4-18-10">4.18.10. iright(house(_, _, _, _, ivory), house(_, _, _, _, green), H),</a></li>
<li><a href="#sec-4-18-11">4.18.11. member(house(_, snails, winston, _, _), H),</a></li>
<li><a href="#sec-4-18-12">4.18.12. member(house(_, _, kools, _, yellow), H),</a></li>
<li><a href="#sec-4-18-13">4.18.13. nextto(house(_, _, chesterfield, _, <span class="underline">), house(</span>, fox, _, _, _), H),</a></li>
<li><a href="#sec-4-18-14">4.18.14. nextto(house(_, _, kools, _, <span class="underline">), house(</span>, horse, _, _, _), H),</a></li>
<li><a href="#sec-4-18-15">4.18.15. member(house(_, _, luckystrike, oj, _), H),</a></li>
<li><a href="#sec-4-18-16">4.18.16. member(house(japanese, _, parliaments, _, _), H),</a></li>
<li><a href="#sec-4-18-17">4.18.17. nextto(house(norwegian, _, _, _, <span class="underline">), house(</span>, _, _, _, blue), H),</a></li>
<li><a href="#sec-4-18-18">4.18.18. member(house(W, _, _, water, _), H),</a></li>
<li><a href="#sec-4-18-19">4.18.19. member(house(Z, zebra, _, _, _), H).</a></li>
<li><a href="#sec-4-18-20">4.18.20. /* This runs the query a single time:</a></li>
<li><a href="#sec-4-18-21">4.18.21. zebra1(Houses, WaterDrinker, ZebraOwner) :-</a></li>
<li><a href="#sec-4-18-22">4.18.22. benchmark1 :-</a></li>
<li><a href="#sec-4-18-23">4.18.23. N = 1000,</a></li>
<li><a href="#sec-4-18-24">4.18.24. benchmark :- time(benchmark1).</a></li>
<li><a href="#sec-4-18-25">4.18.25. <code>========</code> end</a></li>
</ul>
</li>
<li><a href="#sec-4-19">4.19. Prolog vs. Lisp</a></li>
<li><a href="#sec-4-20">4.20. Pure Prolog</a></li>
<li><a href="#sec-4-21">4.21. Buran Spacecraft</a></li>
<li><a href="#sec-4-22">4.22. SWI-Prolog and Ciao, support</a>
<ul>
<li><a href="#sec-4-22-1">4.22.1. Prolog has also been suggested as a client-side language.</a></li>
</ul>
</li>
<li><a href="#sec-4-23">4.23. prolog and reflection</a></li>
<li><a href="#sec-4-24">4.24. Prolog's single data type is the term.</a>
<ul>
<li><a href="#sec-4-24-1">4.24.1. Special cases of compound terms:</a></li>
<li><a href="#sec-4-24-2">4.24.2. Rules and facts</a></li>
<li><a href="#sec-4-24-3">4.24.3. Head :- Body.</a></li>
<li><a href="#sec-4-24-4">4.24.4. Clauses with empty bodies are called facts. An example of a fact is:</a></li>
<li><a href="#sec-4-24-5">4.24.5. The built-in predicate true/0 is always true.</a></li>
<li><a href="#sec-4-24-6">4.24.6. Clauses with bodies are called rules.</a></li>
<li><a href="#sec-4-24-7">4.24.7. Relational nature of many built-in-predicates</a></li>
<li><a href="#sec-4-24-8">4.24.8. General purpose language</a></li>
</ul>
</li>
<li><a href="#sec-4-25">4.25. Prolog program execution</a>
<ul>
<li><a href="#sec-4-25-1">4.25.1. non-monotonic reasoning</a></li>
<li><a href="#sec-4-25-2">4.25.2. In Prolog, loading code is referred to as consulting</a></li>
<li><a href="#sec-4-25-3">4.25.3. Any computation can be expressed</a></li>
</ul>
</li>
<li><a href="#sec-4-26">4.26. design pattern</a>
<ul>
<li><a href="#sec-4-26-1">4.26.1. higher order predicate</a></li>
<li><a href="#sec-4-26-2">4.26.2. conversions from temporal representation</a></li>
<li><a href="#sec-4-26-3">4.26.3. maplist</a></li>
</ul>
</li>
<li><a href="#sec-4-27">4.27. subset of first-order predicate logic</a></li>
<li><a href="#sec-4-28">4.28. term indexing</a>
<ul>
<li><a href="#sec-4-28-1">4.28.1. research, education and pragma</a></li>
<li><a href="#sec-4-28-2">4.28.2. prolog performance</a></li>
<li><a href="#sec-4-28-3">4.28.3. prolog is not purely declarative</a></li>
</ul>
</li>
<li><a href="#sec-4-29">4.29. Using Prolog with AllegroGraph 3.3 (and gruff)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="prolog">prolog</span>&#xa0;<span class="gruff">gruff</span></span></a>
<ul>
<li><a href="#sec-4-29-1">4.29.1. IRI</a></li>
<li><a href="#sec-4-29-2">4.29.2. index</a></li>
</ul>
</li>
<li><a href="#sec-4-30">4.30. Introduction</a></li>
<li><a href="#sec-4-31">4.31. First let us get AllegroGraph ready to use:</a></li>
<li><a href="#sec-4-32">4.32. So let us first look at person1 in this database:</a></li>
<li><a href="#sec-4-33">4.33. select</a></li>
<li><a href="#sec-4-34">4.34. prolog functors</a></li>
<li><a href="#sec-4-35">4.35. some puzzles to work out</a></li>
<li><a href="#sec-4-36">4.36. another convenient shorthand</a>
<ul>
<li><a href="#sec-4-36-1">4.36.1. logo-franz</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. sparql&#xa0;&#xa0;&#xa0;<span class="tag"><span class="sparql">sparql</span>&#xa0;<span class="rdf">rdf</span></span></a>
<ul>
<li>
<ul>
<li><a href="#sec-5-0-1">5.0.1. <span class="done DONE">DONE</span> tracker-sparql&#xa0;&#xa0;&#xa0;<span class="tag"><span class="sparql">sparql</span>&#xa0;<span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-5-0-2">5.0.2. CONSTRUCT</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">6. raptor&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="parser">parser</span></span></a>
<ul>
<li><a href="#sec-6-1">6.1. <span class="todo TODO">TODO</span> define an interactive function to run rapper on a region</a></li>
<li><a href="#sec-6-2">6.2. man raptor</a>
<ul>
<li><a href="#sec-6-2-1">6.2.1. Raptor RDF Syntax Library - Raptor RDF parser utility&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="raptor">raptor</span></span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">7. rdf.sh (perl)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="perl">perl</span></span></a>
<ul>
<li><a href="#sec-7-1">7.1. Reification&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a>
<ul>
<li><a href="#sec-7-1-1">7.1.1. 1. hypostatization, hypostatisation, reification</a></li>
<li><a href="#sec-7-1-2">7.1.2. 2. depersonalization, depersonalisation, reification</a></li>
</ul>
</li>
<li><a href="#sec-7-2">7.2. Virtualisation and network-attached storage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-3">7.3. Ubiquitous and Organic Error Correction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a></li>
<li><a href="#sec-7-4">7.4. Some Coordinate Terms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a>
<ul>
<li><a href="#sec-7-4-1">7.4.1. bathysphere</a></li>
<li><a href="#sec-7-4-2">7.4.2. bubble</a></li>
<li><a href="#sec-7-4-3">7.4.3. economic bubble</a></li>
<li><a href="#sec-7-4-4">7.4.4. spelunk</a></li>
<li><a href="#sec-7-4-5">7.4.5. smuggle</a></li>
<li><a href="#sec-7-4-6">7.4.6. sub</a></li>
<li><a href="#sec-7-4-7">7.4.7. submarine</a></li>
<li><a href="#sec-7-4-8">7.4.8. subordinate</a></li>
<li><a href="#sec-7-4-9">7.4.9. submariner</a></li>
<li><a href="#sec-7-4-10">7.4.10. super</a></li>
<li><a href="#sec-7-4-11">7.4.11. superhero</a></li>
<li><a href="#sec-7-4-12">7.4.12. supervene</a></li>
<li><a href="#sec-7-4-13">7.4.13. supervise</a></li>
<li><a href="#sec-7-4-14">7.4.14. superintend</a></li>
<li><a href="#sec-7-4-15">7.4.15. supermarine</a></li>
<li><a href="#sec-7-4-16">7.4.16. burst</a></li>
<li><a href="#sec-7-4-17">7.4.17. implode</a></li>
<li><a href="#sec-7-4-18">7.4.18. cut off the air</a></li>
<li><a href="#sec-7-4-19">7.4.19. sever the line</a></li>
<li><a href="#sec-7-4-20">7.4.20. cut the line</a></li>
<li><a href="#sec-7-4-21">7.4.21. transparency</a></li>
<li><a href="#sec-7-4-22">7.4.22. bubble</a></li>
<li><a href="#sec-7-4-23">7.4.23. transparent bubble</a></li>
<li><a href="#sec-7-4-24">7.4.24. 'ship of the imagination'</a></li>
<li><a href="#sec-7-4-25">7.4.25. isolation</a></li>
<li><a href="#sec-7-4-26">7.4.26. broken contact with the outside</a></li>
<li><a href="#sec-7-4-27">7.4.27. containment</a></li>
<li><a href="#sec-7-4-28">7.4.28. rebellion</a></li>
</ul>
</li>
<li><a href="#sec-7-5">7.5. Interface&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a>
<ul>
<li><a href="#sec-7-5-1">7.5.1. Appearance</a></li>
<li><a href="#sec-7-5-2">7.5.2. Workspace</a></li>
<li><a href="#sec-7-5-3">7.5.3. Personalization</a></li>
<li><a href="#sec-7-5-4">7.5.4. Networking</a></li>
<li><a href="#sec-7-5-5">7.5.5. Hardware</a></li>
<li><a href="#sec-7-5-6">7.5.6. Software</a></li>
</ul>
</li>
<li><a href="#sec-7-6">7.6. XPath&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="fn">fn</span></span></a>
<ul>
<li><a href="#sec-7-6-1">7.6.1. IRI is an extention of URI.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-6-2">7.6.2. xmlpatterns &#x2013; A tool for running XQuery queries.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-6-3">7.6.3. XPath is defined</a></li>
<li><a href="#sec-7-6-4">7.6.4. XPath defines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a></li>
</ul>
</li>
<li><a href="#sec-7-7">7.7. XDM instance syn value&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a>
<ul>
<li><a href="#sec-7-7-1">7.7.1. literal</a></li>
<li><a href="#sec-7-7-2">7.7.2. thus</a></li>
</ul>
</li>
<li><a href="#sec-7-8">7.8. NO DUTY == Fish-Eye Door-Good-Mark-Y&#xa0;&#xa0;&#xa0;<span class="tag"><span class="defense">defense</span>&#xa0;<span class="debug">debug</span></span></a>
<ul>
<li><a href="#sec-7-8-1">7.8.1. <span class="todo TODO">TODO</span> NO DUTY rules nd-rules&#xa0;&#xa0;&#xa0;<span class="tag"><span class="src">src</span>&#xa0;<span class="debug">debug</span></span></a></li>
</ul>
</li>
<li><a href="#sec-7-9">7.9. fundamental limits on signal processing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-10">7.10. error-correction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a>
<ul>
<li><a href="#sec-7-10-1">7.10.1. debug</a></li>
</ul>
</li>
<li><a href="#sec-7-11">7.11. relay channel&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-12">7.12. Information rate is the average entropy per symbol.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-13">7.13. .emacs Org yas AC Predict[] Complete&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="elisp">elisp</span></span></a></li>
<li><a href="#sec-7-14">7.14. Information theory is based on probability theory and statistics.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-15">7.15. arithmetization of analysis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a>
<ul>
<li><a href="#sec-7-15-1">7.15.1. axiomatize analysis using properties of the natural numbers</a></li>
<li><a href="#sec-7-15-2">7.15.2. Real numbers as cuts of rational numbers</a></li>
<li><a href="#sec-7-15-3">7.15.3. Real and natural numbers have different cardinalities</a></li>
<li><a href="#sec-7-15-4">7.15.4. (set-theory) (formal-logic)</a></li>
<li><a href="#sec-7-15-5">7.15.5. Search for proofs of consistency</a></li>
<li><a href="#sec-7-15-6">7.15.6. a procedure that would decide,</a></li>
<li><a href="#sec-7-15-7">7.15.7. a proof that every set could be well-ordered</a></li>
<li><a href="#sec-7-15-8">7.15.8. axiom of choice</a></li>
<li><a href="#sec-7-15-9">7.15.9. axioms for set theory</a></li>
<li><a href="#sec-7-15-10">7.15.10. axiom of replacement</a></li>
<li><a href="#sec-7-15-11">7.15.11. limitation of size</a></li>
</ul>
</li>
<li><a href="#sec-7-16">7.16. type-theory (principia-mathematica)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a>
<ul>
<li><a href="#sec-7-16-1">7.16.1. urelements</a></li>
</ul>
</li>
<li><a href="#sec-7-17">7.17. forcing used to establish independent results in set theory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-18">7.18. first-order logic cannot control the cardinalities of infinite structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-19">7.19. first-order formalizations of set theory have countable modes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-20">7.20. completeness theorem&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-21">7.21. trivial grammar problem&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a></li>
<li><a href="#sec-7-22">7.22. robust canonical class of computable functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a></li>
<li><a href="#sec-7-23">7.23. "rough consensus and running code"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="civil">civil</span>&#xa0;<span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a></li>
<li><a href="#sec-7-24">7.24. parsing expression grammar</a></li>
<li><a href="#sec-7-25">7.25. Quantification:&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a>
<ul>
<li><a href="#sec-7-25-1">7.25.1. SeeAlso quantifier elimination</a></li>
</ul>
</li>
<li><a href="#sec-7-26">7.26. replete&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-27">7.27. automata theory is a recognizer theory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-28">7.28. (N,E,P,S) (rewriting-system) (phrase-structure-grammar)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a></li>
<li><a href="#sec-7-29">7.29. Sample Grammar&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a>
<ul>
<li><a href="#sec-7-29-1">7.29.1. LRSTAR</a></li>
<li><a href="#sec-7-29-2">7.29.2. DCG definite clause grammar</a></li>
<li><a href="#sec-7-29-3">7.29.3. a set of definite clauses in first-order logic</a></li>
<li><a href="#sec-7-29-4">7.29.4. a simple grammar</a></li>
<li><a href="#sec-7-29-5">7.29.5. pure prolog</a></li>
<li><a href="#sec-7-29-6">7.29.6. the main practical use of DCG</a></li>
</ul>
</li>
<li><a href="#sec-7-30">7.30. Pseudocode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a>
<ul>
<li><a href="#sec-7-30-1">7.30.1. specific algorithms and translations</a></li>
<li><a href="#sec-7-30-2">7.30.2. codeblocks</a></li>
<li><a href="#sec-7-30-3">7.30.3. numerical computation</a></li>
</ul>
</li>
<li><a href="#sec-7-31">7.31. metalanguage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="metalanguage">metalanguage</span></span></a>
<ul>
<li><a href="#sec-7-31-1">7.31.1. logic and linguistics</a></li>
<li><a href="#sec-7-31-2">7.31.2. embedded, ordered and nested</a></li>
<li><a href="#sec-7-31-3">7.31.3. noun, verb and word are examples of metalanguage</a></li>
<li><a href="#sec-7-31-4">7.31.4. ordered metalanguage</a></li>
<li><a href="#sec-7-31-5">7.31.5. nested metalanguage</a></li>
<li><a href="#sec-7-31-6">7.31.6. metatheory</a></li>
</ul>
</li>
<li><a href="#sec-7-32">7.32. EBNF for Lisp&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="lisp">lisp</span>&#xa0;<span class="debug">debug</span></span></a></li>
<li><a href="#sec-7-33">7.33. Languages form the terrain of computing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="lisp">lisp</span>&#xa0;<span class="debug">debug</span></span></a>
<ul>
<li><a href="#sec-7-33-1">7.33.1. AT: So, what shapes languages?</a></li>
<li><a href="#sec-7-33-2">7.33.2. RR: Grammars do.</a></li>
</ul>
</li>
<li><a href="#sec-7-34">7.34. perl::rdf stuff</a></li>
</ul>
</li>
<li><a href="#sec-8">8. org&#xa0;&#xa0;&#xa0;<span class="tag"><span class="buffer">buffer</span></span></a>
<ul>
<li><a href="#sec-8-1">8.1. acl90</a></li>
<li><a href="#sec-8-2">8.2. bnf2xml</a></li>
<li><a href="#sec-8-3">8.3. inst*n lightnify:</a></li>
<li><a href="#sec-8-4">8.4. light.el:1804:22:Warning: (lambda (x) &#x2026;)</a></li>
<li><a href="#sec-8-5">8.5. negation (non) is sometimes failure, sometimes not failure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a>
<ul>
<li><a href="#sec-8-5-1">8.5.1. a test for three cases</a></li>
</ul>
</li>
<li><a href="#sec-8-6">8.6. Unicity Distance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></a>
<ul>
<li><a href="#sec-8-6-1">8.6.1. Attempts to give a minimum amount of ciphertext</a></li>
<li><a href="#sec-8-6-2">8.6.2. Based on the redundancy of plaintext.</a></li>
</ul>
</li>
<li><a href="#sec-8-7">8.7. org-element.el</a></li>
<li><a href="#sec-8-8">8.8. ox.el</a></li>
</ul>
</li>
<li><a href="#sec-9">9. bnf2xml&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ebnf">ebnf</span>&#xa0;<span class="parser">parser</span></span></a>
<ul>
<li><a href="#sec-9-1">9.1. BNF parser:</a></li>
</ul>
</li>
<li><a href="#sec-10">10. rdf2rdf&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="parser">parser</span></span></a></li>
<li><a href="#sec-11">11. n3&#xa0;&#xa0;&#xa0;<span class="tag"><span class="src">src</span>&#xa0;<span class="n3">n3</span></span></a>
<ul>
<li><a href="#sec-11-1">11.1. ttl</a></li>
</ul>
</li>
<li><a href="#sec-12">12. docs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="doc">doc</span></span></a>
<ul>
<li><a href="#sec-12-1">12.1. w3-rec&#xa0;&#xa0;&#xa0;<span class="tag"><span class="doc">doc</span></span></a></li>
</ul>
</li>
<li><a href="#sec-13">13. xslt&#xa0;&#xa0;&#xa0;<span class="tag"><span class="parser">parser</span>&#xa0;<span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></a>
<ul>
<li><a href="#sec-13-1">13.1. XSLT w3-rec</a></li>
</ul>
</li>
<li><a href="#sec-14">14. unsorted</a>
<ul>
<li><a href="#sec-14-1">14.1. develop a parser/sorter (for rewards)</a></li>
</ul>
</li>
<li><a href="#sec-15">15. gruff&#xa0;&#xa0;&#xa0;<span class="tag"><span class="gruff">gruff</span></span></a>
<ul>
<li><a href="#sec-15-1">15.1. The Programmatic Lisp API to Gruff</a></li>
<li><a href="#sec-15-2">15.2. Lisp Functions for Modifying User Options Programmatically</a></li>
</ul>
</li>
<li><a href="#sec-16">16. grammar: a set of production rules for strings</a>
<ul>
<li><a href="#sec-16-1">16.1. formal grammar</a>
<ul>
<li><a href="#sec-16-1-1">16.1.1. Contents</a></li>
<li><a href="#sec-16-1-2">16.1.2. Introductory example[edit]</a></li>
<li><a href="#sec-16-1-3">16.1.3. Formal definition[edit]</a></li>
<li><a href="#sec-16-1-4">16.1.4. The Chomsky hierarchy[edit]</a></li>
<li><a href="#sec-16-1-5">16.1.5. Recursive grammars[edit]</a></li>
<li><a href="#sec-16-1-6">16.1.6. Analytic grammars[edit]</a></li>
<li><a href="#sec-16-1-7">16.1.7. References[edit]</a></li>
</ul>
</li>
<li><a href="#sec-16-2">16.2. Automata theory: formal languages and formal grammars</a>
<ul>
<li><a href="#sec-16-2-1">16.2.1. Chomsky hierarchy table</a></li>
</ul>
</li>
<li><a href="#sec-16-3">16.3. Wikipedia Stuff</a>
<ul>
<li><a href="#sec-16-3-1">16.3.1. Categories:</a></li>
<li><a href="#sec-16-3-2">16.3.2. Navigation menu</a></li>
<li><a href="#sec-16-3-3">16.3.3. Personal tools</a></li>
<li><a href="#sec-16-3-4">16.3.4. Namespaces</a></li>
<li><a href="#sec-16-3-5">16.3.5. Variants</a></li>
<li><a href="#sec-16-3-6">16.3.6. Views</a></li>
<li><a href="#sec-16-3-7">16.3.7. Actions</a></li>
<li><a href="#sec-16-3-8">16.3.8. Search</a></li>
<li><a href="#sec-16-3-9">16.3.9. Navigation</a></li>
<li><a href="#sec-16-3-10">16.3.10. Interaction</a></li>
<li><a href="#sec-16-3-11">16.3.11. Tools</a></li>
<li><a href="#sec-16-3-12">16.3.12. Print/export</a></li>
<li><a href="#sec-16-3-13">16.3.13. Languages</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-17">17. ebnf2ps</a></li>
<li><a href="#sec-18">18. xml spec 1.0</a></li>
<li><a href="#sec-19">19. aptitude search parser - installed</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> rdf&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h2>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> <span class="todo TODO">TODO</span> selectOneOf&#xa0;&#xa0;&#xa0;<span class="tag"><span class="quicksort">quicksort</span>&#xa0;<span class="prolog">prolog</span>&#xa0;<span class="debug">debug</span></span></h2>
<div class="outline-text-2" id="text-2">
<p>
::= (elisp|xslt|xpath|xquery|sparql|spin)
sort into standards, specifications and implementations perhaps
quicksort might be useful here, but will it have to be in elisp?
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> quicksort</h3>
<div class="outline-text-3" id="text-2-1">
<p>
partition([], _, [], []).
partition([X|Xs], Pivot, Smalls, Bigs) :-
    (   X @&lt; Pivot -&gt;
        Smalls = [X|Rest],
        partition(Xs, Pivot, Rest, Bigs)
    ;   Bigs = [X|Rest],
        partition(Xs, Pivot, Smalls, Rest)
    ).
</p>

<p>
quicksort([])     &#x2013;&gt; [].
quicksort([X|Xs]) &#x2013;&gt;
    { partition(Xs, X, Smaller, Bigger) },
    quicksort(Smaller), [X], quicksort(Bigger).
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> owl&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="owl">owl</span></span></h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> owl2 in triples&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="owl">owl</span></span></h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> <span class="done DONE">DONE</span> load these triples into the ts triple-store</h4>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> Annotations</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
"&#x2026; the OWL 2 RDF-Based Semantics includes many semantic
conditions that can in a sense be regarded as being
"axiomatic", and thus can be considered a replacement for
the missing axiomatic triples."
<a href="file:///usr/share/doc/w3-recs/html/www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/index.html#Appendix:_Axiomatic_Triples_.28Informative.29">file:///usr/share/doc/w3-recs/html/www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/index.html#Appendix:_Axiomatic_Triples_.28Informative.29</a>
</p>
</div>
</div>

<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3"><span class="section-number-4">3.1.3</span> owl2 in turtle</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
owl:AllDifferent rdf:type rdfs:Class .
</p>

<p>
owl:AllDifferent rdfs:subClassOf rdfs:Resource .
</p>

<p>
owl:AllDisjointClasses rdf:type rdfs:Class .
</p>

<p>
owl:AllDisjointClasses rdfs:subClassOf rdfs:Resource .
</p>

<p>
owl:AllDisjointProperties rdf:type rdfs:Class .
</p>

<p>
owl:AllDisjointProperties rdfs:subClassOf rdfs:Resource .
</p>

<p>
owl:Annotation rdf:type rdfs:Class .
</p>

<p>
owl:Annotation rdfs:subClassOf rdfs:Resource .
</p>

<p>
owl:AnnotationProperty rdf:type rdfs:Class .
</p>

<p>
owl:AnnotationProperty rdfs:subClassOf rdf:Property .
</p>

<p>
owl:AsymmetricProperty rdf:type rdfs:Class .
</p>

<p>
owl:AsymmetricProperty rdfs:subClassOf owl:ObjectProperty .
</p>

<p>
owl:Axiom rdf:type rdfs:Class .
</p>

<p>
owl:Axiom rdfs:subClassOf rdfs:Resource .
</p>

<p>
owl:Class rdf:type rdfs:Class .
</p>

<p>
owl:Class rdfs:subClassOf rdfs:Class .
</p>

<p>
owl:DataRange rdf:type rdfs:Class .
</p>

<p>
owl:DataRange rdfs:subClassOf rdfs:Datatype .
</p>

<p>
owl:DatatypeProperty rdf:type rdfs:Class .
</p>

<p>
owl:DatatypeProperty rdfs:subClassOf rdf:Property .
</p>

<p>
owl:DeprecatedClass rdf:type rdfs:Class .
</p>

<p>
owl:DeprecatedClass rdfs:subClassOf rdfs:Class .
</p>

<p>
owl:DeprecatedProperty rdf:type rdfs:Class .
</p>

<p>
owl:DeprecatedProperty rdfs:subClassOf rdf:Property .
</p>

<p>
owl:FunctionalProperty rdf:type rdfs:Class .
</p>

<p>
owl:FunctionalProperty rdfs:subClassOf rdf:Property .
</p>

<p>
owl:InverseFunctionalProperty rdf:type rdfs:Class .
</p>

<p>
owl:InverseFunctionalProperty rdfs:subClassOf owl:ObjectProperty .
</p>

<p>
owl:IrreflexiveProperty rdf:type rdfs:Class .
</p>

<p>
owl:IrreflexiveProperty rdfs:subClassOf owl:ObjectProperty .
</p>

<p>
owl:NamedIndividual rdf:type rdfs:Class .
</p>

<p>
owl:NamedIndividual rdfs:subClassOf owl:Thing .
</p>

<p>
owl:NegativePropertyAssertion rdf:type rdfs:Class .
</p>

<p>
owl:NegativePropertyAssertion rdfs:subClassOf rdfs:Resource .
</p>

<p>
owl:Nothing rdf:type owl:Class .
</p>

<p>
owl:Nothing rdfs:subClassOf owl:Thing .
</p>

<p>
owl:ObjectProperty rdf:type rdfs:Class .
</p>

<p>
owl:ObjectProperty rdfs:subClassOf rdf:Property .
</p>

<p>
owl:Ontology rdf:type rdfs:Class .
</p>

<p>
owl:Ontology rdfs:subClassOf rdfs:Resource .
</p>

<p>
owl:OntologyProperty rdf:type rdfs:Class .
</p>

<p>
owl:OntologyProperty rdfs:subClassOf rdf:Property .
</p>

<p>
owl:ReflexiveProperty rdf:type rdfs:Class .
</p>

<p>
owl:ReflexiveProperty rdfs:subClassOf owl:ObjectProperty .
</p>

<p>
owl:Restriction rdf:type rdfs:Class .
</p>

<p>
owl:Restriction rdfs:subClassOf owl:Class .
</p>

<p>
owl:SymmetricProperty rdf:type rdfs:Class .
</p>

<p>
owl:SymmetricProperty rdfs:subClassOf owl:ObjectProperty .
</p>

<p>
owl:Thing rdf:type owl:Class .
</p>

<p>
owl:TransitiveProperty rdf:type rdfs:Class .
</p>

<p>
owl:TransitiveProperty rdfs:subClassOf owl:ObjectProperty .
</p>
</div>

<ol class="org-ol"><li>Axiomatic Triples for the Properties<br  /><div class="outline-text-5" id="text-3-1-3-1">
<p>
owl:allValuesFrom rdf:type rdf:Property .
</p>

<p>
owl:allValuesFrom rdfs:domain owl:Restriction .
</p>

<p>
owl:allValuesFrom rdfs:range rdfs:Class .
</p>

<p>
owl:annotatedProperty rdf:type rdf:Property .
</p>

<p>
owl:annotatedProperty rdfs:domain rdfs:Resource .
</p>

<p>
owl:annotatedProperty rdfs:range rdfs:Resource .
</p>

<p>
owl:annotatedSource rdf:type rdf:Property .
</p>

<p>
owl:annotatedSource rdfs:domain rdfs:Resource .
</p>

<p>
owl:annotatedSource rdfs:range rdfs:Resource .
</p>

<p>
owl:annotatedTarget rdf:type rdf:Property .
</p>

<p>
owl:annotatedTarget rdfs:domain rdfs:Resource .
</p>

<p>
owl:annotatedTarget rdfs:range rdfs:Resource .
</p>

<p>
owl:assertionProperty rdf:type rdf:Property .
</p>

<p>
owl:assertionProperty rdfs:domain owl:NegativePropertyAssertion .
</p>

<p>
owl:assertionProperty rdfs:range rdf:Property .
</p>

<p>
owl:backwardCompatibleWith rdf:type owl:AnnotationProperty .
</p>

<p>
owl:backwardCompatibleWith rdf:type owl:OntologyProperty .
</p>

<p>
owl:backwardCompatibleWith rdfs:domain owl:Ontology .
</p>

<p>
owl:backwardCompatibleWith rdfs:range owl:Ontology .
</p>

<p>
owl:bottomDataProperty rdf:type owl:DatatypeProperty .
</p>

<p>
owl:bottomDataProperty rdfs:domain owl:Thing .
</p>

<p>
owl:bottomDataProperty rdfs:range rdfs:Literal .
</p>

<p>
owl:bottomObjectProperty rdf:type owl:ObjectProperty .
</p>

<p>
owl:bottomObjectProperty rdfs:domain owl:Thing .
</p>

<p>
owl:bottomObjectProperty rdfs:range owl:Thing .
</p>

<p>
owl:cardinality rdf:type rdf:Property .
</p>

<p>
owl:cardinality rdfs:domain owl:Restriction .
</p>

<p>
owl:cardinality rdfs:range xsd:nonNegativeInteger .
</p>

<p>
owl:complementOf rdf:type rdf:Property .
</p>

<p>
owl:complementOf rdfs:domain owl:Class .
</p>

<p>
owl:complementOf rdfs:range owl:Class .
</p>

<p>
owl:datatypeComplementOf rdf:type rdf:Property .
</p>

<p>
owl:datatypeComplementOf rdfs:domain rdfs:Datatype .
</p>

<p>
owl:datatypeComplementOf rdfs:range rdfs:Datatype .
</p>

<p>
owl:deprecated rdf:type owl:AnnotationProperty .
</p>

<p>
owl:deprecated rdfs:domain rdfs:Resource .
</p>

<p>
owl:deprecated rdfs:range rdfs:Resource .
</p>

<p>
owl:differentFrom rdf:type rdf:Property .
</p>

<p>
owl:differentFrom rdfs:domain owl:Thing .
</p>

<p>
owl:differentFrom rdfs:range owl:Thing .
</p>

<p>
owl:disjointUnionOf rdf:type rdf:Property .
</p>

<p>
owl:disjointUnionOf rdfs:domain owl:Class .
</p>

<p>
owl:disjointUnionOf rdfs:range rdf:List .
</p>

<p>
owl:disjointWith rdf:type rdf:Property .
</p>

<p>
owl:disjointWith rdfs:domain owl:Class .
</p>

<p>
owl:disjointWith rdfs:range owl:Class .
</p>

<p>
owl:distinctMembers rdf:type rdf:Property .
</p>

<p>
owl:distinctMembers rdfs:domain owl:AllDifferent .
</p>

<p>
owl:distinctMembers rdfs:range rdf:List .
</p>

<p>
owl:equivalentClass rdf:type rdf:Property .
</p>

<p>
owl:equivalentClass rdfs:domain rdfs:Class .
</p>

<p>
owl:equivalentClass rdfs:range rdfs:Class .
</p>

<p>
owl:equivalentProperty rdf:type rdf:Property .
</p>

<p>
owl:equivalentProperty rdfs:domain rdf:Property .
</p>

<p>
owl:equivalentProperty rdfs:range rdf:Property .
</p>

<p>
owl:hasKey rdf:type rdf:Property .
</p>

<p>
owl:hasKey rdfs:domain owl:Class .
</p>

<p>
owl:hasKey rdfs:range rdf:List .
</p>

<p>
owl:hasSelf rdf:type rdf:Property .
</p>

<p>
owl:hasSelf rdfs:domain owl:Restriction .
</p>

<p>
owl:hasSelf rdfs:range rdfs:Resource .
</p>

<p>
owl:hasValue rdf:type rdf:Property .
</p>

<p>
owl:hasValue rdfs:domain owl:Restriction .
</p>

<p>
owl:hasValue rdfs:range rdfs:Resource .
</p>

<p>
owl:imports rdf:type owl:OntologyProperty .
</p>

<p>
owl:imports rdfs:domain owl:Ontology .
</p>

<p>
owl:imports rdfs:range owl:Ontology .
</p>

<p>
owl:incompatibleWith rdf:type owl:AnnotationProperty .
</p>

<p>
owl:incompatibleWith rdf:type owl:OntologyProperty .
</p>

<p>
owl:incompatibleWith rdfs:domain owl:Ontology .
</p>

<p>
owl:incompatibleWith rdfs:range owl:Ontology .
</p>

<p>
owl:intersectionOf rdf:type rdf:Property .
</p>

<p>
owl:intersectionOf rdfs:domain rdfs:Class .
</p>

<p>
owl:intersectionOf rdfs:range rdf:List .
</p>

<p>
owl:inverseOf rdf:type rdf:Property .
</p>

<p>
owl:inverseOf rdfs:domain owl:ObjectProperty .
</p>

<p>
owl:inverseOf rdfs:range owl:ObjectProperty .
</p>

<p>
owl:maxCardinality rdf:type rdf:Property .
</p>

<p>
owl:maxCardinality rdfs:domain owl:Restriction .
</p>

<p>
owl:maxCardinality rdfs:range xsd:nonNegativeInteger .
</p>

<p>
owl:maxQualifiedCardinality rdf:type rdf:Property .
</p>

<p>
owl:maxQualifiedCardinality rdfs:domain owl:Restriction .
</p>

<p>
owl:maxQualifiedCardinality rdfs:range xsd:nonNegativeInteger .
</p>

<p>
owl:members rdf:type rdf:Property .
</p>

<p>
owl:members rdfs:domain rdfs:Resource .
</p>

<p>
owl:members rdfs:range rdf:List .
</p>

<p>
owl:minCardinality rdf:type rdf:Property .
</p>

<p>
owl:minCardinality rdfs:domain owl:Restriction .
</p>

<p>
owl:minCardinality rdfs:range xsd:nonNegativeInteger .
</p>

<p>
owl:minQualifiedCardinality rdf:type rdf:Property .
</p>

<p>
owl:minQualifiedCardinality rdfs:domain owl:Restriction .
</p>

<p>
owl:minQualifiedCardinality rdfs:range xsd:nonNegativeInteger .
</p>

<p>
owl:onClass rdf:type rdf:Property .
</p>

<p>
owl:onClass rdfs:domain owl:Restriction .
</p>

<p>
owl:onClass rdfs:range owl:Class .
</p>

<p>
owl:onDataRange rdf:type rdf:Property .
</p>

<p>
owl:onDataRange rdfs:domain owl:Restriction .
</p>

<p>
owl:onDataRange rdfs:range rdfs:Datatype .
</p>

<p>
owl:onDatatype rdf:type rdf:Property .
</p>

<p>
owl:onDatatype rdfs:domain rdfs:Datatype .
</p>

<p>
owl:onDatatype rdfs:range rdfs:Datatype .
</p>

<p>
owl:oneOf rdf:type rdf:Property .
</p>

<p>
owl:oneOf rdfs:domain rdfs:Class .
</p>

<p>
owl:oneOf rdfs:range rdf:List .
</p>

<p>
owl:onProperty rdf:type rdf:Property .
</p>

<p>
owl:onProperty rdfs:domain owl:Restriction .
</p>

<p>
owl:onProperty rdfs:range rdf:Property .
</p>

<p>
owl:onProperties rdf:type rdf:Property .
</p>

<p>
owl:onProperties rdfs:domain owl:Restriction .
</p>

<p>
owl:onProperties rdfs:range rdf:List .
</p>

<p>
owl:priorVersion rdf:type owl:AnnotationProperty .
</p>

<p>
owl:priorVersion rdf:type owl:OntologyProperty .
</p>

<p>
owl:priorVersion rdfs:domain owl:Ontology .
</p>

<p>
owl:priorVersion rdfs:range owl:Ontology .
</p>

<p>
owl:propertyChainAxiom rdf:type rdf:Property .
</p>

<p>
owl:propertyChainAxiom rdfs:domain owl:ObjectProperty .
</p>

<p>
owl:propertyChainAxiom rdfs:range rdf:List .
</p>

<p>
owl:propertyDisjointWith rdf:type rdf:Property .
</p>

<p>
owl:propertyDisjointWith rdfs:domain rdf:Property .
</p>

<p>
owl:propertyDisjointWith rdfs:range rdf:Property .
</p>

<p>
owl:qualifiedCardinality rdf:type rdf:Property .
</p>

<p>
owl:qualifiedCardinality rdfs:domain owl:Restriction .
</p>

<p>
owl:qualifiedCardinality rdfs:range xsd:nonNegativeInteger .
</p>

<p>
owl:sameAs rdf:type rdf:Property .
</p>

<p>
owl:sameAs rdfs:domain owl:Thing .
</p>

<p>
owl:sameAs rdfs:range owl:Thing .
</p>

<p>
owl:someValuesFrom rdf:type rdf:Property .
</p>

<p>
owl:someValuesFrom rdfs:domain owl:Restriction .
</p>

<p>
owl:someValuesFrom rdfs:range rdfs:Class .
</p>

<p>
owl:sourceIndividual rdf:type rdf:Property .
</p>

<p>
owl:sourceIndividual rdfs:domain owl:NegativePropertyAssertion .
</p>

<p>
owl:sourceIndividual rdfs:range owl:Thing .
</p>

<p>
owl:targetIndividual rdf:type rdf:Property .
</p>

<p>
owl:targetIndividual rdfs:domain owl:NegativePropertyAssertion .
</p>

<p>
owl:targetIndividual rdfs:range owl:Thing .
</p>

<p>
owl:targetValue rdf:type rdf:Property .
</p>

<p>
owl:targetValue rdfs:domain owl:NegativePropertyAssertion .
</p>

<p>
owl:targetValue rdfs:range rdfs:Literal .
</p>

<p>
owl:topDataProperty rdf:type owl:DatatypeProperty .
</p>

<p>
owl:topDataProperty rdfs:domain owl:Thing .
</p>

<p>
owl:topDataProperty rdfs:range rdfs:Literal .
</p>

<p>
owl:topObjectProperty rdf:type rdf:ObjectProperty .
</p>

<p>
owl:topObjectProperty rdfs:domain owl:Thing .
</p>

<p>
owl:topObjectProperty rdfs:range owl:Thing .
</p>

<p>
owl:unionOf rdf:type rdf:Property .
</p>

<p>
owl:unionOf rdfs:domain rdfs:Class .
</p>

<p>
owl:unionOf rdfs:range rdf:List .
</p>

<p>
owl:versionInfo rdf:type owl:AnnotationProperty .
</p>

<p>
owl:versionInfo rdfs:domain rdfs:Resource .
</p>

<p>
owl:versionInfo rdfs:range rdfs:Resource .
</p>

<p>
owl:versionIRI rdf:type owl:OntologyProperty .
</p>

<p>
owl:versionIRI rdfs:domain owl:Ontology .
</p>

<p>
owl:versionIRI rdfs:range owl:Ontology .
</p>

<p>
owl:withRestrictions rdf:type rdf:Property .
</p>

<p>
owl:withRestrictions rdfs:domain rdfs:Datatype .
</p>

<p>
owl:withRestrictions rdfs:range rdf:List .
</p>
</div>
</li>

<li>Axiomatic Triples for the Datatypes<br  /><div class="outline-text-5" id="text-3-1-3-2">
<p>
xsd:anyURI rdf:type rdfs:Datatype .
</p>

<p>
xsd:anyURI rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:base64Binary rdf:type rdfs:Datatype .
</p>

<p>
xsd:base64Binary rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:boolean rdf:type rdfs:Datatype .
</p>

<p>
xsd:boolean rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:byte rdf:type rdfs:Datatype .
</p>

<p>
xsd:byte rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:dateTime rdf:type rdfs:Datatype .
</p>

<p>
xsd:dateTime rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:dateTimeStamp rdf:type rdfs:Datatype .
</p>

<p>
xsd:dateTimeStamp rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:decimal rdf:type rdfs:Datatype .
</p>

<p>
xsd:decimal rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:double rdf:type rdfs:Datatype .
</p>

<p>
xsd:double rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:float rdf:type rdfs:Datatype .
</p>

<p>
xsd:float rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:hexBinary rdf:type rdfs:Datatype .
</p>

<p>
xsd:hexBinary rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:int rdf:type rdfs:Datatype .
</p>

<p>
xsd:int rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:integer rdf:type rdfs:Datatype .
</p>

<p>
xsd:integer rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:language rdf:type rdfs:Datatype .
</p>

<p>
xsd:language rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:long rdf:type rdfs:Datatype .
</p>

<p>
xsd:long rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:Name rdf:type rdfs:Datatype .
</p>

<p>
xsd:Name rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:NCName rdf:type rdfs:Datatype .
</p>

<p>
xsd:NCName rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:negativeInteger rdf:type rdfs:Datatype .
</p>

<p>
xsd:negativeInteger rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:NMTOKEN rdf:type rdfs:Datatype .
</p>

<p>
xsd:NMTOKEN rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:nonNegativeInteger rdf:type rdfs:Datatype .
</p>

<p>
xsd:nonNegativeInteger rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:nonPositiveInteger rdf:type rdfs:Datatype .
</p>

<p>
xsd:nonPositiveInteger rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:normalizedString rdf:type rdfs:Datatype .
</p>

<p>
xsd:normalizedString rdfs:subClassOf rdfs:Literal .
</p>

<p>
rdf:PlainLiteral rdf:type rdfs:Datatype .
</p>

<p>
rdf:PlainLiteral rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:positiveInteger rdf:type rdfs:Datatype .
</p>

<p>
xsd:positiveInteger rdfs:subClassOf rdfs:Literal .
</p>

<p>
owl:rational rdf:type rdfs:Datatype .
</p>

<p>
owl:rational rdfs:subClassOf rdfs:Literal .
</p>

<p>
owl:real rdf:type rdfs:Datatype .
</p>

<p>
owl:real rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:short rdf:type rdfs:Datatype .
</p>

<p>
xsd:short rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:string rdf:type rdfs:Datatype .
</p>

<p>
xsd:string rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:token rdf:type rdfs:Datatype .
</p>

<p>
xsd:token rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:unsignedByte rdf:type rdfs:Datatype .
</p>

<p>
xsd:unsignedByte rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:unsignedInt rdf:type rdfs:Datatype .
</p>

<p>
xsd:unsignedInt rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:unsignedLong rdf:type rdfs:Datatype .
</p>

<p>
xsd:unsignedLong rdfs:subClassOf rdfs:Literal .
</p>

<p>
xsd:unsignedShort rdf:type rdfs:Datatype .
</p>

<p>
xsd:unsignedShort rdfs:subClassOf rdfs:Literal .
</p>

<p>
rdf:XMLLiteral rdf:type rdfs:Datatype .
</p>

<p>
rdf:XMLLiteral rdfs:subClassOf rdfs:Literal .
</p>
</div>
</li>

<li>Axiomatic Triples for the Facets<br  /><div class="outline-text-5" id="text-3-1-3-3">
<p>
&lt;rdf:langRange&gt; &lt;rdf:type&gt; &lt;owl:DatatypeProperty&gt; .
</p>

<p>
&lt;rdf:langRange&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;rdf:langRange&gt; &lt;rdfs:range&gt; &lt;rdfs:Literal&gt; .
</p>

<p>
&lt;xsd:length&gt; &lt;rdf:type&gt; &lt;owl:DatatypeProperty&gt; .
</p>

<p>
&lt;xsd:length&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;xsd:length&gt; &lt;rdfs:range&gt; &lt;rdfs:Literal&gt; .
</p>

<p>
&lt;xsd:maxExclusive&gt; &lt;rdf:type&gt; &lt;owl:DatatypeProperty&gt; .
</p>

<p>
&lt;xsd:maxExclusive&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;xsd:maxExclusive&gt; &lt;rdfs:range&gt; &lt;rdfs:Literal&gt; .
</p>

<p>
&lt;xsd:maxInclusive&gt; &lt;rdf:type&gt; &lt;owl:DatatypeProperty&gt; .
</p>

<p>
&lt;xsd:maxInclusive&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;xsd:maxInclusive&gt; &lt;rdfs:range&gt; &lt;rdfs:Literal&gt; .
</p>

<p>
&lt;xsd:maxLength&gt; &lt;rdf:type&gt; &lt;owl:DatatypeProperty&gt; .
</p>

<p>
&lt;xsd:maxLength&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;xsd:maxLength&gt; &lt;rdfs:range&gt; &lt;rdfs:Literal&gt; .
</p>

<p>
&lt;xsd:minExclusive&gt; &lt;rdf:type&gt; &lt;owl:DatatypeProperty&gt; .
</p>

<p>
&lt;xsd:minExclusive&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;xsd:minExclusive&gt; &lt;rdfs:range&gt; &lt;rdfs:Literal&gt; .
</p>

<p>
&lt;xsd:minInclusive&gt; &lt;rdf:type&gt; &lt;owl:DatatypeProperty&gt; .
</p>

<p>
&lt;xsd:minInclusive&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;xsd:minInclusive&gt; &lt;rdfs:range&gt; &lt;rdfs:Literal&gt; .
</p>

<p>
&lt;xsd:minLength&gt; &lt;rdf:type&gt; &lt;owl:DatatypeProperty&gt; .
</p>

<p>
xsd:minLength rdfs:domain rdfs:Resource .
</p>

<p>
xsd:minLength rdfs:range rdfs:Literal .
</p>

<p>
xsd:pattern rdf:type owl:DatatypeProperty .
</p>

<p>
xsd:pattern rdfs:domain rdfs:Resource .
</p>

<p>
xsd:pattern rdfs:range rdfs:Literal .
</p>
</div>
</li>

<li>Additional Axiomatic Triples for Classes and Properties<br  /><div class="outline-text-5" id="text-3-1-3-4">
<p>
&lt;rdfs:Class&gt; &lt;rdfs:subClassOf&gt; &lt;owl:Class&gt; .
</p>

<p>
&lt;rdfs:comment&gt; &lt;rdf:type&gt; &lt;owl:AnnotationProperty&gt; .
</p>

<p>
&lt;rdfs:comment&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;rdfs:comment&gt; &lt;rdfs:range&gt; &lt;rdfs:Literal&gt; .
</p>

<p>
&lt;rdfs:Datatype&gt; &lt;rdfs:subClassOf&gt; &lt;owl:DataRange&gt; .
</p>

<p>
&lt;rdfs:isDefinedBy&gt; &lt;rdf:type&gt; &lt;owl:AnnotationProperty&gt; .
</p>

<p>
&lt;rdfs:isDefinedBy&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;rdfs:isDefinedBy&gt; &lt;rdfs:range&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;rdfs:label&gt; &lt;rdf:type&gt; &lt;owl:AnnotationProperty&gt; .
</p>

<p>
&lt;rdfs:label&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;rdfs:label&gt; &lt;rdfs:range&gt; &lt;rdfs:Literal&gt; .
</p>

<p>
&lt;rdfs:Literal&gt; &lt;rdf:type&gt; &lt;rdfs:Datatype&gt; .
</p>

<p>
&lt;rdf:Property&gt; &lt;rdfs:subClassOf&gt; &lt;owl:ObjectProperty&gt; .
</p>

<p>
&lt;rdfs:Resource&gt; &lt;rdfs:subClassOf&gt; &lt;owl:Thing&gt; .
</p>

<p>
&lt;rdfs:seeAlso&gt; &lt;rdf:type&gt; &lt;owl:AnnotationProperty&gt; .
</p>

<p>
&lt;rdfs:seeAlso&gt; &lt;rdfs:domain&gt; &lt;rdfs:Resource&gt; .
</p>

<p>
&lt;rdfs:seeAlso&gt; &lt;rdfs:range&gt; &lt;rdfs:Resource&gt; .
</p>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> misc owl2&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-3-2">
<p>
ICEXT(I(ex:c1))  ICEXT(I(ex:c2))  ICEXT(I(ex:c3)) . 
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> owl2 basic gloss</h3>
<div class="outline-text-3" id="text-3-3">
<p>
owl:AllDifferent 
</p>

<p>
owl:AllDisjointClasses 
</p>

<p>
owl:AllDisjointProperties 
</p>

<p>
owl:allValuesFrom 
</p>

<p>
owl:annotatedProperty 
</p>

<p>
owl:annotatedSource 
</p>

<p>
owl:annotatedTarget 
</p>

<p>
owl:Annotation 
</p>

<p>
owl:AnnotationProperty 
</p>

<p>
owl:assertionProperty 
</p>

<p>
owl:AsymmetricProperty 
</p>

<p>
owl:Axiom 
</p>

<p>
owl:backwardCompatibleWith 
</p>

<p>
owl:bottomDataProperty 
</p>

<p>
owl:bottomObjectProperty 
</p>

<p>
owl:cardinality 
</p>

<p>
owl:Class 
</p>

<p>
owl:complementOf 
</p>

<p>
owl:DataRange 
</p>

<p>
owl:datatypeComplementOf 
</p>

<p>
owl:DatatypeProperty 
</p>

<p>
owl:deprecated 
</p>

<p>
owl:DeprecatedClass 
</p>

<p>
owl:DeprecatedProperty 
</p>

<p>
owl:differentFrom 
</p>

<p>
owl:disjointUnionOf 
</p>

<p>
owl:disjointWith 
</p>

<p>
owl:distinctMembers 
</p>

<p>
owl:equivalentClass 
</p>

<p>
owl:equivalentProperty 
</p>

<p>
owl:FunctionalProperty 
</p>

<p>
owl:hasKey 
</p>

<p>
owl:hasSelf 
</p>

<p>
owl:hasValue 
</p>

<p>
owl:imports 
</p>

<p>
owl:incompatibleWith 
</p>

<p>
owl:intersectionOf 
</p>

<p>
owl:InverseFunctionalProperty 
</p>

<p>
owl:inverseOf 
</p>

<p>
owl:IrreflexiveProperty 
</p>

<p>
owl:maxCardinality 
</p>

<p>
owl:maxQualifiedCardinality 
</p>

<p>
owl:members 
</p>

<p>
owl:minCardinality 
</p>

<p>
owl:minQualifiedCardinality 
</p>

<p>
owl:NamedIndividual 
</p>

<p>
owl:NegativePropertyAssertion 
</p>

<p>
owl:Nothing 
</p>

<p>
owl:ObjectProperty 
</p>

<p>
owl:onClass 
</p>

<p>
owl:onDataRange 
</p>

<p>
owl:onDatatype 
</p>

<p>
owl:oneOf 
</p>

<p>
owl:onProperty 
</p>

<p>
owl:onProperties 
</p>

<p>
owl:Ontology 
</p>

<p>
owl:OntologyProperty 
</p>

<p>
owl:priorVersion 
</p>

<p>
owl:propertyChainAxiom 
</p>

<p>
owl:propertyDisjointWith 
</p>

<p>
owl:qualifiedCardinality 
</p>

<p>
owl:ReflexiveProperty 
</p>

<p>
owl:Restriction 
</p>

<p>
owl:sameAs 
</p>

<p>
owl:someValuesFrom 
</p>

<p>
owl:sourceIndividual 
</p>

<p>
owl:SymmetricProperty 
</p>

<p>
owl:targetIndividual 
</p>

<p>
owl:targetValue 
</p>

<p>
owl:Thing 
</p>

<p>
owl:topDataProperty 
</p>

<p>
owl:topObjectProperty 
</p>

<p>
owl:TransitiveProperty 
</p>

<p>
owl:unionOf 
</p>

<p>
owl:versionInfo 
</p>

<p>
owl:versionIRI 
</p>

<p>
owl:withRestrictions 
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> About owl2 and axiomatic triples</h3>
<div class="outline-text-3" id="text-3-4">
<p>
_:x rdf:type owl:Class.
</p>

<p>
_:x owl:intersectionOf ( C1  Cn ). 
</p>

<p>
_:x rdf:type owl:Class.
</p>

<p>
_:x owl:unionOf ( C1  Cn ). 
</p>

<p>
_:x rdf:type owl:Class.
</p>

<p>
_:x owl:complementOf C. 
</p>

<p>
_:x rdf:type owl:Class.
</p>

<p>
_:x owl:oneOf ( a1  an ). 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:allValuesFrom C .
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:someValuesFrom C .
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:hasValue a. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:hasSelf "true"^<sup>xsd</sup>:boolean. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:cardinality n. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:qualifiedCardinality n.
</p>

<p>
_:x owl:onClass C. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:maxCardinality n. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:maxQualifiedCardinality n.
</p>

<p>
_:x owl:onClass C. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:minCardinality n. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty P.
</p>

<p>
_:x owl:minQualifiedCardinality n.
</p>

<p>
_:x owl:onClass C. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty R.
</p>

<p>
_:x owl:allValuesFrom D. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty R.
</p>

<p>
_:x owl:someValuesFrom D. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty R.
</p>

<p>
_:x owl:hasValue v. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty R.
</p>

<p>
_:x owl:cardinality n. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty R.
</p>

<p>
_:x owl:qualifiedCardinality n.
</p>

<p>
_:x owl:onDataRange D. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty R.
</p>

<p>
_:x owl:maxCardinality n. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty R.
</p>

<p>
_:x owl:maxQualifiedCardinality n.
</p>

<p>
_:x owl:onDataRange D. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty R.
</p>

<p>
_:x owl:minCardinality n. 
</p>

<p>
_:x rdf:type owl:Restriction.
</p>

<p>
_:x owl:onProperty R.
</p>

<p>
_:x owl:minQualifiedCardinality n.
</p>

<p>
_:x owl:onDataRange D. 
</p>

<p>
_:x rdf:type rdfs:Datatype.
</p>

<p>
_:x owl:datatypeComplementOf D. 
</p>

<p>
_:x rdf:type rdfs:Datatype.
</p>

<p>
_:x owl:intersectionOf (D1Dn). 
</p>

<p>
_:x rdf:type rdfs:Datatype.
</p>

<p>
_:x owl:unionOf (D1Dn). 
</p>

<p>
_:x rdf:type rdfs:Datatype.
</p>

<p>
_:x owl:oneOf ( v1  vn ). 
</p>

<p>
_:x rdf:type rdfs:Datatype.
</p>

<p>
_:x owl:onDatatype DN.
</p>

<p>
<span class="underline">:x owl:withRestrictions (</span>:x1 &#x2026; _:xn).
</p>

<p>
_:xj fj vj.      j=1n 
</p>

<p>
C1 rdfs:subClassOf C2. 
</p>

<p>
Cj owl:equivalentClass Cj+1. j=1n-1 
</p>

<p>
C1 owl:disjointWith C2. 
</p>

<p>
_:x rdf:type owl:AllDisjointClasses.
</p>

<p>
_:x owl:members ( C1  Cn ). 
</p>

<p>
P1 rdfs:subPropertyOf P2. 
</p>

<p>
P owl:propertyChainAxiom (P1  Pn). 
</p>

<p>
P rdfs:domain C. 
</p>

<p>
P rdfs:range C. 
</p>

<p>
Pj owl:equivalentProperty Pj+1. j=1n-1 
</p>

<p>
P1 owl:propertyDisjointWith P2. 
</p>

<p>
_:x rdf:type owl:AllDisjointProperties.
</p>

<p>
_:x owl:members ( P1  Pn ). 
</p>

<p>
CN owl:disjointUnionOf ( C1  Cn ).
</p>

<p>
P1 owl:inverseOf P2. 
</p>

<p>
P rdf:type owl:FunctionalProperty. 
</p>

<p>
P rdf:type owl:InverseFunctionalProperty. 
</p>

<p>
P rdf:type owl:ReflexiveProperty. 
</p>

<p>
P rdf:type owl:IrreflexiveProperty. 
</p>

<p>
P rdf:type owl:SymmetricProperty. 
</p>

<p>
P rdf:type owl:AsymmetricProperty. 
</p>

<p>
P rdf:type owl:TransitiveProperty. 
</p>

<p>
DN owl:equivalentClass D. 
</p>

<p>
aj owl:sameAs aj+1. j=1n-1 
</p>

<p>
a1 owl:differentFrom a2. 
</p>

<p>
_:x rdf:type owl:AllDifferent.
</p>

<p>
_:x owl:members (a1  an). 
</p>

<p>
a rdf:type C. 
</p>

<p>
a1 PN a2. 
</p>

<p>
a R v. 
</p>

<p>
_:x rdf:type owl:NegativePropertyAssertion.
</p>

<p>
_:x owl:sourceIndividual a1.
</p>

<p>
_:x owl:assertionProperty P.
</p>

<p>
_:x owl:targetIndividual a2. 
</p>

<p>
_:x rdf:type owl:NegativePropertyAssertion.
</p>

<p>
_:x owl:sourceIndividual a.
</p>

<p>
_:x owl:assertionProperty R.
</p>

<p>
_:x owl:targetValue v. 
</p>

<p>
C owl:hasKey (P1  Pm R1  Rn).
</p>

<p>
m+n&gt;0 
</p>

<p>
CN rdf:type owl:Class. 
</p>

<p>
DN rdf:type rdfs:Datatype. 
</p>

<p>
PN rdf:type owl:ObjectProperty. 
</p>

<p>
R rdf:type owl:DatatypeProperty. 
</p>

<p>
A rdf:type owl:AnnotationProperty. 
</p>

<p>
aN rdf:type owl:NamedIndividual. 
</p>

<p>
@prefix p U. 
</p>

<p>
rdf:type rdf:type rdf:Property .
</p>

<p>
rdf:type rdfs:domain rdfs:Resource .
</p>

<p>
rdf:type rdfs:range rdfs:Class .
</p>

<p>
rdfs:Datatype rdfs:subClassOf rdfs:Class .
</p>

<p>
rdfs:isDefinedBy rdfs:subPropertyOf rdfs:seeAlso .
</p>

<p>
I(rdf:type)  ICEXT(I(rdf:Property)) ,
</p>

<p>
IEXT(I(rdf:type))  ICEXT(I(rdfs:Resource))  ICEXT(I(rdfs:Class)) ,
</p>

<p>
ICEXT(I(rdfs:Datatype))  ICEXT(I(rdfs:Class)) ,
</p>

<p>
IEXT(I(rdfs:isDefinedBy))  IEXT(I(rdfs:seeAlso)) . 
</p>

<p>
I(owl:FunctionalProperty)  IC 
</p>

<p>
owl:FunctionalProperty rdf:type rdfs:Class .
</p>

<p>
ICEXT(I(owl:FunctionalProperty))  IP 
</p>

<p>
owl:FunctionalProperty rdfs:subClassOf rdf:Property .
</p>

<p>
E rdf:type rdfs:Datatype .
</p>

<p>
E rdfs:subClassOf rdfs:Literal .
</p>

<p>
I(owl:disjointWith)  IP 
</p>

<p>
owl:disjointWith rdf:type rdf:Property .
</p>

<p>
IEXT(I(owl:disjointWith))  IC  IC 
</p>

<p>
owl:disjointWith rdfs:domain owl:Class .
</p>

<p>
owl:disjointWith rdfs:range owl:Class .
</p>

<p>
E rdf:type owl:DatatypeProperty .
</p>

<p>
E rdfs:domain rdfs:Resource .
</p>

<p>
E rdfs:range rdfs:Literal .
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> prolog&#xa0;&#xa0;&#xa0;<span class="tag"><span class="prolog">prolog</span></span></h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Allegro Prolog&#xa0;&#xa0;&#xa0;<span class="tag"><span class="prolog">prolog</span>&#xa0;<span class="lisp">lisp</span>&#xa0;<span class="gruff">gruff</span></span></h3>
<div class="outline-text-3" id="text-4-1">
</div><ol class="org-ol"><li>Release 0.98b<br  /><div class="outline-text-5" id="text-4-1-0-1">
<p>
Release 0.98b of Allegro Prolog continues a sequence of minor bugfix releases
from 0.98, but 0.98 and its accompanying documentation have significant
changes and enhancements from earlier releases.
</p>

<p>
The prolog module can be loaded with 
</p>
<div class="lisp">
<p>
(require :prolog) .
(use-package :prolog)
prolog:==
 options
(shadowing-import '(prolog:==))(use-package :prolog)
</p>

</div>


<p>
Symbols are exported from the prolog package. If you intend to use
Prolog interactively you will probably find it convenient to execute
(use-package :prolog) also.
</p>

<p>
It happens that both the prolog and cg packages export a symbol named ==
which will signal a package conflict if there is an attempt to use both
packages. This will happen, for instance, if you try to use the prolog
package in the cg-user package without first shadowing one or the other
symbol. Usually you want <code>= to refer to prolog:=</code>. You will get that if you
load the prolog module and evaluate (shadowing-import '(prolog:==)) and then
(use-package :prolog).
</p>
</div>
</li>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> User Documentation</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
This document is not intended as an introduction to programming in Prolog. It
assumes some programming knowledge of both Prolog and Common Lisp.
</p>

<p>
Allegro Prolog is an implementation of Prolog in Common Lisp. It is based on
the implementation developed by Peter Norvig in Paradigms of Artificial
Intelligence Programming. The code has been further optimized and useful
extensions provided, making an industrial-strength Prolog programming
environment with a flexible calling interface in both directions between
Common Lisp and Prolog.
</p>

<p>
Prolog functors are translated to compiled Common Lisp functions. A single
Lisp function combines all rules for each distinct functor/arity. Special
treatment is given for facts, that is, rules with no variables in the head
and no clauses in the body. The Lisp function automatically captures these as
data instead of code. This allows reasonably large collections of data to be
specified as regular Prolog rules. Larger, highly-scalable data sets can be
implemented by extensions outlined below.
</p>

<p>
Allegro Prolog does not intend to be an ISO-compliant Prolog, nor does it
implement the entire Prolog language. Its purpose is to provide Prolog logic
programming as an integrated extension to Common Lisp for use in Lisp
programs, not as a separate language. Many standard Prolog arithmetic,
predicate operators, and I/O operators are not implemented, as they are a
subset of the standard Common Lisp operators available using lisp/2. There is
also no support for operator syntax (e.g. infix notation), as input notation
is subsumed by sexpr syntax. These choices may be reconsidered in the future
if there is reason to if there is motivation to make Allegro Prolog a
self-standing Prolog implementation. What is provided is the basic Prolog
engine for logic programming.
</p>

<p>
Prolog source files may be loaded either compiled or interpreted, as Prolog
functors are automatically compiled upon first use. But since Allegro Prolog
programs will typically contain both Lisp and Prolog code intermixed, it is
generally a good idea to compile the files so that the Lisp code is compiled.
</p>

<p>
All public symbols are exported from the prolog package. The definitions
mostly follow Norvig. Lisp S-expression syntax is used rather than Edinburgh
syntax, although support for Edinburgh input may be provided in the future.
Prolog variables are Lisp symbols that have names that begin with the `?'
character. The anonymous variable is the symbol `?' (that is, `prolog:?').
Some symbols exported from the prolog package are eq to symbols exported from
the common-lisp package, but there is never any ambiguity between use of a
Prolog name and a Lisp name. There is no implementation of the Prolog module
system. Programmers should be aware that there is a danger of collision with
inherited symbols. For example, the symbol cl:list is not defined by Prolog
but would typically be inherited from the common-lisp package by an
application package. An attempt to make a Lisp function definition on cl:list
would be prevented by package locking, but definition as a Prolog functor is
not protected. If multiple application packages attempt to make such
definitions, they would collide on the inherited symbol.
</p>

<p>
Allegro Prolog has no known dependencies on 8-bit vs. 16-bit character images
or on ANSI vs. Modern mode images.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Built-in Prolog Functors</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The following Prolog functors are predefined in Allegro Prolog and generally
implement the standard Prolog functionality. The set of defined functors may
be extended in the future. A few functors in this implementation accept
varying arity and are indicated with a *, as in or/*.
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> allegro-prolog functors</h3>
<div class="outline-text-3" id="text-4-3">
<p>
=/2   ==/2   abolish/2   and/*   append/3   arg/3   assert/1   asserta/1
assertz/1   atom/1   atomic/1   bagof/3   call/1   consult/1   
copy-term/2   erase/1   fail/0   first/1   functor/3   ground/1   if/2   
if/3   is/2   last/1   leash/1   length/1   listing/1   member/2   
memberp/2 (member without backtracking)   not/1   number/1   or/*   princ
/1   read/1   recorda/1   recordz/1   recorded/2   repeat/0   rest/1   
retract/1   rev/2   setof/3   true/0   var/1   write/1  
</p>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> ! is the Prolog cut.</h3>
<div class="outline-text-3" id="text-4-4">
<p>
It may written as an atom ! as well as the 1-element list (!). The
Prolog atom predicate is equivalent to Lisp's symbolp. The Prolog
atomic predicate is equivalent to Lisp's atom, true for any object
that is not a cons.
</p>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> The Prolog Top Level</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Allegro Prolog does not provide a top level listener loop other than the
regular lisp listener. Prolog computation may be invoked programmatically
from Lisp using the prolog macro described below, or interactively by
executing the ?- macro. Here is a simple example interactive session using ?-
.
</p>

<p>
cl-user(2): (require :prolog)
nil
cl-user(3): (use-package :prolog)
t
cl-user(4): (?- (append ?x ?y (1 2 3)))
?x = ()
?y = (1 2 3) &lt;ENTER&gt;
?x = (1)
?y = (2 3) &lt;ENTER&gt;
?x = (1 2)
?y = (3) &lt;ENTER&gt;
?x = (1 2 3)
?y = () &lt;ENTER&gt;
No.
cl-user(5): 
</p>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> the ?- macro</h3>
<div class="outline-text-3" id="text-4-6">
<p>
The ?- macro operates similarly to the top-level loop in interactive Prologs.
A ?- expression takes zero or more subforms which are clauses and tries to
solve them. When a solution is found, it prints the values of all variables
in the expression then reads a character from <b>standard-input</b>. (If there are
no variables it prints "Yes."). If the character is either newline (usually 
enter on a keyboard) or semicolon, Prolog backtracks and attempts to find
another solution. If the character is a period, Prolog prints "No." and
returns.
</p>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> Defined Lisp Operators</h3>
<div class="outline-text-3" id="text-4-7">
<p>
Lisp Operator                                                                                                                                                                                                                                                                                                                                Description                                                                                                                                                                                                                                                                                                                      
</p>

<p>
&lt;- clause*                      Assert a fact or rule. A macro.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</p>

<p>
                                As above, but first retracts all rules for the functor with the same arity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                This is similar to the action taken for &lt;- the first time a functor/arity is                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
                                seen within a consult, but &lt;&#x2013; is especially useful interactively. By                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                retracting previous clauses it allows predicates to be changed and files to                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
&lt;&#x2013; clause*                     be loaded more than once. A useful convention (in a file that might be loaded                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                rather than consulted) is to use &lt;&#x2013; in the first rule for a particular                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                function/arity. An example of typical usage would be:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
</p>

<p>
(&lt;&#x2013; (member ?item (?item . ?)))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
(&lt;-  (member ?item (? . ?rest)) (member ?item ?rest))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</p>

<p>
?- clause*                      Interactively try to prove the concatenation of clauses, printing unified                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                variables and then backtracking after each success. A macro.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
</p>

<p>
                                This function calls cl:load on its filename or pathname argument, with the                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                additional functionality that the first time &lt;- is executed for a given                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
consult &amp;rest filename*         predicate/arity, that predicate/arity is cleared before the new definition is                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                established. consult/1 is also available as a prolog functor, accepting a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                single filename or a list of filenames.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</p>

<p>
A macro analogous to Lisp trace which causes printing at each of the four                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
ports to the functor: call, exit, redo, and fail. This predicate is often                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
called trace in other Prologs, but that name clashes with the standard                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
cl:trace macro.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</p>

<p>
Leash output is printed to <b>trace-output</b>.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
</p>

<p>
If leash is called with no arguments it returns a list of the                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
currently-leashed functor/aritys currently being leashed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
</p>

<p>
When a functor/arity is leashed (or unleashed) it is automatically recompiled                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
without (or with) tail-call optimization to make leash output conform to                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
Prolog WAM model even for tail-recursive functors. The programmer does not                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
normally need to be concerned with this.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
</p>

<p>
Some built in functors such as if, not, or, and and are normally rewritten by                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
inline macro transformers so will usually not appear in leash output if                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
leashed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
</p>

<p>
                                Here is an example of leash. rev-member is like member but returns results                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                starting from the tail of the list:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
leash {functor arity}*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                cl-user(2): (require :prolog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                cl-user(3): (use-package :prolog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                cl-user(4): (&lt;&#x2013; (rev-member ?item (? . ?rest)) (rev-member ?item ?rest)) rev-member cl-user(5): (&lt;- (rev-member ?item (?item . ?))) rev-member cl-user(6): (leash rev-member 2) t cl-user(7): (?- (rev-member ?animal (dog cat fish))) <sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> Entering rev-member/2 {Unbound 1000fe7cb1} (dog cat fish) <sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup> Entering rev-member/2 {Unbound 1000fe7cb1} (cat fish) <sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup> Entering rev-member/2 {Unbound 1000fe7cb1} (fish) <sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup> Entering rev-member/2 {Unbound 1000fe7cb1} () <sup><a id="fnr.4.100" name="fnr.4.100" class="footref" href="#fn.4">4</a></sup> Failed rev-member/2 <sup><a id="fnr.3.100" name="fnr.3.100" class="footref" href="#fn.3">3</a></sup> Succeeded rev-member/2 fish (fish) <sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup> Succeeded rev-member/2 fish (cat fish) <sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> Succeeded rev-member/2 fish (dog cat fish) ?animal="fish" &lt;ENTER&gt;
                                <sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                 <sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup> Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                  <sup><a id="fnr.3.100" name="fnr.3.100" class="footref" href="#fn.3">3</a></sup> Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
                                  <sup><a id="fnr.3.100" name="fnr.3.100" class="footref" href="#fn.3">3</a></sup> Failed rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                 <sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup> Succeeded rev-member/2 cat (cat fish)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                <sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> Succeeded rev-member/2 cat (dog cat fish)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                ?animal = cat &lt;ENTER&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                <sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                 <sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup> Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                 <sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup> Failed rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                <sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> Succeeded rev-member/2 dog (dog cat fish)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                ?animal = dog &lt;ENTER&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                <sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                <sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> Failed rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                No.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                cl-user(8):                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
</p>

<p>
leash-1 functor arity           Functional version of the above.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
</p>

<p>
unleash {functor arity}*        Analogous to Lisp untrace. If called with no arguments, every                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                currently-leashed functor/arity is unleashed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
</p>

<p>
unleash-1 functor arity         Functional version of the above                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</p>

<p>
If variable this is an integer, the debugger will be entered if leash output                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
<b>leash-limit</b>                   exceeds the specified depth. This is intended as a convenience when debugging                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
deep recursion. Initially nil.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
</p>

<p>
Leash output indents one space for each level of leashed functor. If leashing                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
<b>prolog-leash-indent-wrap</b>      is deeply recursive this indentation may make the leash output unreadable, so                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
the indentation is taken modulo the value of this variable. It must be a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
nonnegative integer, but may be set large. Initially 20.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
</p>

<p>
                                This may be called after new rules are asserted before making Prolog queries.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
prolog-compile-symbols functor* Called with no arguments, it compiles all functors needing (re)compilation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                Otherwise, a functor/arity will be compiled automatically the first time it                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                is called.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
</p>

<p>
Whether a rule is established by &lt;- or assert/2, a Lisp form inside a prolog
rule executed by the lisp/2 and similar functors may not refer to the Lisp
lexical environment outside the rule definition. This restriction is
necessary because the code for the Prolog functor is not compiled until
later, after all functor/arity clauses have been combined to form its
function body.
</p>
</div>
</div>

<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> The Programming Interface between Prolog and Common Lisp</h3>
<div class="outline-text-3" id="text-4-8">
<p>
In addition to the interactive query and assertion macros (e.g. ?-&gt; and &lt;-)
there are several operators to call in either direction between Prolog code
and Lisp code.
</p>
</div>

<div id="outline-container-sec-4-8-1" class="outline-4">
<h4 id="sec-4-8-1"><span class="section-number-4">4.8.1</span> Prolog Functor                                Description</h4>
<div class="outline-text-4" id="text-4-8-1">
<p>
                Execute a Lisp form from Prolog. The Lisp form is compiled (at the same
                time the Prolog predicate is compiled) and may refer to variables in   
                the surrounding dynamic Lisp environment. Lexical references cannot go 
                beyond the rule boundary. Prolog variables may be referenced, but only 
lisp arg form   in evaluated positions (i.e. not inside constants). Prolog variables   
                are dereferenced as necessary into non-dynamic-extent copies. The      
                clause fails and no Lisp code is executed if any Prolog variables in   
                the form are unbound. The result of executing the Lisp form second     
                argument is unified with the first argument.                           
</p>

<p>
lisp form       As above, but the Lisp form is executed for side effect only. Any value
                returned by the form is ignored.                                       
</p>

<p>
                As above, but unbound Prolog variables do not cause the clause to fail.
                If the Prolog variables referenced within the Lisp form are guaranteed 
                to be bound, this functor is more efficient than the                   
lisp* arg form  otherwise-equivalent lisp functor because it does not need to set up   
lisp* form      code to handle the unbound-variable failure case. It is often the case 
                in numeric calculation that the variables are certain to be bound. In  
                such situations it is faster to execute (lisp* ?x (1+ ?x)) than (lisp ?
                x (1+ ?x)).                                                            
</p>

<p>
                A convenience functor similar to lisp but runs as a predicate and fails
                if execution of the form returns nil. The familiar Prolog numeric      
lispp form      predicates can be obtained this way:                                   
</p>

<p>
(lispp (&gt;= ?x 5))                                                    
</p>

<p>
                As above, except that unbound Prolog variables do not cause the rule to
lispp* form     fail. lispp* is more efficient than lispp if all referenced Prolog     
                variables are bound.                                                   
</p>

<p>
lisp! arg form                                                                         
lisp! form      Similar to the above functors, with the provision that any             
lisp*! arg form dynamic-extent data bound to Prolog variables in the form are consed in
lisp*! form     the heap before being passed to Lisp. See the section below on Prolog  
lispp! form     and Dynamic Extent.                                                    
lispp*! form                                                                           
</p>

<p>
                This is an exact equivalent for the 2-argument lisp functor above. is  
                is the traditional name for this functor. The lisp and is in this      
                implementation are slightly more powerful than the Prolog is since they
                are capable of unifying (even destructuring) an arbitrary returned     
                value returned by the Lisp form, while the Prolog functor is intended  
is arg form     only for numerical calculations.                                       
</p>

<p>
cl-user: (?- (is (?div ?rem) (multiple-value-list (truncate 11 3)))) 
?div = 3                                                             
?rem = 2                                                             
No.                                                                  
</p>
</div>
</div>

<div id="outline-container-sec-4-8-2" class="outline-4">
<h4 id="sec-4-8-2"><span class="section-number-4">4.8.2</span> Lisp Operator                           Description</h4>
<div class="outline-text-4" id="text-4-8-2">
<p>
               Lisp code running inside a call to one of the the Prolog lisp 
fail           functors can call this Lisp function to cause the clause to   
               fail immediately.                                             
</p>

<p>
A Lisp macro that invokes Prolog programmatically to solve the
conjunction of the clauses. The surrounding Lisp environment  
(lexical as well as dynamic) can be accessed using the lisp   
functor. This example refers to the likes data in an example  
in a later section of this document:                          
</p>

<p>
                 (defun human-friends-of (person)                            
                   (let ((friends nil))                                      
                     (prolog (lisp ?person person)                           
                             (likes ?person ?x)                              
                             (human ?x)                                      
                             (lisp (pushnew ?x friends)))                    
prolog clause*       friends))                                               
</p>

<p>
The expansion of the prolog macro wraps a block named prolog  
around the body so Lisp forms inside the body can easily      
return a value:                                               
</p>

<p>
(defun human-friend-of (person)                             
  (prolog (lisp ?person person)                             
          (likes ?person ?x)                                
          (human ?x)                                        
          (lisp (return-from prolog ?x))))                  
</p>

<p>
Unless there is some nonlocal exit, execution of the prolog   
macro silently finds all solutions to the clauses.            
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9"><span class="section-number-3">4.9</span> Prolog and Dynamic Extent</h3>
<div class="outline-text-3" id="text-4-9">
<p>
Computation in Prolog works by attempting to satisfy a clause and, if
successful, calling a continuation function. If that continuation fails
control may return to any previous choice point, undoing any intervening
unifications, and trying a different solution choice. Prolog unification data
and continuation functions always have dynamic extent. The implementation
exploits this by allocating Prolog variables themselves, cons structure
created by unification, and continuation closure functions on the stack, that
is, with dynamic extent. This allows Prolog code to operate with essentially
zero consing and with a resulting improvement in speed.
</p>

<p>
There are, however, certain functors that typically cons data with indefinite
extent. Solutions collected by the bagof/3 and setof/3 functors are
automatically heap consed, as are any rules stored by the assert, asserta,
assertz, recorda, and recordz functors.
</p>

<p>
The family of lisp functors are special cases. When a call to the lisp
functor is performed, the values of any Prolog variables referenced in the
Lisp form are communicated efficiently to the Lisp code using symbol macros.
But those variables may contain nested unification with other Prolog
variables, and the structure created by unification may have been consed with
dynamic extent. This is not normally a concern since the Lisp code is of
course running within the dynamic extent of the surrounding Prolog code, but
it would become an issue if the Lisp code stored the data somewhere with
indefinite extent.
</p>

<p>
Dynamic extent is only a concern for cons structures. Numeric data is
generally not stack consed.
</p>

<p>
Some examples will make this clear. Consider the following code:
</p>
<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">ancestors-of</span> (person)
  (<span style="color: #00ffff;">let</span> ((ancestors nil))
    (prolog (lisp ?person person)
            (ancestor ?x person)
            (lisp (push ?x ancestors)))
    ancestors))
</pre>
</div>
<p>
If the data returned by the ancestor predicate are atoms (e.g. symbols) there
is no problem since they cannot be stack consed. Similarly, there is no
problem with numbers and numeric calculation since the implementation
generally does not stack cons numbers. But suppose Prolog data passed to Lisp
code was created by unification:
</p>
<div class="org-src-container">

<pre class="src src-lisp">(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">grandfather-pairs</span> ()
  (<span style="color: #00ffff;">let</span> ((pairs nil))
    (prolog (grandfather ?gramp ?child)
            (lisp (push (?gramp ?child) pairs)))
    pairs))
</pre>
</div>
<p>
&#x2026; are atoms, but it would not work if the objects being passed back were conses
created by Prolog unification. But structure created by Prolog unification
has only dynamic extent &#x2013; that is, it may be consed on the stack.
Stack-consed data must be copied to the heap if it is passed outward to Lisp
or otherwise preserved outside the dynamic contour where it is created. As an
example see the function zebra-benchmark in the zebra example file.
</p>

<p>
A top-level list created by bagof and setof are automatically given
indefinite extent, as is any substructure created by unification and
collected on these lists. Therefore the programmer should not have to worry
about dynamic extent when using these predicates.
</p>
</div>
</div>

<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10"><span class="section-number-3">4.10</span> Tail Call Elimination</h3>
<div class="outline-text-3" id="text-4-10">
<p>
The ISO standard for Prolog apparently does not require tail-call
elimination. However, most implementations provide it to some degree. It is
certainly a valuable feature. Allegro Prolog functors usually do not perform
tail-call elimination. The Prolog compiler tries to stack cons Prolog
variables, data structure, and continuations. Stack allocation of these data
enhances performance, but stack-consed data generally prohibits tail-call
elimination.
</p>

<p>
Since tail-call elimination can be important for particular functors in
certain styles of coding, a crude control over stack consing has been
implemented at the level of an individual functor/arity. This facility is
experimental and is likely to change in future releases.
</p>

<p>
The first clause of any rule may be a cl:declare which makes declarations
about the functor. Declarations may appear in any rule for a given functor/
arity &#x2013; declarations in later rules (according to the ordering maintained by
assert and friends) override earlier declarations.
</p>

<p>
The only declarations currently supported are :tail-calls and :no-tail-calls.
The latter is the default.
</p>

<p>
(&lt;&#x2013; (my-member ?item (?item . ?)) (declare :tail-calls)) (&lt;- (my-member ?item (? . ?rest)) (my-member ?item ?rest))
</p>

<p>
The (declare :tail-calls) could have been included in either or both of the
two rules.
</p>

<p>
The built in member/2 and length/2 functors are written in a way that
consumes neither Prolog nor Lisp stack, but if they had not, the version of
my-member shown above implements heap-consing by the functor and allows tail
recursion on the Lisp stack. The functor still requires Prolog stack for the
unifications performed on the ?rest Prolog variable, but this is small (one
word per unified variable) compared to the consumption of Lisp stack that
recursion would require.
</p>

<p>
Tail call elimination is subject to the normal constraints imposed by the
Lisp compiler. These are platform dependent.The presence in a functor/arity
of calls to the lisp, lispp or lisp! functors will sometimes prevent tail
call elimination. Where possible, use lisp*, lispp* and lisp*! instead.
</p>
</div>
</div>

<div id="outline-container-sec-4-11" class="outline-3">
<h3 id="sec-4-11"><span class="section-number-3">4.11</span> The Prolog Stack</h3>
<div class="outline-text-3" id="text-4-11">
</div><div id="outline-container-sec-4-11-1" class="outline-4">
<h4 id="sec-4-11-1"><span class="section-number-4">4.11.1</span> Lisp Name                             Description</h4>
<div class="outline-text-4" id="text-4-11-1">
<p>
                             Prolog maintains a stack of unifications as it  
                             tries to satisfy clauses recursively. This stack
                             is separate from the regular Lisp execution     
                             stack. The initial stack length is determined by
                             the implementation, but the stack will double in
                             length when the current length is exceeded. This
                             Lisp condition is signalled with cerror when    
                             automatic doubling will exceed the limit        
prolog-stack-overflow        contained in the variable <b>prolog-stack-limit</b>. 
                             Continuing (e.g. with the standard Lisp continue
                             function) will continue Prolog computation with 
                             the stack length doubled.                       
</p>

<p>
The only superclass of this condition is        
cl:condition itself. In particular, it is not a 
subclass of error so extraneous error handlers  
don't try to handle it.                         
</p>

<p>
prolog-stack-overflow-length This reader on the above condition returns the  
                             current stack length.                           
</p>

<p>
A special variable containing a positive integer
<b>prolog-stack-limit</b>         that specifies the size above which a           
prolog-stack-overflow-length will be signalled. 
The initial value is 4096.                      
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-12" class="outline-3">
<h3 id="sec-4-12"><span class="section-number-3">4.12</span> I/O Functors</h3>
<div class="outline-text-3" id="text-4-12">
<p>
The set of built-in Prolog I/O functors is intentionally limited because most
input and output would naturally be done by Lisp code. A few functors are
provided for convenience.
</p>
</div>

<div id="outline-container-sec-4-12-1" class="outline-4">
<h4 id="sec-4-12-1"><span class="section-number-4">4.12.1</span> Lisp Name                             Description</h4>
<div class="outline-text-4" id="text-4-12-1">
<p>
                                        The value argument is unified with a 
                                        single datum read from               
                                        <b>standard-input</b>. This is just a     
                                        simple wrapper for the Lisp read     
                                        function. The input syntax is Lisp   
                                        syntax, not Edinburgh.               
read value [stream [stream [stream] ] ]                                      
                                        The functors read/2, read/3, and read
                                        /4 are also defined, providing the   
                                        stream, eof-error, and eof-value     
                                        optional arguments to read. If       
                                        supplied, the values of these        
                                        arguments must be grounded.          
</p>

<p>
                                        The value argument is written to     
                                        <b>standard-output</b>. This is just a    
                                        simple wrapper for the Lisp write    
                                        function. The output syntax is Lisp  
write value [stream]                    syntax, not Edinburgh.               
</p>

<p>
The functor write/2 is also defined, 
providing the stream, write. If      
supplied, the value must be grounded.
</p>

<p>
princ value [stream]                    Like write but uses the Lisp princ   
                                        function.                            
</p>

<p>
nl [stream]                             A wrapper for the Lisp terpri        
                                        function.                            
</p>
</div>
</div>

<div id="outline-container-sec-4-12-2" class="outline-4">
<h4 id="sec-4-12-2"><span class="section-number-4">4.12.2</span> Unification with standard-objects.</h4>
<div class="outline-text-4" id="text-4-12-2">
</div><ol class="org-ol"><li>Prolog Functor                                    Description<br  /><div class="outline-text-5" id="text-4-12-2-1">
<p>
                                      This Prolog functor unifies the value of a slot of a     
                                      standard instance. The instance and slot-name arguments  
                                      must be bound, otherwise the predicate silently fails.   
                                      The slot-value argument is unified against the content of
                                      the slot. A Lisp error is signalled if the slot does not 
                                      exist or is not bound. The implementation is:            
slot= inst slot-name slot-value                                                                
                                        (&lt;&#x2013; (slot= ?instance ?slot-name ?slot-value)          
                                             (lisp ?slot-value                                 
                                                   (slot-value ?instance ?slot-name)))         
</p>

<p>
When it is only necessary to read a slot, this functor is
faster than the two that follow.                         
</p>

<p>
slot=* inst slot-name slot-value      Like lisp* except that this functor fails silently if the
                                      slot does not exist or is unbound.                       
</p>

<p>
As above, this Prolog functor unifies the value of a slot
in a standard instance. However, if the slot is unbound  
it is bound dynamically as if by letf to the value of    
slot-value, and the clause succeeds. (If slot-value is   
unbound or contains any unbound Prolog variables, the    
clause fails.) The slot is again made unbound when       
execution returns out of the continuation (by            
backtracking, or by Lisp nonlocal exit). While the slot  
is bound it is visible to other threads. Example:        
</p>

<p>
                                        cl-user(38): (defparameter <b>inst</b> (make-instance 'foo))
slot-value inst slot-name slot-value    <b>inst</b>                                                 
                                        cl-user(39): (?- (lisp ?i <b>inst</b>)                      
                                                         (slot-value ?i a ?sv))                
                                        No.                                                    
                                        cl-user(40): (?- (lisp ?i <b>inst</b>)                      
                                                         (slot-value ?i a 123)                 
                                                         (slot-value ?i a ?sv))                
                                        ?i = #&lt;foo&gt;                                            
                                        ?sv = 123                                              
                                        No.                                                    
                                        cl-user(41): (?- (lisp ?i <b>inst</b>)                      
                                                         (slot-value ?i a ?sv))                
                                        No.                                                    
</p>

<p>
As above, except that if the slot is set it is not made  
unbound when execution backtracks. The side effect of    
setting the slot persists. Example:                      
</p>

<p>
                                        cl-user(42): (defparameter <b>inst</b> (make-instance 'foo))
                                        <b>inst</b>                                                 
                                        cl-user(43): (?- (lisp ?i <b>inst</b>)                      
                                                         (slot-value! ?i a ?sv))               
                                        No.                                                    
slot-value! inst slot-name slot-value   cl-user(44): (?- (lisp ?i <b>inst</b>)                      
                                                         (slot-value! ?i a 123)                
                                                         (slot-value! ?i a ?sv))               
                                        ?i = #&lt;foo&gt;                                            
                                        ?sv = 123                                              
                                        No.                                                    
                                        cl-user(45): (?- (lisp ?i <b>inst</b>)                      
                                                         (slot-value! ?i a ?sv))               
                                        ?i = #&lt;foo&gt;                                            
                                        ?sv = 123                                              
                                        No.                                                    
</p>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-4-13" class="outline-3">
<h3 id="sec-4-13"><span class="section-number-3">4.13</span> The Prolog `Database' and Generators.</h3>
<div class="outline-text-3" id="text-4-13">
<p>
In its simplest model, Prolog needs only to remember rules. (A fact is simply
a rule with no trailing clauses and no variables in its head.) All rules for
a particular functor/arity are remembered in the order they were asserted and
the Prolog implementation somehow references these when that functor/arity is
invoked. Under this simple model, there is no firm distinction between that
portion of a system which the programmer considers program, that part which
he considers internal data and tables, and (sometimes) that part which he
would consider external data.
</p>

<p>
But the scaling requirements and operating characteristics of Prolog data
sets vary over enormous ranges. Many standard functors have only one or two
rules:
</p>

<p>
(&lt;&#x2013; (first ?x (?x . ?)))
</p>

<p>
(&lt;&#x2013; (member ?item (?item . ?)))
(&lt;-  (member ?item (? . ?rest)) (member ?item ?rest))
</p>

<p>
Functors like these are naturally represented as compiled code, or may even
be inlined. Rules which are conceptually implemented by compiled program code
are managed by the Prolog assert/abolish mechanism.
</p>

<p>
Now consider a different example (from Norvig) where a functor is defined
partly by algorithm (nontrivial rules) and partly by data (facts):
</p>

<p>
(&lt;&#x2013; (likes Kim Robin))
(&lt;-  (likes Sandy Lee))
(&lt;-  (likes Sandy Kim))
(&lt;-  (likes Robin cats))
(&lt;-  (likes Sandy ?x) (likes ?x cats))
(&lt;-  (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
(&lt;-  (likes ?x ?x))
</p>

<p>
The likes/2 predicate has seven rules, four of which are facts. Despite the
combination of programmatic rules and facts, this combined data is still
small enough to be represented directly by the code implementing the functor/
arity predicate. (This is true especially for Allegro Prolog since compiled
functors capture facts as constant data, rather that expanding them into
volumous Lisp code.) However, this representation would become unwieldy if
the number of individuals represented in the data were a few orders of
magnitude larger, and especially if more of the individuals had idiosyncratic
affinities. The factual data would better be represented in tabular form,
usually called recorded databases in Prolog. These are managed by functors
such as recorda. Prolog stores recorded facts in an equal-key hashtable.
</p>

<p>
Note that details of the following functors differ in some ways from those of
other Prolog implementations, and the API may change in the future. The
predicates assert/1, asserta/1, assertz/1 and abolish/2 pertain to the
compiled predicate database. The predicates recorda/2, recordz/2, retract/1,
and retractall/1 pertain to the hashtable database of facts. The hashtable
database is not automatically referenced by compiled functors; it is
consulted only by the recorded/2 predicate.
</p>
</div>
</div>

<div id="outline-container-sec-4-14" class="outline-3">
<h3 id="sec-4-14"><span class="section-number-3">4.14</span> AllegroCache Object Database</h3>
<div class="outline-text-3" id="text-4-14">
<p>
There is a separate interface to the AllegroCache object database described 
below.
</p>
</div>

<div id="outline-container-sec-4-14-1" class="outline-4">
<h4 id="sec-4-14-1"><span class="section-number-4">4.14.1</span> Prolog Functor                           Description</h4>
<div class="outline-text-4" id="text-4-14-1">
<p>
Asserts a single rule into the database. The new rule  
is placed after all existing rules for that functor/   
arity.                                                 
</p>

<p>
                      Note that assert/1 takes a single list of clauses,     
assertz rule          therefore one would write                              
</p>

<p>
&#x2026; (assert ((likes ?name Lisp))) &#x2026;                  
</p>

<p>
and not                                                
</p>

<p>
&#x2026; (assert (likes ?name Lisp)) &#x2026;                    
</p>

<p>
assert rule           Same as assertz.                                       
</p>

<p>
asserta rule          Like assertz except the new rule is placed before all  
                      existing rules..                                       
</p>

<p>
abolish functor arity All rules for the functor/arity are removed.           
</p>

<p>
A typical Prolog application will reason over sets of data. In small
programming examples, the data is simply included as `facts' that are part of
the program source itself. Reading facts from an external source and
asserting them into the program is not much different. While a clever Prolog
implementation can optimize collections of facts, this approach cannot scale
indefinitely. First, it requires the facts be captured as data belonging to
the function. Second, efficient reasoning over large data sets requires
knowledge about how the data will be accessed. Often this is really an
indexing problem, and the application programmer must guide the system by
describing (or implementing) how the data is indexed. It is no coincidence
that this concern is similar to database implementation.
</p>

<p>
A Prolog functor/arity is compiled automatically the first time it is called.
Any assert or retract to that functor/arity automatically invalidates the
compiled function such that it will be recompiled the next time it is called.
While the Allegro compiler is reasonably fast, performance may be poor if
dynamic fact/rule management is performed using assert and retract with high
bandwidth, interspersed with calls to the functor/arity. In such applications
it would be better to use the recorded interface or some other custom fact
maintenance code, perhaps using generator.
</p>
</div>
</div>

<div id="outline-container-sec-4-14-2" class="outline-4">
<h4 id="sec-4-14-2"><span class="section-number-4">4.14.2</span> Prolog Functor                           Description</h4>
<div class="outline-text-4" id="text-4-14-2">
<p>
                  Asserts a single new rule into the recorded database, keyed
                  on the key which is the head of the rule. Only the functor 
recordz rule      and arity are considered in matching the key. The new rule 
                  is placed after all existing rules for that key. See the   
                  example below under generator.                             
</p>

<p>
recorda rule      Same as recordz except that the new rule is placed before  
                  all current rules for key.                                 
</p>

<p>
                  Finds the list of rules matching key in the recorded       
recorded key rule database and unifies rule successively to each rule. Only  
                  the functor and arity are considered in matching the key.  
</p>

<p>
retract key       All rules for the key are removed from the recorded        
                  database. Succeeds only if something is deleted.           
</p>

<p>
A common idiom for solving the data set issue is to construct a Lisp closure
that iteratively generates the data items to be returned. The following
functors support this use.
</p>
</div>
</div>

<div id="outline-container-sec-4-14-3" class="outline-4">
<h4 id="sec-4-14-3"><span class="section-number-4">4.14.3</span> Prolog Functor                                           Description</h4>
<div class="outline-text-4" id="text-4-14-3">
<p>
The generator argument should be a Lisp closure that returns an item each    
time it is called. When there are no more items, it should return nil. This  
protocol cannot be used with generators that may return nil; see generator*  
below. The item argument is unified with the returned item.                  
</p>

<p>
Example:                                                                     
</p>

<p>
                                  ;; This asserts facts into the record database all the package             
                                  ;; inheritances in the running Lisp.                                       
                                  cl-user(40): (?- (lisp ?gen (let ((packages (list-all-packages)))          
                                                                (lambda () (pop packages))))                 
                                                   (generator ?package ?gen)                                 
                                                   (lisp ?used-list (package-use-list ?package))             
generator item generator                           (member ?used ?used-list)                                 
                                                   (recordz (use ?package ?used))                            
                                                   (fail))                                                   
                                  No.                                                                        
                                  ;; This queries which packages are used by the current package.            
                                  cl-user(41): (?- (lisp ?package <b>package</b>)                                 
                                                   (recorded (use ?package ?) (? ? ?used)))                  
                                  ?package = #&lt;The common-lisp-user package&gt;                                 
                                  ?t = #&lt;The prolog package&gt;                                                 
                                  ?package = #&lt;The common-lisp-user package&gt;                                 
                                  ?t = #&lt;The common-lisp package&gt;                                            
                                  ?package = #&lt;The common-lisp-user package&gt;                                 
                                  ?t = #&lt;The excl package&gt;                                                   
                                  No.                                                                        
</p>

<p>
                                Similar to generator but suitable when generated items may include nil. The  
generator* item generator       generator should return two values: the item, and a boolean indicating that  
                                an item was returned. When there are no more items the second value should be
                                nil.                                                                         
</p>

<p>
This is a convenience shortcut for typical use of the generator functor. The 
second argument is a lisp form that returns the generator closure. The values
it generates are unified against the first argument. The example above could 
be written more conveniently this way:                                       
</p>

<p>
generating item lisp-generator    cl-user(40): (?- (generating ?package (let ((packages (list-all-packages)))
                                                                          (lambda () (pop packages))))       
                                                   (lisp ?used-list (package-use-list ?package))             
                                                   (member ?used ?used-list)                                 
                                                   (recordz (use ?package ?used))                            
                                                   (fail))                                                   
                                  No.                                                                        
</p>

<p>
generating* item lisp-generator As above for generator*.                                                     
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-15" class="outline-3">
<h3 id="sec-4-15"><span class="section-number-3">4.15</span> prolog lattice</h3>
<div class="outline-text-3" id="text-4-15">
<p>
A Prolog program that walks a lattice of linked objects is naturally
implemented using the lisp operator to follow links using standard Lisp
accessors.
</p>

<p>
(&lt;&#x2013; (class-subclass-gen ?gen ?class)
     (lisp ?gen
           (let ((class-stack (list
                               (if (symbolp ?class)
                                   (find-class ?class)
                                 ?class))))
             (lambda ()
               (let ((class (pop class-stack)))
                 (when class
                   (loop for subclass in (clos:class-direct-subclasses class)
                          do (push subclass class-stack))
                   class))))))
</p>

<p>
(&lt;&#x2013; (has-initarg-p ?class ?slot-name ?initarg)
     (lisp t (typep ?class 'standard-class))
     (lisp ?dslotds (clos:class-direct-slots ?class))
     (member ?dslotd ?dslotds)
     (lisp ?initargs (clos:slot-definition-initargs ?dslotd))
     (member ?initarg ?initargs)
     (lisp ?slot-name (clos:slot-definition-name ?dslotd)))
</p>

<p>
(&lt;&#x2013; (class-initarg ?root-class ?class ?slot-name ?initarg)
     (class-subclass-gen ?gen ?root-class)
     (generator ?class ?gen)
     (has-initarg-p ?class ?slot-name ?initarg))
</p>

<p>
;; This query will unify to each standard-class and slot that has a
;; :documentation initialization argument.
;;   (?- (class-initarg t ?class ?slot :documentation))
</p>

<p>
But querying large collections of relational data may require the programmer
to inform the system how the data should be stored and indexed. Allegro
Prolog has under development some general mechanisms for indexing data sets,
or else an application programmer may implement his own custom mechanisms.
For example, the application programmer might back end the Prolog program
with a full relational or object database. These possibilities are under
active exploration as extensions.
</p>
</div>
</div>

<div id="outline-container-sec-4-16" class="outline-3">
<h3 id="sec-4-16"><span class="section-number-3">4.16</span> The Interface to AllegroCache</h3>
<div class="outline-text-3" id="text-4-16">
</div><div id="outline-container-sec-4-16-1" class="outline-4">
<h4 id="sec-4-16-1"><span class="section-number-4">4.16.1</span> SeeAlso AllegroGraph, Gruff</h4>
<div class="outline-text-4" id="text-4-16-1">
<p>
Prolog code can reason directly over data stored in an AllegroCache database.
The interface is contained in the pcache module which can be loaded with
(require :pcache). The module is currently distributed as part of the
AllegroCache distribution.
</p>

<p>
The interface consists of the single prolog:db functor. This functor has
variable arity.
</p>
</div>
</div>

<div id="outline-container-sec-4-16-2" class="outline-4">
<h4 id="sec-4-16-2"><span class="section-number-4">4.16.2</span> Prolog Functor                          Description</h4>
<div class="outline-text-4" id="text-4-16-2">
<p>
The db functor should only be   
executed in a dynamic (Lisp)    
environment in which the        
<b>allegrocache</b> variable is bound
to an open AllegroCache         
database. The class argument    
must be grounded and have the   
value of a persistent-metaclasss
class or the name of such a     
class. ?instance is a variable  
that will be unified with a     
succession of instances of that 
class. If there are no          
additional arguments, the clause
succeeds once for each instance 
of that class in the database.  
</p>

<p>
                                             If there are additional         
db class ?instance { slot-name slot-value }* arguments, they are pairs of    
                                             slot-names and slot-values. Each
                                             slot-name must be grounded and  
                                             be a symbol naming a slot. If   
                                             ungrounded, the functor silently
                                             fails. The value of that slot is
                                             unified against the slot-value  
                                             which may be grounded or not.   
</p>

<p>
If the first slot is indexed and
the first value is fully        
grounded, retrieval uses        
AllegroCache's indexing and is  
fast. Otherwise retrieval may   
need to iterate over all        
instances of the class.         
Improvements in this simple     
indexing strategy may be        
explored in future releases.    
</p>

<p>
This is an example of a Roman numeral database that can do arithmetic by
database lookup. The objects in the database store Roman numeral and English
representations. The example retrieves the integer and English representation
of numbers that are half the value of perfect squares that are multiples of
</p>
<ol class="org-ol">
<li></li>
</ol>

<p>
(defclass roman ()
  ((int     :accessor int     :index :any-unique :initarg :int)
   (roman   :accessor roman   :index :any-unique :initarg :roman)
   (english :accessor english :index :any-unique :initarg :english)
   (0mod100 :accessor 0mod100 :index :any        :initarg :0mod100)
   (square  :accessor square  :initarg :square))
  (:metaclass db.allegrocache:persistent-class))
</p>

<p>
(defun test-populate ()
  (with-file-database ("roman.db" :if-exists :supersede :if-does-not-exist :create)
    (loop for i from 1 to 500
        do (make-instance 'roman
</p>
<p>
:int i
</p>
<p>
:roman   (intern (format nil "~@r" i) (load-time-value (find-package :keyword)))
</p>
<p>
:english (mapcar (lambda (string)
                   (intern string
                           (load-time-value (find-package :keyword))))
                 (split-re "[ -]" (format nil "~r" i)))
</p>
<p>
:0mod100 (zerop (mod i 100))
</p>
<p>
:square (* i i)))))
</p>

<p>
(defmacro with-file-database ((name
                               &amp;key (if-exists nil if-exists-p)
                                    (if-does-not-exist nil if-does-not-exist-p)
                                    read-only)
                              &amp;body body)
  `(let ((db.allegrocache:*allegrocache* nil))
     (unwind-protect
         (multiple-value-prog1
             (progn
               (db.allegrocache:open-file-database
                ,name
                ,@(and if-exists-p
                       `(:if-exists ,if-exists))
                ,@(and if-does-not-exist-p
                       `(:if-does-not-exist ,if-does-not-exist)))
               ,@body)
           (unless ,read-only
             (db.allegrocache:commit)))
       (when db.allegrocache:*allegrocache*
         (db.allegrocache:close-database db.allegrocache:*allegrocache*)))))
</p>

<p>
cl-user(15): (test-populate)
nil
cl-user(16): (with-file-database ("roman.db")
               (?- (bagof (?half ?english)
                          (and
                           (db roman ?r 0mod100 t int ?int english ?english square ?square)
                           (lisp ?half (truncate ?int 2))
                           (db roman ?r2 int ?half english ?english-half))
                          ?bag)))
?r = 
?english = 
?square = 
?int = 
?r2 = 
?half = 
?english-half = 
?bag = ((100 (two hundred)) (150 (three hundred)) (200 (four hundred)) (250 (five hundred))
        (50 (one hundred)))
No.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-17" class="outline-3">
<h3 id="sec-4-17"><span class="section-number-3">4.17</span> Known Issues.</h3>
<div class="outline-text-3" id="text-4-17">
<p>
Allegro Prolog is a new product and rough edges can be expected while
experience is gained supporting large programs. More attention is needed on
smooth integration into the Allegro program development and debugging
environment. These are some other known issues:
</p>

<p>
The interface to and capabilities of leash deserve extension better to
support debugging. A mechanism such as the Allegro CL :inside trace option
would be especially useful, as would the ability to select individually which
of a functor's four WAM ports to leash. In some cases immediately recursive
invocation of a functor will not be intercepted by leash. (The issue is
essentially the same as tracing lisp self calls.)
</p>

<p>
It might be worthwhile to make public the Prolog compiler-macro interface if
it allows better optimization of user code. However, the API and conventions
for a compiler macro are complex and need review and some convenience macros
before the machinery can be exported.
</p>

<p>
A more powerful solution to the tail-jump elimination problem is pending.
</p>

<p>
Performance could be improved in some kinds of programs by a capability to
control indexing of rule terms. This is available as the index/1 in some
Prolog implementations.
</p>

<p>
Definition of Prolog functors should be integrated into the Allegro CL source
file recording machinery. This would provide warnings about multiple
definitions, particularly in definitions on inherited symbols.
</p>

<p>
An etags extension for &lt;- and &lt;&#x2013; would be helpful.
</p>

<p>
Franz Inc is interested in bugs and the experience of programmers using 
Allegro Prolog. Contact support@franz.com.
</p>
</div>
</div>

<div id="outline-container-sec-4-18" class="outline-3">
<h3 id="sec-4-18"><span class="section-number-3">4.18</span> Example: the zebra problem</h3>
<div class="outline-text-3" id="text-4-18">
<p>
Here is the Lisp code and the Prolog code for the zebra problem, a well known
example of a puzzle with a set of facts about the attributes of people who
live in adjacent houses. First here is the Lisp code:
</p>
<div class="org-src-container">

<pre class="src src-lisp"><span style="color: #ff7f24;">;;;</span><span style="color: #ff7f24;">========== zebra.cl</span>

<span style="color: #ff7f24;">;;;; </span><span style="color: #ff7f24;">-*- Mode: common-lisp; Syntax: Common-Lisp -*-</span>

(<span style="color: #00ffff;">in-package</span> <span style="color: #b0c4de;">:user</span>)
(<span style="color: #00ffff;">eval-when</span> (compile load eval)
  (use-package <span style="color: #b0c4de;">:prolog</span>))

(<span style="color: #00ffff;">eval-when</span> (compile) (setf excl:*load-xref-info* nil))

(&lt;-- (nextto ?x ?y ?list) (iright ?x ?y ?list))
(&lt;-  (nextto ?x ?y ?list) (iright ?y ?x ?list))
(&lt;-- (iright ?left ?right (?left ?right . ?rest)))
(&lt;-  (iright ?left ?right (?x . ?rest))
     (iright ?left ?right ?rest))

(&lt;-- (zebra ?h ?w ?z)
     <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Each house is of the form:</span>
     <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">(house nationality pet cigarette drink house-color)</span>
     (= ?h ((house norwegian ? ? ? ?)   <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">1,10</span>
            ?
            (house ? ? ? milk ?) ? ?))  <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">9</span>
     (member (house englishman ? ? ? red) ?h) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">2</span>
     (member (house spaniard dog ? ? ?) ?h) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">3</span>
     (member (house ? ? ? coffee green) ?h) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">4</span>
     (member (house ukrainian ? ? tea ?) ?h) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">5</span>
     (iright (house ? ? ? ? ivory)      <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">6</span>
             (house ? ? ? ? green) ?h)
     (member (house ? snails winston ? ?) ?h) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">7</span>
     (member (house ? ? kools ? yellow) ?h) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">8</span>
     (nextto (house ? ? chesterfield ? ?) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">11</span>
             (house ? fox ? ? ?) ?h)
     (nextto (house ? ? kools ? ?)      <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">12</span>
             (house ? horse ? ? ?) ?h)
     (member (house ? ? luckystrike oj ?) ?h) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">13</span>
     (member (house japanese ? parliaments ? ?) ?h) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">14</span>
     (nextto (house norwegian ? ? ? ?)  <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">15</span>
             (house ? ? ? ? blue) ?h)
     (member (house ?w ? ? water ?) ?h) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">Q1</span>
     (member (house ?z zebra ? ? ?) ?h) <span style="color: #ff7f24;">;</span><span style="color: #ff7f24;">Q2</span>
     )

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">This runs the query:</span>

(?- (zebra ?houses ?water-drinker ?zebra-owner))

<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">These are benchmarking and profiling functions.  </span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">It is believed that solving zebra a</span>
<span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">single time requires 12825 inferences.</span>

(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">zebra-benchmark</span> (<span style="color: #98fb98;">&amp;optional</span> (n 1000))
  (<span style="color: #00ffff;">declare</span> (optimize (speed 3) (safety 0)))
  (<span style="color: #00ffff;">let</span> (rt0 rt1)
    (time (<span style="color: #00ffff;">loop</span> initially (setf rt0 (get-internal-run-time))
              repeat n do (prolog (zebra ?houses ?water-drinker ?zebra-owner)
                                  !     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">Stop once answer is found.  </span>
                                        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">This appears to be</span>
                                        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">what other implementations do, </span>
                                        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">e.g. time/1 in</span>
                                        <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">SWI Prolog.</span>
                                  )
              finally (setf rt1 (get-internal-run-time))))
    (<span style="color: #00ffff;">let</span> (zebra-owner water-drinker houses)
      (prolog (zebra ?houses ?water-drinker ?zebra-owner)
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">Nearly any cons structure created by Prolog </span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">unification will be consed with</span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">dynamic extent.  It isn't safe to return such </span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">structure outside the contour</span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">that created it.  Prolog doesn't need to worry, </span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">since unification always</span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">has dynamic extent, but arbitrary Lisp </span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">code needs to be careful.  The first</span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">two values this function will return are </span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">symbols, but the third is a cons</span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">tree created by Prolog unification.  In order </span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">to return it, the tree needs</span>
              <span style="color: #ff7f24;">;; </span><span style="color: #ff7f24;">to be copied with indefinite extent.</span>
              (lisp (setf zebra-owner ?zebra-owner
                          water-drinker ?water-drinker
                          houses (copy-tree ?houses)))
              !)
      (values (/ (* n 12825) (/ (- rt1 rt0) 1000.0)) <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">real time </span>
                                                     <span style="color: #ff7f24;">; </span><span style="color: #ff7f24;">is milliseconds</span>
              zebra-owner water-drinker houses))))

<span style="color: #ff7f24;">;;;  </span><span style="color: #ff7f24;">zebra.cl end</span>
</pre>
</div>

<p>
Here is Prolog code:
</p>

<div class="org-src-container">

<pre class="src src-prolog">========== zebra.<span style="color: #87cefa;">pl</span>
</pre>
</div>
</div>

<div id="outline-container-sec-4-18-1" class="outline-4">
<h4 id="sec-4-18-1"><span class="section-number-4">4.18.1</span> /* -*- Mode: prolog -*-</h4>
<div class="outline-text-4" id="text-4-18-1">
<ul class="org-ul">
<li></li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-18-2" class="outline-4">
<h4 id="sec-4-18-2"><span class="section-number-4">4.18.2</span> This file for benchmarking against SWI Prolog.</h4>
<div class="outline-text-4" id="text-4-18-2">
<p>
*/
</p>

<div class="org-src-container">

<pre class="src src-prolog"></pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-18-3" class="outline-4">
<h4 id="sec-4-18-3"><span class="section-number-4">4.18.3</span> nextto(X, Y, List) :- iright(X, Y, List).</h4>
</div>
<div id="outline-container-sec-4-18-4" class="outline-4">
<h4 id="sec-4-18-4"><span class="section-number-4">4.18.4</span> nextto(X, Y, List) :- iright(Y, X, List).</h4>
</div>
<div id="outline-container-sec-4-18-5" class="outline-4">
<h4 id="sec-4-18-5"><span class="section-number-4">4.18.5</span> iright(Left, Right, [Left, Right | _]).</h4>
</div>
<div id="outline-container-sec-4-18-6" class="outline-4">
<h4 id="sec-4-18-6"><span class="section-number-4">4.18.6</span> iright(Left, Right, [_ | Rest]) :- iright(Left, Right, Rest).</h4>
</div>
<div id="outline-container-sec-4-18-7" class="outline-4">
<h4 id="sec-4-18-7"><span class="section-number-4">4.18.7</span> zebra(H, W, Z) :-</h4>
<div class="outline-text-4" id="text-4-18-7">
<p>
H = [house(norwegian, _, _, _, <span class="underline">), _, house(</span>, _, _, milk, _), _, _],
 member(house(englishman, _, _, _, red), H),
 member(house(spaniard, dog, _, _, _), H),
</p>
</div>
</div>

<div id="outline-container-sec-4-18-8" class="outline-4">
<h4 id="sec-4-18-8"><span class="section-number-4">4.18.8</span> member(house(_, _, _, coffee, green), H),</h4>
</div>
<div id="outline-container-sec-4-18-9" class="outline-4">
<h4 id="sec-4-18-9"><span class="section-number-4">4.18.9</span> member(house(ukrainian, _,  _, tea, _), H),</h4>
</div>
<div id="outline-container-sec-4-18-10" class="outline-4">
<h4 id="sec-4-18-10"><span class="section-number-4">4.18.10</span> iright(house(_, _, _, _, ivory), house(_, _, _, _, green), H),</h4>
</div>
<div id="outline-container-sec-4-18-11" class="outline-4">
<h4 id="sec-4-18-11"><span class="section-number-4">4.18.11</span> member(house(_, snails, winston, _, _), H),</h4>
</div>
<div id="outline-container-sec-4-18-12" class="outline-4">
<h4 id="sec-4-18-12"><span class="section-number-4">4.18.12</span> member(house(_, _, kools, _, yellow), H),</h4>
</div>
<div id="outline-container-sec-4-18-13" class="outline-4">
<h4 id="sec-4-18-13"><span class="section-number-4">4.18.13</span> nextto(house(_, _, chesterfield, _, <span class="underline">), house(</span>, fox, _, _, _), H),</h4>
</div>
<div id="outline-container-sec-4-18-14" class="outline-4">
<h4 id="sec-4-18-14"><span class="section-number-4">4.18.14</span> nextto(house(_, _, kools, _, <span class="underline">), house(</span>, horse, _, _, _), H),</h4>
</div>
<div id="outline-container-sec-4-18-15" class="outline-4">
<h4 id="sec-4-18-15"><span class="section-number-4">4.18.15</span> member(house(_, _, luckystrike, oj, _), H),</h4>
</div>
<div id="outline-container-sec-4-18-16" class="outline-4">
<h4 id="sec-4-18-16"><span class="section-number-4">4.18.16</span> member(house(japanese, _, parliaments, _, _), H),</h4>
</div>
<div id="outline-container-sec-4-18-17" class="outline-4">
<h4 id="sec-4-18-17"><span class="section-number-4">4.18.17</span> nextto(house(norwegian, _, _, _, <span class="underline">), house(</span>, _, _, _, blue), H),</h4>
</div>
<div id="outline-container-sec-4-18-18" class="outline-4">
<h4 id="sec-4-18-18"><span class="section-number-4">4.18.18</span> member(house(W, _, _, water, _), H),</h4>
</div>
<div id="outline-container-sec-4-18-19" class="outline-4">
<h4 id="sec-4-18-19"><span class="section-number-4">4.18.19</span> member(house(Z, zebra, _, _, _), H).</h4>
</div>
<div id="outline-container-sec-4-18-20" class="outline-4">
<h4 id="sec-4-18-20"><span class="section-number-4">4.18.20</span> /* This runs the query a single time:</h4>
<div class="outline-text-4" id="text-4-18-20">
<ul class="org-ul">
<li></li>
<li>?- zebra(Houses, WaterDrinker, ZebraOwner).
</li>
</ul>
<p>
*/
</p>
</div>
</div>

<div id="outline-container-sec-4-18-21" class="outline-4">
<h4 id="sec-4-18-21"><span class="section-number-4">4.18.21</span> zebra1(Houses, WaterDrinker, ZebraOwner) :-</h4>
<div class="outline-text-4" id="text-4-18-21">
<p>
zebra(Houses, WaterDrinker, ZebraOwner), !.
</p>
</div>
</div>

<div id="outline-container-sec-4-18-22" class="outline-4">
<h4 id="sec-4-18-22"><span class="section-number-4">4.18.22</span> benchmark1 :-</h4>
<div class="outline-text-4" id="text-4-18-22">
<p>
flag(benchmark,_,0),
repeat,
zebra1(Houses, WaterDrinker, ZebraOwner),
flag(benchmark,N,N+1),
</p>
</div>
</div>

<div id="outline-container-sec-4-18-23" class="outline-4">
<h4 id="sec-4-18-23"><span class="section-number-4">4.18.23</span> N = 1000,</h4>
<div class="outline-text-4" id="text-4-18-23">
<p>
!.
</p>
</div>
</div>

<div id="outline-container-sec-4-18-24" class="outline-4">
<h4 id="sec-4-18-24"><span class="section-number-4">4.18.24</span> benchmark :- time(benchmark1).</h4>
</div>
<div id="outline-container-sec-4-18-25" class="outline-4">
<h4 id="sec-4-18-25"><span class="section-number-4">4.18.25</span> <code>========</code> end</h4>
<div class="outline-text-4" id="text-4-18-25">
<div class="org-src-container">

<pre class="src src-emacs-lisp">(shell-command <span style="color: #ffa07a;">"bnf2xml"</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4-19" class="outline-3">
<h3 id="sec-4-19"><span class="section-number-3">4.19</span> Prolog vs. Lisp</h3>
<div class="outline-text-3" id="text-4-19">
<p>
European AI researchers favored Prolog while Americans favored Lisp,
reportedly causing many nationalistic debates on the merits of the
languages
</p>
</div>
</div>
<div id="outline-container-sec-4-20" class="outline-3">
<h3 id="sec-4-20"><span class="section-number-3">4.20</span> Pure Prolog</h3>
<div class="outline-text-3" id="text-4-20">
<p>
Pure Prolog was soon extended, however, to include negation as
failure, in which negative conditions of the form not(Bi) are shown by
trying and failing to solve the corresponding positive conditions Bi.
</p>
</div>
</div>
<div id="outline-container-sec-4-21" class="outline-3">
<h3 id="sec-4-21"><span class="section-number-3">4.21</span> Buran Spacecraft</h3>
<div class="outline-text-3" id="text-4-21">
<p>
the software for the Buran spacecraft was written in the Prolog
programming language.
</p>
</div>
</div>
<div id="outline-container-sec-4-22" class="outline-3">
<h3 id="sec-4-22"><span class="section-number-3">4.22</span> SWI-Prolog and Ciao, support</h3>
<div class="outline-text-3" id="text-4-22">
<p>
server-side web programming with support for web protocols, HTML and
XML. There are also extensions to support semantic web formats
such as RDF and OWL. 
</p>
</div>

<div id="outline-container-sec-4-22-1" class="outline-4">
<h4 id="sec-4-22-1"><span class="section-number-4">4.22.1</span> Prolog has also been suggested as a client-side language.</h4>
<div class="outline-text-4" id="text-4-22-1">
<p>
^ Jan Wielemaker and Michiel Hildebrand and Jacco van Ossenbruggen (2007), "Using {Prolog} as the fundament for applications on the semantic web", in S.Heymans, A. Polleres, E. Ruckhaus, D. Pearse, and G. Gupta, Proceedings of the 2nd Workshop on Applications of Logic Programming and to the web, Semantic Web and Semantic Web Services, CEUR Workshop Proceedings (Porto, Portugal: CEUR-WS.org) 287: 8498
^ Processing OWL2 Ontologies using Thea: An Application of Logic
Programming. Vangelis Vassiliadis, Jan Wielemaker and Chris
Mungall. Proceedings of the 5th International Workshop on OWL:
Experiences and Directions (OWLED 2009), Chantilly, VA, United States,
October 2324, 2009
</p>

<p>
OW Prolog has been created in order to answer Prolog's lack of
graphics and interface.
</p>

<p>
JPL is a bi-directional Java Prolog bridge which ships with SWI-Prolog
by default, allowing Java and Prolog to call each other
(recursively). It is known to have good concurrency support and is
under active development.
</p>

<p>
GNU Prolog for Java is an implementation of ISO Prolog as a Java
library (gnu.prolog)
</p>

<p>
Jekejeke Prolog API provides tightly coupled concurrent call-in and
call-out facilities between Prolog and Java or Android, with the
marked possibility to create individual knowledge base objects. It can
be used to embed the ISO Prolog interpreter in standalones, applets,
servlets, APKs, etc..
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-23" class="outline-3">
<h3 id="sec-4-23"><span class="section-number-3">4.23</span> prolog and reflection</h3>
<div class="outline-text-3" id="text-4-23">
<p>
Prolog is a homoiconic language and provides many facilities for
reflection
</p>

<p>
solve(true, 1) :- !.
solve((A, B), C) :-
    !, solve(A, C1), solve(B, C2), minimum(C1, C2, C).
solve(A, 1) :-
    builtin(A), !, A.
solve(A, C) :-
    clause<sub>cf</sub>(A, B, C1), solve(B, C2), C is C1 * C2.
</p>

<p>
builtin(A is B).
builtin(read(X)).
% etc.
</p>

<p>
and clauses represented as clause<sub>cf</sub>(Head, Body, Certainty). Given
those, it can be called as solve(Goal, Certainty) to execute Goal and
obtain a measure of certainty about the result.
</p>
</div>
</div>
<div id="outline-container-sec-4-24" class="outline-3">
<h3 id="sec-4-24"><span class="section-number-3">4.24</span> Prolog's single data type is the term.</h3>
<div class="outline-text-3" id="text-4-24">
<p>
Terms are either atoms, numbers, variables or compound terms.
</p>

<p>
An atom is a general-purpose name with no inherent meaning. Examples
of atoms include x, blue, 'Taco', and 'some atom'.  Numbers can be
floats or integers.  Variables are denoted by a string consisting of
letters, numbers and underscore characters, and beginning with an
upper-case letter or underscore. Variables closely resemble
variables in logic in that they are placeholders for arbitrary
terms.  A compound term is composed of an atom called a "functor"
and a number of "arguments", which are again terms. Compound terms
are ordinarily written as a functor followed by a comma-separated
list of argument terms, which is contained in parentheses. The
number of arguments is called the term's arity. An atom can be
regarded as a compound term with arity zero. Examples of compound
terms are truck<sub>year</sub>('Mazda', 1986) and
'Person<sub>Friends'</sub>(zelda,[tom,jim]).
</p>
</div>

<div id="outline-container-sec-4-24-1" class="outline-4">
<h4 id="sec-4-24-1"><span class="section-number-4">4.24.1</span> Special cases of compound terms:</h4>
<div class="outline-text-4" id="text-4-24-1">
<p>
A List is an ordered collection of terms. It is denoted by square
 brackets with the terms separated by commas or in the case of the
 empty list, []. For example [1,2,3] or [red,green,blue].  Strings:
 A sequence of characters surrounded by quotes is equivalent to a
 list of (numeric) character codes, generally in the local
 character encoding, or Unicode if the system supports Unicode. For
 example, "to be, or not to be".
</p>
</div>
</div>

<div id="outline-container-sec-4-24-2" class="outline-4">
<h4 id="sec-4-24-2"><span class="section-number-4">4.24.2</span> Rules and facts</h4>
<div class="outline-text-4" id="text-4-24-2">
<p>
Prolog programs describe relations, defined by means of clauses. Pure
Prolog is restricted to Horn clauses. There are two types of clauses:
facts and rules. A rule is of the form
</p>
</div>
</div>

<div id="outline-container-sec-4-24-3" class="outline-4">
<h4 id="sec-4-24-3"><span class="section-number-4">4.24.3</span> Head :- Body.</h4>
<div class="outline-text-4" id="text-4-24-3">
<p>
and is read as "Head is true if Body is true". A rule's body consists
of calls to predicates, which are called the rule's goals. The
built-in predicate ,/2 (meaning a 2-arity operator with name ,)
denotes conjunction of goals, and ;/2 denotes
disjunction. Conjunctions and disjunctions can only appear in the
body, not in the head of a rule.
</p>
</div>
</div>

<div id="outline-container-sec-4-24-4" class="outline-4">
<h4 id="sec-4-24-4"><span class="section-number-4">4.24.4</span> Clauses with empty bodies are called facts. An example of a fact is:</h4>
<div class="outline-text-4" id="text-4-24-4">
<p>
cat(tom).
</p>

<p>
which is equivalent to the rule:
</p>

<p>
cat(tom) :- true.
</p>
</div>
</div>

<div id="outline-container-sec-4-24-5" class="outline-4">
<h4 id="sec-4-24-5"><span class="section-number-4">4.24.5</span> The built-in predicate true/0 is always true.</h4>
<div class="outline-text-4" id="text-4-24-5">
<p>
Given the above fact, one can ask:
</p>

<p>
is tom a cat?
</p>

<p>
?- cat(tom).
Yes
</p>

<p>
what things are cats?
</p>

<p>
?- cat(X).
X = tom
</p>
</div>
</div>

<div id="outline-container-sec-4-24-6" class="outline-4">
<h4 id="sec-4-24-6"><span class="section-number-4">4.24.6</span> Clauses with bodies are called rules.</h4>
<div class="outline-text-4" id="text-4-24-6">
<p>
An example of a rule is:
</p>

<p>
animal(X) :- cat(X).
</p>

<p>
If we add that rule and ask what things are animals?
</p>

<p>
?- animal(X).
X = tom
</p>
</div>
</div>
<div id="outline-container-sec-4-24-7" class="outline-4">
<h4 id="sec-4-24-7"><span class="section-number-4">4.24.7</span> Relational nature of many built-in-predicates</h4>
<div class="outline-text-4" id="text-4-24-7">
<p>
Due to the relational nature of many built-in predicates, they can
typically be used in several directions. For example, length/2 can be
used to determine the length of a list (length(List, L), given a list
List) as well as to generate a list skeleton of a given length
(length(X, 5)), and also to generate both list skeletons and their
lengths together (length(X, L)). Similarly, append/3 can be used both
to append two lists (append(ListA, ListB, X) given lists ListA and
ListB) as well as to split a given list into parts (append(X, Y,
List), given a list List). For this reason, a comparatively small set
of library predicates suffices for many Prolog programs.
</p>
</div>
</div>
<div id="outline-container-sec-4-24-8" class="outline-4">
<h4 id="sec-4-24-8"><span class="section-number-4">4.24.8</span> General purpose language</h4>
<div class="outline-text-4" id="text-4-24-8">
<p>
As a general purpose language, Prolog also provides various built-in
predicates to perform routine activities like input/output, using
graphics and otherwise communicating with the operating system. These
predicates are not given a relational meaning and are only useful for
the side-effects they exhibit on the system. For example, the
predicate write/1 displays a term on the screen.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-25" class="outline-3">
<h3 id="sec-4-25"><span class="section-number-3">4.25</span> Prolog program execution</h3>
<div class="outline-text-3" id="text-4-25">
<p>
Execution of a Prolog program is initiated by the user's posting of a
single goal, called the query. Logically, the Prolog engine tries to
find a resolution refutation of the negated query. The resolution
method used by Prolog is called SLD resolution. If the negated query
can be refuted, it follows that the query, with the appropriate
variable bindings in place, is a logical consequence of the
program. In that case, all generated variable bindings are reported to
the user, and the query is said to have succeeded. Operationally,
Prolog's execution strategy can be thought of as a generalization of
function calls in other languages, one difference being that multiple
clause heads can match a given call. In that case, the system creates
a choice-point, unifies the goal with the clause head of the first
alternative, and continues with the goals of that first
alternative. If any goal fails in the course of executing the program,
all variable bindings that were made since the most recent
choice-point was created are undone, and execution continues with the
next alternative of that choice-point. This execution strategy is
called chronological backtracking. For example:
</p>

<p>
mother<sub>child</sub>(trude, sally).
</p>

<p>
father<sub>child</sub>(tom, sally).
father<sub>child</sub>(tom, erica).
father<sub>child</sub>(mike, tom).
</p>

<p>
sibling(X, Y)      :- parent<sub>child</sub>(Z, X), parent<sub>child</sub>(Z, Y).
</p>

<p>
parent<sub>child</sub>(X, Y) :- father<sub>child</sub>(X, Y).
parent<sub>child</sub>(X, Y) :- mother<sub>child</sub>(X, Y).
</p>

<p>
This results in the following query being evaluated as true:
</p>

<p>
?- sibling(sally, erica).
Yes
</p>

<p>
This is obtained as follows: Initially, the only matching clause-head for the query sibling(sally, erica) is the first one, so proving the query is equivalent to proving the body of that clause with the appropriate variable bindings in place, i.e., the conjunction (parent<sub>child</sub>(Z,sally), parent<sub>child</sub>(Z,erica)). The next goal to be proved is the leftmost one of this conjunction, i.e., parent<sub>child</sub>(Z, sally). Two clause heads match this goal. The system creates a choice-point and tries the first alternative, whose body is father<sub>child</sub>(Z, sally). This goal can be proved using the fact father<sub>child</sub>(tom, sally), so the binding Z = tom is generated, and the next goal to be proved is the second part of the above conjunction: parent<sub>child</sub>(tom, erica). Again, this can be proved by the corresponding fact. Since all goals could be proved, the query succeeds. Since the query contained no variables, no bindings are reported to the user. A query with variables, like:
</p>

<p>
?- father<sub>child</sub>(Father, Child).
</p>

<p>
enumerates all valid answers on backtracking.
</p>

<p>
Notice that with the code as stated above, the query ?- sibling(sally,
sally). also succeeds. One would insert additional goals to describe
the relevant restrictions, if desired.
</p>
</div>
<div id="outline-container-sec-4-25-1" class="outline-4">
<h4 id="sec-4-25-1"><span class="section-number-4">4.25.1</span> non-monotonic reasoning</h4>
<div class="outline-text-4" id="text-4-25-1">
<p>
The built-in Prolog predicate \+/1 provides negation as failure, which
allows for non-monotonic reasoning
</p>
</div>
</div>
<div id="outline-container-sec-4-25-2" class="outline-4">
<h4 id="sec-4-25-2"><span class="section-number-4">4.25.2</span> In Prolog, loading code is referred to as consulting</h4>
<div class="outline-text-4" id="text-4-25-2">
<p>
Hello world
</p>

<p>
An example of a query:
</p>

<p>
?- write('Hello world!'), nl.
Hello world!
true.
</p>

<p>
?-
</p>
</div>
</div>

<div id="outline-container-sec-4-25-3" class="outline-4">
<h4 id="sec-4-25-3"><span class="section-number-4">4.25.3</span> Any computation can be expressed</h4>
<div class="outline-text-4" id="text-4-25-3">
<p>
declaratively as a sequence of state transitions.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-26" class="outline-3">
<h3 id="sec-4-26"><span class="section-number-3">4.26</span> design pattern</h3>
<div class="outline-text-3" id="text-4-26">
<p>
A design pattern is a general reusable solution to a commonly
occurring problem in software design. 
</p>

<p>
In Prolog, design patterns go under various names: skeletons and
techniques, cliches, program schemata, and logic description schemata.
</p>

<p>
An alternative to design patterns is higher order programming.
</p>
</div>

<div id="outline-container-sec-4-26-1" class="outline-4">
<h4 id="sec-4-26-1"><span class="section-number-4">4.26.1</span> higher order predicate</h4>
<div class="outline-text-4" id="text-4-26-1">
<p>
A higher-order predicate is a predicate that takes one or more other
predicates as arguments
</p>

<p>
call/1, call/2, call/3, findall/3, setof/3, and bagof/3
</p>

<p>
higher-order predicates like maplist/2, which applies an arbitrary
predicate to each member of a given list, and sublist/3, which filters
elements that satisfy a given predicate, also allowing for currying
</p>
</div>
</div>
<div id="outline-container-sec-4-26-2" class="outline-4">
<h4 id="sec-4-26-2"><span class="section-number-4">4.26.2</span> conversions from temporal representation</h4>
<div class="outline-text-4" id="text-4-26-2">
<p>
to convert solutions from temporal representation (answer substitutions
on backtracking) to spatial representation (terms), Prolog has various
all-solutions predicates that collect all answer substitutions of a
given query in a list. This can be used for list comprehension. 
</p>
</div>
<ol class="org-ol"><li>example<br  /><div class="outline-text-5" id="text-4-26-2-1">
<p>
For example, perfect numbers equal the sum of their proper divisors:
</p>

<p>
perfect(N) :-
    between(1, inf, N), U is N // 2,
    findall(D, (between(1,U,D), N mod D <code>:</code> 0), Ds),
    sumlist(Ds, N).
</p>

<p>
This can be used to enumerate perfect numbers, and also to check
whether a number is perfect.
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-4-26-3" class="outline-4">
<h4 id="sec-4-26-3"><span class="section-number-4">4.26.3</span> maplist</h4>
<div class="outline-text-4" id="text-4-26-3">
<p>
As another example, the predicate maplist applies a predicate P to all
corresponding positions in a pair of lists:
</p>

<p>
maplist(<sub>P</sub>, [], []).
maplist(P, [X1|X1s], [X2|X2s]) :-
   call(P, X1, X2),
   maplist(P, X1s, X2s).
</p>

<p>
When P is a function in the sense that for all X, P(X,Y) unifies Y
with a single unique value, maplist(P, Xs, Ys) is equivalent to
applying the map function in functional programming as Ys = map(P,
Xs).
</p>

<p>
Higher-order programming style in Prolog was pioneered in HiLog and
Prolog.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-27" class="outline-3">
<h3 id="sec-4-27"><span class="section-number-3">4.27</span> subset of first-order predicate logic</h3>
<div class="outline-text-3" id="text-4-27">
<p>
Pure Prolog is based on a subset of first-order predicate logic, Horn
clauses, which is Turing-complete. Turing completeness of Prolog can
be shown by using it to simulate a Turing machine:
</p>

<p>
turing(Tape0, Tape) :-
    perform(q0, [], Ls, Tape0, Rs),
    reverse(Ls, Ls1),
    append(Ls1, Rs, Tape).
</p>

<p>
perform(qf, Ls, Ls, Rs, Rs) :- !.
perform(Q0, Ls0, Ls, Rs0, Rs) :-
    symbol(Rs0, Sym, RsRest),
    once(rule(Q0, Sym, Q1, NewSym, Action)),
    action(Action, Ls0, Ls1, [NewSym|RsRest], Rs1),
    perform(Q1, Ls1, Ls, Rs1, Rs).
</p>

<p>
symbol([], b, []).
symbol([Sym|Rs], Sym, Rs).
</p>

<p>
action(left, Ls0, Ls, Rs0, Rs) :- left(Ls0, Ls, Rs0, Rs).
action(stay, Ls, Ls, Rs, Rs).
action(right, Ls0, [Sym|Ls0], [Sym|Rs], Rs).
</p>

<p>
left([], [], Rs0, [b|Rs0]).
left([L|Ls], Ls, Rs, [L|Rs]).
</p>

<p>
A simple example Turing machine is specified by the facts:
</p>

<p>
rule(q0, 1, q0, 1, right).
rule(q0, b, qf, 1, stay).
</p>

<p>
This machine performs incrementation by one of a number in unary
encoding: It loops over any number of "1" cells and appends an
additional "1" at the end. Example query and result:
</p>

<p>
?- turing([1,1,1], Ts).
Ts = [1, 1, 1, 1] ;
</p>

<p>
This illustrates how any computation can be expressed declaratively as
a sequence of state transitions, implemented in Prolog as a relation
between successive states of interest.
</p>

<p>
For efficiency, Prolog code is typically compiled to abstract machine
code, often influenced by the register-based Warren Abstract Machine
(WAM) instruction set.
</p>

<p>
Prolog systems typically implement a well-known optimization method
called tail call optimization (TCO) for deterministic predicates
exhibiting tail recursion or, more generally, tail calls: A clause's
stack frame is discarded before performing a call in a tail
position. Therefore, deterministic tail-recursive predicates are
executed with constant stack space, like loops in other languages.
</p>
</div>
</div>

<div id="outline-container-sec-4-28" class="outline-3">
<h3 id="sec-4-28"><span class="section-number-3">4.28</span> term indexing</h3>
<div class="outline-text-3" id="text-4-28">
<p>
Finding clauses that are unifiable with a term in a query is linear in
the number of clauses. Term indexing uses a data structure that
enables sublinear-time lookups. Indexing only affects program
performance, it does not affect semantics.
</p>
</div>
<div id="outline-container-sec-4-28-1" class="outline-4">
<h4 id="sec-4-28-1"><span class="section-number-4">4.28.1</span> research, education and pragma</h4>
<div class="outline-text-4" id="text-4-28-1">
<p>
Although Prolog is widely used in research and education, Prolog and
other logic programming languages have not had a significant impact on
the computer industry in general. Most applications are small by
industrial standards, with few exceeding 100,000 lines of
code. Programming in the large is considered to be complicated
because not all Prolog compilers support modules, and there are
compatibility problems between the module systems of the major Prolog
compilers. Portability of Prolog code across implementations has
also been a problem, but developments since 2007 have meant: "the
portability within the family of Edinburgh/Quintus derived Prolog
implementations is good enough to allow for maintaining portable
real-world applications."
</p>
</div>
</div>
<div id="outline-container-sec-4-28-2" class="outline-4">
<h4 id="sec-4-28-2"><span class="section-number-4">4.28.2</span> prolog performance</h4>
<div class="outline-text-4" id="text-4-28-2">
<p>
Software developed in Prolog has been criticised for having a high
performance penalty compared to conventional programming
languages. However, advances in implementation methods have reduced
the penalties to as little as 25%-50% for some applications.
</p>
</div>
</div>
<div id="outline-container-sec-4-28-3" class="outline-4">
<h4 id="sec-4-28-3"><span class="section-number-4">4.28.3</span> prolog is not purely declarative</h4>
<div class="outline-text-4" id="text-4-28-3">
<p>
Prolog is not purely declarative: because of constructs like the cut
operator, a procedural reading of a Prolog program is needed to
understand it. The order of clauses in a Prolog program is
significant. Other logic programming languages, such as Datalog, are
truly declarative but restrict the language.
</p>

<p>
The syntax of Prolog does not specify which arguments of a predicate
are inputs and which are outputs. However, this information is
significant and it is recommended that it be included in the comments
Modes provide valuable information when reasoning about Prolog
programs and can also be used to accelerate execution
Prolog systems that provide a graphics library are SWI-prolog,
Visual-prolog, LPA Prolog for Windows and B-Prolog.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-29" class="outline-3">
<h3 id="sec-4-29"><span class="section-number-3">4.29</span> Using Prolog with AllegroGraph 3.3 (and gruff)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="prolog">prolog</span>&#xa0;<span class="gruff">gruff</span></span></h3>
<div class="outline-text-3" id="text-4-29">
</div><div id="outline-container-sec-4-29-1" class="outline-4">
<h4 id="sec-4-29-1"><span class="section-number-4">4.29.1</span> IRI</h4>
<div class="outline-text-4" id="text-4-29-1">
<p>
<a href="file:///archive/xk05/Downloads/agraph-fse-3.3/doc/prolog-tutorial.html">file:///archive/xk05/Downloads/agraph-fse-3.3/doc/prolog-tutorial.html</a>   
</p>
</div>
</div>
<div id="outline-container-sec-4-29-2" class="outline-4">
<h4 id="sec-4-29-2"><span class="section-number-4">4.29.2</span> index</h4>
<div class="outline-text-4" id="text-4-29-2">
<p>
Using Prolog with AllegroGraph 3.3
</p>

<ul class="org-ul">
<li>AllegroGraph
<ul class="org-ul">
<li>Introduction
</li>
<li>Upgrade Guide
</li>
<li>Recent Changes
</li>
<li>HTTP/Sesame Protocol
</li>
<li>Server Installation
</li>
</ul>
</li>
<li>Java
<ul class="org-ul">
<li>Java Tutorial
</li>
<li>Learning Center (local)
</li>
<li>Learning Center (franz.com)
</li>
<li>Javadocs
</li>
<li>Jena
</li>
</ul>
</li>
<li>Python
<ul class="org-ul">
<li>Python client
</li>
<li>Python Tutorial
</li>
<li>Python API
</li>
</ul>
</li>
<li>Lisp
<ul class="org-ul">
<li>Lisp Installation
</li>
<li>AllegroGraph Tutorial
</li>
<li>Client
</li>
<li>hasValue Reasoning Tutorial
</li>
<li>Freetext indexing tutorial
</li>
<li>Federation tutorial
</li>
<li>Temporal tutorial
</li>
<li>Geospatial tutorial
</li>
<li>RDFS++ Reasoning Tutorial
</li>
<li>Reference Guide
</li>
<li>AllegroGraph and Prolog
</li>
</ul>
</li>
<li>SPARQL
<ul class="org-ul">
<li>SPARQL Tutorial
</li>
<li>SPARQL Reference
</li>
<li>SPARQL Client
</li>
<li>SPARQL Server
</li>
<li>SPARQL Geospatial Extension
</li>
<li>SPARQL Construct
</li>
<li>Twinql Releases Notes
</li>
</ul>
</li>
<li>Other
<ul class="org-ul">
<li>FAQ
</li>
<li>LUBM Benchmarks
</li>
<li>Performance Tuning
</li>
<li>Suggested Reading
</li>
<li>Community Resources
</li>
<li>Copyrights
</li>
</ul>
</li>
<li>Franz, Inc.
</li>
<li>Download
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-4-30" class="outline-3">
<h3 id="sec-4-30"><span class="section-number-3">4.30</span> Introduction</h3>
<div class="outline-text-3" id="text-4-30">
<p>
We would urge you to first do this tutorial and then study the Allegro Prolog
documentation if necessary. This is a basic tutorial on how to use Prolog with
AllegroGraph 3.3. It should be enough to get you going but if you have any
questions please write to us and we will help you. In this example we will focus
mainly on how to use the following constructs:
</p>

<ul class="org-ul">
<li>select
</li>
<li>q-
</li>
<li>q
</li>
<li>&lt;&#x2013;
</li>
<li>&lt;-
</li>
<li>??
</li>
<li>!
</li>
</ul>

<p>
When consulting the Reference Guide, one should understand the conventions for
documenting Prolog functors. A Prolog functor clause looks like a regular Lisp
function call, the symbol naming the functor being the first element of the list
and the remaining elements being arguments. But arguments to a Prolog functor call
can either be supplied as input to the functor, or unsupplied so that the clause
might return that argument as a result by unifying some data to it, or may be a
tree of nodes containing both ground data an Prolog variables. The common example
is the functor append which has three arguments and succeeds for any solution
there the third argument is the same as the first two arguments appended. The
remarkable thing about Prolog semantics is that append is a declarative relation
that succeeds regardless which arguments are supplied as inputs and which are
supplied as outputs. &lt;ret&gt; indicates where the user would type a return to ask
Prolog to find the next result.
</p>

<p>
&gt; (?- (append (1 2) (3) ?z))  
?z = (1 2 3)  
&lt;ret&gt;  
No.  
&gt; (?- (append (1 2) ?y (1 2 3)))  
?y = (3)  
&lt;ret&gt;  
No.  
&gt; (?- (append ?x ?y (1 2 3)))  
?x = ()  
?y = (1 2 3)  
&lt;ret&gt;  
?x = (1)  
?y = (2 3)  
&lt;ret&gt;  
?x = (1 2)  
?y = (3)  
&lt;ret&gt;  
?x = (1 2 3)  
?y = ()  
&lt;ret&gt;  
No.  
&gt; (?- (append ? (1 ?next . ?) (1 2 1 3 4 1 5 1)))  
?next = 2  
&lt;ret&gt;  
?next = 3  
&lt;ret&gt;  
?next = 5  
&lt;ret&gt;  
No. 
</p>

<p>
The last example successively unifies to each element in the list immediately
preceded by a 1. It shows the power of unification against partially ground tree
structure.
</p>

<p>
Now we return to the the notational convention: A functor argument that is an
input to the functor and which must be supplied is marked in the documentaiton
with a +. A functor argument that is returned by the functor and which must not be
supplied is marked with a -. An argument that can be either is marked with .
(Prolog documentation generally used ? for this, but in Lisp-bnased Prologs that
character is used as the first character of a symbol that is a Prolog variable,
overloading using it to indicate and input-output argument would be very
confusing.) Within this convention append would be notated as (append &amp;plusmn;left
&amp;plusmn;right &amp;plusmn;result). But a functor like part= which simply checks
whether two parts are the same UPI and which requires two actual which requires
two actual furure-part or UPI arguments, would be documented (part= +upi1 +upi2)`.
</p>

<p>
The rest of this tutorial will be based on a tiny genealogy database of the
Kennedy family.
</p>

<p>
Please open the file kennedy.ntriples that came with this distribution in a text
editor or with TopBraidComposer and study the contents of the file. Notice that
people in this file have a type, sometimes multiple children, multiple spouses,
multiple professions, and go to multiple colleges or universities.
</p>

<p>
This tutorial uses Lisp as the base language but there is also a Java example with
the same content.
</p>
</div>
</div>

<div id="outline-container-sec-4-31" class="outline-3">
<h3 id="sec-4-31"><span class="section-number-3">4.31</span> First let us get AllegroGraph ready to use:</h3>
<div class="outline-text-3" id="text-4-31">
<p>
&gt; (require :agraph)  
;; &#x2026;. output deleted.  
</p>

<p>
&gt; (in-package :triple-store-user)  
#&lt;The db.agraph.user package&gt;  
</p>

<p>
&gt; (enable-!-reader)  
#&lt;Function read-!&gt;  
t  
</p>

<p>
&gt; (register-namespace "ex" "<a href="http://www.franz.com/simple">http://www.franz.com/simple</a>#"  
</p>
<p>
   :errorp nil)  
"<a href="http://www.franz.com/simple">http://www.franz.com/simple</a>#" 
</p>

<p>
Now we can create a triple-store and load it with data. The function 
create-triple-store creates a new triple-store and opens it. If you use the
triple-store name "temp/test", then AllegroGraph will create a new directory named
temp in your current directory (use the top-level command :pwd if you want to see
what this is). It will then make another directory named test as a sub-directory
of temp. All of this triple-store's data will be placed in this new directory temp
/test:
</p>

<p>
&gt; (defun fill-kennedy-db ()   
    (create-triple-store "temp/test"  
</p>
<p>
                         :if-exists :supersede)  
    (time  
     (load-ntriples #p"sys:agraph;tutorial-files;kennedy.ntriples"))  
    (index-all-triples))  
fill-kennedy-db  
&gt; (fill-kennedy-db)  
;; &#x2026;. output deleted. 
</p>
</div>
</div>

<div id="outline-container-sec-4-32" class="outline-3">
<h3 id="sec-4-32"><span class="section-number-3">4.32</span> So let us first look at person1 in this database:</h3>
<div class="outline-text-3" id="text-4-32">
<p>
&gt; (print-triples  
   (get-triples-list :s !ex:person1))  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a> <a href="http://www.franz.com/simple#person">http://www.franz.com/simple#person</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#first-name">http://www.franz.com/simple#first-name</a> <a href="http://www.franz.com/simple#Joseph">http://www.franz.com/simple#Joseph</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#middle-initial">http://www.franz.com/simple#middle-initial</a> <a href="http://www.franz.com/simple#Patrick">http://www.franz.com/simple#Patrick</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#last-name">http://www.franz.com/simple#last-name</a> <a href="http://www.franz.com/simple#Kennedy">http://www.franz.com/simple#Kennedy</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#birth-year">http://www.franz.com/simple#birth-year</a> <a href="http://www.franz.com/simple#1888">http://www.franz.com/simple#1888</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#death-year">http://www.franz.com/simple#death-year</a> <a href="http://www.franz.com/simple#1969">http://www.franz.com/simple#1969</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#sex">http://www.franz.com/simple#sex</a> <a href="http://www.franz.com/simple#male">http://www.franz.com/simple#male</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#spouse">http://www.franz.com/simple#spouse</a> <a href="http://www.franz.com/simple#person2">http://www.franz.com/simple#person2</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#suffix">http://www.franz.com/simple#suffix</a> <a href="http://www.franz.com/simple#none">http://www.franz.com/simple#none</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#has-child">http://www.franz.com/simple#has-child</a> <a href="http://www.franz.com/simple#person9">http://www.franz.com/simple#person9</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#has-child">http://www.franz.com/simple#has-child</a> <a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#has-child">http://www.franz.com/simple#has-child</a> <a href="http://www.franz.com/simple#person17">http://www.franz.com/simple#person17</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#has-child">http://www.franz.com/simple#has-child</a> <a href="http://www.franz.com/simple#person4">http://www.franz.com/simple#person4</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#has-child">http://www.franz.com/simple#has-child</a> <a href="http://www.franz.com/simple#person6">http://www.franz.com/simple#person6</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#has-child">http://www.franz.com/simple#has-child</a> <a href="http://www.franz.com/simple#person15">http://www.franz.com/simple#person15</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#has-child">http://www.franz.com/simple#has-child</a> <a href="http://www.franz.com/simple#person11">http://www.franz.com/simple#person11</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#has-child">http://www.franz.com/simple#has-child</a> <a href="http://www.franz.com/simple#person3">http://www.franz.com/simple#person3</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#has-child">http://www.franz.com/simple#has-child</a> <a href="http://www.franz.com/simple#person7">http://www.franz.com/simple#person7</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#profession">http://www.franz.com/simple#profession</a> <a href="http://www.franz.com/simple#producer">http://www.franz.com/simple#producer</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#profession">http://www.franz.com/simple#profession</a> <a href="http://www.franz.com/simple#banker">http://www.franz.com/simple#banker</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#profession">http://www.franz.com/simple#profession</a> <a href="http://www.franz.com/simple#ambassador">http://www.franz.com/simple#ambassador</a> .  
<a href="http://www.franz.com/simple#person1">http://www.franz.com/simple#person1</a> <a href="http://www.franz.com/simple#alma-mater">http://www.franz.com/simple#alma-mater</a> <a href="http://www.franz.com/simple#Harvard">http://www.franz.com/simple#Harvard</a> . 
</p>

<p>
Now we are ready to try the select statement in combination with the Prolog q
functor. Let us try to find all the children of person1. Just type the following
in the listener. Afterward, I'll explain.
</p>
</div>
</div>

<div id="outline-container-sec-4-33" class="outline-3">
<h3 id="sec-4-33"><span class="section-number-3">4.33</span> select</h3>
<div class="outline-text-3" id="text-4-33">
<p>
&gt; (select (?x)  
   (q- !ex:person1 !ex:has-child ?x))  
(("<a href="http://www.franz.com/simple#person9">http://www.franz.com/simple#person9</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>")  
 ("<a href="http://www.franz.com/simple#person17">http://www.franz.com/simple#person17</a>")  
 ("<a href="http://www.franz.com/simple#person4">http://www.franz.com/simple#person4</a>")  
 ("<a href="http://www.franz.com/simple#person6">http://www.franz.com/simple#person6</a>")  
 ("<a href="http://www.franz.com/simple#person15">http://www.franz.com/simple#person15</a>")  
 ("<a href="http://www.franz.com/simple#person11">http://www.franz.com/simple#person11</a>")  
 ("<a href="http://www.franz.com/simple#person3">http://www.franz.com/simple#person3</a>")  
 ("<a href="http://www.franz.com/simple#person7">http://www.franz.com/simple#person7</a>")) 
</p>

<p>
select is a wrapper used around one or more Prolog statements. The first element
after select is template for the format and variables that you want to bind and
return. So in this example above we want to bind the variable ?x. The rest of the
elements tell Prolog what we want to bind ?x to.
</p>

<p>
This select statement has only one clause, namely (q- !ex:person1 !ex:has-child ?
x)`
</p>

<p>
If you have studied how get-triples works you probably can guess what happens
here. q- is a Prolog functor that is our link to the data in the triple-store. It
calls get-triples and unifies the ?x with the objects of all triples with subject
!ex:person1 and predicate !ex:has-child.
</p>

<p>
So let us make it a little bit more complex. Let us find all the children of the
children of person1. Here is how you do it:
</p>

<p>
&gt; (select (?y)  
   (q- !ex:person1 !ex:has-child ?x)  
   (q- ?x !ex:has-child ?y))  
(("<a href="http://www.franz.com/simple#person33">http://www.franz.com/simple#person33</a>")  
 ("<a href="http://www.franz.com/simple#person26">http://www.franz.com/simple#person26</a>")  
 ("<a href="http://www.franz.com/simple#person28">http://www.franz.com/simple#person28</a>")  
 ("<a href="http://www.franz.com/simple#person31">http://www.franz.com/simple#person31</a>")  
 ("<a href="http://www.franz.com/simple#person25">http://www.franz.com/simple#person25</a>")  
 ("<a href="http://www.franz.com/simple#person62">http://www.franz.com/simple#person62</a>")  
 ("<a href="http://www.franz.com/simple#person56">http://www.franz.com/simple#person56</a>")  
 ("<a href="http://www.franz.com/simple#person42">http://www.franz.com/simple#person42</a>")  
 ("<a href="http://www.franz.com/simple#person47">http://www.franz.com/simple#person47</a>")  
 ("<a href="http://www.franz.com/simple#person51">http://www.franz.com/simple#person51</a>") &#x2026;) 
</p>

<p>
Although Prolog is a declarative language, a procedural reading of this query
works better for most people. So the previous query can be read as
</p>

<p>
Find all triples that start with !ex:person1 !ex:has-child. For each match set
?x to the object of that triple; then for each triple that starts with ?x !
ex:has-child find the ?y
</p>

<p>
The following example should now be easy to understand. Here we are trying to find
all the spouses of the grand-children of ?z. Notice that we ignore the ?x and ?y
in the query. The select will only return the ?z
</p>

<p>
&gt; (select (?z)  
   (q- !ex:person1 !ex:has-child ?x)  
   (q- ?x !ex:has-child ?y)  
   (q- ?y !ex:spouse ?z))  
(("<a href="http://www.franz.com/simple#person34">http://www.franz.com/simple#person34</a>")  
 ("<a href="http://www.franz.com/simple#person27">http://www.franz.com/simple#person27</a>")  
 ("<a href="http://www.franz.com/simple#person30">http://www.franz.com/simple#person30</a>")  
 ("<a href="http://www.franz.com/simple#person32">http://www.franz.com/simple#person32</a>")  
 ("<a href="http://www.franz.com/simple#person63">http://www.franz.com/simple#person63</a>")  
 ("<a href="http://www.franz.com/simple#person57">http://www.franz.com/simple#person57</a>")  
 ("<a href="http://www.franz.com/simple#person43">http://www.franz.com/simple#person43</a>")  
 ("<a href="http://www.franz.com/simple#person49">http://www.franz.com/simple#person49</a>")  
 ("<a href="http://www.franz.com/simple#person48">http://www.franz.com/simple#person48</a>")  
 ("<a href="http://www.franz.com/simple#person52">http://www.franz.com/simple#person52</a>") &#x2026;) 
</p>

<p>
Now if you wanted to you could get the other variables back. Here is the same
query but now you also want to see the grand-child.
</p>

<p>
&gt; (select (?y ?z)  
    (q- !ex:person1 !ex:has-child ?x)  
    (q- ?x !ex:has-child ?y)  
    (q- ?y !ex:spouse ?z))  
(("<a href="http://www.franz.com/simple#person33">http://www.franz.com/simple#person33</a>" "<a href="http://www.franz.com/simple#person34">http://www.franz.com/simple#person34</a>")  
 ("<a href="http://www.franz.com/simple#person26">http://www.franz.com/simple#person26</a>" "<a href="http://www.franz.com/simple#person27">http://www.franz.com/simple#person27</a>")  
 ("<a href="http://www.franz.com/simple#person28">http://www.franz.com/simple#person28</a>" "<a href="http://www.franz.com/simple#person30">http://www.franz.com/simple#person30</a>")  
 ("<a href="http://www.franz.com/simple#person31">http://www.franz.com/simple#person31</a>" "<a href="http://www.franz.com/simple#person32">http://www.franz.com/simple#person32</a>")  
 ("<a href="http://www.franz.com/simple#person62">http://www.franz.com/simple#person62</a>" "<a href="http://www.franz.com/simple#person63">http://www.franz.com/simple#person63</a>")  
 ("<a href="http://www.franz.com/simple#person56">http://www.franz.com/simple#person56</a>" "<a href="http://www.franz.com/simple#person57">http://www.franz.com/simple#person57</a>")  
 ("<a href="http://www.franz.com/simple#person42">http://www.franz.com/simple#person42</a>" "<a href="http://www.franz.com/simple#person43">http://www.franz.com/simple#person43</a>")  
 ("<a href="http://www.franz.com/simple#person47">http://www.franz.com/simple#person47</a>" "<a href="http://www.franz.com/simple#person49">http://www.franz.com/simple#person49</a>")  
 ("<a href="http://www.franz.com/simple#person47">http://www.franz.com/simple#person47</a>" "<a href="http://www.franz.com/simple#person48">http://www.franz.com/simple#person48</a>")  
 ("<a href="http://www.franz.com/simple#person51">http://www.franz.com/simple#person51</a>" "<a href="http://www.franz.com/simple#person52">http://www.franz.com/simple#person52</a>") &#x2026;) 
</p>
</div>
</div>

<div id="outline-container-sec-4-34" class="outline-3">
<h3 id="sec-4-34"><span class="section-number-3">4.34</span> prolog functors</h3>
<div class="outline-text-3" id="text-4-34">
<p>
So now we understand the select and the q statement. We are halfway there. Let us
now define some Prolog functors.
</p>

<p>
The following defines a functor that says: ?x is a male if in the triple store I
can find an ?x that has the !ex:sex !ex:male.
</p>

<p>
&gt; (&lt;&#x2013; (male ?x)  
    (q- ?x !ex:sex !ex:male))  
male 
</p>

<p>
Let us try it out by finding all the sons of person1.
</p>

<p>
&gt; (select (?x)  
    (q- !ex:person1 !ex:has-child ?x)  
    (male ?x)) ;;; Note how we use NO q here!  
(("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>")  
 ("<a href="http://www.franz.com/simple#person17">http://www.franz.com/simple#person17</a>")  
 ("<a href="http://www.franz.com/simple#person4">http://www.franz.com/simple#person4</a>")  
 ("<a href="http://www.franz.com/simple#person3">http://www.franz.com/simple#person3</a>")) 
</p>

<p>
Now this is not too exciting, and it is equivalent to the following:
</p>

<p>
(select (?x)  
 (q- !ex:person1 !ex:has-child ?x)  
 (q- ?x !ex:sex !ex:male)) 
</p>

<p>
So let us make it more complex:
</p>

<p>
&gt; (&lt;&#x2013; (female ?x)  
    (q- ?x !ex:sex !ex:female))  
female  
&gt; (&lt;&#x2013; (father ?x ?y)  
    (male ?x)  
    (q- ?x !ex:has-child ?y))  
father  
&gt; (&lt;&#x2013; (mother ?x ?y)  
    (female ?x)  
    (q- ?x !ex:has-child ?y))  
mother 
</p>

<p>
The female, father, mother relations are all simple to understand. The following
adds the idea of multiple rules (or functors). Notice how we define the parent
relationship with two rules, where the first rule uses &lt;&#x2013; and the second rule
uses &lt;-. The reason is that &lt;&#x2013; means: wipe out all the previous rules that I had
about parent and start anew whereas &lt;- means, add to the existing rules for
parent.
</p>

<p>
The following should be read as:
</p>

<ul class="org-ul">
<li>?x is the parent of ?y if ?x is the father of ?y or
</li>
<li>?x is the parent of ?y if ?x is the mother of ?y.

<p>
(&lt;&#x2013; (parent ?x ?y)
</p>

<p>
(father ?x ?y))  
parent 
</p>

<p>
(&lt;- (parent ?x ?y)
</p>

<p>
(mother ?x ?y))  
parent 
</p>
</li>
</ul>

<p>
So let us try it out by finding the grand children of person1
</p>

<p>
&gt; (select (?y)  
    (parent !ex:person1 ?x)  
    (parent ?x ?y))  
(("<a href="http://www.franz.com/simple#person33">http://www.franz.com/simple#person33</a>")  
 ("<a href="http://www.franz.com/simple#person26">http://www.franz.com/simple#person26</a>")  
 ("<a href="http://www.franz.com/simple#person28">http://www.franz.com/simple#person28</a>")  
 ("<a href="http://www.franz.com/simple#person31">http://www.franz.com/simple#person31</a>")  
 ("<a href="http://www.franz.com/simple#person25">http://www.franz.com/simple#person25</a>")  
 ("<a href="http://www.franz.com/simple#person62">http://www.franz.com/simple#person62</a>")  
 ("<a href="http://www.franz.com/simple#person56">http://www.franz.com/simple#person56</a>")  
 ("<a href="http://www.franz.com/simple#person42">http://www.franz.com/simple#person42</a>")  
 ("<a href="http://www.franz.com/simple#person47">http://www.franz.com/simple#person47</a>")  
 ("<a href="http://www.franz.com/simple#person51">http://www.franz.com/simple#person51</a>") &#x2026;) 
</p>

<p>
We could have done the same thing by defining a grandparent functor. See the next
definition.
</p>

<p>
&gt; (&lt;&#x2013; (grandparent ?x ?y)  
    (parent ?x ?z)  
    (parent ?z ?y))  
grandparent  
&gt; (&lt;&#x2013; (grandchild ?x ?y)  
    (grandparent ?y ?x))  
grandchild 
</p>

<p>
And here it gets really interesting because we now go for the first time to a
recursive functor.
</p>

<p>
&gt; (&lt;&#x2013; (ancestor ?x ?y)  
    (parent ?x ?y))  
ancestor  
&gt; (&lt;-  (ancestor ?x ?y)      
    (parent ?x ?z)  
    (ancestor ?z ?y))                
ancestor 
</p>

<p>
Read the previous two expressions as
</p>

<ul class="org-ul">
<li>?x is the ancestor of ?y if
<ul class="org-ul">
<li>?x is the parent of ?y or
</li>
<li>?x is the parent of some person ?z and ?z is the ancestor of ?y
</li>
</ul>
</li>
</ul>

<p>
A descendant is of course the reverse of ancestor
</p>

<p>
&gt; (&lt;&#x2013; (descendant ?x ?y)  
    (ancestor ?y ?x))  
descendant 
</p>

<p>
So if we want to find all the male descendants of person1 then here is how to do
it.
</p>

<p>
&gt; (select (?x)  
    (descendant ?x !ex:person1)  
    (male ?x))  
(("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>")  
 ("<a href="http://www.franz.com/simple#person17">http://www.franz.com/simple#person17</a>")  
 ("<a href="http://www.franz.com/simple#person4">http://www.franz.com/simple#person4</a>")  
 ("<a href="http://www.franz.com/simple#person3">http://www.franz.com/simple#person3</a>")  
 ("<a href="http://www.franz.com/simple#person33">http://www.franz.com/simple#person33</a>")  
 ("<a href="http://www.franz.com/simple#person28">http://www.franz.com/simple#person28</a>")  
 ("<a href="http://www.franz.com/simple#person31">http://www.franz.com/simple#person31</a>")  
 ("<a href="http://www.franz.com/simple#person25">http://www.franz.com/simple#person25</a>")  
 ("<a href="http://www.franz.com/simple#person62">http://www.franz.com/simple#person62</a>")  
 ("<a href="http://www.franz.com/simple#person47">http://www.franz.com/simple#person47</a>") &#x2026;) 
</p>
</div>
</div>

<div id="outline-container-sec-4-35" class="outline-3">
<h3 id="sec-4-35"><span class="section-number-3">4.35</span> some puzzles to work out</h3>
<div class="outline-text-3" id="text-4-35">
<p>
And then here are some puzzles that you can work out for yourself.. Note the use
of not and part= in these statements. 'not' can contain any expression. part= will
compare its two arguments as UPIs; It will not unify.
</p>

<p>
&gt; (&lt;&#x2013; (aunt ?x ?y)  
    (father ?z ?x)  
    (female ?x)  
    (father ?z ?w)  
    (not (part= ?x ?w))  
    (parent ?w ?y))  
aunt  
&gt; (&lt;&#x2013; (uncle ?x ?y)  
    (father ?z ?x)  
    (male ?x)  
    (father ?z ?w)  
    (not (part= ?x ?w))  
    (parent ?w ?y))  
uncle 
</p>

<p>
And the final query: find all the children of person1 that are uncles
</p>

<p>
&gt; (select (?x ?y)  
    (parent !ex:person1 ?x)  
    (uncle ?x ?y))  
(("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person33">http://www.franz.com/simple#person33</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person26">http://www.franz.com/simple#person26</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person28">http://www.franz.com/simple#person28</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person31">http://www.franz.com/simple#person31</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person25">http://www.franz.com/simple#person25</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person62">http://www.franz.com/simple#person62</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person56">http://www.franz.com/simple#person56</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person42">http://www.franz.com/simple#person42</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person47">http://www.franz.com/simple#person47</a>")  
 ("<a href="http://www.franz.com/simple#person13">http://www.franz.com/simple#person13</a>"  
  "<a href="http://www.franz.com/simple#person51">http://www.franz.com/simple#person51</a>")  
 &#x2026;)  
&gt; 
</p>
</div>
</div>

<div id="outline-container-sec-4-36" class="outline-3">
<h3 id="sec-4-36"><span class="section-number-3">4.36</span> another convenient shorthand</h3>
<div class="outline-text-3" id="text-4-36">
<p>
There is another convenient shorthand to know in Allegro Prolog. It is often
necessary to use small bits of Lisp code inside a series of prolog clauses. A
typical example is here, where it is necessary inside a sequence of prolog clauses
to retrieve a value from the surrounding Lisp environment. Here we define a Lisp
function that returns the first and last name of every person born in the argument
year.
</p>

<p>
&gt; (defun born-in-year (year)  
    (select0 (?first-name ?last-name)  
      (lisp ?year (literal (princ-to-string year)))  
      (q- ?person !ex:birth-year ?year)  
      (q- ?person !ex:first-name ?first-name)  
      (q- ?person !ex:last-name ?last-name)))  
born-in-year  
&gt; (born-in-year 1915)  
(({Joseph} {Kennedy}) ({Robert} {Shriver}))  
t 
</p>

<p>
The year argument may be a string or an integer, but we need to convert it to a
string since that's the way birth years are stored in this particular database.
Then the argument needs to be interned as a literal. But the important point is
that we need to get the value of year from the surrounding Lisp environments and
bind it to a Prolog variable (here named ?year) so it can be passed to q-.
</p>

<p>
This necessary transfer of data into the Prolog environment clutters the code and
makes it harder to read. The ?? syntax marker can eliminate much of this:
</p>

<p>
&gt; (defun born-in-year (year)  
    (select0 (?first-name ?last-name)  
      (q- ?person !ex:birth-year (?? (literal (princ-to-string year))))  
      (q- ?person !ex:first-name ?first-name)  
      (q- ?person !ex:last-name ?last-name))) 
</p>

<p>
This is nothing more than a syntactic shorthand of the previous example and
operates just like it. It eliminates the need for the Prolog variable to be
visible. The body of ?? has syntax like Lisp progn and substitutes the value
computed by the progn body into the Prolog clause.
</p>

<p>
There is a problem with the syntax for the Prolog cut and AllegroGraph's
future-part syntax. Prolog uses the exclamation point ! to denote the cut
operation. When executed, a cut clears all previous backtracking points within the
current predicate. For example,
</p>

<p>
&gt; (&lt;&#x2013; (parent ?x)  
       (parent ?x ?)  
       !) 
</p>

<p>
defines a predicate that tests whether the argument person a parent, but if so
succeeds only once. The ! is traditional Prolog notation, but AllegroGraph uses
the ! character as a reader macro to create a future part, so the above definition
will signal a read error when the AllegroGraph readtable is in effect (see the !
-reader macro section).
</p>

<p>
The simplest way to resolve this is to preface the Prolog ! with a backslash in
any code that might be read with the AllegroGraph readtable in effect. The
backslash suppresses any reader macro for the following character. This adds
minimal clutter to the source code, and is completely harmless even when the
AllegroGraph readtable is not in effect.
</p>

<p>
&gt; (&lt;&#x2013; (is-a-parent ?x)  
       (parent ?x ?)  
       \!) 
</p>

<p>
Be aware that sometimes names with syntax parent/2 will appear in Prolog
documentation and in the debugger. The portion of the name is the predicate name
&#x2013; also called a functor and the same as the Lisp symbol naming the predicate. The
non-negative integer after the slash is the arity, which is the number of
arguments to the predicate. Two predicates with the same functor but different
arity are completely unrelated to one another. In the example above the predicate 
parent/1 has no relation to the parent/2 predicate defined earlier in this
document and which it calls.
</p>
</div>

<div id="outline-container-sec-4-36-1" class="outline-4">
<h4 id="sec-4-36-1"><span class="section-number-4">4.36.1</span> logo-franz</h4>
<div class="outline-text-4" id="text-4-36-1">
<p>
Copyright (c) 2005 - 2010 Franz, Incorporated
</p>

<p>
Last updated 17 February 2010 at 14:09
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> sparql&#xa0;&#xa0;&#xa0;<span class="tag"><span class="sparql">sparql</span>&#xa0;<span class="rdf">rdf</span></span></h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-0-1" class="outline-4">
<h4 id="sec-5-0-1"><span class="section-number-4">5.0.1</span> <span class="done DONE">DONE</span> tracker-sparql&#xa0;&#xa0;&#xa0;<span class="tag"><span class="sparql">sparql</span>&#xa0;<span class="rdf">rdf</span></span></h4>
<div class="outline-text-4" id="text-5-0-1">
</div><ol class="org-ol"><li><span class="done DONE">DONE</span> tracker-sparql -q "SELECT ?cl WHERE { ?cl a rdfs:Class }"<br  /><div class="outline-text-5" id="text-5-0-1-1">
<p>
Results:
  <a href="http://www.w3.org/2001/XMLSchema#string">http://www.w3.org/2001/XMLSchema#string</a>
  <a href="http://www.w3.org/2001/XMLSchema#boolean">http://www.w3.org/2001/XMLSchema#boolean</a>
  <a href="http://www.w3.org/2001/XMLSchema#integer">http://www.w3.org/2001/XMLSchema#integer</a>
  <a href="http://www.w3.org/2001/XMLSchema#double">http://www.w3.org/2001/XMLSchema#double</a>
  <a href="http://www.w3.org/2001/XMLSchema#date">http://www.w3.org/2001/XMLSchema#date</a>
  <a href="http://www.w3.org/2001/XMLSchema#dateTime">http://www.w3.org/2001/XMLSchema#dateTime</a>
  <a href="http://www.w3.org/2000/01/rdf-schema#Resource">http://www.w3.org/2000/01/rdf-schema#Resource</a>
  <a href="http://www.w3.org/2000/01/rdf-schema#Class">http://www.w3.org/2000/01/rdf-schema#Class</a>
  <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#Property">http://www.w3.org/1999/02/22-rdf-syntax-ns#Property</a>
  <a href="http://www.w3.org/2000/01/rdf-schema#Literal">http://www.w3.org/2000/01/rdf-schema#Literal</a>
  <a href="http://www.tracker-project.org/ontologies/tracker#Namespace">http://www.tracker-project.org/ontologies/tracker#Namespace</a>
  <a href="http://www.tracker-project.org/ontologies/tracker#Ontology">http://www.tracker-project.org/ontologies/tracker#Ontology</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/08/15/nrl#InverseFunctionalProperty">http://www.semanticdesktop.org/ontologies/2007/08/15/nrl#InverseFunctionalProperty</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataObject">http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataObject</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataSource">http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataSource</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/01/19/nie#InformationElement">http://www.semanticdesktop.org/ontologies/2007/01/19/nie#InformationElement</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Tag">http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Tag</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Property">http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Property</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Role">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Role</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Affiliation">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Affiliation</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Contact">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Contact</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactGroup">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactGroup</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactList">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactList</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactMedium">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactMedium</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#EmailAddress">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#EmailAddress</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAddress">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAddress</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAccount">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAccount</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#OrganizationContact">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#OrganizationContact</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PersonContact">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PersonContact</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PhoneNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PhoneNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PostalAddress">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PostalAddress</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ModemNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ModemNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#MessagingNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#MessagingNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PagerNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PagerNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Gender">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Gender</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VoicePhoneNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VoicePhoneNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VideoTelephoneNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VideoTelephoneNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IsdnNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IsdnNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ParcelDeliveryAddress">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ParcelDeliveryAddress</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#FaxNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#FaxNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CarPhoneNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CarPhoneNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactListDataObject">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactListDataObject</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PcsNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PcsNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#InternationalDeliveryAddress">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#InternationalDeliveryAddress</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#BbsNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#BbsNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CellPhoneNumber">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CellPhoneNumber</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#DomesticDeliveryAddress">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#DomesticDeliveryAddress</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PresenceStatus">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PresenceStatus</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMCapability">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMCapability</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco#AuthorizationStatus">http://www.semanticdesktop.org/ontologies/2007/03/22/nco#AuthorizationStatus</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Document">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Document</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileDataObject">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileDataObject</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Software">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Software</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Media">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Media</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Visual">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Visual</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Image">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Image</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RasterImage">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RasterImage</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DataContainer">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DataContainer</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemotePortAddress">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemotePortAddress</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaFileListEntry">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaFileListEntry</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#VectorImage">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#VectorImage</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Audio">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Audio</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#CompressionType">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#CompressionType</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Icon">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Icon</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#TextDocument">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#TextDocument</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PlainTextDocument">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PlainTextDocument</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HtmlDocument">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HtmlDocument</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#OperatingSystem">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#OperatingSystem</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaList">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaList</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Executable">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Executable</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Folder">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Folder</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Font">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Font</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Filesystem">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Filesystem</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareService">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareService</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareItem">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareItem</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Presentation">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Presentation</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemoteDataObject">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemoteDataObject</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PaginatedTextDocument">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PaginatedTextDocument</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Video">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Video</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Spreadsheet">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Spreadsheet</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Trash">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Trash</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileHash">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileHash</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SourceCode">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SourceCode</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Application">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Application</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#EmbeddedFileDataObject">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#EmbeddedFileDataObject</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Attachment">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Attachment</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#ArchiveItem">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#ArchiveItem</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Archive">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Archive</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MindMap">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MindMap</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaStream">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaStream</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#BookmarkFolder">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#BookmarkFolder</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FilesystemImage">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FilesystemImage</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HardDiskPartition">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HardDiskPartition</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Cursor">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Cursor</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Bookmark">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Bookmark</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DeletedResource">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DeletedResource</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Website">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Website</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#WebHistory">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#WebHistory</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Note">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Note</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareCategory">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareCategory</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareApplication">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareApplication</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Orientation">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Orientation</a>
  <a href="http://www.tracker-project.org/ontologies/poi#ObjectOfInterest">http://www.tracker-project.org/ontologies/poi#ObjectOfInterest</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Equipment">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Equipment</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HelpDocument">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HelpDocument</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterest">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterest</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterestContent">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterestContent</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MimePart">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MimePart</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Multipart">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Multipart</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Message">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Message</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Email">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Email</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Attachment">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Attachment</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailAccount">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailAccount</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailboxDataObject">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailboxDataObject</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MessageHeader">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MessageHeader</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#IMMessage">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#IMMessage</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Conversation">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Conversation</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#CommunicationChannel">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#CommunicationChannel</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PermanentChannel">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PermanentChannel</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#TransientChannel">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#TransientChannel</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Call">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Call</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#VOIPCall">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#VOIPCall</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailFolder">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailFolder</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessage">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessage</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#SMSMessage">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#SMSMessage</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessageFolder">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessageFolder</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#DeliveryStatus">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#DeliveryStatus</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#ReportReadStatus">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#ReportReadStatus</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MMSMessage">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MMSMessage</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#UnionParentClass">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#UnionParentClass</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifier">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifier</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttachmentEncoding">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttachmentEncoding</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#EventStatus">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#EventStatus</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceFrequency">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceFrequency</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attachment">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attachment</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AccessClassification">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AccessClassification</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarDataObject">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarDataObject</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#JournalStatus">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#JournalStatus</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifierRange">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifierRange</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeOrOrganizer">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeOrOrganizer</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AlarmAction">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AlarmAction</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceRule">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceRule</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TodoStatus">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TodoStatus</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimeTransparency">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimeTransparency</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalTimeEntity">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalTimeEntity</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarScale">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarScale</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeRole">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeRole</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#BydayRulePart">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#BydayRulePart</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Weekday">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Weekday</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Trigger">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Trigger</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyType">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyType</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarUserType">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarUserType</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#ParticipationStatus">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#ParticipationStatus</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RequestStatus">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RequestStatus</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalDateTime">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalDateTime</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimezoneObservance">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimezoneObservance</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Organizer">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Organizer</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attendee">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attendee</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalPeriod">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalPeriod</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Calendar">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Calendar</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyPeriod">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyPeriod</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TriggerRelation">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TriggerRelation</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Alarm">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Alarm</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Event">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Event</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Todo">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Todo</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Freebusy">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Freebusy</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Journal">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Journal</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Timezone">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Timezone</a>
  <a href="http://www.tracker-project.org/temp/scal#Calendar">http://www.tracker-project.org/temp/scal#Calendar</a>
  <a href="http://www.tracker-project.org/temp/scal#CalendarItem">http://www.tracker-project.org/temp/scal#CalendarItem</a>
  <a href="http://www.tracker-project.org/temp/scal#TransparencyValues">http://www.tracker-project.org/temp/scal#TransparencyValues</a>
  <a href="http://www.tracker-project.org/temp/scal#Attendee">http://www.tracker-project.org/temp/scal#Attendee</a>
  <a href="http://www.tracker-project.org/temp/scal#AttendanceStatus">http://www.tracker-project.org/temp/scal#AttendanceStatus</a>
  <a href="http://www.tracker-project.org/temp/scal#AttendeeRole">http://www.tracker-project.org/temp/scal#AttendeeRole</a>
  <a href="http://www.tracker-project.org/temp/scal#RSVPValues">http://www.tracker-project.org/temp/scal#RSVPValues</a>
  <a href="http://www.tracker-project.org/temp/scal#CalendarUserType">http://www.tracker-project.org/temp/scal#CalendarUserType</a>
  <a href="http://www.tracker-project.org/temp/scal#Event">http://www.tracker-project.org/temp/scal#Event</a>
  <a href="http://www.tracker-project.org/temp/scal#Todo">http://www.tracker-project.org/temp/scal#Todo</a>
  <a href="http://www.tracker-project.org/temp/scal#Journal">http://www.tracker-project.org/temp/scal#Journal</a>
  <a href="http://www.tracker-project.org/temp/scal#EventStatus">http://www.tracker-project.org/temp/scal#EventStatus</a>
  <a href="http://www.tracker-project.org/temp/scal#TodoStatus">http://www.tracker-project.org/temp/scal#TodoStatus</a>
  <a href="http://www.tracker-project.org/temp/scal#JournalStatus">http://www.tracker-project.org/temp/scal#JournalStatus</a>
  <a href="http://www.tracker-project.org/temp/scal#CalendarAlarm">http://www.tracker-project.org/temp/scal#CalendarAlarm</a>
  <a href="http://www.tracker-project.org/temp/scal#TimePoint">http://www.tracker-project.org/temp/scal#TimePoint</a>
  <a href="http://www.tracker-project.org/temp/scal#AccessLevel">http://www.tracker-project.org/temp/scal#AccessLevel</a>
  <a href="http://www.tracker-project.org/temp/scal#RecurrenceRule">http://www.tracker-project.org/temp/scal#RecurrenceRule</a>
  <a href="http://www.semanticdesktop.org/ontologies/2007/05/10/nid3#ID3Audio">http://www.semanticdesktop.org/ontologies/2007/05/10/nid3#ID3Audio</a>
  <a href="http://www.tracker-project.org/temp/nmm#MusicPiece">http://www.tracker-project.org/temp/nmm#MusicPiece</a>
  <a href="http://www.tracker-project.org/temp/nmm#MusicAlbum">http://www.tracker-project.org/temp/nmm#MusicAlbum</a>
  <a href="http://www.tracker-project.org/temp/nmm#MusicAlbumDisc">http://www.tracker-project.org/temp/nmm#MusicAlbumDisc</a>
  <a href="http://www.tracker-project.org/temp/nmm#SynchronizedText">http://www.tracker-project.org/temp/nmm#SynchronizedText</a>
  <a href="http://www.tracker-project.org/temp/nmm#Video">http://www.tracker-project.org/temp/nmm#Video</a>
  <a href="http://www.tracker-project.org/temp/nmm#Artist">http://www.tracker-project.org/temp/nmm#Artist</a>
  <a href="http://www.tracker-project.org/temp/nmm#Playlist">http://www.tracker-project.org/temp/nmm#Playlist</a>
  <a href="http://www.tracker-project.org/temp/nmm#ImageList">http://www.tracker-project.org/temp/nmm#ImageList</a>
  <a href="http://www.tracker-project.org/temp/nmm#Photo">http://www.tracker-project.org/temp/nmm#Photo</a>
  <a href="http://www.tracker-project.org/temp/nmm#Flash">http://www.tracker-project.org/temp/nmm#Flash</a>
  <a href="http://www.tracker-project.org/temp/nmm#MeteringMode">http://www.tracker-project.org/temp/nmm#MeteringMode</a>
  <a href="http://www.tracker-project.org/temp/nmm#WhiteBalance">http://www.tracker-project.org/temp/nmm#WhiteBalance</a>
  <a href="http://www.tracker-project.org/temp/nmm#RadioStation">http://www.tracker-project.org/temp/nmm#RadioStation</a>
  <a href="http://www.tracker-project.org/temp/nmm#DigitalRadio">http://www.tracker-project.org/temp/nmm#DigitalRadio</a>
  <a href="http://www.tracker-project.org/temp/nmm#AnalogRadio">http://www.tracker-project.org/temp/nmm#AnalogRadio</a>
  <a href="http://www.tracker-project.org/temp/nmm#RadioModulation">http://www.tracker-project.org/temp/nmm#RadioModulation</a>
  <a href="http://www.tracker-project.org/temp/mto#TransferElement">http://www.tracker-project.org/temp/mto#TransferElement</a>
  <a href="http://www.tracker-project.org/temp/mto#Transfer">http://www.tracker-project.org/temp/mto#Transfer</a>
  <a href="http://www.tracker-project.org/temp/mto#UploadTransfer">http://www.tracker-project.org/temp/mto#UploadTransfer</a>
  <a href="http://www.tracker-project.org/temp/mto#DownloadTransfer">http://www.tracker-project.org/temp/mto#DownloadTransfer</a>
  <a href="http://www.tracker-project.org/temp/mto#SyncTransfer">http://www.tracker-project.org/temp/mto#SyncTransfer</a>
  <a href="http://www.tracker-project.org/temp/mto#State">http://www.tracker-project.org/temp/mto#State</a>
  <a href="http://www.tracker-project.org/temp/mto#TransferMethod">http://www.tracker-project.org/temp/mto#TransferMethod</a>
  <a href="http://www.tracker-project.org/temp/mlo#GeoLocation">http://www.tracker-project.org/temp/mlo#GeoLocation</a>
  <a href="http://www.tracker-project.org/temp/mlo#GeoPoint">http://www.tracker-project.org/temp/mlo#GeoPoint</a>
  <a href="http://www.tracker-project.org/temp/mlo#GeoSphere">http://www.tracker-project.org/temp/mlo#GeoSphere</a>
  <a href="http://www.tracker-project.org/temp/mlo#GeoBoundingBox">http://www.tracker-project.org/temp/mlo#GeoBoundingBox</a>
  <a href="http://www.tracker-project.org/temp/mlo#LocationBoundingBox">http://www.tracker-project.org/temp/mlo#LocationBoundingBox</a>
  <a href="http://www.tracker-project.org/temp/mlo#Route">http://www.tracker-project.org/temp/mlo#Route</a>
  <a href="http://www.tracker-project.org/temp/mlo#LandmarkCategory">http://www.tracker-project.org/temp/mlo#LandmarkCategory</a>
  <a href="http://www.tracker-project.org/temp/mlo#Landmark">http://www.tracker-project.org/temp/mlo#Landmark</a>
  <a href="http://www.tracker-project.org/temp/mlo#PointOfInterest">http://www.tracker-project.org/temp/mlo#PointOfInterest</a>
  <a href="http://www.tracker-project.org/temp/mfo#FeedElement">http://www.tracker-project.org/temp/mfo#FeedElement</a>
  <a href="http://www.tracker-project.org/temp/mfo#FeedChannel">http://www.tracker-project.org/temp/mfo#FeedChannel</a>
  <a href="http://www.tracker-project.org/temp/mfo#FeedMessage">http://www.tracker-project.org/temp/mfo#FeedMessage</a>
  <a href="http://www.tracker-project.org/temp/mfo#Enclosure">http://www.tracker-project.org/temp/mfo#Enclosure</a>
  <a href="http://www.tracker-project.org/temp/mfo#FeedSettings">http://www.tracker-project.org/temp/mfo#FeedSettings</a>
  <a href="http://www.tracker-project.org/temp/mfo#Action">http://www.tracker-project.org/temp/mfo#Action</a>
  <a href="http://www.tracker-project.org/temp/mfo#FeedType">http://www.tracker-project.org/temp/mfo#FeedType</a>
  <a href="http://www.tracker-project.org/temp/mtp#ScanType">http://www.tracker-project.org/temp/mtp#ScanType</a>
  <a href="http://www.tracker-project.org/ontologies/tracker#Volume">http://www.tracker-project.org/ontologies/tracker#Volume</a>
  <a href="http://www.tracker-project.org/temp/slo#LandmarkCategory">http://www.tracker-project.org/temp/slo#LandmarkCategory</a>
  <a href="http://www.tracker-project.org/temp/slo#Landmark">http://www.tracker-project.org/temp/slo#Landmark</a>
  <a href="http://www.tracker-project.org/temp/slo#GeoLocation">http://www.tracker-project.org/temp/slo#GeoLocation</a>
  <a href="http://www.tracker-project.org/temp/slo#Route">http://www.tracker-project.org/temp/slo#Route</a>
  <a href="http://www.tracker-project.org/ontologies/osinfo#Installer">http://www.tracker-project.org/ontologies/osinfo#Installer</a>
</p>
</div>
</li>

<li><span class="done DONE">DONE</span> tracker-sparql -q "SELECT ?prefix ?ns WHERE {<br  /><div class="outline-text-5" id="text-5-0-1-2">
<p>
   &gt;                     ?ns a tracker:Namespace ;
   &gt;                     tracker:prefix ?prefix
   &gt;                 }"
Results:
  xsd, <a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>#
  rdf, <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns">http://www.w3.org/1999/02/22-rdf-syntax-ns</a>#
  rdfs, <a href="http://www.w3.org/2000/01/rdf-schema">http://www.w3.org/2000/01/rdf-schema</a>#
  tracker, <a href="http://www.tracker-project.org/ontologies/tracker">http://www.tracker-project.org/ontologies/tracker</a>#
  nrl, <a href="http://www.semanticdesktop.org/ontologies/2007/08/15/nrl">http://www.semanticdesktop.org/ontologies/2007/08/15/nrl</a>#
  dc, <a href="http://purl.org/dc/elements/1.1/">http://purl.org/dc/elements/1.1/</a>
  nie, <a href="http://www.semanticdesktop.org/ontologies/2007/01/19/nie">http://www.semanticdesktop.org/ontologies/2007/01/19/nie</a>#
  nao, <a href="http://www.semanticdesktop.org/ontologies/2007/08/15/nao">http://www.semanticdesktop.org/ontologies/2007/08/15/nao</a>#
  nco, <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nco">http://www.semanticdesktop.org/ontologies/2007/03/22/nco</a>#
  nfo, <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nfo">http://www.semanticdesktop.org/ontologies/2007/03/22/nfo</a>#
  poi, <a href="http://www.tracker-project.org/ontologies/poi">http://www.tracker-project.org/ontologies/poi</a>#
  nmo, <a href="http://www.semanticdesktop.org/ontologies/2007/03/22/nmo">http://www.semanticdesktop.org/ontologies/2007/03/22/nmo</a>#
  ncal, <a href="http://www.semanticdesktop.org/ontologies/2007/04/02/ncal">http://www.semanticdesktop.org/ontologies/2007/04/02/ncal</a>#
  scal, <a href="http://www.tracker-project.org/temp/scal">http://www.tracker-project.org/temp/scal</a>#
  nid3, <a href="http://www.semanticdesktop.org/ontologies/2007/05/10/nid3">http://www.semanticdesktop.org/ontologies/2007/05/10/nid3</a>#
  nmm, <a href="http://www.tracker-project.org/temp/nmm">http://www.tracker-project.org/temp/nmm</a>#
  mto, <a href="http://www.tracker-project.org/temp/mto">http://www.tracker-project.org/temp/mto</a>#
  mlo, <a href="http://www.tracker-project.org/temp/mlo">http://www.tracker-project.org/temp/mlo</a>#
  mfo, <a href="http://www.tracker-project.org/temp/mfo">http://www.tracker-project.org/temp/mfo</a>#
  mtp, <a href="http://www.tracker-project.org/temp/mtp">http://www.tracker-project.org/temp/mtp</a>#
  fts, <a href="http://www.tracker-project.org/ontologies/fts">http://www.tracker-project.org/ontologies/fts</a>#
  slo, <a href="http://www.tracker-project.org/temp/slo">http://www.tracker-project.org/temp/slo</a>#
  osinfo, <a href="http://www.tracker-project.org/ontologies/osinfo">http://www.tracker-project.org/ontologies/osinfo</a>#
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-5-0-2" class="outline-4">
<h4 id="sec-5-0-2"><span class="section-number-4">5.0.2</span> CONSTRUCT</h4>
<div class="outline-text-4" id="text-5-0-2">
<p>
"The CONSTRUCT query form returns a single RDF graph
specified by a graph template. The result is an RDF graph
formed by taking each query solution in the solution
sequence, substituting for the variables in the graph
template, and combining the triples into a single RDF
graph by set union."
</p>
<div class="org-src-container">

<pre class="src src-sparql">CONSTRUCT {
    where xk:role ("?chapel" "?leader")
    owl:Exclusion "?anti-chapel"
    , owl:Related "?chancel"
    , owl:Members ("?altar" "?choir")
    }
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> raptor&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="parser">parser</span></span></h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> <span class="todo TODO">TODO</span> define an interactive function to run rapper on a region</h3>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> man raptor</h3>
<div class="outline-text-3" id="text-6-2">
</div><div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> Raptor RDF Syntax Library - Raptor RDF parser utility&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="raptor">raptor</span></span></h4>
<div class="outline-text-4" id="text-6-2-1">
</div><ol class="org-ol"><li>NAME<br  /><div class="outline-text-5" id="text-6-2-1-1">
<p>
rapper  Raptor RDF parsing and serializing utility
</p>
</div>
</li>

<li>SYNOPSIS<br  /><div class="outline-text-5" id="text-6-2-1-2">
<p>
rapper [OPTIONS] INPUT-URI [INPUT-BASE-URI]
</p>
</div>
</li>

<li>EXAMPLE<br  /><div class="outline-text-5" id="text-6-2-1-3">
<p>
rapper -o ntriples <a href="http://planetrdf.com/guide/rss.rdf">http://planetrdf.com/guide/rss.rdf</a>
rapper -i rss-tag-soup -o rss-1.0 pile-of-rss.xml
     <a href="http://example.org/base/">http://example.org/base/</a> 
rapper &#x2013;count <a href="http://example.org/index.rdf">http://example.org/index.rdf</a>
</p>
</div>
</li>

<li>DESCRIPTION<br  /><div class="outline-text-5" id="text-6-2-1-4">
<p>
The rapper utility allows parsing of RDF content by the
Raptor RDF parser toolkit emitting the results as RDF
triples in a choice of syntaxes. The INPUT-URI can be a
file name, - for standard input or if Raptor is built
with a WWW retrieval library, a general URI. The optional
INPUT-BASE-URI is used as the document parser base URI if
present otherwise defaults to the INPUT-URI. A value of
- means no base URI.
</p>
</div>
</li>

<li>OPTIONS<br  /><div class="outline-text-5" id="text-6-2-1-5">
<p>
rapper uses the usual GNU command line syntax, with long
options starting with two dashes (-) if supported by
the getopt<sub>long</sub> function. Otherwise the short options are
only available.
</p>

<p>
h, help
</p>

<p>
Show a summary of the options.
</p>

<p>
i, input FORMAT
</p>

<p>
Set the input FORMAT to one of rdfxml (RDF/XML,
default), ntriples (N-Triples, see below), turtle
(Turtle, see below) or rss-tag-soup (RSS Tag Soup). The
RSS Tag Soup parser can turn the many XML RSS formats and
Atom 0.3 into RDF triples.
</p>

<p>
The list of parsers depends on how libraptor(3) was
built. The list of supported parsers is given in the help
summary given by h.
</p>

<p>
I, input-uri URI
</p>

<p>
Set the input/parser base URI or use value - for no
base. The default is the INPUT-URI argument value.
</p>

<p>
o, output FORMAT
</p>

<p>
Set the output FORMAT to ntriples (N-Triples, default),
rdfxml (RDF/XML), rdfxml-abbrev (RDF/XML with
abbreviations) or rss-1.0 (RSS 1.0, also an RDF/XML
syntax).
</p>

<p>
The list of serializers depends on how libraptor(3) was
built. The list of supported serializers is given in the
help summary given by h.
</p>

<p>
O, output-uri URI
</p>

<p>
Set the output/serializer base URI or use value - for
no base. The default is the input base uri, either set by
the argument INPUT-BASE-URI or via options I,
input-uri URI
</p>

<p>
c, count
</p>

<p>
Only count the triples and produce no other output.
</p>

<p>
e, ignore-errors
</p>

<p>
Ignore errors, do not emit the messages and try to
continue parsing.
</p>

<p>
f, feature FEATURE[=VALUE]
</p>

<p>
Set a parser or serializer feature FEATURE to a value, or
to 1 if VALUE is omitted, Use f help to get lists of
valid parser and serializer features.
</p>

<p>
If the form f xmlns:prefix="uri" is used, the prefix
and namespace uri given will be set for serializing. The
syntax matches XML in that either or both of prefix or
uri can be omitted.
</p>

<p>
g, guess
</p>

<p>
Guess the parser to use from the source-URI rather than
use the i FORMAT.
</p>

<p>
q, quiet
</p>

<p>
No extra information messages.
</p>

<p>
r, replace-newlines
</p>

<p>
Replace newlines in multi-line literals with spaces.
</p>

<p>
show-graphs
</p>

<p>
Print graph names (URIs) as they are seen in the input. This only has
a meaning for parsers that support graph names such as the TRiG
parser.
</p>

<p>
show-namespaces
</p>

<p>
Print namespaces as they are seen in the input.
</p>

<p>
t, trace
</p>

<p>
Print URIs retrieved during parsing. Especially useful
for monitoring what the guess and GRDDL parsers are
doing.
</p>

<p>
w, ignore-warnings
</p>

<p>
Ignore warnings, do not emit the messages.
</p>

<p>
v, version
</p>

<p>
Print the raptor version and exit.  
</p>
</div>
</li>

<li>EXAMPLES<br  /><div class="outline-text-5" id="text-6-2-1-6">
<p>
rapper -q -i ntriples -o rdfxml 
-f xmlns:rss="<a href="http://purl.org/rss/1.0/">http://purl.org/rss/1.0/</a>" 
-f xmlns:ex="<a href="http://example.org/">http://example.org/</a>" 
          tests/test.nt
</p>

<p>
rapper -q -o rdfxml 
-f xmlns:rdfs="<a href="http://www.w3.org/2000/01/rdf-schema">http://www.w3.org/2000/01/rdf-schema</a>#" 
          tests/rdf-schema.rdf 
          <a href="http://www.w3.org/2000/01/rdf-schema">http://www.w3.org/2000/01/rdf-schema</a>#
</p>
</div>
</li>

<li>Examples<br  /><div class="outline-text-5" id="text-6-2-1-7">
<p>
rapper -q -i ntriples -o rdfxml 
       -f xmlns:rss="<a href="http://purl.org/rss/1.0/">http://purl.org/rss/1.0/</a>"
       -f xmlns:ex="<a href="http://example.org/">http://example.org/</a>" tests/test.nt
</p>

<p>
rapper -q -o rdfxml 
       -f xmlns:rdfs="<a href="http://www.w3.org/2000/01/rdf-schema">http://www.w3.org/2000/01/rdf-schema</a>#" tests/rdf-schema.rdf 
          <a href="http://www.w3.org/2000/01/rdf-schema">http://www.w3.org/2000/01/rdf-schema</a>#
</p>

<div class="org-src-container">

<pre class="src src-elisp">(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">rapper</span>)
(interactive)
(shell-command rapper)
(insert results at point)
(append-results-to-buffer-or-file)
</pre>
</div>
</div>
</li></ol>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> rdf.sh (perl)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="perl">perl</span></span></h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">

<pre class="src src-elisp">(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">rdf.sh</span>)
(interactive)
(shell-command rdf.sh)
(insert results at point)
(append-results-to-buffer-or-file)
</pre>
</div>
<div class="org-src-container">

<pre class="src src-turtle">&lt;http://sebastian.tramp.name/Projects/rdf.sh&gt; a :Project;
    &lt;http://purl.org/dc/terms/updated&gt; "2013-05-05T17:52:26Z"^^xsd:dateTime;
	 :description "A multi-tool shell script for doing Semantic Web jobs on the command line.";
	 :developer &lt;http://sebastian.tramp.name&gt;;
	 :download-page &lt;https://github.com/seebi/rdf.sh/archives/master&gt;;
	 :homepage &lt;https://github.com/seebi/rdf.sh/&gt;;
	 :programming-language "Shell";
	 :name "rdf.sh".
</pre>
</div>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Reification&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-1">
<p>
WN: The noun reification has 2 senses (no senses from
tagged texts)
</p>
</div>
<div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1"><span class="section-number-4">7.1.1</span> 1. hypostatization, hypostatisation, reification</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
&#x2013; (regarding something abstract as a material thing)
</p>
</div>
</div>
<div id="outline-container-sec-7-1-2" class="outline-4">
<h4 id="sec-7-1-2"><span class="section-number-4">7.1.2</span> 2. depersonalization, depersonalisation, reification</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
&#x2013; (representing a human being as a physical thing
deprived of personal qualities or individuality;
"according to Marx, treating labor as a commodity
exemplified the reification of the individual")
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Virtualisation and network-attached storage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Ubiquitous and Organic Error Correction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-3">
<p>
Are error correcting algorithms and heuristics organic to
our observations?  Are they built into the math we use to
describe reality, automatically and without conscious
purpose? Do these error correcting algorithms enhance or
obscure our vision?  Do they need revision themselves, in
a sort of recursive way? Do our corrections require
corrections? Who watches the watchers?
</p>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Some Coordinate Terms&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-4">
</div><div id="outline-container-sec-7-4-1" class="outline-4">
<h4 id="sec-7-4-1"><span class="section-number-4">7.4.1</span> bathysphere</h4>
</div>
<div id="outline-container-sec-7-4-2" class="outline-4">
<h4 id="sec-7-4-2"><span class="section-number-4">7.4.2</span> bubble</h4>
</div>
<div id="outline-container-sec-7-4-3" class="outline-4">
<h4 id="sec-7-4-3"><span class="section-number-4">7.4.3</span> economic bubble</h4>
</div>
<div id="outline-container-sec-7-4-4" class="outline-4">
<h4 id="sec-7-4-4"><span class="section-number-4">7.4.4</span> spelunk</h4>
</div>
<div id="outline-container-sec-7-4-5" class="outline-4">
<h4 id="sec-7-4-5"><span class="section-number-4">7.4.5</span> smuggle</h4>
</div>
<div id="outline-container-sec-7-4-6" class="outline-4">
<h4 id="sec-7-4-6"><span class="section-number-4">7.4.6</span> sub</h4>
</div>
<div id="outline-container-sec-7-4-7" class="outline-4">
<h4 id="sec-7-4-7"><span class="section-number-4">7.4.7</span> submarine</h4>
</div>
<div id="outline-container-sec-7-4-8" class="outline-4">
<h4 id="sec-7-4-8"><span class="section-number-4">7.4.8</span> subordinate</h4>
</div>
<div id="outline-container-sec-7-4-9" class="outline-4">
<h4 id="sec-7-4-9"><span class="section-number-4">7.4.9</span> submariner</h4>
</div>
<div id="outline-container-sec-7-4-10" class="outline-4">
<h4 id="sec-7-4-10"><span class="section-number-4">7.4.10</span> super</h4>
</div>
<div id="outline-container-sec-7-4-11" class="outline-4">
<h4 id="sec-7-4-11"><span class="section-number-4">7.4.11</span> superhero</h4>
</div>
<div id="outline-container-sec-7-4-12" class="outline-4">
<h4 id="sec-7-4-12"><span class="section-number-4">7.4.12</span> supervene</h4>
</div>
<div id="outline-container-sec-7-4-13" class="outline-4">
<h4 id="sec-7-4-13"><span class="section-number-4">7.4.13</span> supervise</h4>
</div>
<div id="outline-container-sec-7-4-14" class="outline-4">
<h4 id="sec-7-4-14"><span class="section-number-4">7.4.14</span> superintend</h4>
</div>
<div id="outline-container-sec-7-4-15" class="outline-4">
<h4 id="sec-7-4-15"><span class="section-number-4">7.4.15</span> supermarine</h4>
</div>
<div id="outline-container-sec-7-4-16" class="outline-4">
<h4 id="sec-7-4-16"><span class="section-number-4">7.4.16</span> burst</h4>
</div>
<div id="outline-container-sec-7-4-17" class="outline-4">
<h4 id="sec-7-4-17"><span class="section-number-4">7.4.17</span> implode</h4>
</div>
<div id="outline-container-sec-7-4-18" class="outline-4">
<h4 id="sec-7-4-18"><span class="section-number-4">7.4.18</span> cut off the air</h4>
</div>
<div id="outline-container-sec-7-4-19" class="outline-4">
<h4 id="sec-7-4-19"><span class="section-number-4">7.4.19</span> sever the line</h4>
</div>
<div id="outline-container-sec-7-4-20" class="outline-4">
<h4 id="sec-7-4-20"><span class="section-number-4">7.4.20</span> cut the line</h4>
</div>
<div id="outline-container-sec-7-4-21" class="outline-4">
<h4 id="sec-7-4-21"><span class="section-number-4">7.4.21</span> transparency</h4>
</div>
<div id="outline-container-sec-7-4-22" class="outline-4">
<h4 id="sec-7-4-22"><span class="section-number-4">7.4.22</span> bubble</h4>
</div>
<div id="outline-container-sec-7-4-23" class="outline-4">
<h4 id="sec-7-4-23"><span class="section-number-4">7.4.23</span> transparent bubble</h4>
</div>
<div id="outline-container-sec-7-4-24" class="outline-4">
<h4 id="sec-7-4-24"><span class="section-number-4">7.4.24</span> 'ship of the imagination'</h4>
</div>
<div id="outline-container-sec-7-4-25" class="outline-4">
<h4 id="sec-7-4-25"><span class="section-number-4">7.4.25</span> isolation</h4>
</div>
<div id="outline-container-sec-7-4-26" class="outline-4">
<h4 id="sec-7-4-26"><span class="section-number-4">7.4.26</span> broken contact with the outside</h4>
</div>
<div id="outline-container-sec-7-4-27" class="outline-4">
<h4 id="sec-7-4-27"><span class="section-number-4">7.4.27</span> containment</h4>
</div>
<div id="outline-container-sec-7-4-28" class="outline-4">
<h4 id="sec-7-4-28"><span class="section-number-4">7.4.28</span> rebellion</h4>
</div>
</div>
<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> Interface&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-5">
</div><div id="outline-container-sec-7-5-1" class="outline-4">
<h4 id="sec-7-5-1"><span class="section-number-4">7.5.1</span> Appearance</h4>
<div class="outline-text-4" id="text-7-5-1">
<ul class="org-ul">
<li>Themes (aka Workspace) (Widget Style, Desktop
theme, Cursor theme) 
</li>

<li>Style (Window decoration, Splash screen, Gtk) 
</li>

<li>Colors 
</li>

<li>Font 
</li>

<li>Emoticons 
</li>
</ul>

<p>
(Remark: Jens Reuterberg proposed some kind of
mega theme at the KDE forum, which sounds pretty
nice. But all topics need some categories to
keep the navigation consistent. Another point
for discussion is where Widget Style belongs to:
Theme or Style? Again, we should take care of
balancing the structure.)
</p>
</div>
</div>

<div id="outline-container-sec-7-5-2" class="outline-4">
<h4 id="sec-7-5-2"><span class="section-number-4">7.5.2</span> Workspace</h4>
<div class="outline-text-4" id="text-7-5-2">
<ul class="org-ul">
<li>Window behavior (Desktop effects, Screen
Edges, Launch Feedback, Task switcher, KWin
Scripts, Window Rules) 
</li>

<li>Notification (Applications, System Bell) 
</li>

<li>Shortcuts and Gestures (Custom, Standard,
Global) 
</li>

<li>Activities 
</li>
</ul>

<p>
(Remark: Cant we just drop the beep support
(aka System Bell)? Who owns and want to use an
in-built speaker instead of jingles?)
</p>
</div>
</div>

<div id="outline-container-sec-7-5-3" class="outline-4">
<h4 id="sec-7-5-3"><span class="section-number-4">7.5.3</span> Personalization</h4>
<div class="outline-text-4" id="text-7-5-3">
<ul class="org-ul">
<li>Account Details (Password, Path, Wallet) 
</li>

<li>Regional Settings (aka Locale)
(Country/Region, Language, Spell Checker) 
</li>

<li>Standard Programs (Default Applications, File
Association, Desktop Search) 
</li>

<li>Accessibility 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-5-4" class="outline-4">
<h4 id="sec-7-5-4"><span class="section-number-4">7.5.4</span> Networking</h4>
<div class="outline-text-4" id="text-7-5-4">
<ul class="org-ul">
<li>(Network) Settings (Proxy, Preferences,
Certificates (aka SSL Preferences), +Network
Manager) 
</li>

<li>Connectivity (Accounts aka (PIM) Personal
Information, Instant Messaging and VoIP,
Social Desktop, Web Shortcuts) 
</li>

<li>Sharing 
</li>
</ul>

<p>
(Remark: Network Manager settings should get an
own KCM, which is being in preparation right
now. Secondly, it is questionable if PIM
accounts should have a central configuration
since its applied in Kontact only. And,
apparently from the study results too, the
organization of web shortcuts is difficult and
could be improved by another wording.)
</p>
</div>
</div>

<div id="outline-container-sec-7-5-5" class="outline-4">
<h4 id="sec-7-5-5"><span class="section-number-4">7.5.5</span> Hardware</h4>
<div class="outline-text-4" id="text-7-5-5">
<ul class="org-ul">
<li>Input Devices (including Keyboard, Mouse,
Touchpad, Joystick, Remote Control, Camera) 
</li>

<li>Display and Monitor (including Gamma) 
</li>

<li>Removable Devices 
</li>

<li>Printers 
</li>

<li>Multimedia 
</li>

<li>Device Actions 
</li>

<li>Power management 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-5-6" class="outline-4">
<h4 id="sec-7-5-6"><span class="section-number-4">7.5.6</span> Software</h4>
<div class="outline-text-4" id="text-7-5-6">
<ul class="org-ul">
<li>Bodega 
</li>

<li>Adobe Flash Player 
</li>
</ul>

<p>
(Remark: Apparently, Bodega is just an idea for
future improvements. The topic could be extended
by the distribution specific software
management.)
</p>

<p>
Based on this list we will outline an idea how to
get both simple access to a module and the full
set of features without introducing a further
navigation. Join the discussion at the KDE forum!
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> XPath&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="fn">fn</span></span></h3>
<div class="outline-text-3" id="text-7-6">
<p>
[Definition: XPath operates on the abstract,
logical structure of an XML document, rather than
its surface syntax. This logical structure, known
as the data model, is defined in [XQuery 1.0 and
XPath 2.0 Data Model (Second Edition)].]
</p>

<p>
XPath is designed to be embedded in a host
language such as [XSL Transformations (XSLT)
Version 2.0 (Second Edition)] or [XQuery 1.0: An
XML Query Language (Second Edition)]. XPath has a
natural subset that can be used for matching
(testing whether or not a node matches a pattern);
this use of XPath is described in [XSL
Transformations (XSLT) Version 2.0 (Second
Edition)].
</p>

<p>
XQuery Version 1.0 is an extension of XPath
Version 2.0. Any expression that is syntactically
valid and executes successfully in both XPath 2.0
and XQuery 1.0 will return the same result in both
languages. Since these languages are so closely
related, their grammars and language descriptions
are generated from a common source to ensure
consistency, and the editors of these
specifications work together closely.
</p>
</div>

<div id="outline-container-sec-7-6-1" class="outline-4">
<h4 id="sec-7-6-1"><span class="section-number-4">7.6.1</span> IRI is an extention of URI.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h4>
<div class="outline-text-4" id="text-7-6-1">
<p>
URI is still used in documentation for backward compatibility
with the larger corpus of specifications.
</p>

<p>
[Definition: Within this specification, the term
URI refers to a Universal Resource Identifier as
defined in [RFC3986] and extended in [RFC3987]
with the new name IRI.] The term URI has been
retained in preference to IRI to avoid introducing
new names for concepts such as "Base URI" that are
defined or referenced across the whole family of
XML specifications.
</p>



<p>
[Definition: Statically known documents. This is a
mapping from strings onto types. The string
represents the absolute URI of a resource that is
potentially available using the fn:doc
function. The type is the static type of a call to
fn:doc with the given URI as its literal
argument. ] If the argument to fn:doc is a string
literal that is not present in statically known
documents, then the static type of fn:doc is
document-node()?.
</p>

<p>
Note:
</p>

<p>
The purpose of the statically known documents is
to provide static type information, not to
determine which documents are available. A URI
need not be found in the statically known
documents to be accessed using fn:doc.
</p>
</div>
</div>

<div id="outline-container-sec-7-6-2" class="outline-4">
<h4 id="sec-7-6-2"><span class="section-number-4">7.6.2</span> xmlpatterns &#x2013; A tool for running XQuery queries.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h4>
<div class="outline-text-4" id="text-7-6-2">
<ul class="org-ul">
<li>When appearing, any following options are not 
interpreted as switches.
</li>
</ul>
<p>
-help                      Displays this help.
-initial-template &lt;string&gt; The name of the initial template to call as a 
                           Clark Name.
-is-uri                    If specified, all filenames on the command line 
                           are interpreted as URIs instead of a local
                           filenames.
-no-format                 By default output is formatted for readability. 
                           When specified, strict serialization is
                           performed.
-output &lt;local file&gt;       A local file to which the output should be 
                           written. The file is overwritten, or if not
                           exist, created. If absent, stdout is used.
-param &lt;name=value&gt;        Binds an external variable. The value is 
                           directly available using the variable
                           reference: $name.
-version                   Displays version information.
focus &lt;string&gt;             The document to use as focus. Mandatory in case 
                           a stylesheet is used. This option is also
                           affected by the is-uris option.
query/stylesheet &lt;string&gt;  A local filename pointing to the query to run. 
                           If the name ends with .xsl it's assumed to be
                           an XSL-T stylesheet. If it ends with .xq, it's
                           assumed to be an XQuery query. (In other cases
                           it's also assumed to be an XQuery query, but
                           that interpretation may change in a future
                           release of Qt.)
</p>
</div>
</div>

<div id="outline-container-sec-7-6-3" class="outline-4">
<h4 id="sec-7-6-3"><span class="section-number-4">7.6.3</span> XPath is defined</h4>
<div class="outline-text-4" id="text-7-6-3">
<p>
in terms of the data model and the expression context.
</p>
</div>
</div>
<div id="outline-container-sec-7-6-4" class="outline-4">
<h4 id="sec-7-6-4"><span class="section-number-4">7.6.4</span> XPath defines&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h4>
<div class="outline-text-4" id="text-7-6-4">
<p>
two phases of processing called the static
analysis phase and the dynamic evaluation phase
</p>
</div>
<ol class="org-ol"><li>thus<br  /><div class="outline-text-5" id="text-7-6-4-1">
<p>
(((data-model) (expression-context)) 
(xpath) 
((static-analysis-phase) (dynamic-evalution-phase)))
</p>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-7-7" class="outline-3">
<h3 id="sec-7-7"><span class="section-number-3">7.7</span> XDM instance syn value&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-7">
<p>
The term XDM instance is used, synonymously with the term value, to
denote an unconstrained sequence of nodes and/or atomic values in the
data model.
</p>
</div>

<div id="outline-container-sec-7-7-1" class="outline-4">
<h4 id="sec-7-7-1"><span class="section-number-4">7.7.1</span> literal</h4>
<div class="outline-text-4" id="text-7-7-1">
<p>
A literal is a direct syntactic representation of an atomic value.
</p>
</div>
</div>

<div id="outline-container-sec-7-7-2" class="outline-4">
<h4 id="sec-7-7-2"><span class="section-number-4">7.7.2</span> thus</h4>
<div class="outline-text-4" id="text-7-7-2">
<p>
A literal is a direct syntactic representation
of an atomic XDM instance.
</p>

<p>
literal <code>= XDM instance =</code> sequence
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7-8" class="outline-3">
<h3 id="sec-7-8"><span class="section-number-3">7.8</span> NO DUTY == Fish-Eye Door-Good-Mark-Y&#xa0;&#xa0;&#xa0;<span class="tag"><span class="defense">defense</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-8">
</div><div id="outline-container-sec-7-8-1" class="outline-4">
<h4 id="sec-7-8-1"><span class="section-number-4">7.8.1</span> <span class="todo TODO">TODO</span> NO DUTY rules nd-rules&#xa0;&#xa0;&#xa0;<span class="tag"><span class="src">src</span>&#xa0;<span class="debug">debug</span></span></h4>
<div class="outline-text-4" id="text-7-8-1">
<p>
How would this look in prolog|xslt|xpath|spin|sparql?
</p>
<div class="org-src-container">

<pre class="src src-*pseudocode*">(defn test for duty
(no-duty (seq (concat ((Line) (Intense Hand)) 
		      ((Out) (Out)) 
		      ((Door-Good-Mark-Y)))
	 )))
</pre>
</div>
<div class="org-src-container">

<pre class="src src-n3"><span style="color: #98fb98;">:</span><span style="color: #7fffd4;">no-duty</span> <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">disjoint</span> <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">evangelism</span> .
</pre>
</div>
<div class="org-src-container">

<pre class="src src-*pseudocode*">test for (task|todo), 
     if none, ignore
     test for duty
test for duty, 
     if none, reject (task|todo)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7-9" class="outline-3">
<h3 id="sec-7-9"><span class="section-number-3">7.9</span> fundamental limits on signal processing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
</div>
<div id="outline-container-sec-7-10" class="outline-3">
<h3 id="sec-7-10"><span class="section-number-3">7.10</span> error-correction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-10">
</div><div id="outline-container-sec-7-10-1" class="outline-4">
<h4 id="sec-7-10-1"><span class="section-number-4">7.10.1</span> debug</h4>
<div class="outline-text-4" id="text-7-10-1">
<p>
debug is an interactive autoloaded Lisp function.
</p>

<p>
(debug &amp;rest DEBUGGER-ARGS)
</p>

<p>
Enter debugger.  `c' returns from the debugger.
Arguments are mainly for use when this is called from the internals
of the evaluator.
</p>

<p>
You may call with no args, or you may pass nil as the first arg and
any other args you like.  In that case, the list of args after the
first will be printed into the backtrace buffer.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7-11" class="outline-3">
<h3 id="sec-7-11"><span class="section-number-3">7.11</span> relay channel&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
</div>
<div id="outline-container-sec-7-12" class="outline-3">
<h3 id="sec-7-12"><span class="section-number-3">7.12</span> Information rate is the average entropy per symbol.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
</div>
<div id="outline-container-sec-7-13" class="outline-3">
<h3 id="sec-7-13"><span class="section-number-3">7.13</span> .emacs Org yas AC Predict[] Complete&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="elisp">elisp</span></span></h3>
</div>
<div id="outline-container-sec-7-14" class="outline-3">
<h3 id="sec-7-14"><span class="section-number-3">7.14</span> Information theory is based on probability theory and statistics.&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-14">
<p>
:information-theory owl:subproperty ( :probability-theory :statistics ) .
:logarithmic-base owl:subproperty ( :bit :nat :hartley ) .
:logarithmic-base :def """The choice of logarithmic base in the following formulae determines
 the unit of information entropy that is used. The most common unit of
 information is the bit, based on the binary logarithm. Other units
 include the nat, which is based on the natural logarithm, and the
 hartley, which is based on the common logarithm.""" .
</p>
</div>
</div>

<div id="outline-container-sec-7-15" class="outline-3">
<h3 id="sec-7-15"><span class="section-number-3">7.15</span> arithmetization of analysis&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-15">
</div><div id="outline-container-sec-7-15-1" class="outline-4">
<h4 id="sec-7-15-1"><span class="section-number-4">7.15.1</span> axiomatize analysis using properties of the natural numbers</h4>
<div class="outline-text-4" id="text-7-15-1">
</div><ol class="org-ol"><li>(, )-definition of limit<br  /></li>
<li>continuous functions<br  /><ol class="org-ol"><li>infinitesimals<br  /></li></ol>
</li></ol>
</div>
<div id="outline-container-sec-7-15-2" class="outline-4">
<h4 id="sec-7-15-2"><span class="section-number-4">7.15.2</span> Real numbers as cuts of rational numbers</h4>
</div>
<div id="outline-container-sec-7-15-3" class="outline-4">
<h4 id="sec-7-15-3"><span class="section-number-4">7.15.3</span> Real and natural numbers have different cardinalities</h4>
</div>
<div id="outline-container-sec-7-15-4" class="outline-4">
<h4 id="sec-7-15-4"><span class="section-number-4">7.15.4</span> (set-theory) (formal-logic)</h4>
</div>
<div id="outline-container-sec-7-15-5" class="outline-4">
<h4 id="sec-7-15-5"><span class="section-number-4">7.15.5</span> Search for proofs of consistency</h4>
<div class="outline-text-4" id="text-7-15-5">
</div><ol class="org-ol"><li>Result of discovery of paradoxes in informal set theory<br  /></li>
<li>23 Hilbert problems<br  /><ol class="org-ol"><li>Continuum hypothesis (proof consistency of elementary arithmetic)<br  /><ol class="org-ol"><li>Respectively<br  /></li></ol>
</li>
<li>produce a method that could decide<br  /><div class="outline-text-6" id="text-7-15-5-2-2">
<p>
whether a multivariate polynomial equation over the integers has
a solution
</p>
</div>
</li></ol>
</li></ol>
</div>
<div id="outline-container-sec-7-15-6" class="outline-4">
<h4 id="sec-7-15-6"><span class="section-number-4">7.15.6</span> a procedure that would decide,</h4>
<div class="outline-text-4" id="text-7-15-6">
<p>
given a formalized mathematical statement, 
whether the statement is true or false.
</p>
</div>
</div>
<div id="outline-container-sec-7-15-7" class="outline-4">
<h4 id="sec-7-15-7"><span class="section-number-4">7.15.7</span> a proof that every set could be well-ordered</h4>
</div>
<div id="outline-container-sec-7-15-8" class="outline-4">
<h4 id="sec-7-15-8"><span class="section-number-4">7.15.8</span> axiom of choice</h4>
<div class="outline-text-4" id="text-7-15-8">
</div><ol class="org-ol"><li>challenged by discovered paradoxes in naive set theory<br  /><ol class="org-ol"><li>collection of all ordinal numbers cannot form a set<br  /></li></ol>
</li></ol>
</div>
<div id="outline-container-sec-7-15-9" class="outline-4">
<h4 id="sec-7-15-9"><span class="section-number-4">7.15.9</span> axioms for set theory</h4>
</div>
<div id="outline-container-sec-7-15-10" class="outline-4">
<h4 id="sec-7-15-10"><span class="section-number-4">7.15.10</span> axiom of replacement</h4>
</div>
<div id="outline-container-sec-7-15-11" class="outline-4">
<h4 id="sec-7-15-11"><span class="section-number-4">7.15.11</span> limitation of size</h4>
</div>
</div>
<div id="outline-container-sec-7-16" class="outline-3">
<h3 id="sec-7-16"><span class="section-number-3">7.16</span> type-theory (principia-mathematica)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-16">
</div><div id="outline-container-sec-7-16-1" class="outline-4">
<h4 id="sec-7-16-1"><span class="section-number-4">7.16.1</span> urelements</h4>
<div class="outline-text-4" id="text-7-16-1">
</div><ol class="org-ol"><li>not needed<br  /></li></ol>
</div>
</div>
<div id="outline-container-sec-7-17" class="outline-3">
<h3 id="sec-7-17"><span class="section-number-3">7.17</span> forcing used to establish independent results in set theory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
</div>
<div id="outline-container-sec-7-18" class="outline-3">
<h3 id="sec-7-18"><span class="section-number-3">7.18</span> first-order logic cannot control the cardinalities of infinite structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
</div>
<div id="outline-container-sec-7-19" class="outline-3">
<h3 id="sec-7-19"><span class="section-number-3">7.19</span> first-order formalizations of set theory have countable modes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
</div>
<div id="outline-container-sec-7-20" class="outline-3">
<h3 id="sec-7-20"><span class="section-number-3">7.20</span> completeness theorem&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-20">
<p>
completeness theorem, which establishes a correspondence between
syntax and semantics in first-order logic
</p>

<p>
compactness theorem, demonstrating the finitary nature of first-order
logical consequence
incompleteness (in a different meaning of the word) of all
sufficiently strong, effective first-order theories
severe limitations on axiomatic foundations
a consistency proof of any sufficiently strong, effective axiom system
cannot be obtained in the system itself, if the system is consistent,
nor in any weaker system
consistency of arithmetic using a finitistic system together with a
principle of transfinite induction. Gentzen's result introduced the
ideas of cut elimination and proof-theoretic ordinals, which became
key tools in proof theory
consistency of classical arithmetic to that of intutitionistic
arithmetic in higher types
 bijection, injection, and surjection
tudy of computability came to be known as recursion theory
recursive definitions of functions
Turing machines
computable function 
robust enough to admit numerous independent characterizations
oncepts of relative computability
arithmetical hierarchy.
higher-order functionals
At its core, mathematical logic deals with mathematical concepts
expressed using formal logical systems
considering only expressions in a fixed formal language
propositional logic and first-order logic
second-order logic
infinitary logic
intuitionistic logic
First-order logic is a particular formal system of logic. Its syntax
involves only finite expressions as well-formed formulas, while its
semantics are characterized by the limitation of all quantifiers to a
fixed domain of discourse.
Impossible for a set of first-order axioms to characterize the natural
numbers, the real numbers, or any other infinite structure up to
isomorphism
equivalence between semantic and syntactic definitions of logical
consequence in first-order logic
lemma
a set of sentences has a model if and only if every finite subset has
a model
an inconsistent set of formulas must have a finite inconsistent subset
The completeness and compactness theorems allow for sophisticated
analysis of logical consequence in first-order logic and the
development of model theory, and they are a key reason for the
prominence of first-order logic in mathematics.
The first incompleteness theorem states that for any sufficiently
strong, effectively given logical system there exists a statement
which is true but not provable within that system.
or any sufficiently strong, effectively given logical system there
exists a statement which is true but not provable within that system
any sufficiently strong, consistent, effective first-order theory has
models that are not elementarily equivalent
no sufficiently strong, consistent, effective axiom system for
arithmetic can prove its own consistency
allow for formulas to provide an infinite amount of information
include a portion of set theory directly in their semantics
quantifiers may only be nested to finite depths
but formulas may have finite or countably infinite conjunctions and
disjunctions within them
(x=0) :disjoint (x=1) :disjoint (x=2) :disjoint &#x2026;
Higher-order logics allow for quantification not only of elements of
the domain of discourse, but subsets of the domain of discourse, sets
of such subsets, and other objects of higher type
rather than having a separate domain for each higher-type quantifier
to range over, the quantifiers instead range over all objects of the
appropriate type
higher-order logics are more expressive, allowing complete
axiomatizations of structures such as the natural numbers, they do not
satisfy analogues of the completeness and compactness theorems from
first-order logic
less amenable to proof-theoretic analysis
Another type of logics are fixed-point logics that allow inductive
definitions, like one writes for primitive recursive functions
constructive information can be recovered from intuitionistic proofs
describing a cumulative hierarchy of sets
objects such as the set of all sets at the cost of restrictions on its
set-existence axioms
axiom of choice
continuum hypothesis
given a collection of nonempty sets there is a single set C that
contains exactly one element from each set in the collection
large cardinals
determinacy
Here a theory is a set of formulas in a particular formal logic and
signature, while a model is a structure that gives a concrete
interpretation of the theory
Model theory is closely related to universal algebra and algebraic
geometry, although the methods of model theory focus more on logical
considerations than those fields
The set of all models of a particular theory is called an elementary
class; classical model theory seeks to determine the properties of
models in a particular elementary class, or determine whether certain
classes of structures form elementary classes.
The method of quantifier elimination can be used to show that
definable sets in particular theories cannot be too complicated
Tarski (1948) established quantifier elimination for real-closed
fields, a result which also shows the theory of the field of real
numbers is decidable. (He also noted that his methods were equally
applicable to algebraically closed fields of arbitrary
characteristic.) A modern subfield developing from this is concerned
with o-minimal structures.
quantifier elimination for real-closed fields
if a first-order theory in a countable language is categorical in some
uncountable cardinality, i.e. all models of this cardinality are
isomorphic, then it is categorical in all uncountable cardinalities.
</p>
</div>
</div>

<div id="outline-container-sec-7-21" class="outline-3">
<h3 id="sec-7-21"><span class="section-number-3">7.21</span> trivial grammar problem&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-21">
<p>
"a complete theory with less than continuum many nonisomorphic
countable models can have only countably many"
</p>
</div>
</div>
<div id="outline-container-sec-7-22" class="outline-3">
<h3 id="sec-7-22"><span class="section-number-3">7.22</span> robust canonical class of computable functions&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-22">
<p>
a robust, canonical class of computable functions with numerous
independent, equivalent characterizations using Turing machines, 
calculus, and other systems lattice of recursively enumerable sets
Generalized recursion theory extends the ideas of recursion theory to
computations that are no longer necessarily finite study of
computability in higher types hyperarithmetical theory and -recursion
theory unsolvability of the halting problem, a result with far-ranging
implications in both recursion theory and computer science Proof
theory and constructive mathematics Computer science also contributes
to mathematics by developing techniques for the automatic checking or
even finding of proofs, such as automated theorem proving and logic
programming.  automated-theorem-proving logic-programming The area
directors, together with the IETF Chair, form the Internet Engineering
Steering Group (IESG), which is responsible for the overall operation
of the IETF.  The IETF is formally a part of the Internet Society.
</p>
</div>
</div>
<div id="outline-container-sec-7-23" class="outline-3">
<h3 id="sec-7-23"><span class="section-number-3">7.23</span> "rough consensus and running code"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="civil">civil</span>&#xa0;<span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-23">
<p>
Jari Arkko (2013 )<sup><a id="fnr.5" name="fnr.5" class="footref" href="#fn.5">5</a></sup> See also
</p>

<p>
GADS Task Force
Internet Architecture Board
Internet Engineering Steering Group
Internet Research Task Force
Internet standard
Request for Comments
Standardization
</p>

<p>
<a href="http://ietf.org/">http://ietf.org/</a>
</p>
</div>
</div>

<div id="outline-container-sec-7-24" class="outline-3">
<h3 id="sec-7-24"><span class="section-number-3">7.24</span> parsing expression grammar</h3>
<div class="outline-text-3" id="text-7-24">
<p>
 In computer science, a parsing expression grammar, or PEG, is a type
of analytic formal grammar, i.e. it describes a formal language in
terms of a set of rules for recognizing strings in the language. The
formalism was introduced by Bryan Ford in 2004<sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> and is closely
related to the family of top-down parsing languages introduced in the
early 1970s. Syntactically, PEGs also look similar to context-free
grammars (CFGs), but they have a different interpretation: the choice
operator selects the first match in PEG, while it is ambiguous in
CFG. This is closer to how string recognition tends to be done in
practice, e.g. by a recursive descent parser.
It is conjectured that there exist context-free languages that cannot
be parsed by a PEG, but this is not yet proven.
The fundamental difference between context-free grammars and parsing
expression grammars is that the PEG's choice operator is ordered
</p>

<p>
there is more to creation than design
</p>

<p>
The following parsing expression grammar describes the classic non-context-free language \{ a<sup>n</sup> b<sup>n</sup> c<sup>n</sup> : n &ge; 1 \} :
</p>

<p>
S  &amp;(A 'c') 'a'+ B !('a'/'b'/'c')
A  'a' A? 'b'
B  'b' B? 'c'
</p>

<p>
The following recursive rule matches standard C-style if/then/else statements in such a way that the optional "else" clause always binds to the innermost "if", because of the implicit prioritization of the '/' operator. (In a context-free grammar, this construct yields the classic dangling else ambiguity.)
</p>

<p>
S  'if' C 'then' S 'else' S / 'if' C 'then' S
The parsing expression foo &amp;(bar) matches and consumes the text "foo"
but only if it is followed by the text "bar". The parsing expression
foo !(bar) matches the text "foo" but only if it is not followed by
the text "bar". The expression !(a+ b) a matches a single "a" but only
if it is not part of an arbitrarily long sequence of a's followed by a
b.
Any parsing expression grammar can be converted directly into a
recursive descent parser
It is possible to obtain better performance for any parsing expression
grammar by converting its recursive descent parser into a packrat
parser, which always runs in linear time, at the cost of substantially
greater storage space requirements
</p>

<p>
A packrat parser<sup><a id="fnr.3.100" name="fnr.3.100" class="footref" href="#fn.3">3</a></sup> is a form of parser similar to a recursive descent
parser in construction, except that during the parsing process it
memoizes the intermediate results of all invocations of the mutually
recursive parsing functions, ensuring that each parsing function is
only invoked at most once at a given input position. Because of this
memoization, a packrat parser has the ability to parse many
context-free grammars and any parsing expression grammar (including
some that do not represent context-free languages) in linear time
</p>
</div>
</div>

<div id="outline-container-sec-7-25" class="outline-3">
<h3 id="sec-7-25"><span class="section-number-3">7.25</span> Quantification:&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-25">
<p>
A quantifier after a token (such as a character) or group specifies
how often that preceding element is allowed to occur. The most
common quantifiers are the question mark ?, the asterisk *
(derived from the Kleene star), and the plus sign + (Kleene plus).
</p>

<p>
?         The question mark indicates there is zero or one of the preceding element. For example, colou?r matches both "color" and "colour".
</p>
<ul class="org-ul">
<li>The asterisk indicates there is zero or more of the preceding element. For example, ab*c matches "ac", "abc", "abbc", "abbbc", and so on.
</li>
<li>The plus sign indicates there is one or more of the preceding element. For example, ab+c matches "abc", "abbc", "abbbc", and so on, but not "ac".
</li>
</ul>
</div>
<div id="outline-container-sec-7-25-1" class="outline-4">
<h4 id="sec-7-25-1"><span class="section-number-4">7.25.1</span> SeeAlso quantifier elimination</h4>
<div class="outline-text-4" id="text-7-25-1">
<p>
   "eliminate specifications of preceding element occurance"
   "dont ask how many times you have to repeat yourself"
These constructions can be combined to form arbitrarily complex
   expressions, much like one can construct arithmetical expressions
   from numbers and the operations +, , , and 
For example, H(ae?|)ndel and H(a|ae|)ndel are both valid patterns
   which match the same strings as the earlier example, H(|ae?)ndel.
</p>

<p>
Regular expressions describe regular languages in formal language
theory. They have the same expressive power as regular grammars.
</p>

<p>
Given a finite alphabet , the following constants are defined as regular expressions:
</p>

<p>
(empty set)  denoting the set .
(empty string)  denoting the set containing only the "empty" string, which has no characters at all.
(literal character) a in  denoting the set containing only the character a.
</p>

<p>
Given regular expressions R and S, the following operations over them are defined to produce regular expressions:
</p>

<p>
(concatenation) RS denotes the set of strings that can be obtained by concatenating a string in R and a string in S. For example {"ab", "c"}{"d", "ef"} = {"abd", "abef", "cd", "cef"}.
(alternation) R | S denotes the set union of sets described by R and S. For example, if R describes {"ab", "c"} and S describes {"ab", "d", "ef"}, expression R | S describes {"ab", "c", "d", "ef"}.
(Kleene star) R* denotes the smallest superset of set described by R that contains  and is closed under string concatenation. This is the set of all strings that can be made by concatenating any finite number (including zero) of strings from set described by R. For example, {"0","1"}* is the set of all finite binary strings (including the empty string), and {"ab", "c"}* = {, "ab", "c", "abab", "abc", "cab", "cc", "ababab", "abcab", &#x2026; }.
</p>

<p>
To avoid parentheses it is assumed that the Kleene star has the
highest priority, then concatenation and then alternation. If there is
no ambiguity then parentheses may be omitted. For example, (ab)c can
be written as abc, and a|(b(c*)) can be written as a|bc*. Many
textbooks use the symbols , +, or  for alternation instead of the
vertical bar.
</p>

<p>
egular expressions in this sense can express the regular languages,
exactly the class of languages accepted by deterministic finite
automata.
</p>

<p>
ome classes of regular languages can only be described by
deterministic finite automata whose size grows exponentially in the
size of the shortest equivalent regular expressions. 
</p>

<p>
uckily, there is a simple mapping from regular expressions to the more general nondeterministic finite automata (NFAs) that does not lead to such a blowup in size; for this reason NFAs are often used as alternative representations of regular languages. NFAs are a simple variation of the type-3 grammars of the Chomsky hierarchy.<sup><a id="fnr.6" name="fnr.6" class="footref" href="#fn.6">6</a></sup>
</p>

<p>
Finally, it is worth noting that many real-world "regular expression"
engines implement features that cannot be described by the regular
expressions in the sense of formal language theory &#x2026; 
</p>

<p>
The oldest and fastest relies on a result in formal language theory
that allows every nondeterministic finite automaton (NFA) to be
transformed into a deterministic finite automaton (DFA).
</p>

<p>
An alternative approach is to simulate the NFA directly, essentially
building each DFA state on demand and then discarding it at the next
step. This keeps the DFA implicit and avoids the exponential
construction cost, but running cost rises to O(m n).
</p>

<p>
The explicit approach is called the DFA algorithm and the implicit
approach the NFA algorithm. 
</p>

<p>
Regular expression Denial of Service
</p>

<p>
In Arabic scripts, insensitivity to initial, medial, final, and
isolated position may be desired.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7-26" class="outline-3">
<h3 id="sec-7-26"><span class="section-number-3">7.26</span> replete&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-26">
<p>
dict replete
4 definitions found
</p>

<p>
From The Collaborative International Dictionary of English v.0.48 [gcide]:
</p>

<p>
Replete \Re*plete"\, v. t.
   To fill completely, or to satiety. [R.]
   [1913 Webster]
</p>

<p>
From The Collaborative International Dictionary of English v.0.48 [gcide]:
</p>

<p>
Replete \Re*plete"\ (r?-pl?t"), a. [L. repletus, p. p. of
   replere to fill again, fill up; pref. re- re- + plere to
   fill, akin to plenus full: cf. F. replet corpulent. See
   {Plenty}, {Replenish}.]
   Filled again; completely filled; full; charged; abounding.
   "His words replete with guile." &#x2013;Milton.
   [1913 Webster]
</p>

<p>
      When he of wine was replet at his feast. &#x2013;Chaucer.
[1913 Webster]
</p>

<p>
      In heads replete with thoughts of other men. &#x2013;Cowper.
[1913 Webster]
</p>

<p>
From WordNet (r) 3.0 (2006) [wn]:
</p>

<p>
replete
    adj 1: filled to satisfaction with food or drink; "a full
           stomach" [syn: {full}, {replete(p)}]
    2: (followed by `with')deeply filled or permeated; "imbued with
       the spirit of the Reformation"; "words instinct with love";
       "it is replete with misery" [syn: {instinct(p)},
       {replete(p)}]
    v 1: fill to satisfaction; "I am sated" [syn: {satiate}, {sate},
         {replete}, {fill}]
</p>

<p>
From Moby Thesaurus II by Grady Ward, 1.0 [moby-thesaurus]:
</p>

<p>
115 Moby Thesaurus words for "replete":
   SRO, abounding, abundant, affluent, all-sufficing, allayed, ample,
   aplenty, awash, bottomless, bounteous, bountiful, brimful,
   brimming, bulging, bursting, capacity, chock-full, chuck-full,
   cloyed, congested, copious, cram-full, crammed, crowded, diffuse,
   disgusted, effuse, engorged, epidemic, exhaustless, extravagant,
   exuberant, farci, fat, fed-up, fertile, filled, flush, full,
   full of, full to bursting, galore, generous, glutted, gorged,
   in plenty, in quantity, inexhaustible, jaded, jam-packed, jammed,
   lavish, liberal, loaded, luxuriant, many, maximal, much, numerous,
   opulent, overfed, overflowing, overfull, overgorged, oversaturated,
   overstuffed, packed, packed like sardines, plenary, plenitudinous,
   plenteous, plentiful, plenty, prevailing, prevalent, prodigal,
   productive, profuse, profusive, rampant, ready to burst,
   replication, rich, rife, riotous, round, running over, sated,
   satiated, satisfied, saturated, sick of, slaked, soaked,
   standing room only, stuffed, superabundant, supersaturated,
   surfeited, swarming, swollen, teeming, thronged, tired of, topful,
   wealthy, well-found, well-furnished, well-provided, well-stocked,
   wholesale, with a bellyful, with a snootful, with enough of
</p>

<p>
In formal language theory, a grammar (when the context is not given,
often called a formal grammar for clarity) is a set of production
rules for strings in a formal language.
</p>

<p>
The rules describe how to form strings from the language's alphabet
that are valid according to the language's syntax.
</p>

<p>
A grammar does not describe the meaning of the strings or what can be
done with them in whatever contextonly their form.
</p>

<p>
Formal language theory, the discipline which studies formal grammars
and languages, is a branch of applied mathematics.
</p>
</div>
</div>

<div id="outline-container-sec-7-27" class="outline-3">
<h3 id="sec-7-27"><span class="section-number-3">7.27</span> automata theory is a recognizer theory&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-27">
<p>
One of the interesting results of automata theory is that it is not
possible to design a recognizer for certain formal languages.
</p>
</div>
</div>

<div id="outline-container-sec-7-28" class="outline-3">
<h3 id="sec-7-28"><span class="section-number-3">7.28</span> (N,E,P,S) (rewriting-system) (phrase-structure-grammar)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-28">
<p>
The operation of a grammar can be defined in terms of relations on strings:
</p>

<p>
Given a grammar G = (N, &Sigma;, P, S), the binary relation &rArr;<sub>G</sub> (pronounced as "G derives in one step") on strings in (&Sigma; &cup; N)<sup>*</sup> is defined by:
</p>

<p>
x &rArr;<sub>G</sub> y \mbox{ iff } &exist; u, v, p, q &isin; (&Sigma; &cup; N)<sup>*</sup>: (x = upv) &and; (p &rarr; q &isin; P) &and; (y = uqv)
</p>

<p>
the relation {&rArr;<sub>G</sub>}<sup>*</sup> (pronounced as G derives in zero or more steps) is defined as the reflexive transitive closure of &rArr;<sub>G</sub>
a sentential form is a member of (&Sigma; &cup; N)<sup>*</sup> that can be derived in a finite number of steps from the start symbol S; that is, a sentential form is a member of \{ w &isin; (&Sigma; &cup; N)<sup>*</sup> \mid S {&rArr;<sub>G</sub>}<sup>*</sup> w \}. A sentential form that contains no nonterminal symbols (i.e. is a member of &Sigma;<sup>*</sup>) is called a sentence.<sup><a id="fnr.7" name="fnr.7" class="footref" href="#fn.7">7</a></sup>
the language of G, denoted as \boldsymbol{L}(G), is defined as all those sentences that can be derived in a finite number of steps from the start symbol S; that is, the set \{ w &isin; &Sigma;<sup>*</sup> \mid S {&rArr;<sub>G</sub>}<sup>*</sup> w \}.
</p>

<p>
Note that the grammar G = (N, &Sigma;, P, S) is effectively the
semi-Thue system (N &cup; &Sigma;, P), rewriting strings in exactly the
same way; the only difference is in that we distinguish specific
nonterminal symbols which must be rewritten in rewrite rules, and are
only interested in rewritings from the designated start symbol S to
strings without nonterminal symbols.
</p>

<p>
hough there is a tremendous body of literature on parsing algorithms,
most of these algorithms assume that the language to be parsed is
initially described by means of a generative formal grammar, and that
the goal is to transform this generative grammar into a working
parser. Strictly speaking, a generative grammar does not in any way
correspond to the algorithm used to parse a language, and various
algorithms have different restrictions on the form of production rules
that are considered well-formed.
</p>

<p>
a generative grammar refers to a particular approach to the study of
syntax.
</p>

<p>
A generative grammar of a language attempts to give a set of rules
that will correctly predict which combinations of words will form
grammatical sentences.
</p>

<p>
transformational grammar, and this term is still used as a general
term that includes his subsequent theories
</p>

<p>
Chomsky has argued that many of the properties of a generative grammar
arise from an "innate" universal grammar. 
Proponents of generative grammar have argued that most grammar is not
the result of communicative function and is not simply learned from
the environment (see the poverty of the stimulus argument). In this
respect, generative grammar takes a point of view different from
cognitive grammar, functional, and behaviorist theories
</p>

<p>
The rules of a generative grammar typically function as an algorithm
to predict grammaticality as a discrete (yes-or-no) result. In this
respect, it differs from stochastic grammar, which considers
grammaticality as a probabilistic variable.
</p>

<p>
some work in generative grammar (e.g. recent work by Joan Bresnan)
uses stochastic versions of optimality theory
</p>


<p>
An alternative model of syntax based on the idea that notions like
Subject, Direct Object, and Indirect Object play a primary role in
grammar.
</p>

<p>
Essentially, the tree model works something like this example, in which S is a sentence, D is a determiner, N a noun, V a verb, NP a noun phrase and VP a verb phrase:
</p>

<p>
Basic english syntax tree.svg
</p>

<p>
The resulting sentence could be The dog ate the bone. Such a tree diagram is also called a phrase marker. They can be represented more conveniently in text form, (though the result is less easy to read); in this format the above sentence would be rendered as:
[S [NP [D The ] [N dog ] ] [VP [V ate ] [NP [D the ] [N bone ] ] ] ]
</p>

<p>
When generative grammar was first proposed, it was widely hailed as a
way of formalizing the implicit set of rules a person "knows" when
they know their native language and produce grammatical utterances in
it (grammaticality intuitions). However Chomsky has repeatedly
rejected that interpretation; according to him, the grammar of a
language is a statement of what it is that a person has to know in
order to recognize an utterance as grammatical, but not a hypothesis
about the processes involved in either understanding or producing
language.
</p>

<p>
Generative grammar has been used to a limited extent in music theory
and analysis since the 1980s.<sup><a id="fnr.4.100" name="fnr.4.100" class="footref" href="#fn.4">4</a></sup><sup>, </sup><sup><a id="fnr.7.100" name="fnr.7.100" class="footref" href="#fn.7">7</a></sup> The most well-known approaches
were developed by Mark Steedman<sup><a id="fnr.8" name="fnr.8" class="footref" href="#fn.8">8</a></sup> as well as Fred Lerdahl and Ray
Jackendoff,<sup><a id="fnr.9" name="fnr.9" class="footref" href="#fn.9">9</a></sup> who formalised and extended ideas from Schenkerian
analysis.<sup><a id="fnr.10" name="fnr.10" class="footref" href="#fn.10">10</a></sup> More recently, such early generative approaches to music
were further developed and extended by several scholars
</p>

<p>
See also
</p>

<p>
Formal grammar
Phrase structure rules
Cognitive linguistics
Parsing
Linguistic competence
</p>

<p>
a system which "makes infinite use of finite means"
</p>
</div>
</div>

<div id="outline-container-sec-7-29" class="outline-3">
<h3 id="sec-7-29"><span class="section-number-3">7.29</span> Sample Grammar&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-29">
<p>
<i>* Input Tokens. *</i>
   &lt;identifier&gt;   =&gt; lookup();   <i>/ Lookup &amp; store in symbol table.
   &lt;integer&gt;      =&gt; lookup();   /</i> Lookup &amp; store in symbol table. 
<i>* Operator precedence. *</i>
   { '<code>=' '!</code>' }  &lt;&lt;              // Lowest priority.    
   { '+'  '-'  }  &lt;&lt;         
   { '*'  '/'  }  &lt;&lt;              <i>/ Highest priority.
/* Productions. *</i>
   Goal     -&gt; Program&#x2026; &lt;eof&gt;                        *&gt; goal<sub>()</sub>  emit ("\t\tSTART\n"     ,,"\t\tEOF\n")          
   Program  -&gt; 'program' &lt;identifier&gt; '{' Stmt&#x2026; '}'  *&gt; program<sub>(2)</sub> emit ("\t\tPROGRAM %s\n",,"\t\tEND PROGRAM %s\n")
   Stmt     -&gt; Assignment
            -&gt; IfThen
            -&gt; IfElse
            -&gt; IfThenElse
   Assignment  ~&gt; Target '=' Exp ';'                   *&gt; assign<sub>()</sub>  emit (          ,,"\t\tSTORE\n")         
   IfThen      -&gt; 'if' RelExp Then 'endif'             *&gt; if<sub>()</sub>      emit ("if&amp;0:\n" ,,"endif&amp;0:\n" )
   IfElse      -&gt; 'if' RelExp Else 'endif'             *&gt; if<sub>()</sub>      emit ("if&amp;0:\n" ,,"endif&amp;0:\n" )
   IfThenElse  -&gt; 'if' RelExp Then2 Else2 'endif'      *&gt; if<sub>()</sub>      emit ("if&amp;0:\n" ,,"endif&amp;0:\n" )              
   Target      -&gt; &lt;identifier&gt;                         *&gt; target<sub>(1)</sub> emit (          ,,"\t\tLADR %s\n")
   RelExp   -&gt; Exp '<code>=' Exp                            *&gt; eq_(2) emit (          ,,"\t\tEQ\n" ) 
            -&gt; Exp '!</code>' Exp                            *&gt; ne<sub>(2)</sub> emit (          ,,"\t\tNE\n" ) 
   Exp      -&gt; Primary    
            -&gt; Exp '+' Exp                             *&gt; add<sub>(2)</sub> emit (          ,,"\t\tADD\n") 
            -&gt; Exp '-' Exp                             *&gt; sub<sub>(2)</sub> emit (          ,,"\t\tSUB\n") 
            -&gt; Exp '*' Exp                             *&gt; mul<sub>(2)</sub> emit (          ,,"\t\tMUL\n") 
            -&gt; Exp '/' Exp                             *&gt; div<sub>(2)</sub> emit (          ,,"\t\tDIV\n") 
   Primary  -&gt; &lt;identifier&gt;                            *&gt; id<sub>(1)</sub> emit (          ,,"\t\tLOAD %s\n")
            -&gt; &lt;integer&gt;                               *&gt; int<sub>(1)</sub> emit (          ,,"\t\tLOAD %s\n")
            -&gt; '(' Exp ')'  
   Then     -&gt; 'then' Stmt&#x2026;                          *&gt; then<sub>()</sub>  emit ("\t\tBR NZ endif&amp;1\nthen&amp;1:\n",,)
   Else     -&gt; 'else' Stmt&#x2026;                          *&gt; else<sub>()</sub>  emit ("\t\tBR Z endif&amp;1\nelse&amp;1:\n" ,,)
   Then2    -&gt; 'then' Stmt&#x2026;                          *&gt; then<sub>()</sub>  emit ("\t\tBR NZ else&amp;1\nthen&amp;1:\n" ,,)
   Else2    -&gt; 'else' Stmt&#x2026;                          <b>&gt; else<sub>()</sub>  emit ("\t\tBR endif&amp;1\nelse&amp;1:\n"   ,,)
/</b> End of Grammar. */
</p>
</div>

<div id="outline-container-sec-7-29-1" class="outline-4">
<h4 id="sec-7-29-1"><span class="section-number-4">7.29.1</span> LRSTAR</h4>
<div class="outline-text-4" id="text-7-29-1">
<p>
An LR(1)/LR(k) parser generator that reads TBNF grammar
notation.
</p>
</div>
</div>
<div id="outline-container-sec-7-29-2" class="outline-4">
<h4 id="sec-7-29-2"><span class="section-number-4">7.29.2</span> DCG definite clause grammar</h4>
<div class="outline-text-4" id="text-7-29-2">
<p>
A definite clause grammar (DCG) is a way of expressing grammar, either
for natural or formal languages, in a logic programming language such
as Prolog. It is closely related to the concept of attribute grammars
/ affix grammars from which Prolog was originally developed
</p>
</div>
</div>

<div id="outline-container-sec-7-29-3" class="outline-4">
<h4 id="sec-7-29-3"><span class="section-number-4">7.29.3</span> a set of definite clauses in first-order logic</h4>
</div>
<div id="outline-container-sec-7-29-4" class="outline-4">
<h4 id="sec-7-29-4"><span class="section-number-4">7.29.4</span> a simple grammar</h4>
<div class="outline-text-4" id="text-7-29-4">
<p>
sentence &#x2013;&gt; noun<sub>phrase</sub>, verb<sub>phrase</sub>.
 noun<sub>phrase</sub> &#x2013;&gt; det, noun.
 verb<sub>phrase</sub> &#x2013;&gt; verb, noun<sub>phrase</sub>.
 det &#x2013;&gt; [the].
 det &#x2013;&gt; [a].
 noun &#x2013;&gt; [cat].
 noun &#x2013;&gt; [bat].
 verb &#x2013;&gt; [eats].
</p>

<p>
This generates sentences such as "the cat eats the bat", "a bat eats
the cat". One can generate all of the valid expressions in the
language generated by this grammar at a Prolog interpreter by typing
sentence(X,[])
</p>
</div>
<ol class="org-ol"><li>test valid sentence<br  /><div class="outline-text-5" id="text-7-29-4-1">
<p>
Similarly, one can test whether a sentence is valid in the language by
typing something like sentence([the,bat,eats,the,bat],[]).
DCG notation is just syntactic sugar for normal definite clauses in Prolog. For example, the previous example could be translated into the following:
</p>

<p>
sentence(S1,S3) :- noun<sub>phrase</sub>(S1,S2), verb<sub>phrase</sub>(S2,S3).
noun<sub>phrase</sub>(S1,S3) :- det(S1,S2), noun(S2,S3).
verb<sub>phrase</sub>(S1,S3) :- verb(S1,S2), noun<sub>phrase</sub>(S2,S3).
det([the|X], X).
det([a|X], X).
noun([cat|X], X).
noun([bat|X], X).
verb([eats|X], X).
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-7-29-5" class="outline-4">
<h4 id="sec-7-29-5"><span class="section-number-4">7.29.5</span> pure prolog</h4>
<div class="outline-text-4" id="text-7-29-5">
<p>
In pure Prolog, normal DCG rules with no extra arguments on the
functors, such as the previous example, can only express context-free
grammars; there is only one argument on the left side of the
production. However, context-sensitive grammars can also be expressed
with DCGs, by providing extra arguments, such as in the following
example:
</p>

<p>
s &#x2013;&gt; a(N), b(N), c(N).
a(0) &#x2013;&gt; [].
a(M) &#x2013;&gt; [a], a(N), {M is N + 1}.
b(0) &#x2013;&gt; [].
b(M) &#x2013;&gt; [b], b(N), {M is N + 1}.
c(0) &#x2013;&gt; [].
c(M) &#x2013;&gt; [c], c(N), {M is N + 1}.
</p>
</div>
<ol class="org-ol"><li>a set of DCG rules<br  /><div class="outline-text-5" id="text-7-29-5-1">
<p>
This set of DCG rules describes the grammar which generates the
language that consists of strings of the form a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>.
</p>

<p>
s &#x2013;&gt; symbols(Sem,a), symbols(Sem,b), symbols(Sem,c).
symbols(end,_) &#x2013;&gt; [].
symbols(s(Sem),S) &#x2013;&gt; [S], symbols(Sem,S).
</p>
</div>
</li>
<li>another set of DCG rules<br  /><div class="outline-text-5" id="text-7-29-5-2">
<p>
This set of DCG rules describes the grammar which generates the
language that consists of strings of the form a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>, by
structurally representing n[citation needed]
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-7-29-6" class="outline-4">
<h4 id="sec-7-29-6"><span class="section-number-4">7.29.6</span> the main practical use of DCG</h4>
<div class="outline-text-4" id="text-7-29-6">
<p>
The main practical use of a DCG is to parse sentences of the given
grammar, i.e. to construct a parse tree. 
</p>
</div>
<ol class="org-ol"><li>extra arguments<br  /><div class="outline-text-5" id="text-7-29-6-1">
<p>
This can be done by providing "extra arguments" to the functors in the
DCG, like in the following rules:
</p>

<p>
sentence(s(NP,VP)) &#x2013;&gt; noun<sub>phrase</sub>(NP), verb<sub>phrase</sub>(VP).
noun<sub>phrase</sub>(np(D,N)) &#x2013;&gt; det(D), noun(N).
verb<sub>phrase</sub>(vp(V,NP)) &#x2013;&gt; verb(V), noun<sub>phrase</sub>(NP).
det(d(the)) &#x2013;&gt; [the].
det(d(a)) &#x2013;&gt; [a].
noun(n(bat)) &#x2013;&gt; [bat].
noun(n(cat)) &#x2013;&gt; [cat].
verb(v(eats)) &#x2013;&gt; [eats].
</p>
</div>
</li>
<li>query the interpreter<br  /><div class="outline-text-5" id="text-7-29-6-2">
<p>
One can now query the interpreter to yield a parse tree of any given sentence:
 ?- sentence(Parse<sub>tree</sub>, [the,bat,eats,a,cat], []).
 Parse<sub>tree</sub> = s(np(d(the),n(bat)),vp(v(eats),np(d(a),n(cat)))) ? ;
</p>
</div>
</li>
<li>DCTG definite clause translation grammars<br  /><div class="outline-text-5" id="text-7-29-6-3">
<p>
Another extension, called definite clause translation grammars (DCTGs)
was described by in 1984. DCTG notation looks very similar to DCG
notation; the major difference is that one uses ::= instead of &#x2013;&gt; in
the rules. It was devised to handle grammatical attributes
conveniently. The translation of DCTGs into normal Prolog clauses
is like that of DCGs, but 3 arguments are added instead of 2.
</p>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-7-30" class="outline-3">
<h3 id="sec-7-30"><span class="section-number-3">7.30</span> Pseudocode&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-7-30">
<p>
Pseudocode is an informal high-level description of the operating
principle of a computer program or other algorithm.
</p>
</div>
<div id="outline-container-sec-7-30-1" class="outline-4">
<h4 id="sec-7-30-1"><span class="section-number-4">7.30.1</span> specific algorithms and translations</h4>
<div class="outline-text-4" id="text-7-30-1">
<p>
A programmer who needs to implement a specific algorithm, especially
an unfamiliar one, will often start with a pseudocode description, and
then "translate" that description into the target programming language
and modify it to interact correctly with the rest of the
program. Programmers may also start a project by sketching out the
code in pseudocode on paper before writing it in its actual language,
as a top-down structuring approach, with a stepwise refinement.
</p>
</div>
</div>
<div id="outline-container-sec-7-30-2" class="outline-4">
<h4 id="sec-7-30-2"><span class="section-number-4">7.30.2</span> codeblocks</h4>
<div class="outline-text-4" id="text-7-30-2">
<p>
Function calls and blocks of code, such as code contained within a
loop, are often replaced by a one-line natural language sentence.
</p>
</div>
</div>
<div id="outline-container-sec-7-30-3" class="outline-4">
<h4 id="sec-7-30-3"><span class="section-number-4">7.30.3</span> numerical computation</h4>
<div class="outline-text-4" id="text-7-30-3">
<p>
In numerical computation, pseudocode often consists of mathematical
notation, typically from set and matrix theory, mixed with the control
structures of a conventional programming language, and perhaps also
natural language descriptions
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7-31" class="outline-3">
<h3 id="sec-7-31"><span class="section-number-3">7.31</span> metalanguage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="metalanguage">metalanguage</span></span></h3>
<div class="outline-text-3" id="text-7-31">
<p>
Broadly, any metalanguage is language or symbols used when language
itself is being discussed or examined. 
</p>
</div>
<div id="outline-container-sec-7-31-1" class="outline-4">
<h4 id="sec-7-31-1"><span class="section-number-4">7.31.1</span> logic and linguistics</h4>
<div class="outline-text-4" id="text-7-31-1">
<p>
In logic and linguistics, a metalanguage is a language used to make
statements about statements in another language (the object
language). Expressions in a metalanguage are often distinguished from
those in an object language by the use of italics, quotation marks, or
writing on a separate line.
</p>
</div>
</div>
<div id="outline-container-sec-7-31-2" class="outline-4">
<h4 id="sec-7-31-2"><span class="section-number-4">7.31.2</span> embedded, ordered and nested</h4>
<div class="outline-text-4" id="text-7-31-2">
<p>
There is a variety of recognized metalanguages, including embedded,
ordered, and nested (or, hierarchical).
</p>
</div>
</div>
<div id="outline-container-sec-7-31-3" class="outline-4">
<h4 id="sec-7-31-3"><span class="section-number-4">7.31.3</span> noun, verb and word are examples of metalanguage</h4>
<div class="outline-text-4" id="text-7-31-3">
<p>
words such as noun, verb, or even word describe features and concepts
pertaining to the English language itself
</p>
</div>
</div>
<div id="outline-container-sec-7-31-4" class="outline-4">
<h4 id="sec-7-31-4"><span class="section-number-4">7.31.4</span> ordered metalanguage</h4>
<div class="outline-text-4" id="text-7-31-4">
<p>
An ordered metalanguage is analogous to ordered logic. An example of
an ordered metalanguage is the construction of one metalanguage to
discuss an object language, followed by the creation of another
metalanguage to discuss the first, etc.
</p>
</div>
</div>
<div id="outline-container-sec-7-31-5" class="outline-4">
<h4 id="sec-7-31-5"><span class="section-number-4">7.31.5</span> nested metalanguage</h4>
<div class="outline-text-4" id="text-7-31-5">
<p>
A nested (or, hierarchical) metalanguage is similar to an ordered
metalanguage in that each level represents a greater degree of
abstraction. However, a nested metalanguage differs from an ordered
one in that each level includes the one below. The paradigmatic
example of a nested metalanguage comes from the Linnean taxonomic
system in biology. Each level in the system incorporates the one below
it. The language used to discuss genus is also used to discuss
species; the one used to discuss orders is also used to discuss
genera, etc., up to kingdoms.
</p>
</div>
</div>
<div id="outline-container-sec-7-31-6" class="outline-4">
<h4 id="sec-7-31-6"><span class="section-number-4">7.31.6</span> metatheory</h4>
<div class="outline-text-4" id="text-7-31-6">
<p>
A metatheory is a theory whose subject matter is some other theory (a
theory about a theory). Statements made in the metatheory about the
theory are called metatheorems. A metatheorem is a true statement
about a formal system expressed in a metalanguage. Unlike theorems
proved within a given formal system, a metatheorem is proved within a
metatheory, and may reference concepts that are present in the
metatheory but not the object theory. 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7-32" class="outline-3">
<h3 id="sec-7-32"><span class="section-number-3">7.32</span> EBNF for Lisp&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="lisp">lisp</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-32">
<p>
 s<sub>expression</sub> ::= atomic<sub>symbol</sub> | "(" s<sub>expression</sub> "." s<sub>expression</sub> ")" 
                                   list                                  
         list ::= "(" s<sub>expression</sub>* ")"
atomic<sub>symbol</sub> ::= letter atom<sub>part</sub>
    atom<sub>part</sub> ::= empty | letter atom<sub>part</sub>
                          number atom<sub>part</sub>
       letter ::= "a" | "b" | " &#x2026;" | "z"
       number ::= "1" | "2" | " &#x2026;" | "9" 
</p>
</div>
</div>
<div id="outline-container-sec-7-33" class="outline-3">
<h3 id="sec-7-33"><span class="section-number-3">7.33</span> Languages form the terrain of computing&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="lisp">lisp</span>&#xa0;<span class="debug">debug</span></span></h3>
<div class="outline-text-3" id="text-7-33">
<p>
Programming languages, protocol specifications, query languages, file
formats, pattern languages, memory layouts, formal languages, config
files, mark-up languages, formatting languages and meta-languages
shape the way we compute.
</p>
</div>
<div id="outline-container-sec-7-33-1" class="outline-4">
<h4 id="sec-7-33-1"><span class="section-number-4">7.33.1</span> AT: So, what shapes languages?</h4>
</div>
<div id="outline-container-sec-7-33-2" class="outline-4">
<h4 id="sec-7-33-2"><span class="section-number-4">7.33.2</span> RR: Grammars do.</h4>
</div>
</div>
<div id="outline-container-sec-7-34" class="outline-3">
<h3 id="sec-7-34"><span class="section-number-3">7.34</span> perl::rdf stuff</h3>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> org&#xa0;&#xa0;&#xa0;<span class="tag"><span class="buffer">buffer</span></span></h2>
<div class="outline-text-2" id="text-8">
<p>
Major Mode Bindings Starting With C-c C-v:
key             binding
&#x2014;             -&#x2014;&#x2014;
</p>

<p>
C-c C-v C-a        org-babel-sha1-hash
C-c C-v C-b        org-babel-execute-buffer
C-c C-v C-c        org-babel-check-src-block
C-c C-v C-d        org-babel-demarcate-block
C-c C-v C-e        org-babel-execute-maybe
C-c C-v C-f        org-babel-tangle-file
C-c C-v TAB        org-babel-view-src-block-info
C-c C-v C-j        org-babel-insert-header-arg
C-c C-v C-l        org-babel-load-in-session
C-c C-v C-n        org-babel-next-src-block
C-c C-v C-o        org-babel-open-src-block-result
C-c C-v C-p        org-babel-previous-src-block
C-c C-v C-r        org-babel-goto-named-result
C-c C-v C-s        org-babel-execute-subtree
C-c C-v C-t        org-babel-tangle
C-c C-v C-u        org-babel-goto-src-block-head
C-c C-v C-v        org-babel-expand-src-block
C-c C-v C-x        org-babel-do-key-sequence-in-edit-buffer
C-c C-v C-z        org-babel-switch-to-session
C-c C-v ESC        Prefix Command
C-c C-v I        org-babel-view-src-block-info
C-c C-v a        org-babel-sha1-hash
C-c C-v b        org-babel-execute-buffer
C-c C-v c        org-babel-check-src-block
C-c C-v d        org-babel-demarcate-block
C-c C-v e        org-babel-execute-maybe
C-c C-v f        org-babel-tangle-file
C-c C-v g        org-babel-goto-named-src-block
C-c C-v h        org-babel-describe-bindings
C-c C-v i        org-babel-lob-ingest
C-c C-v j        org-babel-insert-header-arg
C-c C-v l        org-babel-load-in-session
C-c C-v n        org-babel-next-src-block
C-c C-v o        org-babel-open-src-block-result
C-c C-v p        org-babel-previous-src-block
C-c C-v r        org-babel-goto-named-result
C-c C-v s        org-babel-execute-subtree
C-c C-v t        org-babel-tangle
C-c C-v u        org-babel-goto-src-block-head
C-c C-v v        org-babel-expand-src-block
C-c C-v x        org-babel-do-key-sequence-in-edit-buffer
C-c C-v z        org-babel-switch-to-session-with-code
</p>

<p>
C-c C-v C-M-h        org-babel-mark-block
</p>
</div>

<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> acl90</h3>
<div class="outline-text-3" id="text-8-1">
<p>
<i>archive/xk05/acl90/doc</i>
Location: <a href="file:///archive/xk05/acl90/doc/prolog.html">file:///archive/xk05/acl90/doc/prolog.html</a>                          
ToC DocOverview CGDoc RelNotes Index PermutedIndex     Allegro CL version 8.0
                                                                   New in 7.0
</p>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> bnf2xml</h3>
<div class="outline-text-3" id="text-8-2">
<div class="prolog">
<p>

</p>

</div>
<p>
/*
</p>

<p>
FEATURES:
        fully reflexive (don't need *, automatic)
        OR, AND, == (bnf bnf a maybe, see below)
</p>

<p>
REPLACE / DO something hack , 2 ways to match
        form   &lt;a&gt; : &lt;repl&gt; "" ""
        repl &lt;a<sub>r</sub>&gt; : &lt;foo&gt; "" ""
                if &lt;a&gt; take parallel &lt;a<sub>r</sub>&gt;
                replaces in output: REPORT c (not report a or b)
                does not change input
        form   &lt;a&gt; : &lt;subst&gt; "" ""
        repl &lt;a<sub>s</sub>&gt; : &lt;foo&gt; "" ""
                if &lt;a&gt; take parallel &lt;a<sub>r</sub>&gt;
                replace input during search
                restars search on that line and continues
                downward (do not start at line 0)
                replaces in all REPORT a,b,c
        form   &lt;a&gt; : &lt;sys&gt; "" ""
        repl &lt;a<sub>S</sub>&gt; : &lt;foo&gt; "" ""
                if &lt;a&gt; system(&lt;a<sub>r</sub>&gt;)
        NOTES:
</p>
<ul class="org-ul">
<li>lines must be one after the other, _r is
actuall &lt;a<sub>foo</sub>&gt; (use positionally)
</li>
<li>#define SYS<sub>FOO</sub><sub>PRINTONLY</sub> is default
</li>
<li>Note input subst remains once done, so
plan ahead not to depend on whether the
line where &lt;a&gt; is found wholey matches)
</li>
</ul>
<p>
TODOS
        this looks easiest, or getop if must
                cat opts bnf1 bnf2 | parse
</p>

<p>
input is one line only (can't parse input file)
</p>

<p>
cannot yet use input to use 1st bnf to read in a 2nd bnf
        which would then read input
        point being to allow varied bnf syntax support
</p>

<p>
output is not very useable yet but mostly complete
</p>

<p>
WARNING: having read Ale I guaruntee the naming is confusing and not good enough.
</p>

<p>
see parse.discussion about many parsers / analyzers
</p>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> inst*n lightnify:</h3>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> light.el:1804:22:Warning: (lambda (x) &#x2026;)</h3>
<div class="outline-text-3" id="text-8-4">
<p>
quoted with ' rather than with #'
</p>
</div>
</div>

<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> negation (non) is sometimes failure, sometimes not failure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-8-5">
</div><div id="outline-container-sec-8-5-1" class="outline-4">
<h4 id="sec-8-5-1"><span class="section-number-4">8.5.1</span> a test for three cases</h4>
<div class="outline-text-4" id="text-8-5-1">
</div><ol class="org-ol"><li>:non a :failure<br  /></li>
<li>:non a :success<br  /></li>
<li>:non a :no-result<br  /></li></ol>
</div>
</div>
<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6"><span class="section-number-3">8.6</span> Unicity Distance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span></span></h3>
<div class="outline-text-3" id="text-8-6">
</div><div id="outline-container-sec-8-6-1" class="outline-4">
<h4 id="sec-8-6-1"><span class="section-number-4">8.6.1</span> Attempts to give a minimum amount of ciphertext</h4>
<div class="outline-text-4" id="text-8-6-1">
</div><ol class="org-ol"><li>necessary to ensure decipherability.<br  /></li></ol>
</div>
<div id="outline-container-sec-8-6-2" class="outline-4">
<h4 id="sec-8-6-2"><span class="section-number-4">8.6.2</span> Based on the redundancy of plaintext.</h4>
</div>
</div>
<div id="outline-container-sec-8-7" class="outline-3">
<h3 id="sec-8-7"><span class="section-number-3">8.7</span> org-element.el</h3>
<div class="outline-text-3" id="text-8-7">
<p>
;;; org-element.el &#x2014; Parser And Applications for Org syntax
</p>

<p>
;; Copyright (C) 2012-2014 Free Software Foundation, Inc.
</p>

<p>
;; Author: Nicolas Goaziou &lt;n.goaziou at gmail dot com&gt;
;; Keywords: outlines, hypermedia, calendar, wp
</p>

<p>
;; This file is part of GNU Emacs.
</p>

<p>
;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
</p>

<p>
;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
</p>

<p>
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</p>

<p>
;;; Commentary:
;;
;; Org syntax can be divided into three categories: "Greater
;; elements", "Elements" and "Objects".
;;
;; Elements are related to the structure of the document.  Indeed, all
;; elements are a cover for the document: each position within belongs
;; to at least one element.
;;
;; An element always starts and ends at the beginning of a line.  With
;; a few exceptions (`clock', `headline', `inlinetask', `item',
;; `planning', `node-property', `quote-section' `section' and
;; `table-row' types), it can also accept a fixed set of keywords as
;; attributes.  Those are called "affiliated keywords" to distinguish
;; them from other keywords, which are full-fledged elements.  Almost
;; all affiliated keywords are referenced in
;; `org-element-affiliated-keywords'; the others are export attributes
;; and start with "ATTR_" prefix.
;;
;; Element containing other elements (and only elements) are called
;; greater elements.  Concerned types are: `center-block', `drawer',
;; `dynamic-block', `footnote-definition', `headline', `inlinetask',
;; `item', `plain-list', `property-drawer', `quote-block', `section'
;; and `special-block'.
;;
;; Other element types are: `babel-call', `clock', `comment',
;; `comment-block', `diary-sexp', `example-block', `export-block',
;; `fixed-width', `horizontal-rule', `keyword', `latex-environment',
;; `node-property', `paragraph', `planning', `quote-section',
;; `src-block', `table', `table-row' and `verse-block'.  Among them,
;; `paragraph' and `verse-block' types can contain Org objects and
;; plain text.
;;
;; Objects are related to document's contents.  Some of them are
;; recursive.  Associated types are of the following: `bold', `code',
;; `entity', `export-snippet', `footnote-reference',
;; `inline-babel-call', `inline-src-block', `italic',
;; `latex-fragment', `line-break', `link', `macro', `radio-target',
;; `statistics-cookie', `strike-through', `subscript', `superscript',
;; `table-cell', `target', `timestamp', `underline' and `verbatim'.
;;
;; Some elements also have special properties whose value can hold
;; objects themselves (e.g. an item tag or a headline name).  Such
;; values are called "secondary strings".  Any object belongs to
;; either an element or a secondary string.
;;
;; Notwithstanding affiliated keywords, each greater element, element
;; and object has a fixed set of properties attached to it.  Among
;; them, four are shared by all types: `:begin' and `:end', which
;; refer to the beginning and ending buffer positions of the
;; considered element or object, `:post-blank', which holds the number
;; of blank lines, or white spaces, at its end and `:parent' which
;; refers to the element or object containing it.  Greater elements,
;; elements and objects containing objects will also have
;; `:contents-begin' and `:contents-end' properties to delimit
;; contents.  Eventually, greater elements and elements accepting
;; affiliated keywords will have a `:post-affiliated' property,
;; referring to the buffer position after all such keywords.
;;
;; At the lowest level, a `:parent' property is also attached to any
;; string, as a text property.
;;
;; Lisp-wise, an element or an object can be represented as a list.
;; It follows the pattern (TYPE PROPERTIES CONTENTS), where:
;;   TYPE is a symbol describing the Org element or object.
;;   PROPERTIES is the property list attached to it.  See docstring of
;;              appropriate parsing function to get an exhaustive
;;              list.
;;   CONTENTS is a list of elements, objects or raw strings contained
;;            in the current element or object, when applicable.
;;
;; An Org buffer is a nested list of such elements and objects, whose
;; type is `org-data' and properties is nil.
;;
;; The first part of this file defines Org syntax, while the second
;; one provide accessors and setters functions.
;;
;; The next part implements a parser and an interpreter for each
;; element and object type in Org syntax.
;;
;; The following part creates a fully recursive buffer parser.  It
;; also provides a tool to map a function to elements or objects
;; matching some criteria in the parse tree.  Functions of interest
;; are `org-element-parse-buffer', `org-element-map' and, to a lesser
;; extent, `org-element-parse-secondary-string'.
;;
;; The penultimate part is the cradle of an interpreter for the
;; obtained parse tree: `org-element-interpret-data'.
;;
;; The library ends by furnishing `org-element-at-point' function, and
;; a way to give information about document structure around point
;; with `org-element-context'.
</p>


<p>
;;; Code:
</p>

<p>
(eval-when-compile (require 'cl))
(require 'org)
</p>


<p>

;;; Definitions And Rules
;;
;; Define elements, greater elements and specify recursive objects,
;; along with the affiliated keywords recognized.  Also set up
;; restrictions on recursive objects combinations.
;;
;; These variables really act as a control center for the parsing
;; process.
</p>

<p>
(defconst org-element-paragraph-separate
  (concat "<sup>\\</sup>\\(?:"
          ;; Headlines, inlinetasks.
          org-outline-regexp "\\|"
          ;; Footnote definitions.
	  "\\[\\(?:[0-9]+\\|fn:[-_[:word:]]+\\)\\]" "\\|"
          ;; Diary sexps.
          "%%(" "\\|"
          "[ \t]*\\(?:"
          ;; Empty lines.
          "$" "\\|"
	  ;; Tables (any type).
	  "\\(?:|\\|\\+-[-+]\\)" "\\|"
          ;; Blocks (any type), Babel calls and keywords.  Note: this
          ;; is only an indication and need some thorough check.
          "#\\(?:[+ ]\\|$\\)" "\\|"
          ;; Drawers (any type) and fixed-width areas.  This is also
          ;; only an indication.
          ":" "\\|"
          ;; Horizontal rules.
          "-\\{5,\\}[ \t]*$" "\\|"
          ;; LaTeX environments.
          "\\\\begin{\\([A-Za-z0-9]+\\*?\\)}" "\\|"
          ;; Planning and Clock lines.
          (regexp-opt (list org-scheduled-string
                            org-deadline-string
                            org-closed-string
                            org-clock-string))
          "\\|"
          ;; Lists.
          (let ((term (case org-plain-list-ordered-item-terminator
                        (?\) ")") (?. "\\.") (otherwise "[.)]")))
                (alpha (and org-list-allow-alphabetical "\\|[A-Za-z]")))
            (concat "\\(?:[-+*]\\|\\(?:[0-9]+" alpha "\\)" term "\\)"
                    "\\(?:[ \t]\\|$\\)"))
          "\\)\\)")
  "Regexp to separate paragraphs in an Org buffer.
In the case of lines starting with \"#\" and \":\", this regexp
is not sufficient to know if point is at a paragraph ending.  See
`org-element-paragraph-parser' for more information.")
</p>

<p>
(defconst org-element-all-elements
  '(babel-call center-block clock comment comment-block diary-sexp drawer
               dynamic-block example-block export-block fixed-width
               footnote-definition headline horizontal-rule inlinetask item
               keyword latex-environment node-property paragraph plain-list
               planning property-drawer quote-block quote-section section
               special-block src-block table table-row verse-block)
  "Complete list of element types.")
</p>

<p>
(defconst org-element-greater-elements
  '(center-block drawer dynamic-block footnote-definition headline inlinetask
                 item plain-list property-drawer quote-block section
                 special-block table)
  "List of recursive element types aka Greater Elements.")
</p>

<p>
(defconst org-element-all-successors
  '(link export-snippet footnote-reference inline-babel-call
         inline-src-block latex-or-entity line-break macro plain-link
         radio-target statistics-cookie sub/superscript table-cell target
         text-markup timestamp)
  "Complete list of successors.")
</p>

<p>
(defconst org-element-object-successor-alist
  '((subscript . sub/superscript) (superscript . sub/superscript)
    (bold . text-markup) (code . text-markup) (italic . text-markup)
    (strike-through . text-markup) (underline . text-markup)
    (verbatim . text-markup) (entity . latex-or-entity)
    (latex-fragment . latex-or-entity))
  "Alist of translations between object type and successor name.
Sharing the same successor comes handy when, for example, the
regexp matching one object can also match the other object.")
</p>

<p>
(defconst org-element-all-objects
  '(bold code entity export-snippet footnote-reference inline-babel-call
         inline-src-block italic line-break latex-fragment link macro
         radio-target statistics-cookie strike-through subscript superscript
         table-cell target timestamp underline verbatim)
  "Complete list of object types.")
</p>

<p>
(defconst org-element-recursive-objects
  '(bold italic link subscript radio-target strike-through superscript
         table-cell underline)
  "List of recursive object types.")
</p>

<p>
(defvar org-element-block-name-alist
  '(("CENTER" . org-element-center-block-parser)
    ("COMMENT" . org-element-comment-block-parser)
    ("EXAMPLE" . org-element-example-block-parser)
    ("QUOTE" . org-element-quote-block-parser)
    ("SRC" . org-element-src-block-parser)
    ("VERSE" . org-element-verse-block-parser))
  "Alist between block names and the associated parsing function.
Names must be uppercase.  Any block whose name has no association
is parsed with `org-element-special-block-parser'.")
</p>

<p>
(defconst org-element-link-type-is-file
  '("file" "file+emacs" "file+sys" "docview")
  "List of link types equivalent to \"file\".
Only these types can accept search options and an explicit
application to open them.")
</p>

<p>
(defconst org-element-affiliated-keywords
  '("CAPTION" "DATA" "HEADER" "HEADERS" "LABEL" "NAME" "PLOT" "RESNAME" "RESULT"
    "RESULTS" "SOURCE" "SRCNAME" "TBLNAME")
  "List of affiliated keywords as strings.
By default, all keywords setting attributes (e.g., \"ATTR<sub>LATEX\</sub>")
are affiliated keywords and need not to be in this list.")
</p>

<p>
(defconst org-element-keyword-translation-alist
  '(("DATA" . "NAME")  ("LABEL" . "NAME") ("RESNAME" . "NAME")
    ("SOURCE" . "NAME") ("SRCNAME" . "NAME") ("TBLNAME" . "NAME")
    ("RESULT" . "RESULTS") ("HEADERS" . "HEADER"))
  "Alist of usual translations for keywords.
The key is the old name and the value the new one.  The property
holding their value will be named after the translated name.")
</p>

<p>
(defconst org-element-multiple-keywords '("CAPTION" "HEADER")
  "List of affiliated keywords that can occur more than once in an element.
</p>

<p>
Their value will be consed into a list of strings, which will be
returned as the value of the property.
</p>

<p>
This list is checked after translations have been applied.  See
`org-element-keyword-translation-alist'.
</p>

<p>
By default, all keywords setting attributes (e.g., \"ATTR<sub>LATEX\</sub>")
allow multiple occurrences and need not to be in this list.")
</p>

<p>
(defconst org-element-parsed-keywords '("CAPTION")
  "List of affiliated keywords whose value can be parsed.
</p>

<p>
Their value will be stored as a secondary string: a list of
strings and objects.
</p>

<p>
This list is checked after translations have been applied.  See
`org-element-keyword-translation-alist'.")
</p>

<p>
(defconst org-element-dual-keywords '("CAPTION" "RESULTS")
  "List of affiliated keywords which can have a secondary value.
</p>

<p>
In Org syntax, they can be written with optional square brackets
before the colons.  For example, RESULTS keyword can be
associated to a hash value with the following:
</p>

<p>
This list is checked after translations have been applied.  See
`org-element-keyword-translation-alist'.")
</p>

<p>
(defconst org-element-document-properties '("AUTHOR" "DATE" "TITLE")
  "List of properties associated to the whole document.
Any keyword in this list will have its value parsed and stored as
a secondary string.")
</p>

<p>
(defconst org-element&#x2013;affiliated-re
  (format "[ \t]*#\\+\\(?:%s\\):\\(?: \\|$\\)"
          (concat
           ;; Dual affiliated keywords.
           (format "\\(?1:%s\\)\\(?:\\[\\(.*\\)\\]\\)?"
                   (regexp-opt org-element-dual-keywords))
           "\\|"
           ;; Regular affiliated keywords.
           (format "\\(?1:%s\\)"
                   (regexp-opt
                    (org-remove-if
                     #'(lambda (keyword)
                         (member keyword org-element-dual-keywords))
                     org-element-affiliated-keywords)))
           "\\|"
           ;; Export attributes.
           "\\(?1:ATTR_[-_A-Za-z0-9]+\\)"))
  "Regexp matching any affiliated keyword.
</p>

<p>
Keyword name is put in match group 1.  Moreover, if keyword
belongs to `org-element-dual-keywords', put the dual value in
match group 2.
</p>

<p>
Don't modify it, set `org-element-affiliated-keywords' instead.")
</p>

<p>
(defconst org-element-object-restrictions
  (let* ((standard-set
          (remq 'plain-link (remq 'table-cell org-element-all-successors)))
         (standard-set-no-line-break (remq 'line-break standard-set)))
    `((bold ,@standard-set)
      (footnote-reference ,@standard-set)
      (headline ,@standard-set-no-line-break)
      (inlinetask ,@standard-set-no-line-break)
      (italic ,@standard-set)
      (item ,@standard-set-no-line-break)
      (keyword ,@standard-set)
      ;; Ignore all links excepted plain links in a link description.
      ;; Also ignore radio-targets and line breaks.
      (link export-snippet inline-babel-call inline-src-block latex-or-entity
            macro plain-link statistics-cookie sub/superscript text-markup)
      (paragraph ,@standard-set)
      ;; Remove any variable object from radio target as it would
      ;; prevent it from being properly recognized.
      (radio-target latex-or-entity sub/superscript text-markup)
      (strike-through ,@standard-set)
      (subscript ,@standard-set)
      (superscript ,@standard-set)
      ;; Ignore inline babel call and inline src block as formulas are
      ;; possible.  Also ignore line breaks and statistics cookies.
      (table-cell link export-snippet footnote-reference latex-or-entity macro
                  radio-target sub/superscript target text-markup timestamp)
      (table-row table-cell)
      (underline ,@standard-set)
      (verse-block ,@standard-set)))
  "Alist of objects restrictions.
</p>

<p>
CAR is an element or object type containing objects and CDR is
a list of successors that will be called within an element or
object of such type.
</p>

<p>
For example, in a `radio-target' object, one can only find
entities, latex-fragments, subscript, superscript and text
markup.
</p>

<p>
This alist also applies to secondary string.  For example, an
`headline' type element doesn't directly contain objects, but
still has an entry since one of its properties (`:title') does.")
</p>

<p>
(defconst org-element-secondary-value-alist
  '((headline . :title)
    (inlinetask . :title)
    (item . :tag)
    (footnote-reference . :inline-definition))
  "Alist between element types and location of secondary value.")
</p>

<p>
(defconst org-element-object-variables '(org-link-abbrev-alist-local)
  "List of buffer-local variables used when parsing objects.
These variables are copied to the temporary buffer created by
`org-export-secondary-string'.")
</p>


<p>

;;; Accessors and Setters
;;
;; Provide four accessors: `org-element-type', `org-element-property'
;; `org-element-contents' and `org-element-restriction'.
;;
;; Setter functions allow to modify elements by side effect.  There is
;; `org-element-put-property', `org-element-set-contents',
;; `org-element-set-element' and `org-element-adopt-element'.  Note
;; that `org-element-set-element' and `org-element-adopt-elements' are
;; higher level functions since also update `:parent' property.
</p>

<p>
(defsubst org-element-type (element)
  "Return type of ELEMENT.
</p>

<p>
The function returns the type of the element or object provided.
It can also return the following special value:
  `plain-text'       for a string
  `org-data'         for a complete document
  nil                in any other case."
  (cond
   ((not (consp element)) (and (stringp element) 'plain-text))
   ((symbolp (car element)) (car element))))
</p>

<p>
(defsubst org-element-property (property element)
  "Extract the value from the PROPERTY of an ELEMENT."
  (if (stringp element) (get-text-property 0 property element)
    (plist-get (nth 1 element) property)))
</p>

<p>
(defsubst org-element-contents (element)
  "Extract contents from an ELEMENT."
  (cond ((not (consp element)) nil)
        ((symbolp (car element)) (nthcdr 2 element))
        (t element)))
</p>

<p>
(defsubst org-element-restriction (element)
  "Return restriction associated to ELEMENT.
ELEMENT can be an element, an object or a symbol representing an
element or object type."
  (cdr (assq (if (symbolp element) element (org-element-type element))
             org-element-object-restrictions)))
</p>

<p>
(defsubst org-element-put-property (element property value)
  "In ELEMENT set PROPERTY to VALUE.
Return modified element."
  (if (stringp element) (org-add-props element nil property value)
    (setcar (cdr element) (plist-put (nth 1 element) property value))
    element))
</p>

<p>
(defsubst org-element-set-contents (element &amp;rest contents)
  "Set ELEMENT contents to CONTENTS.
Return modified element."
  (cond ((not element) (list contents))
        ((not (symbolp (car element))) contents)
        ((cdr element) (setcdr (cdr element) contents))
        (t (nconc element contents))))
</p>

<p>
(defsubst org-element-set-element (old new)
  "Replace element or object OLD with element or object NEW.
The function takes care of setting `:parent' property for NEW."
  ;; Since OLD is going to be changed into NEW by side-effect, first
  ;; make sure that every element or object within NEW has OLD as
  ;; parent.
  (mapc (lambda (blob) (org-element-put-property blob :parent old))
        (org-element-contents new))
  ;; Transfer contents.
  (apply 'org-element-set-contents old (org-element-contents new))
  ;; Ensure NEW has same parent as OLD, then overwrite OLD properties
  ;; with NEW's.
  (org-element-put-property new :parent (org-element-property :parent old))
  (setcar (cdr old) (nth 1 new))
  ;; Transfer type.
  (setcar old (car new)))
</p>

<p>
(defsubst org-element-adopt-elements (parent &amp;rest children)
  "Append elements to the contents of another element.
</p>

<p>
PARENT is an element or object.  CHILDREN can be elements,
objects, or a strings.
</p>

<p>
The function takes care of setting `:parent' property for CHILD.
Return parent element."
  ;; Link every child to PARENT. If PARENT is nil, it is a secondary
  ;; string: parent is the list itself.
  (mapc (lambda (child)
          (org-element-put-property child :parent (or parent children)))
        children)
  ;; Add CHILDREN at the end of PARENT contents.
  (when parent
    (apply 'org-element-set-contents
           parent
           (nconc (org-element-contents parent) children)))
  ;; Return modified PARENT element.
  (or parent children))
</p>


<p>

;;; Greater elements
;;
;; For each greater element type, we define a parser and an
;; interpreter.
;;
;; A parser returns the element or object as the list described above.
;; Most of them accepts no argument.  Though, exceptions exist.  Hence
;; every element containing a secondary string (see
;; `org-element-secondary-value-alist') will accept an optional
;; argument to toggle parsing of that secondary string.  Moreover,
;; `item' parser requires current list's structure as its first
;; element.
;;
;; An interpreter accepts two arguments: the list representation of
;; the element or object, and its contents.  The latter may be nil,
;; depending on the element or object considered.  It returns the
;; appropriate Org syntax, as a string.
;;
;; Parsing functions must follow the naming convention:
;; org-element-TYPE-parser, where TYPE is greater element's type, as
;; defined in `org-element-greater-elements'.
;;
;; Similarly, interpreting functions must follow the naming
;; convention: org-element-TYPE-interpreter.
;;
;; With the exception of `headline' and `item' types, greater elements
;; cannot contain other greater elements of their own type.
;;
;; Beside implementing a parser and an interpreter, adding a new
;; greater element requires to tweak `org-element&#x2013;current-element'.
;; Moreover, the newly defined type must be added to both
;; `org-element-all-elements' and `org-element-greater-elements'.
</p>


<p>
;;;; Center Block
</p>

<p>
(defun org-element-center-block-parser (limit affiliated)
  "Parse a center block.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `center-block' and CDR is a plist
containing `:begin', `:end', `:hiddenp', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the block."
  (let ((case-fold-search t))
    (if (not (save-excursion
               (re-search-forward "<sup>[</sup> \t]*#\\+END<sub>CENTER[</sub> \t]*$" limit t)))
        ;; Incomplete block: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (let ((block-end-line (match-beginning 0)))
        (let* ((begin (car affiliated))
               (post-affiliated (point))
               ;; Empty blocks have no contents.
               (contents-begin (progn (forward-line)
                                      (and (&lt; (point) block-end-line)
                                           (point))))
               (contents-end (and contents-begin block-end-line))
               (hidden (org-invisible-p2))
               (pos-before-blank (progn (goto-char block-end-line)
                                        (forward-line)
                                        (point)))
               (end (save-excursion
                      (skip-chars-forward " \r\t\n" limit)
                      (if (eobp) (point) (line-beginning-position)))))
          (list 'center-block
                (nconc
                 (list :begin begin
</p>
<p>
:end end
</p>
<p>
:hiddenp hidden
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated))))))))
</p>

<p>
(defun org-element-center-block-interpreter (center-block contents)
  "Interpret CENTER-BLOCK element as Org syntax.
CONTENTS is the contents of the element."
  (format "#+BEGIN<sub>CENTER\n</sub>%s#+END<sub>CENTER</sub>" contents))
</p>


<p>
;;;; Drawer
</p>

<p>
(defun org-element-drawer-parser (limit affiliated)
  "Parse a drawer.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `drawer' and CDR is a plist containing
`:drawer-name', `:begin', `:end', `:hiddenp', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.
</p>

<p>
Assume point is at beginning of drawer."
  (let ((case-fold-search t))
    (if (not (save-excursion (re-search-forward "<sup>[</sup> \t]*:END:[ \t]*$" limit t)))
        ;; Incomplete drawer: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (save-excursion
        (let* ((drawer-end-line (match-beginning 0))
               (name (progn (looking-at org-drawer-regexp)
                            (org-match-string-no-properties 1)))
               (begin (car affiliated))
               (post-affiliated (point))
               ;; Empty drawers have no contents.
               (contents-begin (progn (forward-line)
                                      (and (&lt; (point) drawer-end-line)
                                           (point))))
               (contents-end (and contents-begin drawer-end-line))
               (hidden (org-invisible-p2))
               (pos-before-blank (progn (goto-char drawer-end-line)
                                        (forward-line)
                                        (point)))
               (end (progn (skip-chars-forward " \r\t\n" limit)
                           (if (eobp) (point) (line-beginning-position)))))
          (list 'drawer
                (nconc
                 (list :begin begin
</p>
<p>
:end end
</p>
<p>
:drawer-name name
</p>
<p>
:hiddenp hidden
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated))))))))
</p>

<p>
(defun org-element-drawer-interpreter (drawer contents)
  "Interpret DRAWER element as Org syntax.
CONTENTS is the contents of the element."
  (format ":%s:\n%s:END:"
          (org-element-property :drawer-name drawer)
          contents))
</p>


<p>
;;;; Dynamic Block
</p>

<p>
(defun org-element-dynamic-block-parser (limit affiliated)
  "Parse a dynamic block.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `dynamic-block' and CDR is a plist
containing `:block-name', `:begin', `:end', `:hiddenp',
`:contents-begin', `:contents-end', `:arguments', `:post-blank'
and `:post-affiliated' keywords.
</p>

<p>
Assume point is at beginning of dynamic block."
  (let ((case-fold-search t))
    (if (not (save-excursion
               (re-search-forward "<sup>[</sup> \t]*#\\+END:?[ \t]*$" limit t)))
        ;; Incomplete block: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (let ((block-end-line (match-beginning 0)))
        (save-excursion
          (let* ((name (progn (looking-at org-dblock-start-re)
                              (org-match-string-no-properties 1)))
                 (arguments (org-match-string-no-properties 3))
                 (begin (car affiliated))
                 (post-affiliated (point))
                 ;; Empty blocks have no contents.
                 (contents-begin (progn (forward-line)
                                        (and (&lt; (point) block-end-line)
                                             (point))))
                 (contents-end (and contents-begin block-end-line))
                 (hidden (org-invisible-p2))
                 (pos-before-blank (progn (goto-char block-end-line)
                                          (forward-line)
                                          (point)))
                 (end (progn (skip-chars-forward " \r\t\n" limit)
                             (if (eobp) (point) (line-beginning-position)))))
            (list 'dynamic-block
                  (nconc
                   (list :begin begin
</p>
<p>
:end end
</p>
<p>
:block-name name
</p>
<p>
:arguments arguments
</p>
<p>
:hiddenp hidden
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated)))))))))
</p>

<p>
(defun org-element-dynamic-block-interpreter (dynamic-block contents)
  "Interpret DYNAMIC-BLOCK element as Org syntax.
CONTENTS is the contents of the element."
  (format "#+BEGIN: %s%s\n%s#+END:"
          (org-element-property :block-name dynamic-block)
          (let ((args (org-element-property :arguments dynamic-block)))
            (and args (concat " " args)))
          contents))
</p>


<p>
;;;; Footnote Definition
</p>

<p>
(defun org-element-footnote-definition-parser (limit affiliated)
  "Parse a footnote definition.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `footnote-definition' and CDR is
a plist containing `:label', `:begin' `:end', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the footnote definition."
  (save-excursion
    (let* ((label (progn (looking-at org-footnote-definition-re)
                         (org-match-string-no-properties 1)))
           (begin (car affiliated))
           (post-affiliated (point))
           (ending (save-excursion
                     (if (progn
                           (end-of-line)
                           (re-search-forward
                            (concat org-outline-regexp-bol "\\|"
                                    org-footnote-definition-re "\\|"
                                    "<sup>\\</sup>\\([ \t]*\n\\)\\{2,\\}") limit 'move))
                         (match-beginning 0)
                       (point))))
           (contents-begin (progn
                             (search-forward "]")
                             (skip-chars-forward " \r\t\n" ending)
                             (cond ((= (point) ending) nil)
                                   ((= (line-beginning-position) begin) (point))
                                   (t (line-beginning-position)))))
           (contents-end (and contents-begin ending))
           (end (progn (goto-char ending)
                       (skip-chars-forward " \r\t\n" limit)
                       (if (eobp) (point) (line-beginning-position)))))
      (list 'footnote-definition
            (nconc
             (list :label label
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank (count-lines ending end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated))))))
</p>

<p>
(defun org-element-footnote-definition-interpreter (footnote-definition contents)
  "Interpret FOOTNOTE-DEFINITION element as Org syntax.
CONTENTS is the contents of the footnote-definition."
  (concat (format "[%s]" (org-element-property :label footnote-definition))
          " "
          contents))
</p>


<p>
;;;; Headline
</p>

<p>
(defun org-element-headline-parser (limit &amp;optional raw-secondary-p)
  "Parse a headline.
</p>

<p>
Return a list whose CAR is `headline' and CDR is a plist
containing `:raw-value', `:title', `:alt-title', `:begin',
`:end', `:pre-blank', `:hiddenp', `:contents-begin' and
`:contents-end', `:level', `:priority', `:tags',
`:todo-keyword',`:todo-type', `:scheduled', `:deadline',
`:closed', `:quotedp', `:archivedp', `:commentedp' and
`:footnote-section-p' keywords.
</p>

<p>
The plist also contains any property set in the property drawer,
with its name in upper cases and colons added at the
beginning (e.g., `:CUSTOM<sub>ID'</sub>).
</p>

<p>
LIMIT is a buffer position bounding the search.
</p>

<p>
When RAW-SECONDARY-P is non-nil, headline's title will not be
parsed as a secondary string, but as a plain string instead.
</p>

<p>
Assume point is at beginning of the headline."
  (save-excursion
    (let* ((components (org-heading-components))
           (level (nth 1 components))
           (todo (nth 2 components))
           (todo-type
            (and todo (if (member todo org-done-keywords) 'done 'todo)))
           (tags (let ((raw-tags (nth 5 components)))
                   (and raw-tags (org-split-string raw-tags ":"))))
           (raw-value (or (nth 4 components) ""))
           (quotedp
            (let ((case-fold-search nil))
              (string-match (format "^%s\\( \\|$\\)" org-quote-string)
                            raw-value)))
           (commentedp
            (let ((case-fold-search nil))
              (string-match (format "^%s\\( \\|$\\)" org-comment-string)
                            raw-value)))
           (archivedp (member org-archive-tag tags))
           (footnote-section-p (and org-footnote-section
                                    (string= org-footnote-section raw-value)))
           ;; Upcase property names.  It avoids confusion between
           ;; properties obtained through property drawer and default
           ;; properties from the parser (e.g. `:end' and :END:)
           (standard-props
            (let (plist)
              (mapc
               (lambda (p)
                 (setq plist
                       (plist-put plist
                                  (intern (concat ":" (upcase (car p))))
                                  (cdr p))))
               (org-entry-properties nil 'standard))
              plist))
           (time-props
            ;; Read time properties on the line below the headline.
            (save-excursion
              (when (progn (forward-line)
                           (looking-at org-planning-or-clock-line-re))
                (let ((end (line-end-position)) plist)
                  (while (re-search-forward
                          org-keyword-time-not-clock-regexp end t)
                    (goto-char (match-end 1))
                    (skip-chars-forward " \t")
                    (let ((keyword (match-string 1))
                          (time (org-element-timestamp-parser)))
                      (cond ((equal keyword org-scheduled-string)
                             (setq plist (plist-put plist :scheduled time)))
                            ((equal keyword org-deadline-string)
                             (setq plist (plist-put plist :deadline time)))
                            (t (setq plist (plist-put plist :closed time))))))
                  plist))))
           (begin (point))
           (end (min (save-excursion (org-end-of-subtree t t)) limit))
           (pos-after-head (progn (forward-line) (point)))
           (contents-begin (save-excursion
                             (skip-chars-forward " \r\t\n" end)
                             (and (/= (point) end) (line-beginning-position))))
           (hidden (org-invisible-p2))
           (contents-end (and contents-begin
                              (progn (goto-char end)
                                     (skip-chars-backward " \r\t\n")
                                     (forward-line)
                                     (point)))))
      ;; Clean RAW-VALUE from any quote or comment string.
      (when (or quotedp commentedp)
        (let ((case-fold-search nil))
          (setq raw-value
                (replace-regexp-in-string
                 (concat
                  (regexp-opt (list org-quote-string org-comment-string))
                  "\\(?: \\|$\\)")
                 ""
                 raw-value))))
      ;; Clean TAGS from archive tag, if any.
      (when archivedp (setq tags (delete org-archive-tag tags)))
      (let ((headline
             (list 'headline
                   (nconc
                    (list :raw-value raw-value
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:pre-blank
(if (not contents-begin) 0
  (count-lines pos-after-head contents-begin))
</p>
<p>
:hiddenp hidden
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:level level
</p>
<p>
:priority (nth 3 components)
</p>
<p>
:tags tags
</p>
<p>
:todo-keyword todo
</p>
<p>
:todo-type todo-type
</p>
<p>
:post-blank (count-lines
             (or contents-end pos-after-head)
             end)
</p>
<p>
:footnote-section-p footnote-section-p
</p>
<p>
:archivedp archivedp
</p>
<p>
:commentedp commentedp
</p>
<p>
                  :quotedp quotedp)
            time-props
            standard-props))))
(let ((alt-title (org-element-property :ALT<sub>TITLE</sub> headline)))
  (when alt-title
    (org-element-put-property
     headline :alt-title
     (if raw-secondary-p alt-title
       (org-element-parse-secondary-string
        alt-title (org-element-restriction 'headline) headline)))))
(org-element-put-property
 headline :title
 (if raw-secondary-p raw-value
   (org-element-parse-secondary-string
    raw-value (org-element-restriction 'headline) headline)))))))
</p>

<p>
(defun org-element-headline-interpreter (headline contents)
  "Interpret HEADLINE element as Org syntax.
CONTENTS is the contents of the element."
  (let* ((level (org-element-property :level headline))
         (todo (org-element-property :todo-keyword headline))
         (priority (org-element-property :priority headline))
         (title (org-element-interpret-data
                 (org-element-property :title headline)))
         (tags (let ((tag-list (if (org-element-property :archivedp headline)
                                   (cons org-archive-tag
                                         (org-element-property :tags headline))
                                 (org-element-property :tags headline))))
                 (and tag-list
                      (format ":%s:" (mapconcat 'identity tag-list ":")))))
         (commentedp (org-element-property :commentedp headline))
         (quotedp (org-element-property :quotedp headline))
         (pre-blank (or (org-element-property :pre-blank headline) 0))
         (heading (concat (make-string (org-reduced-level level) ?*)
                          (and todo (concat " " todo))
                          (and quotedp (concat " " org-quote-string))
                          (and commentedp (concat " " org-comment-string))
                          (and priority
                               (format " [#%s]" (char-to-string priority)))
                          (cond ((and org-footnote-section
                                      (org-element-property
</p>
<p>
                                   :footnote-section-p headline))
                             (concat " " org-footnote-section))
                            (title (concat " " title))))))
(concat heading
        ;; Align tags.
        (when tags
          (cond
           ((zerop org-tags-column) (format " %s" tags))
           ((&lt; org-tags-column 0)
            (concat
             (make-string
              (max (- (+ org-tags-column (length heading) (length tags))) 1)
              ? )
             tags))
           (t
            (concat
             (make-string (max (- org-tags-column (length heading)) 1) ? )
             tags))))
        (make-string (1+ pre-blank) 10)
        contents)))
</p>


<p>
;;;; Inlinetask
</p>

<p>
(defun org-element-inlinetask-parser (limit &amp;optional raw-secondary-p)
  "Parse an inline task.
</p>

<p>
Return a list whose CAR is `inlinetask' and CDR is a plist
containing `:title', `:begin', `:end', `:hiddenp',
`:contents-begin' and `:contents-end', `:level', `:priority',
`:raw-value', `:tags', `:todo-keyword', `:todo-type',
`:scheduled', `:deadline', `:closed' and `:post-blank' keywords.
</p>

<p>
The plist also contains any property set in the property drawer,
with its name in upper cases and colons added at the
beginning (e.g., `:CUSTOM<sub>ID'</sub>).
</p>

<p>
When optional argument RAW-SECONDARY-P is non-nil, inline-task's
title will not be parsed as a secondary string, but as a plain
string instead.
</p>

<p>
Assume point is at beginning of the inline task."
  (save-excursion
    (let* ((begin (point))
           (components (org-heading-components))
           (todo (nth 2 components))
           (todo-type (and todo
                           (if (member todo org-done-keywords) 'done 'todo)))
           (tags (let ((raw-tags (nth 5 components)))
                   (and raw-tags (org-split-string raw-tags ":"))))
           (raw-value (or (nth 4 components) ""))
           ;; Upcase property names.  It avoids confusion between
           ;; properties obtained through property drawer and default
           ;; properties from the parser (e.g. `:end' and :END:)
           (standard-props
            (let (plist)
              (mapc
               (lambda (p)
                 (setq plist
                       (plist-put plist
                                  (intern (concat ":" (upcase (car p))))
                                  (cdr p))))
               (org-entry-properties nil 'standard))
              plist))
           (time-props
            ;; Read time properties on the line below the inlinetask
            ;; opening string.
            (save-excursion
              (when (progn (forward-line)
                           (looking-at org-planning-or-clock-line-re))
                (let ((end (line-end-position)) plist)
                  (while (re-search-forward
                          org-keyword-time-not-clock-regexp end t)
                    (goto-char (match-end 1))
                    (skip-chars-forward " \t")
                    (let ((keyword (match-string 1))
                          (time (org-element-timestamp-parser)))
                      (cond ((equal keyword org-scheduled-string)
                             (setq plist (plist-put plist :scheduled time)))
                            ((equal keyword org-deadline-string)
                             (setq plist (plist-put plist :deadline time)))
                            (t (setq plist (plist-put plist :closed time))))))
                  plist))))
           (task-end (save-excursion
                       (end-of-line)
                       (and (re-search-forward org-outline-regexp-bol limit t)
                            (org-looking-at-p "END[ \t]*$")
                            (line-beginning-position))))
           (contents-begin (progn (forward-line)
                                  (and task-end (&lt; (point) task-end) (point))))
           (hidden (and contents-begin (org-invisible-p2)))
           (contents-end (and contents-begin task-end))
           (before-blank (if (not task-end) (point)
                           (goto-char task-end)
                           (forward-line)
                           (point)))
           (end (progn (skip-chars-forward " \r\t\n" limit)
                       (if (eobp) (point) (line-beginning-position))))
           (inlinetask
            (list 'inlinetask
                  (nconc
                   (list :raw-value raw-value
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:hiddenp hidden
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:level (nth 1 components)
</p>
<p>
:priority (nth 3 components)
</p>
<p>
:tags tags
</p>
<p>
:todo-keyword todo
</p>
<p>
:todo-type todo-type
</p>
<p>
                   :post-blank (count-lines before-blank end))
             time-props
             standard-props))))
(org-element-put-property
 inlinetask :title
 (if raw-secondary-p raw-value
   (org-element-parse-secondary-string
    raw-value
    (org-element-restriction 'inlinetask)
    inlinetask))))))
</p>

<p>
(defun org-element-inlinetask-interpreter (inlinetask contents)
  "Interpret INLINETASK element as Org syntax.
CONTENTS is the contents of inlinetask."
  (let* ((level (org-element-property :level inlinetask))
         (todo (org-element-property :todo-keyword inlinetask))
         (priority (org-element-property :priority inlinetask))
         (title (org-element-interpret-data
                 (org-element-property :title inlinetask)))
         (tags (let ((tag-list (org-element-property :tags inlinetask)))
                 (and tag-list
                      (format ":%s:" (mapconcat 'identity tag-list ":")))))
         (task (concat (make-string level ?*)
                       (and todo (concat " " todo))
                       (and priority
                            (format " [#%s]" (char-to-string priority)))
                       (and title (concat " " title)))))
    (concat task
            ;; Align tags.
            (when tags
              (cond
               ((zerop org-tags-column) (format " %s" tags))
               ((&lt; org-tags-column 0)
                (concat
                 (make-string
                  (max (- (+ org-tags-column (length task) (length tags))) 1)
                  ? )
                 tags))
               (t
                (concat
                 (make-string (max (- org-tags-column (length task)) 1) ? )
                 tags))))
            ;; Prefer degenerate inlinetasks when there are no
            ;; contents.
            (when contents
              (concat "\n"
                      contents
                      (make-string level ?*) " END")))))
</p>


<p>
;;;; Item
</p>

<p>
(defun org-element-item-parser (limit struct &amp;optional raw-secondary-p)
  "Parse an item.
</p>

<p>
STRUCT is the structure of the plain list.
</p>

<p>
Return a list whose CAR is `item' and CDR is a plist containing
`:bullet', `:begin', `:end', `:contents-begin', `:contents-end',
`:checkbox', `:counter', `:tag', `:structure', `:hiddenp' and
`:post-blank' keywords.
</p>

<p>
When optional argument RAW-SECONDARY-P is non-nil, item's tag, if
any, will not be parsed as a secondary string, but as a plain
string instead.
</p>

<p>
Assume point is at the beginning of the item."
  (save-excursion
    (beginning-of-line)
    (looking-at org-list-full-item-re)
    (let* ((begin (point))
           (bullet (org-match-string-no-properties 1))
           (checkbox (let ((box (org-match-string-no-properties 3)))
                       (cond ((equal "[ ]" box) 'off)
                             ((equal "[X]" box) 'on)
                             ((equal "[-]" box) 'trans))))
           (counter (let ((c (org-match-string-no-properties 2)))
                      (save-match-data
                        (cond
                         ((not c) nil)
                         ((string-match "[A-Za-z]" c)
                          (- (string-to-char (upcase (match-string 0 c)))
                             64))
                         ((string-match "[0-9]+" c)
                          (string-to-number (match-string 0 c)))))))
           (end (save-excursion (goto-char (org-list-get-item-end begin struct))
                                (unless (bolp) (forward-line))
                                (point)))
           (contents-begin
            (progn (goto-char
                    ;; Ignore tags in un-ordered lists: they are just
                    ;; a part of item's body.
                    (if (and (match-beginning 4)
                             (save-match-data (string-match "[.)]" bullet)))
                        (match-beginning 4)
                      (match-end 0)))
                   (skip-chars-forward " \r\t\n" limit)
                   ;; If first line isn't empty, contents really start
                   ;; at the text after item's meta-data.
                   (if (= (point-at-bol) begin) (point) (point-at-bol))))
           (hidden (progn (forward-line)
                          (and (not (= (point) end)) (org-invisible-p2))))
           (contents-end (progn (goto-char end)
                                (skip-chars-backward " \r\t\n")
                                (forward-line)
                                (point)))
           (item
            (list 'item
                  (list :bullet bullet
</p>
<p>
:begin begin
</p>
<p>
:end end
;; CONTENTS-BEGIN and CONTENTS-END may be
;; mixed up in the case of an empty item
;; separated from the next by a blank line.
;; Thus ensure the former is always the
;; smallest.
</p>
<p>
:contents-begin (min contents-begin contents-end)
</p>
<p>
:contents-end (max contents-begin contents-end)
</p>
<p>
:checkbox checkbox
</p>
<p>
:counter counter
</p>
<p>
:hiddenp hidden
</p>
<p>
:structure struct
</p>
<p>
                  :post-blank (count-lines contents-end end)))))
(org-element-put-property
 item :tag
 (let ((raw-tag (org-list-get-tag begin struct)))
   (and raw-tag
        (if raw-secondary-p raw-tag
          (org-element-parse-secondary-string
           raw-tag (org-element-restriction 'item) item))))))))
</p>

<p>
(defun org-element-item-interpreter (item contents)
  "Interpret ITEM element as Org syntax.
CONTENTS is the contents of the element."
  (let* ((bullet (let ((bullet (org-element-property :bullet item)))
                   (org-list-bullet-string
                    (cond ((not (string-match "[0-9a-zA-Z]" bullet)) "- ")
                          ((eq org-plain-list-ordered-item-terminator ?\)) "1)")
                          (t "1.")))))
         (checkbox (org-element-property :checkbox item))
         (counter (org-element-property :counter item))
         (tag (let ((tag (org-element-property :tag item)))
                (and tag (org-element-interpret-data tag))))
         ;; Compute indentation.
         (ind (make-string (length bullet) 32))
         (item-starts-with-par-p
          (eq (org-element-type (car (org-element-contents item)))
              'paragraph)))
    ;; Indent contents.
    (concat
     bullet
     (and counter (format "[@%d] " counter))
     (case checkbox
       (on "[X] ")
       (off "[ ] ")
       (trans "[-] "))
     (and tag (format "%s :: " tag))
     (when contents
       (let ((contents (replace-regexp-in-string
                        "\\(^\\)[ \t]*\&sect;-" ind contents nil nil 1)))
         (if item-starts-with-par-p (org-trim contents)
           (concat "\n" contents)))))))
</p>


<p>
;;;; Plain List
</p>

<p>
(defun org-element&#x2013;list-struct (limit)
  ;; Return structure of list at point.  Internal function.  See
  ;; `org-list-struct' for details.
  (let ((case-fold-search t)
        (top-ind limit)
        (item-re (org-item-re))
        (drawers-re (concat ":\\("
			    (mapconcat 'regexp-quote org-drawers "\\|")
			    "\\):[ \t]*$"))
        (inlinetask-re (and (featurep 'org-inlinetask) "<sup>\\</sup>*+ "))
        items struct)
    (save-excursion
      (catch 'exit
        (while t
          (cond
           ;; At limit: end all items.
           ((&gt;= (point) limit)
            (throw 'exit
                   (let ((end (progn (skip-chars-backward " \r\t\n")
                                     (forward-line)
                                     (point))))
                     (dolist (item items (sort (nconc items struct)
                                               'car-less-than-car))
                       (setcar (nthcdr 6 item) end)))))
           ;; At list end: end all items.
           ((looking-at org-list-end-re)
            (throw 'exit (dolist (item items (sort (nconc items struct)
                                                   'car-less-than-car))
                           (setcar (nthcdr 6 item) (point)))))
           ;; At a new item: end previous sibling.
           ((looking-at item-re)
            (let ((ind (save-excursion (skip-chars-forward " \t")
                                       (current-column))))
              (setq top-ind (min top-ind ind))
              (while (and items (&lt;= ind (nth 1 (car items))))
                (let ((item (pop items)))
                  (setcar (nthcdr 6 item) (point))
                  (push item struct)))
              (push (progn (looking-at org-list-full-item-re)
                           (let ((bullet (match-string-no-properties 1)))
                             (list (point)
                                   ind
                                   bullet
                                   (match-string-no-properties 2) ; counter
                                   (match-string-no-properties 3) ; checkbox
                                   ;; Description tag.
                                   (and (save-match-data
                                          (string-match "[-+*]" bullet))
                                        (match-string-no-properties 4))
                                   ;; Ending position, unknown so far.
                                   nil)))
                    items))
            (forward-line 1))
           ;; Skip empty lines.
           ((looking-at "<sup>[</sup> \t]*$") (forward-line))
           ;; Skip inline tasks and blank lines along the way.
           ((and inlinetask-re (looking-at inlinetask-re))
            (forward-line)
            (let ((origin (point)))
              (when (re-search-forward inlinetask-re limit t)
                (if (org-looking-at-p "END[ \t]*$") (forward-line)
                  (goto-char origin)))))
           ;; At some text line.  Check if it ends any previous item.
           (t
            (let ((ind (progn (skip-chars-forward " \t") (current-column))))
              (when (&lt;= ind top-ind)
                (skip-chars-backward " \r\t\n")
                (forward-line))
              (while (&lt;= ind (nth 1 (car items)))
                (let ((item (pop items)))
                  (setcar (nthcdr 6 item) (line-beginning-position))
                  (push item struct)
                  (unless items
                    (throw 'exit (sort struct 'car-less-than-car))))))
            ;; Skip blocks (any type) and drawers contents.
            (cond
             ((and (looking-at "#\\+BEGIN\\(:\\|_\\S-+\\)")
                   (re-search-forward
                    (format "<sup>[</sup> \t]*#\\+END%s[ \t]*$"
                            (org-match-string-no-properties 1))
                    limit t)))
             ((and (looking-at drawers-re)
                   (re-search-forward "<sup>[</sup> \t]*:END:[ \t]*$" limit t))))
            (forward-line))))))))
</p>

<p>
(defun org-element-plain-list-parser (limit affiliated structure)
  "Parse a plain list.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.  STRUCTURE is the structure of the plain list being
parsed.
</p>

<p>
Return a list whose CAR is `plain-list' and CDR is a plist
containing `:type', `:begin', `:end', `:contents-begin' and
`:contents-end', `:structure', `:post-blank' and
`:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the list."
  (save-excursion
    (let* ((struct (or structure (org-element&#x2013;list-struct limit)))
           (prevs (org-list-prevs-alist struct))
           (type (org-list-get-list-type (point) struct prevs))
           (contents-begin (point))
           (begin (car affiliated))
           (contents-end
            (progn (goto-char (org-list-get-list-end (point) struct prevs))
                   (unless (bolp) (forward-line))
                   (point)))
           (end (progn (skip-chars-forward " \r\t\n" limit)
                       (if (= (point) limit) limit (line-beginning-position)))))
      ;; Return value.
      (list 'plain-list
            (nconc
             (list :type type
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:structure struct
</p>
<p>
:post-blank (count-lines contents-end end)
</p>
<p>
      :post-affiliated contents-begin)
(cdr affiliated))))))
</p>

<p>
(defun org-element-plain-list-interpreter (plain-list contents)
  "Interpret PLAIN-LIST element as Org syntax.
CONTENTS is the contents of the element."
  (with-temp-buffer
    (insert contents)
    (goto-char (point-min))
    (org-list-repair)
    (buffer-string)))
</p>


<p>
;;;; Property Drawer
</p>

<p>
(defun org-element-property-drawer-parser (limit affiliated)
  "Parse a property drawer.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `property-drawer' and CDR is a plist
containing `:begin', `:end', `:hiddenp', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the property drawer."
  (save-excursion
    (let ((case-fold-search t))
      (if (not (save-excursion
                 (re-search-forward "<sup>[</sup> \t]*:END:[ \t]*$" limit t)))
          ;; Incomplete drawer: parse it as a paragraph.
          (org-element-paragraph-parser limit affiliated)
        (save-excursion
          (let* ((drawer-end-line (match-beginning 0))
                 (begin (car affiliated))
                 (post-affiliated (point))
                 (contents-begin (progn (forward-line)
                                        (and (&lt; (point) drawer-end-line)
                                             (point))))
                 (contents-end (and contents-begin drawer-end-line))
                 (hidden (org-invisible-p2))
                 (pos-before-blank (progn (goto-char drawer-end-line)
                                          (forward-line)
                                          (point)))
                 (end (progn (skip-chars-forward " \r\t\n" limit)
                             (if (eobp) (point) (line-beginning-position)))))
            (list 'property-drawer
                  (nconc
                   (list :begin begin
</p>
<p>
:end end
</p>
<p>
:hiddenp hidden
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated)))))))))
</p>

<p>
(defun org-element-property-drawer-interpreter (property-drawer contents)
  "Interpret PROPERTY-DRAWER element as Org syntax.
CONTENTS is the properties within the drawer."
  (format ":PROPERTIES:\n%s:END:" contents))
</p>


<p>
;;;; Quote Block
</p>

<p>
(defun org-element-quote-block-parser (limit affiliated)
  "Parse a quote block.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `quote-block' and CDR is a plist
containing `:begin', `:end', `:hiddenp', `:contents-begin',
`:contents-end', `:post-blank' and `:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the block."
  (let ((case-fold-search t))
    (if (not (save-excursion
               (re-search-forward "<sup>[</sup> \t]*#\\+END<sub>QUOTE[</sub> \t]*$" limit t)))
        ;; Incomplete block: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (let ((block-end-line (match-beginning 0)))
        (save-excursion
          (let* ((begin (car affiliated))
                 (post-affiliated (point))
                 ;; Empty blocks have no contents.
                 (contents-begin (progn (forward-line)
                                        (and (&lt; (point) block-end-line)
                                             (point))))
                 (contents-end (and contents-begin block-end-line))
                 (hidden (org-invisible-p2))
                 (pos-before-blank (progn (goto-char block-end-line)
                                          (forward-line)
                                          (point)))
                 (end (progn (skip-chars-forward " \r\t\n" limit)
                             (if (eobp) (point) (line-beginning-position)))))
            (list 'quote-block
                  (nconc
                   (list :begin begin
</p>
<p>
:end end
</p>
<p>
:hiddenp hidden
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated)))))))))
</p>

<p>
(defun org-element-quote-block-interpreter (quote-block contents)
  "Interpret QUOTE-BLOCK element as Org syntax.
CONTENTS is the contents of the element."
  (format "#+BEGIN<sub>QUOTE\n</sub>%s#+END<sub>QUOTE</sub>" contents))
</p>


<p>
;;;; Section
</p>

<p>
(defun org-element-section-parser (limit)
  "Parse a section.
</p>

<p>
LIMIT bounds the search.
</p>

<p>
Return a list whose CAR is `section' and CDR is a plist
containing `:begin', `:end', `:contents-begin', `contents-end'
and `:post-blank' keywords."
  (save-excursion
    ;; Beginning of section is the beginning of the first non-blank
    ;; line after previous headline.
    (let ((begin (point))
          (end (progn (org-with-limited-levels (outline-next-heading))
                      (point)))
          (pos-before-blank (progn (skip-chars-backward " \r\t\n")
                                   (forward-line)
                                   (point))))
      (list 'section
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin begin
</p>
<p>
:contents-end pos-before-blank
</p>
<p>
:post-blank (count-lines pos-before-blank end))))))
</p>

<p>
(defun org-element-section-interpreter (section contents)
  "Interpret SECTION element as Org syntax.
CONTENTS is the contents of the element."
  contents)
</p>


<p>
;;;; Special Block
</p>

<p>
(defun org-element-special-block-parser (limit affiliated)
  "Parse a special block.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `special-block' and CDR is a plist
containing `:type', `:begin', `:end', `:hiddenp',
`:contents-begin', `:contents-end', `:post-blank' and
`:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the block."
  (let* ((case-fold-search t)
         (type (progn (looking-at "[ \t]*#\\+BEGIN<sub>\\</sub>\\(\\S-+\\)")
                      (upcase (match-string-no-properties 1)))))
    (if (not (save-excursion
               (re-search-forward
                (format "<sup>[</sup> \t]*#\\+END_%s[ \t]*$" (regexp-quote type))
                limit t)))
        ;; Incomplete block: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (let ((block-end-line (match-beginning 0)))
        (save-excursion
          (let* ((begin (car affiliated))
                 (post-affiliated (point))
                 ;; Empty blocks have no contents.
                 (contents-begin (progn (forward-line)
                                        (and (&lt; (point) block-end-line)
                                             (point))))
                 (contents-end (and contents-begin block-end-line))
                 (hidden (org-invisible-p2))
                 (pos-before-blank (progn (goto-char block-end-line)
                                          (forward-line)
                                          (point)))
                 (end (progn (skip-chars-forward " \r\t\n" limit)
                             (if (eobp) (point) (line-beginning-position)))))
            (list 'special-block
                  (nconc
                   (list :type type
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:hiddenp hidden
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated)))))))))
</p>

<p>
(defun org-element-special-block-interpreter (special-block contents)
  "Interpret SPECIAL-BLOCK element as Org syntax.
CONTENTS is the contents of the element."
  (let ((block-type (org-element-property :type special-block)))
    (format "#+BEGIN_%s\n%s#+END_%s" block-type contents block-type)))
</p>


<p>

;;; Elements
;;
;; For each element, a parser and an interpreter are also defined.
;; Both follow the same naming convention used for greater elements.
;;
;; Also, as for greater elements, adding a new element type is done
;; through the following steps: implement a parser and an interpreter,
;; tweak `org-element&#x2013;current-element' so that it recognizes the new
;; type and add that new type to `org-element-all-elements'.
;;
;; As a special case, when the newly defined type is a block type,
;; `org-element-block-name-alist' has to be modified accordingly.
</p>


<p>
;;;; Babel Call
</p>

<p>
(defun org-element-babel-call-parser (limit affiliated)
  "Parse a babel call.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `babel-call' and CDR is a plist
containing `:begin', `:end', `:info', `:post-blank' and
`:post-affiliated' as keywords."
  (save-excursion
    (let ((case-fold-search t)
          (info (progn (looking-at org-babel-block-lob-one-liner-regexp)
                       (org-babel-lob-get-info)))
          (begin (car affiliated))
          (post-affiliated (point))
          (pos-before-blank (progn (forward-line) (point)))
          (end (progn (skip-chars-forward " \r\t\n" limit)
                      (if (eobp) (point) (line-beginning-position)))))
      (list 'babel-call
            (nconc
             (list :begin begin
</p>
<p>
:end end
</p>
<p>
:info info
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated))))))
</p>

<p>
(defun org-element-babel-call-interpreter (babel-call contents)
  "Interpret BABEL-CALL element as Org syntax.
CONTENTS is nil."
  (let* ((babel-info (org-element-property :info babel-call))
         (main (car babel-info))
         (post-options (nth 1 babel-info)))
    (concat "#+CALL: "
            (if (not (string-match "\\[\\(\\[.*?\\]\\)\\]" main)) main
              ;; Remove redundant square brackets.
              (replace-match (match-string 1 main) nil nil main))
            (and post-options (format "[%s]" post-options)))))
</p>


<p>
;;;; Clock
</p>

<p>
(defun org-element-clock-parser (limit)
  "Parse a clock.
</p>

<p>
LIMIT bounds the search.
</p>

<p>
Return a list whose CAR is `clock' and CDR is a plist containing
`:status', `:value', `:time', `:begin', `:end' and `:post-blank'
as keywords."
  (save-excursion
    (let* ((case-fold-search nil)
           (begin (point))
           (value (progn (search-forward org-clock-string (line-end-position) t)
                         (skip-chars-forward " \t")
                         (org-element-timestamp-parser)))
           (duration (and (search-forward " =&gt; " (line-end-position) t)
                          (progn (skip-chars-forward " \t")
                                 (looking-at "\\(\\S-+\\)[ \t]*$"))
                          (org-match-string-no-properties 1)))
           (status (if duration 'closed 'running))
           (post-blank (let ((before-blank (progn (forward-line) (point))))
                         (skip-chars-forward " \r\t\n" limit)
                         (skip-chars-backward " \t")
                         (unless (bolp) (end-of-line))
                         (count-lines before-blank (point))))
           (end (point)))
      (list 'clock
            (list :status status
</p>
<p>
:value value
</p>
<p>
:duration duration
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-clock-interpreter (clock contents)
  "Interpret CLOCK element as Org syntax.
CONTENTS is nil."
  (concat org-clock-string " "
          (org-element-timestamp-interpreter
           (org-element-property :value clock) nil)
          (let ((duration (org-element-property :duration clock)))
            (and duration
                 (concat " =&gt; "
                         (apply 'format
                                "%2s:%02s"
                                (org-split-string duration ":")))))))
</p>


<p>
;;;; Comment
</p>

<p>
(defun org-element-comment-parser (limit affiliated)
  "Parse a comment.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `comment' and CDR is a plist
containing `:begin', `:end', `:value', `:post-blank',
`:post-affiliated' keywords.
</p>

<p>
Assume point is at comment beginning."
  (save-excursion
    (let* ((begin (car affiliated))
           (post-affiliated (point))
           (value (prog2 (looking-at "[ \t]*# ?")
                      (buffer-substring-no-properties
                       (match-end 0) (line-end-position))
                    (forward-line)))
           (com-end
            ;; Get comments ending.
            (progn
              (while (and (&lt; (point) limit) (looking-at "[ \t]*#\\( \\|$\\)"))
                ;; Accumulate lines without leading hash and first
                ;; whitespace.
                (setq value
                      (concat value
                              "\n"
                              (buffer-substring-no-properties
                               (match-end 0) (line-end-position))))
                (forward-line))
              (point)))
           (end (progn (goto-char com-end)
                       (skip-chars-forward " \r\t\n" limit)
                       (if (eobp) (point) (line-beginning-position)))))
      (list 'comment
            (nconc
             (list :begin begin
</p>
<p>
:end end
</p>
<p>
:value value
</p>
<p>
:post-blank (count-lines com-end end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated))))))
</p>

<p>
(defun org-element-comment-interpreter (comment contents)
  "Interpret COMMENT element as Org syntax.
CONTENTS is nil."
  (replace-regexp-in-string "^" "# " (org-element-property :value comment)))
</p>


<p>
;;;; Comment Block
</p>

<p>
(defun org-element-comment-block-parser (limit affiliated)
  "Parse an export block.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `comment-block' and CDR is a plist
containing `:begin', `:end', `:hiddenp', `:value', `:post-blank'
and `:post-affiliated' keywords.
</p>

<p>
Assume point is at comment block beginning."
  (let ((case-fold-search t))
    (if (not (save-excursion
               (re-search-forward "<sup>[</sup> \t]*#\\+END<sub>COMMENT[</sub> \t]*$" limit t)))
        ;; Incomplete block: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
        (save-excursion
          (let* ((begin (car affiliated))
                 (post-affiliated (point))
                 (contents-begin (progn (forward-line) (point)))
                 (hidden (org-invisible-p2))
                 (pos-before-blank (progn (goto-char contents-end)
                                          (forward-line)
                                          (point)))
                 (end (progn (skip-chars-forward " \r\t\n" limit)
                             (if (eobp) (point) (line-beginning-position))))
                 (value (buffer-substring-no-properties
                         contents-begin contents-end)))
            (list 'comment-block
                  (nconc
                   (list :begin begin
</p>
<p>
:end end
</p>
<p>
:value value
</p>
<p>
:hiddenp hidden
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated)))))))))
</p>

<p>
(defun org-element-comment-block-interpreter (comment-block contents)
  "Interpret COMMENT-BLOCK element as Org syntax.
CONTENTS is nil."
  (format "#+BEGIN<sub>COMMENT\n</sub>%s#+END<sub>COMMENT</sub>"
          (org-remove-indentation (org-element-property :value comment-block))))
</p>


<p>
;;;; Diary Sexp
</p>

<p>
(defun org-element-diary-sexp-parser (limit affiliated)
  "Parse a diary sexp.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `diary-sexp' and CDR is a plist
containing `:begin', `:end', `:value', `:post-blank' and
`:post-affiliated' keywords."
  (save-excursion
    (let ((begin (car affiliated))
          (post-affiliated (point))
          (value (progn (looking-at "\\(%%(.*\\)[ \t]*$")
                        (org-match-string-no-properties 1)))
          (pos-before-blank (progn (forward-line) (point)))
          (end (progn (skip-chars-forward " \r\t\n" limit)
                      (if (eobp) (point) (line-beginning-position)))))
      (list 'diary-sexp
            (nconc
             (list :value value
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated))))))
</p>

<p>
(defun org-element-diary-sexp-interpreter (diary-sexp contents)
  "Interpret DIARY-SEXP as Org syntax.
CONTENTS is nil."
  (org-element-property :value diary-sexp))
</p>


<p>
;;;; Example Block
</p>

<p>
(defun org-element&#x2013;remove-indentation (s &amp;optional n)
  "Remove maximum common indentation in string S and return it.
When optional argument N is a positive integer, remove exactly
that much characters from indentation, if possible, or return
S as-is otherwise.  Unlike to `org-remove-indentation', this
function doesn't call `untabify' on S."
  (catch 'exit
    (with-temp-buffer
      (insert s)
      (goto-char (point-min))
      ;; Find maximum common indentation, if not specified.
      (setq n (or n
                  (let ((min-ind (point-max)))
                    (save-excursion
                      (while (re-search-forward "<sup>[</sup> \t]*\&sect;-" nil t)
                        (let ((ind (1- (current-column))))
                          (if (zerop ind) (throw 'exit s)
                            (setq min-ind (min min-ind ind))))))
                    min-ind)))
      (if (zerop n) s
        ;; Remove exactly N indentation, but give up if not possible.
        (while (not (eobp))
          (let ((ind (progn (skip-chars-forward " \t") (current-column))))
            (cond ((eolp) (delete-region (line-beginning-position) (point)))
                  ((&lt; ind n) (throw 'exit s))
                  (t (org-indent-line-to (- ind n))))
            (forward-line)))
        (buffer-string)))))
</p>

<p>
(defun org-element-example-block-parser (limit affiliated)
  "Parse an example block.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `example-block' and CDR is a plist
containing `:begin', `:end', `:number-lines', `:preserve-indent',
`:retain-labels', `:use-labels', `:label-fmt', `:hiddenp',
`:switches', `:value', `:post-blank' and `:post-affiliated'
keywords."
  (let ((case-fold-search t))
    (if (not (save-excursion
               (re-search-forward "<sup>[</sup> \t]*#\\+END<sub>EXAMPLE[</sub> \t]*$" limit t)))
        ;; Incomplete block: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
        (save-excursion
          (let* ((switches
                  (progn
                    (looking-at "<sup>[</sup> \t]*#\\+BEGIN<sub>EXAMPLE<br  />
</sub>\\(?: +\\(.*\\)\\)?")
                    (org-match-string-no-properties 1)))
                 ;; Switches analysis
                 (number-lines
                  (cond ((not switches) nil)
                        ((string-match "-n\\&gt;" switches) 'new)
                        ((string-match "+n\\&gt;" switches) 'continued)))
                 (preserve-indent
                  (or org-src-preserve-indentation
                      (and switches (string-match "-i\\&gt;" switches))))
                 ;; Should labels be retained in (or stripped from) example
                 ;; blocks?
                 (retain-labels
                  (or (not switches)
                      (not (string-match "-r\\&gt;" switches))
                      (and number-lines (string-match "-k\\&gt;" switches))))
                 ;; What should code-references use - labels or
                 ;; line-numbers?
                 (use-labels
                  (or (not switches)
                      (and retain-labels
                           (not (string-match "-k\\&gt;" switches)))))
                 (label-fmt
                  (and switches
                       (string-match "-l <del>\"\\([<sup>\</sup>"\n]</del>\\)\"" switches)
                       (match-string 1 switches)))
                 ;; Standard block parsing.
                 (begin (car affiliated))
                 (post-affiliated (point))
                 (block-ind (progn (skip-chars-forward " \t") (current-column)))
                 (contents-begin (progn (forward-line) (point)))
                 (hidden (org-invisible-p2))
                 (value (org-element&#x2013;remove-indentation
                         (org-unescape-code-in-string
                          (buffer-substring-no-properties
                           contents-begin contents-end))
                         (and preserve-indent block-ind)))
                 (pos-before-blank (progn (goto-char contents-end)
                                          (forward-line)
                                          (point)))
                 (end (progn (skip-chars-forward " \r\t\n" limit)
                             (if (eobp) (point) (line-beginning-position)))))
            (list 'example-block
                  (nconc
                   (list :begin begin
</p>
<p>
:end end
</p>
<p>
:value value
</p>
<p>
:switches switches
</p>
<p>
:number-lines number-lines
</p>
<p>
:preserve-indent preserve-indent
</p>
<p>
:retain-labels retain-labels
</p>
<p>
:use-labels use-labels
</p>
<p>
:label-fmt label-fmt
</p>
<p>
:hiddenp hidden
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated)))))))))
</p>

<p>
(defun org-element-example-block-interpreter (example-block contents)
  "Interpret EXAMPLE-BLOCK element as Org syntax.
CONTENTS is nil."
  (let ((switches (org-element-property :switches example-block)))
    (concat "#+BEGIN<sub>EXAMPLE</sub>" (and switches (concat " " switches)) "\n"
            (org-escape-code-in-string
             (org-element-property :value example-block))
            "#+END<sub>EXAMPLE</sub>")))
</p>


<p>
;;;; Export Block
</p>

<p>
(defun org-element-export-block-parser (limit affiliated)
  "Parse an export block.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `export-block' and CDR is a plist
containing `:begin', `:end', `:type', `:hiddenp', `:value',
`:post-blank' and `:post-affiliated' keywords.
</p>

<p>
Assume point is at export-block beginning."
  (let* ((case-fold-search t)
         (type (progn (looking-at "[ \t]*#\\+BEGIN<sub>\\</sub>\\(\\S-+\\)")
                      (upcase (org-match-string-no-properties 1)))))
    (if (not (save-excursion
               (re-search-forward
                (format "<sup>[</sup> \t]*#\\+END_%s[ \t]*$" type) limit t)))
        ;; Incomplete block: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
        (save-excursion
          (let* ((begin (car affiliated))
                 (post-affiliated (point))
                 (contents-begin (progn (forward-line) (point)))
                 (hidden (org-invisible-p2))
                 (pos-before-blank (progn (goto-char contents-end)
                                          (forward-line)
                                          (point)))
                 (end (progn (skip-chars-forward " \r\t\n" limit)
                             (if (eobp) (point) (line-beginning-position))))
                 (value (buffer-substring-no-properties contents-begin
                                                        contents-end)))
            (list 'export-block
                  (nconc
                   (list :begin begin
</p>
<p>
:end end
</p>
<p>
:type type
</p>
<p>
:value value
</p>
<p>
:hiddenp hidden
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated)))))))))
</p>

<p>
(defun org-element-export-block-interpreter (export-block contents)
  "Interpret EXPORT-BLOCK element as Org syntax.
CONTENTS is nil."
  (let ((type (org-element-property :type export-block)))
    (concat (format "#+BEGIN_%s\n" type)
            (org-element-property :value export-block)
            (format "#+END_%s" type))))
</p>


<p>
;;;; Fixed-width
</p>

<p>
(defun org-element-fixed-width-parser (limit affiliated)
  "Parse a fixed-width section.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `fixed-width' and CDR is a plist
containing `:begin', `:end', `:value', `:post-blank' and
`:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the fixed-width area."
  (save-excursion
    (let* ((begin (car affiliated))
           (post-affiliated (point))
           value
           (end-area
            (progn
              (while (and (&lt; (point) limit)
                          (looking-at "[ \t]*:\\( \\|$\\)"))
                ;; Accumulate text without starting colons.
                (setq value
                      (concat value
                              (buffer-substring-no-properties
                               (match-end 0) (point-at-eol))
                              "\n"))
                (forward-line))
              (point)))
           (end (progn (skip-chars-forward " \r\t\n" limit)
                       (if (eobp) (point) (line-beginning-position)))))
      (list 'fixed-width
            (nconc
             (list :begin begin
</p>
<p>
:end end
</p>
<p>
:value value
</p>
<p>
:post-blank (count-lines end-area end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated))))))
</p>

<p>
(defun org-element-fixed-width-interpreter (fixed-width contents)
  "Interpret FIXED-WIDTH element as Org syntax.
CONTENTS is nil."
  (let ((value (org-element-property :value fixed-width)))
    (and value
         (replace-regexp-in-string
          "^" ": "
          (if (string-match "\n\\'" value) (substring value 0 -1) value)))))
</p>


<p>
;;;; Horizontal Rule
</p>

<p>
(defun org-element-horizontal-rule-parser (limit affiliated)
  "Parse an horizontal rule.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `horizontal-rule' and CDR is a plist
containing `:begin', `:end', `:post-blank' and `:post-affiliated'
keywords."
  (save-excursion
    (let ((begin (car affiliated))
          (post-affiliated (point))
          (post-hr (progn (forward-line) (point)))
          (end (progn (skip-chars-forward " \r\t\n" limit)
                      (if (eobp) (point) (line-beginning-position)))))
      (list 'horizontal-rule
            (nconc
             (list :begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank (count-lines post-hr end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated))))))
</p>

<p>
(defun org-element-horizontal-rule-interpreter (horizontal-rule contents)
  "Interpret HORIZONTAL-RULE element as Org syntax.
CONTENTS is nil."
  "&#x2013;&#x2014;")
</p>


<p>
;;;; Keyword
</p>

<p>
(defun org-element-keyword-parser (limit affiliated)
  "Parse a keyword at point.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `keyword' and CDR is a plist
containing `:key', `:value', `:begin', `:end', `:post-blank' and
`:post-affiliated' keywords."
  (save-excursion
    (let ((begin (car affiliated))
          (post-affiliated (point))
          (key (progn (looking-at "[ \t]*#\\+\\(\\S-+*\\):")
                      (upcase (org-match-string-no-properties 1))))
          (value (org-trim (buffer-substring-no-properties
                            (match-end 0) (point-at-eol))))
          (pos-before-blank (progn (forward-line) (point)))
          (end (progn (skip-chars-forward " \r\t\n" limit)
                      (if (eobp) (point) (line-beginning-position)))))
      (list 'keyword
            (nconc
             (list :key key
</p>
<p>
:value value
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated))))))
</p>

<p>
(defun org-element-keyword-interpreter (keyword contents)
  "Interpret KEYWORD element as Org syntax.
CONTENTS is nil."
  (format "#+%s: %s"
          (org-element-property :key keyword)
          (org-element-property :value keyword)))
</p>


<p>
;;;; Latex Environment
</p>

<p>
(defun org-element-latex-environment-parser (limit affiliated)
  "Parse a LaTeX environment.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `latex-environment' and CDR is a plist
containing `:begin', `:end', `:value', `:post-blank' and
`:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the latex environment."
  (save-excursion
    (let ((case-fold-search t)
          (code-begin (point)))
      (looking-at "[ \t]*\\\\begin{\\([A-Za-z0-9]+\\*?\\)}")
      (if (not (re-search-forward (format "<sup>[</sup> \t]*\\\\end{%s}[ \t]*$"
                                          (regexp-quote (match-string 1)))
                                  limit t))
          ;; Incomplete latex environment: parse it as a paragraph.
          (org-element-paragraph-parser limit affiliated)
        (let* ((code-end (progn (forward-line) (point)))
               (begin (car affiliated))
               (value (buffer-substring-no-properties code-begin code-end))
               (end (progn (skip-chars-forward " \r\t\n" limit)
                           (if (eobp) (point) (line-beginning-position)))))
          (list 'latex-environment
                (nconc
                 (list :begin begin
</p>
<p>
:end end
</p>
<p>
:value value
</p>
<p>
:post-blank (count-lines code-end end)
</p>
<p>
      :post-affiliated code-begin)
(cdr affiliated))))))))
</p>

<p>
(defun org-element-latex-environment-interpreter (latex-environment contents)
  "Interpret LATEX-ENVIRONMENT element as Org syntax.
CONTENTS is nil."
  (org-element-property :value latex-environment))
</p>


<p>
;;;; Node Property
</p>

<p>
(defun org-element-node-property-parser (limit)
  "Parse a node-property at point.
</p>

<p>
LIMIT bounds the search.
</p>

<p>
Return a list whose CAR is `node-property' and CDR is a plist
containing `:key', `:value', `:begin', `:end' and `:post-blank'
keywords."
  (save-excursion
    (looking-at org-property-re)
    (let ((case-fold-search t)
          (begin (point))
          (key   (org-match-string-no-properties 2))
          (value (org-match-string-no-properties 3))
          (pos-before-blank (progn (forward-line) (point)))
          (end (progn (skip-chars-forward " \r\t\n" limit)
                      (if (eobp) (point) (point-at-bol)))))
      (list 'node-property
            (list :key key
</p>
<p>
:value value
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank (count-lines pos-before-blank end))))))
</p>

<p>
(defun org-element-node-property-interpreter (node-property contents)
  "Interpret NODE-PROPERTY element as Org syntax.
CONTENTS is nil."
  (format org-property-format
          (format ":%s:" (org-element-property :key node-property))
          (org-element-property :value node-property)))
</p>


<p>
;;;; Paragraph
</p>

<p>
(defun org-element-paragraph-parser (limit affiliated)
  "Parse a paragraph.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `paragraph' and CDR is a plist
containing `:begin', `:end', `:contents-begin' and
`:contents-end', `:post-blank' and `:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the paragraph."
  (save-excursion
    (let* ((begin (car affiliated))
           (contents-begin (point))
           (before-blank
            (let ((case-fold-search t))
              (end-of-line)
              (if (not (re-search-forward
                        org-element-paragraph-separate limit 'm))
                  limit
                ;; A matching `org-element-paragraph-separate' is not
                ;; necessarily the end of the paragraph.  In
                ;; particular, lines starting with # or : as a first
                ;; non-space character are ambiguous.  We have to
                ;; check if they are valid Org syntax (e.g., not an
                ;; incomplete keyword).
                (beginning-of-line)
                (while (not
                        (or
                         ;; There's no ambiguity for other symbols or
                         ;; empty lines: stop here.
                         (looking-at "[ \t]*\\(?:[^:#]\\|$\\)")
                         ;; Stop at valid fixed-width areas.
                         (looking-at "[ \t]*:\\(?: \\|$\\)")
                         ;; Stop at drawers.
                         (and (looking-at org-drawer-regexp)
                              (save-excursion
                                (re-search-forward
                                 "<sup>[</sup> \t]*:END:[ \t]*$" limit t)))
                         ;; Stop at valid comments.
                         (looking-at "[ \t]*#\\(?: \\|$\\)")
                         ;; Stop at valid dynamic blocks.
                         (and (looking-at org-dblock-start-re)
                              (save-excursion
                                (re-search-forward
                                 "<sup>[</sup> \t]*#\\+END:?[ \t]*$" limit t)))
                         ;; Stop at valid blocks.
                         (and (looking-at "[ \t]*#\\+BEGIN<sub>\\</sub>\\(\\S-+\\)")
                              (save-excursion
                                (re-search-forward
                                 (format "<sup>[</sup> \t]*#\\+END_%s[ \t]*$"
                                         (regexp-quote
                                          (org-match-string-no-properties 1)))
                                 limit t)))
                         ;; Stop at valid latex environments.
                         (and (looking-at
                               "[ \t]*\\\\begin{\\([A-Za-z0-9]+\\*?\\)}")
                              (save-excursion
                                (re-search-forward
                                 (format "<sup>[</sup> \t]*\\\\end{%s}[ \t]*$"
                                         (regexp-quote
                                          (org-match-string-no-properties 1)))
                                 limit t)))
                         ;; Stop at valid keywords.
                         (looking-at "[ \t]*#\\+\&sect;-+:")
                         ;; Skip everything else.
                         (not
                          (progn
                            (end-of-line)
                            (re-search-forward org-element-paragraph-separate
                                               limit 'm)))))
                  (beginning-of-line)))
              (if (= (point) limit) limit
                (goto-char (line-beginning-position)))))
           (contents-end (progn (skip-chars-backward " \r\t\n" contents-begin)
                                (forward-line)
                                (point)))
           (end (progn (skip-chars-forward " \r\t\n" limit)
                       (if (eobp) (point) (line-beginning-position)))))
      (list 'paragraph
            (nconc
             (list :begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank (count-lines before-blank end)
</p>
<p>
      :post-affiliated contents-begin)
(cdr affiliated))))))
</p>

<p>
(defun org-element-paragraph-interpreter (paragraph contents)
  "Interpret PARAGRAPH element as Org syntax.
CONTENTS is the contents of the element."
  contents)
</p>


<p>
;;;; Planning
</p>

<p>
(defun org-element-planning-parser (limit)
  "Parse a planning.
</p>

<p>
LIMIT bounds the search.
</p>

<p>
Return a list whose CAR is `planning' and CDR is a plist
containing `:closed', `:deadline', `:scheduled', `:begin', `:end'
and `:post-blank' keywords."
  (save-excursion
    (let* ((case-fold-search nil)
           (begin (point))
           (post-blank (let ((before-blank (progn (forward-line) (point))))
                         (skip-chars-forward " \r\t\n" limit)
                         (skip-chars-backward " \t")
                         (unless (bolp) (end-of-line))
                         (count-lines before-blank (point))))
           (end (point))
           closed deadline scheduled)
      (goto-char begin)
      (while (re-search-forward org-keyword-time-not-clock-regexp end t)
        (goto-char (match-end 1))
        (skip-chars-forward " \t" end)
        (let ((keyword (match-string 1))
              (time (org-element-timestamp-parser)))
          (cond ((equal keyword org-closed-string) (setq closed time))
                ((equal keyword org-deadline-string) (setq deadline time))
                (t (setq scheduled time)))))
      (list 'planning
            (list :closed closed
</p>
<p>
:deadline deadline
</p>
<p>
:scheduled scheduled
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-planning-interpreter (planning contents)
  "Interpret PLANNING element as Org syntax.
CONTENTS is nil."
  (mapconcat
   'identity
   (delq nil
         (list (let ((deadline (org-element-property :deadline planning)))
                 (when deadline
                   (concat org-deadline-string " "
                           (org-element-timestamp-interpreter deadline nil))))
               (let ((scheduled (org-element-property :scheduled planning)))
                 (when scheduled
                   (concat org-scheduled-string " "
                           (org-element-timestamp-interpreter scheduled nil))))
               (let ((closed (org-element-property :closed planning)))
                 (when closed
                   (concat org-closed-string " "
                           (org-element-timestamp-interpreter closed nil))))))
   " "))
</p>


<p>
;;;; Quote Section
</p>

<p>
(defun org-element-quote-section-parser (limit)
  "Parse a quote section.
</p>

<p>
LIMIT bounds the search.
</p>

<p>
Return a list whose CAR is `quote-section' and CDR is a plist
containing `:begin', `:end', `:value' and `:post-blank' keywords.
</p>

<p>
Assume point is at beginning of the section."
  (save-excursion
    (let* ((begin (point))
           (end (progn (org-with-limited-levels (outline-next-heading))
                       (point)))
           (pos-before-blank (progn (skip-chars-backward " \r\t\n")
                                    (forward-line)
                                    (point)))
           (value (buffer-substring-no-properties begin pos-before-blank)))
      (list 'quote-section
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:value value
</p>
<p>
:post-blank (count-lines pos-before-blank end))))))
</p>

<p>
(defun org-element-quote-section-interpreter (quote-section contents)
  "Interpret QUOTE-SECTION element as Org syntax.
CONTENTS is nil."
  (org-element-property :value quote-section))
</p>


<p>
;;;; Src Block
</p>

<p>
(defun org-element-src-block-parser (limit affiliated)
  "Parse a src block.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `src-block' and CDR is a plist
containing `:language', `:switches', `:parameters', `:begin',
`:end', `:hiddenp', `:number-lines', `:retain-labels',
`:use-labels', `:label-fmt', `:preserve-indent', `:value',
`:post-blank' and `:post-affiliated' keywords.
</p>

<p>
Assume point is at the beginning of the block."
  (let ((case-fold-search t))
    (if (not (save-excursion (re-search-forward "<sup>[</sup> \t]*#\\+END<sub>SRC[</sub> \t]*$"
                                                limit t)))
        ;; Incomplete block: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
        (save-excursion
          (let* ((begin (car affiliated))
                 (post-affiliated (point))
                 ;; Get language as a string.
                 (language
                  (progn
                    (looking-at
                     (concat "<sup>[</sup> \t]*#\\+BEGIN<sub>SRC</sub>"
                             "\\(?: +\\(\\S-+\\)\\)?"
                             "\\(\\(?: +\\(?:-l \".*?\"\\|[-+][A-Za-z]\\)\\)+\\)?"
                             "\\(.*\\)[ \t]*$"))
                    (org-match-string-no-properties 1)))
                 ;; Get switches.
                 (switches (org-match-string-no-properties 2))
                 ;; Get parameters.
                 (parameters (org-match-string-no-properties 3))
                 ;; Switches analysis
                 (number-lines
                  (cond ((not switches) nil)
                        ((string-match "-n\\&gt;" switches) 'new)
                        ((string-match "+n\\&gt;" switches) 'continued)))
                 (preserve-indent (or org-src-preserve-indentation
                                      (and switches
                                           (string-match "-i\\&gt;" switches))))
                 (label-fmt
                  (and switches
                       (string-match "-l <del>\"\\([<sup>\</sup>"\n]</del>\\)\"" switches)
                       (match-string 1 switches)))
                 ;; Should labels be retained in (or stripped from)
                 ;; src blocks?
                 (retain-labels
                  (or (not switches)
                      (not (string-match "-r\\&gt;" switches))
                      (and number-lines (string-match "-k\\&gt;" switches))))
                 ;; What should code-references use - labels or
                 ;; line-numbers?
                 (use-labels
                  (or (not switches)
                      (and retain-labels
                           (not (string-match "-k\\&gt;" switches)))))
                 ;; Indentation.
                 (block-ind (progn (skip-chars-forward " \t") (current-column)))
                 ;; Get visibility status.
                 (hidden (progn (forward-line) (org-invisible-p2)))
                 ;; Retrieve code.
                 (value (org-element&#x2013;remove-indentation
                         (org-unescape-code-in-string
                          (buffer-substring-no-properties
                           (point) contents-end))
                         (and preserve-indent block-ind)))
                 (pos-before-blank (progn (goto-char contents-end)
                                          (forward-line)
                                          (point)))
                 ;; Get position after ending blank lines.
                 (end (progn (skip-chars-forward " \r\t\n" limit)
                             (if (eobp) (point) (line-beginning-position)))))
            (list 'src-block
                  (nconc
                   (list :language language
</p>
<p>
:switches (and (org-string-nw-p switches)
               (org-trim switches))
</p>
<p>
:parameters (and (org-string-nw-p parameters)
                 (org-trim parameters))
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:number-lines number-lines
</p>
<p>
:preserve-indent preserve-indent
</p>
<p>
:retain-labels retain-labels
</p>
<p>
:use-labels use-labels
</p>
<p>
:label-fmt label-fmt
</p>
<p>
:hiddenp hidden
</p>
<p>
:value value
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated)))))))))
</p>

<p>
(defun org-element-src-block-interpreter (src-block contents)
  "Interpret SRC-BLOCK element as Org syntax.
CONTENTS is nil."
  (let ((lang (org-element-property :language src-block))
        (switches (org-element-property :switches src-block))
        (params (org-element-property :parameters src-block))
        (value (let ((val (org-element-property :value src-block)))
                 (cond
                  ((org-element-property :preserve-indent src-block) val)
                  ((zerop org-edit-src-content-indentation) val)
                  (t
                   (let ((ind (make-string
                               org-edit-src-content-indentation 32)))
                     (replace-regexp-in-string
                      "\\(^\\)[ \t]*\&sect;-" ind val nil nil 1)))))))
    (concat (format "#+BEGIN<sub>SRC</sub>%s\n"
                    (concat (and lang (concat " " lang))
                            (and switches (concat " " switches))
                            (and params (concat " " params))))
            (org-escape-code-in-string value)
            "#+END<sub>SRC</sub>")))
</p>


<p>
;;;; Table
</p>

<p>
(defun org-element-table-parser (limit affiliated)
  "Parse a table at point.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `table' and CDR is a plist containing
`:begin', `:end', `:tblfm', `:type', `:contents-begin',
`:contents-end', `:value', `:post-blank' and `:post-affiliated'
keywords.
</p>

<p>
Assume point is at the beginning of the table."
  (save-excursion
    (let* ((case-fold-search t)
           (table-begin (point))
           (type (if (org-at-table.el-p) 'table.el 'org))
           (begin (car affiliated))
           (table-end
            (if (re-search-forward org-table-any-border-regexp limit 'm)
                (goto-char (match-beginning 0))
              (point)))
           (tblfm (let (acc)
                    (while (looking-at "[ \t]*#\\+TBLFM: +\\(.*\\)[ \t]*$")
                      (push (org-match-string-no-properties 1) acc)
                      (forward-line))
                    acc))
           (pos-before-blank (point))
           (end (progn (skip-chars-forward " \r\t\n" limit)
                       (if (eobp) (point) (line-beginning-position)))))
      (list 'table
            (nconc
             (list :begin begin
</p>
<p>
:end end
</p>
<p>
:type type
</p>
<p>
:tblfm tblfm
;; Only `org' tables have contents.  `table.el' tables
;; use a `:value' property to store raw table as
;; a string.
</p>
<p>
:contents-begin (and (eq type 'org) table-begin)
</p>
<p>
:contents-end (and (eq type 'org) table-end)
</p>
<p>
:value (and (eq type 'table.el)
            (buffer-substring-no-properties
             table-begin table-end))
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated table-begin)
(cdr affiliated))))))
</p>

<p>
(defun org-element-table-interpreter (table contents)
  "Interpret TABLE element as Org syntax.
CONTENTS is nil."
  (if (eq (org-element-property :type table) 'table.el)
      (org-remove-indentation (org-element-property :value table))
    (concat (with-temp-buffer (insert contents)
                              (org-table-align)
                              (buffer-string))
            (mapconcat (lambda (fm) (concat "#+TBLFM: " fm))
                       (reverse (org-element-property :tblfm table))
                       "\n"))))
</p>


<p>
;;;; Table Row
</p>

<p>
(defun org-element-table-row-parser (limit)
  "Parse table row at point.
</p>

<p>
LIMIT bounds the search.
</p>

<p>
Return a list whose CAR is `table-row' and CDR is a plist
containing `:begin', `:end', `:contents-begin', `:contents-end',
`:type' and `:post-blank' keywords."
  (save-excursion
    (let* ((type (if (looking-at "<sup>[</sup> \t]*|-") 'rule 'standard))
           (begin (point))
           ;; A table rule has no contents.  In that case, ensure
           ;; CONTENTS-BEGIN matches CONTENTS-END.
           (contents-begin (and (eq type 'standard)
                                (search-forward "|")
                                (point)))
           (contents-end (and (eq type 'standard)
                              (progn
                                (end-of-line)
                                (skip-chars-backward " \t")
                                (point))))
           (end (progn (forward-line) (point))))
      (list 'table-row
            (list :type type
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank 0)))))
</p>

<p>
(defun org-element-table-row-interpreter (table-row contents)
  "Interpret TABLE-ROW element as Org syntax.
CONTENTS is the contents of the table row."
  (if (eq (org-element-property :type table-row) 'rule) "|-"
    (concat "| " contents)))
</p>


<p>
;;;; Verse Block
</p>

<p>
(defun org-element-verse-block-parser (limit affiliated)
  "Parse a verse block.
</p>

<p>
LIMIT bounds the search.  AFFILIATED is a list of which CAR is
the buffer position at the beginning of the first affiliated
keyword and CDR is a plist of affiliated keywords along with
their value.
</p>

<p>
Return a list whose CAR is `verse-block' and CDR is a plist
containing `:begin', `:end', `:contents-begin', `:contents-end',
`:hiddenp', `:post-blank' and `:post-affiliated' keywords.
</p>

<p>
Assume point is at beginning of the block."
  (let ((case-fold-search t))
    (if (not (save-excursion
               (re-search-forward "<sup>[</sup> \t]*#\\+END<sub>VERSE[</sub> \t]*$" limit t)))
        ;; Incomplete block: parse it as a paragraph.
        (org-element-paragraph-parser limit affiliated)
      (let ((contents-end (match-beginning 0)))
        (save-excursion
          (let* ((begin (car affiliated))
                 (post-affiliated (point))
                 (hidden (progn (forward-line) (org-invisible-p2)))
                 (contents-begin (point))
                 (pos-before-blank (progn (goto-char contents-end)
                                          (forward-line)
                                          (point)))
                 (end (progn (skip-chars-forward " \r\t\n" limit)
                             (if (eobp) (point) (line-beginning-position)))))
            (list 'verse-block
                  (nconc
                   (list :begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:hiddenp hidden
</p>
<p>
:post-blank (count-lines pos-before-blank end)
</p>
<p>
      :post-affiliated post-affiliated)
(cdr affiliated)))))))))
</p>

<p>
(defun org-element-verse-block-interpreter (verse-block contents)
  "Interpret VERSE-BLOCK element as Org syntax.
CONTENTS is verse block contents."
  (format "#+BEGIN<sub>VERSE\n</sub>%s#+END<sub>VERSE</sub>" contents))
</p>


<p>

;;; Objects
;;
;; Unlike to elements, interstices can be found between objects.
;; That's why, along with the parser, successor functions are provided
;; for each object.  Some objects share the same successor (e.g.,
;; `code' and `verbatim' objects).
;;
;; A successor must accept a single argument bounding the search.  It
;; will return either a cons cell whose CAR is the object's type, as
;; a symbol, and CDR the position of its next occurrence, or nil.
;;
;; Successors follow the naming convention:
;; org-element-NAME-successor, where NAME is the name of the
;; successor, as defined in `org-element-all-successors'.
;;
;; Some object types (e.g., `italic') are recursive.  Restrictions on
;; object types they can contain will be specified in
;; `org-element-object-restrictions'.
;;
;; Adding a new type of object is simple.  Implement a successor,
;; a parser, and an interpreter for it, all following the naming
;; convention.  Register type in `org-element-all-objects' and
;; successor in `org-element-all-successors'.  Maybe tweak
;; restrictions about it, and that's it.
</p>


<p>
;;;; Bold
</p>

<p>
(defun org-element-bold-parser ()
  "Parse bold object at point.
</p>

<p>
Return a list whose CAR is `bold' and CDR is a plist with
`:begin', `:end', `:contents-begin' and `:contents-end' and
`:post-blank' keywords.
</p>

<p>
Assume point is at the first star marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
          (contents-begin (match-beginning 4))
          (contents-end (match-end 4))
          (post-blank (progn (goto-char (match-end 2))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'bold
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-bold-interpreter (bold contents)
  "Interpret BOLD object as Org syntax.
CONTENTS is the contents of the object."
  (format "<b>%s</b>" contents))
</p>

<p>
(defun org-element-text-markup-successor ()
  "Search for the next text-markup object.
</p>

<p>
Return value is a cons cell whose CAR is a symbol among `bold',
`italic', `underline', `strike-through', `code' and `verbatim'
and CDR is beginning position."
  (save-excursion
    (unless (bolp) (backward-char))
    (when (re-search-forward org-emph-re nil t)
      (let ((marker (match-string 3)))
        (cons (cond
               ((equal marker "*") 'bold)
               ((equal marker "/") 'italic)
               ((equal marker "_") 'underline)
               ((equal marker "+") 'strike-through)
               ((equal marker "~") 'code)
               ((equal marker "=") 'verbatim)
               (t (error "Unknown marker at %d" (match-beginning 3))))
              (match-beginning 2))))))
</p>


<p>
;;;; Code
</p>

<p>
(defun org-element-code-parser ()
  "Parse code object at point.
</p>

<p>
Return a list whose CAR is `code' and CDR is a plist with
`:value', `:begin', `:end' and `:post-blank' keywords.
</p>

<p>
Assume point is at the first tilde marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
          (value (org-match-string-no-properties 4))
          (post-blank (progn (goto-char (match-end 2))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'code
            (list :value value
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-code-interpreter (code contents)
  "Interpret CODE object as Org syntax.
CONTENTS is nil."
  (format "<code>%s</code>" (org-element-property :value code)))
</p>


<p>
;;;; Entity
</p>

<p>
(defun org-element-entity-parser ()
  "Parse entity at point.
</p>

<p>
Return a list whose CAR is `entity' and CDR a plist with
`:begin', `:end', `:latex', `:latex-math-p', `:html', `:latin1',
`:utf-8', `:ascii', `:use-brackets-p' and `:post-blank' as
keywords.
</p>

<p>
Assume point is at the beginning of the entity."
  (save-excursion
    (looking-at "\\\\\\(there4\\|sup[123]\\|frac[13][24]\\|[a-zA-Z]+\\)\\($\\|{}\\|[^[:alpha:]]\\)")
    (let* ((value (org-entity-get (match-string 1)))
           (begin (match-beginning 0))
           (bracketsp (string= (match-string 2) "{}"))
           (post-blank (progn (goto-char (match-end 1))
                              (when bracketsp (forward-char 2))
                              (skip-chars-forward " \t")))
           (end (point)))
      (list 'entity
            (list :name (car value)
</p>
<p>
:latex (nth 1 value)
</p>
<p>
:latex-math-p (nth 2 value)
</p>
<p>
:html (nth 3 value)
</p>
<p>
:ascii (nth 4 value)
</p>
<p>
:latin1 (nth 5 value)
</p>
<p>
:utf-8 (nth 6 value)
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:use-brackets-p bracketsp
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-entity-interpreter (entity contents)
  "Interpret ENTITY object as Org syntax.
CONTENTS is nil."
  (concat "\\"
          (org-element-property :name entity)
          (when (org-element-property :use-brackets-p entity) "{}")))
</p>

<p>
(defun org-element-latex-or-entity-successor ()
  "Search for the next latex-fragment or entity object.
</p>

<p>
Return value is a cons cell whose CAR is `entity' or
`latex-fragment' and CDR is beginning position."
  (save-excursion
    (unless (bolp) (backward-char))
    (let ((matchers (cdr org-latex-regexps))
          ;; ENTITY-RE matches both LaTeX commands and Org entities.
          (entity-re
           "\\\\\\(there4\\|sup[123]\\|frac[13][24]\\|[a-zA-Z]+\\)\\($\\|{}\\|[^[:alpha:]]\\)"))
      (when (re-search-forward
             (concat (mapconcat #'cadr matchers "\\|") "\\|" entity-re) nil t)
        (goto-char (match-beginning 0))
        (if (looking-at entity-re)
            ;; Determine if it's a real entity or a LaTeX command.
            (cons (if (org-entity-get (match-string 1)) 'entity 'latex-fragment)
                  (match-beginning 0))
          ;; No entity nor command: point is at a LaTeX fragment.
          ;; Determine its type to get the correct beginning position.
          (cons 'latex-fragment
                (catch 'return
                  (dolist (e matchers)
                    (when (looking-at (nth 1 e))
                      (throw 'return (match-beginning (nth 2 e)))))
                  (point))))))))
</p>


<p>
;;;; Export Snippet
</p>

<p>
(defun org-element-export-snippet-parser ()
  "Parse export snippet at point.
</p>

<p>
Return a list whose CAR is `export-snippet' and CDR a plist with
`:begin', `:end', `:back-end', `:value' and `:post-blank' as
keywords.
</p>

<p>
Assume point is at the beginning of the snippet."
  (save-excursion
    (re-search-forward "@@\\([-A-Za-z0-9]+\\):" nil t)
    (let* ((begin (match-beginning 0))
           (back-end (org-match-string-no-properties 1))
           (value (buffer-substring-no-properties
                   (point)
                   (progn (re-search-forward "@@" nil t) (match-beginning 0))))
           (post-blank (skip-chars-forward " \t"))
           (end (point)))
      (list 'export-snippet
            (list :back-end back-end
</p>
<p>
:value value
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-export-snippet-interpreter (export-snippet contents)
  "Interpret EXPORT-SNIPPET object as Org syntax.
CONTENTS is nil."
  (format "@@%s:%s@@"
          (org-element-property :back-end export-snippet)
          (org-element-property :value export-snippet)))
</p>

<p>
(defun org-element-export-snippet-successor ()
  "Search for the next export-snippet object.
</p>

<p>
Return value is a cons cell whose CAR is `export-snippet' and CDR
its beginning position."
  (save-excursion
    (let (beg)
      (when (and (re-search-forward "@@[-A-Za-z0-9]+:" nil t)
                 (setq beg (match-beginning 0))
                 (search-forward "@@" nil t))
        (cons 'export-snippet beg)))))
</p>


<p>
;;;; Footnote Reference
</p>

<p>
(defun org-element-footnote-reference-parser ()
  "Parse footnote reference at point.
</p>

<p>
Return a list whose CAR is `footnote-reference' and CDR a plist
with `:label', `:type', `:inline-definition', `:begin', `:end'
and `:post-blank' as keywords."
  (save-excursion
    (looking-at org-footnote-re)
    (let* ((begin (point))
           (label (or (org-match-string-no-properties 2)
                      (org-match-string-no-properties 3)
                      (and (match-string 1)
                           (concat "fn:" (org-match-string-no-properties 1)))))
           (type (if (or (not label) (match-string 1)) 'inline 'standard))
           (inner-begin (match-end 0))
           (inner-end
            (let ((count 1))
              (forward-char)
              (while (and (&gt; count 0) (re-search-forward "[][]" nil t))
                (if (equal (match-string 0) "[") (incf count) (decf count)))
              (1- (point))))
           (post-blank (progn (goto-char (1+ inner-end))
                              (skip-chars-forward " \t")))
           (end (point))
           (footnote-reference
            (list 'footnote-reference
                  (list :label label
</p>
<p>
:type type
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
                  :post-blank post-blank))))
(org-element-put-property
 footnote-reference :inline-definition
 (and (eq type 'inline)
      (org-element-parse-secondary-string
       (buffer-substring inner-begin inner-end)
       (org-element-restriction 'footnote-reference)
       footnote-reference))))))
</p>

<p>
(defun org-element-footnote-reference-interpreter (footnote-reference contents)
  "Interpret FOOTNOTE-REFERENCE object as Org syntax.
CONTENTS is nil."
  (let ((label (or (org-element-property :label footnote-reference) "fn:"))
        (def
         (let ((inline-def
                (org-element-property :inline-definition footnote-reference)))
           (if (not inline-def) ""
             (concat ":" (org-element-interpret-data inline-def))))))
    (format "[%s]" (concat label def))))
</p>

<p>
(defun org-element-footnote-reference-successor ()
  "Search for the next footnote-reference object.
</p>

<p>
Return value is a cons cell whose CAR is `footnote-reference' and
CDR is beginning position."
  (save-excursion
    (catch 'exit
      (while (re-search-forward org-footnote-re nil t)
        (save-excursion
          (let ((beg (match-beginning 0))
                (count 1))
            (backward-char)
            (while (re-search-forward "[][]" nil t)
              (if (equal (match-string 0) "[") (incf count) (decf count))
              (when (zerop count)
                (throw 'exit (cons 'footnote-reference beg))))))))))
</p>


<p>
;;;; Inline Babel Call
</p>

<p>
(defun org-element-inline-babel-call-parser ()
  "Parse inline babel call at point.
</p>

<p>
Return a list whose CAR is `inline-babel-call' and CDR a plist
with `:begin', `:end', `:info' and `:post-blank' as keywords.
</p>

<p>
Assume point is at the beginning of the babel call."
  (save-excursion
    (unless (bolp) (backward-char))
    (looking-at org-babel-inline-lob-one-liner-regexp)
    (let ((info (save-match-data (org-babel-lob-get-info)))
          (begin (match-end 1))
          (post-blank (progn (goto-char (match-end 0))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'inline-babel-call
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:info info
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-inline-babel-call-interpreter (inline-babel-call contents)
  "Interpret INLINE-BABEL-CALL object as Org syntax.
CONTENTS is nil."
  (let* ((babel-info (org-element-property :info inline-babel-call))
         (main-source (car babel-info))
         (post-options (nth 1 babel-info)))
    (concat "call_"
            (if (string-match "\\[\\(\\[.*?\\]\\)\\]" main-source)
                ;; Remove redundant square brackets.
                (replace-match
                 (match-string 1 main-source) nil nil main-source)
              main-source)
            (and post-options (format "[%s]" post-options)))))
</p>

<p>
(defun org-element-inline-babel-call-successor ()
  "Search for the next inline-babel-call object.
</p>

<p>
Return value is a cons cell whose CAR is `inline-babel-call' and
CDR is beginning position."
  (save-excursion
    (when (re-search-forward org-babel-inline-lob-one-liner-regexp nil t)
      (cons 'inline-babel-call (match-end 1)))))
</p>


<p>
;;;; Inline Src Block
</p>

<p>
(defun org-element-inline-src-block-parser ()
  "Parse inline source block at point.
</p>

<p>
Return a list whose CAR is `inline-src-block' and CDR a plist
with `:begin', `:end', `:language', `:value', `:parameters' and
`:post-blank' as keywords.
</p>

<p>
Assume point is at the beginning of the inline src block."
  (save-excursion
    (unless (bolp) (backward-char))
    (looking-at org-babel-inline-src-block-regexp)
    (let ((begin (match-beginning 1))
          (language (org-match-string-no-properties 2))
          (parameters (org-match-string-no-properties 4))
          (value (org-match-string-no-properties 5))
          (post-blank (progn (goto-char (match-end 0))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'inline-src-block
            (list :language language
</p>
<p>
:value value
</p>
<p>
:parameters parameters
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-inline-src-block-interpreter (inline-src-block contents)
  "Interpret INLINE-SRC-BLOCK object as Org syntax.
CONTENTS is nil."
  (let ((language (org-element-property :language inline-src-block))
        (arguments (org-element-property :parameters inline-src-block))
        (body (org-element-property :value inline-src-block)))
    (format ""
            language
            (if arguments (format "[%s]" arguments) "")
            body)))
</p>

<p>
(defun org-element-inline-src-block-successor ()
  "Search for the next inline-babel-call element.
</p>

<p>
Return value is a cons cell whose CAR is `inline-babel-call' and
CDR is beginning position."
  (save-excursion
    (unless (bolp) (backward-char))
    (when (re-search-forward org-babel-inline-src-block-regexp nil t)
      (cons 'inline-src-block (match-beginning 1)))))
</p>

<p>
;;;; Italic
</p>

<p>
(defun org-element-italic-parser ()
  "Parse italic object at point.
</p>

<p>
Return a list whose CAR is `italic' and CDR is a plist with
`:begin', `:end', `:contents-begin' and `:contents-end' and
`:post-blank' keywords.
</p>

<p>
Assume point is at the first slash marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
          (contents-begin (match-beginning 4))
          (contents-end (match-end 4))
          (post-blank (progn (goto-char (match-end 2))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'italic
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-italic-interpreter (italic contents)
  "Interpret ITALIC object as Org syntax.
CONTENTS is the contents of the object."
  (format "<i>%s</i>" contents))
</p>


<p>
;;;; Latex Fragment
</p>

<p>
(defun org-element-latex-fragment-parser ()
  "Parse LaTeX fragment at point.
</p>

<p>
Return a list whose CAR is `latex-fragment' and CDR a plist with
`:value', `:begin', `:end', and `:post-blank' as keywords.
</p>

<p>
Assume point is at the beginning of the LaTeX fragment."
  (save-excursion
    (let* ((begin (point))
           (substring-match
            (catch 'exit
              (dolist (e (cdr org-latex-regexps))
                (let ((latex-regexp (nth 1 e)))
                  (when (or (looking-at latex-regexp)
                            (and (not (bobp))
                                 (save-excursion
                                   (backward-char)
                                   (looking-at latex-regexp))))
                    (throw 'exit (nth 2 e)))))
              ;; None found: it's a macro.
              (looking-at "\\\\[a-zA-Z]+\\*?\\(\\(\\[[^][\n{}]*\\]\\)\\|\\({[^{}\n]*}\\)\\)*")
              0))
           (value (org-match-string-no-properties substring-match))
           (post-blank (progn (goto-char (match-end substring-match))
                              (skip-chars-forward " \t")))
           (end (point)))
      (list 'latex-fragment
            (list :value value
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-latex-fragment-interpreter (latex-fragment contents)
  "Interpret LATEX-FRAGMENT object as Org syntax.
CONTENTS is nil."
  (org-element-property :value latex-fragment))
</p>

<p>
;;;; Line Break
</p>

<p>
(defun org-element-line-break-parser ()
  "Parse line break at point.
</p>

<p>
Return a list whose CAR is `line-break', and CDR a plist with
`:begin', `:end' and `:post-blank' keywords.
</p>

<p>
Assume point is at the beginning of the line break."
  (list 'line-break
        (list :begin (point)
</p>
<p>
:end (progn (forward-line) (point))
</p>
<p>
:post-blank 0)))
</p>

<p>
(defun org-element-line-break-interpreter (line-break contents)
  "Interpret LINE-BREAK object as Org syntax.
CONTENTS is nil."
  "\\\\\n")
</p>

<p>
(defun org-element-line-break-successor ()
  "Search for the next line-break object.
</p>

<p>
Return value is a cons cell whose CAR is `line-break' and CDR is
beginning position."
  (save-excursion
    (let ((beg (and (re-search-forward "[<sup>\\\\]<br  />
</sup>\\(\\\\\\\\\\)[ \t]*$" nil t)
                    (goto-char (match-beginning 1)))))
      ;; A line break can only happen on a non-empty line.
      (when (and beg (re-search-backward "\&sect;-" (point-at-bol) t))
        (cons 'line-break beg)))))
</p>


<p>
;;;; Link
</p>

<p>
(defun org-element-link-parser ()
  "Parse link at point.
</p>

<p>
Return a list whose CAR is `link' and CDR a plist with `:type',
`:path', `:raw-link', `:application', `:search-option', `:begin',
`:end', `:contents-begin', `:contents-end' and `:post-blank' as
keywords.
</p>

<p>
Assume point is at the beginning of the link."
  (save-excursion
    (let ((begin (point))
          end contents-begin contents-end link-end post-blank path type
          raw-link link search-option application)
      (cond
       ;; Type 1: Text targeted from a radio target.
       ((and org-target-link-regexp (looking-at org-target-link-regexp))
        (setq type "radio"
              link-end (match-end 0)
              path (org-match-string-no-properties 0)
              contents-begin (match-beginning 0)
              contents-end (match-end 0)))
       ;; Type 2: Standard link, i.e. <a href="http://orgmode.org">homepage</a>
       ((looking-at org-bracket-link-regexp)
        (setq contents-begin (match-beginning 3)
              contents-end (match-end 3)
              link-end (match-end 0)
              ;; RAW-LINK is the original link.  Expand any
              ;; abbreviation in it.
              raw-link (org-translate-link
                        (org-link-expand-abbrev
                         (org-match-string-no-properties 1))))
        ;; Determine TYPE of link and set PATH accordingly.
        (cond
         ;; File type.
         ((or (file-name-absolute-p raw-link)
              (string-match "<sup>\\</sup>.\\.?/" raw-link))
          (setq type "file" path raw-link))
         ;; Explicit type (http, irc, bbdb&#x2026;).  See `org-link-types'.
         ((string-match org-link-re-with-space3 raw-link)
          (setq type (match-string 1 raw-link) path (match-string 2 raw-link)))
         ;; Id type: PATH is the id.
         ((string-match "<sup>id</sup>:\\([-a-f0-9]+\\)" raw-link)
          (setq type "id" path (match-string 1 raw-link)))
         ;; Code-ref type: PATH is the name of the reference.
         ((string-match "<sup>(\\(.*\\))</sup>$" raw-link)
          (setq type "coderef" path (match-string 1 raw-link)))
         ;; Custom-id type: PATH is the name of the custom id.
         ((= (aref raw-link 0) ?#)
          (setq type "custom-id" path (substring raw-link 1)))
         ;; Fuzzy type: Internal link either matches a target, an
         ;; headline name or nothing.  PATH is the target or
         ;; headline's name.
         (t (setq type "fuzzy" path raw-link))))
       ;; Type 3: Plain link, e.g., <a href="http://orgmode.org">http://orgmode.org</a>
       ((looking-at org-plain-link-re)
        (setq raw-link (org-match-string-no-properties 0)
              type (org-match-string-no-properties 1)
              link-end (match-end 0)
              path (org-match-string-no-properties 2)))
       ;; Type 4: Angular link, e.g., <a href="http://orgmode.org">http://orgmode.org</a>
       ((looking-at org-angle-link-re)
        (setq raw-link (buffer-substring-no-properties
                        (match-beginning 1) (match-end 2))
              type (org-match-string-no-properties 1)
              link-end (match-end 0)
              path (org-match-string-no-properties 2))))
      ;; In any case, deduce end point after trailing white space from
      ;; LINK-END variable.
      (setq post-blank (progn (goto-char link-end) (skip-chars-forward " \t"))
            end (point))
      ;; Special "file" type link processing.
      (when (member type org-element-link-type-is-file)
        ;; Extract opening application and search option.
        (cond ((string-match "<sup>file<br  />
</sup>+\\(.*\\)$" type)
               (setq application (match-string 1 type)))
              ((not (string-match "<sup>file</sup>" type))
               (setq application type)))
        (when (string-match "::\\(.*\\)\\'" path)
          (setq search-option (match-string 1 path)
                path (replace-match "" nil nil path)))
        ;; Normalize URI.
        (when (and (not (org-string-match-p "\\`//" path))
                   (file-name-absolute-p path))
          (setq path (concat "//" (expand-file-name path))))
        ;; Make sure TYPE always reports "file".
        (setq type "file"))
      (list 'link
            (list :type type
</p>
<p>
:path path
</p>
<p>
:raw-link (or raw-link path)
</p>
<p>
:application application
</p>
<p>
:search-option search-option
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-link-interpreter (link contents)
  "Interpret LINK object as Org syntax.
CONTENTS is the contents of the object, or nil."
  (let ((type (org-element-property :type link))
        (raw-link (org-element-property :raw-link link)))
    (if (string= type "radio") raw-link
      (format "[[%s]%s]"
              raw-link
              (if contents (format "[%s]" contents) "")))))
</p>

<p>
(defun org-element-link-successor ()
  "Search for the next link object.
</p>

<p>
Return value is a cons cell whose CAR is `link' and CDR is
beginning position."
  (save-excursion
    (let ((link-regexp
           (if (not org-target-link-regexp) org-any-link-re
             (concat org-any-link-re "\\|" org-target-link-regexp))))
      (when (re-search-forward link-regexp nil t)
        (cons 'link (match-beginning 0))))))
</p>

<p>
(defun org-element-plain-link-successor ()
  "Search for the next plain link object.
</p>

<p>
Return value is a cons cell whose CAR is `link' and CDR is
beginning position."
  (and (save-excursion (re-search-forward org-plain-link-re nil t))
       (cons 'link (match-beginning 0))))
</p>


<p>
;;;; Macro
</p>

<p>
(defun org-element-macro-parser ()
  "Parse macro at point.
</p>

<p>
Return a list whose CAR is `macro' and CDR a plist with `:key',
`:args', `:begin', `:end', `:value' and `:post-blank' as
keywords.
</p>

<p>
Assume point is at the macro."
  (save-excursion
    (looking-at "{{{\\([a-zA-Z][-a-zA-Z0-9_]*\\)\\(([ \t\n]*\\([^\000]*?\\))\\)?}}}")
    (let ((begin (point))
          (key (downcase (org-match-string-no-properties 1)))
          (value (org-match-string-no-properties 0))
          (post-blank (progn (goto-char (match-end 0))
                             (skip-chars-forward " \t")))
          (end (point))
          (args (let ((args (org-match-string-no-properties 3)))
                  (when args
                    ;; Do not use `org-split-string' since empty
                    ;; strings are meaningful here.
                    (split-string
                     (replace-regexp-in-string
                      "\\(\\\\*\\)\\(,\\)"
                      (lambda (str)
                        (let ((len (length (match-string 1 str))))
                          (concat (make-string (/ len 2) ?\\)
                                  (if (zerop (mod len 2)) "\000" ","))))
                      args nil t)
                     "\000")))))
      (list 'macro
            (list :key key
</p>
<p>
:value value
</p>
<p>
:args args
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-macro-interpreter (macro contents)
  "Interpret MACRO object as Org syntax.
CONTENTS is nil."
  (org-element-property :value macro))
</p>

<p>
(defun org-element-macro-successor ()
  "Search for the next macro object.
</p>

<p>
Return value is cons cell whose CAR is `macro' and CDR is
beginning position."
  (save-excursion
    (when (re-search-forward
           "{{{\\([a-zA-Z][-a-zA-Z0-9_]*\\)\\(([ \t\n]*\\([^\000]*?\\))\\)?}}}"
           nil t)
      (cons 'macro (match-beginning 0)))))
</p>


<p>
;;;; Radio-target
</p>

<p>
(defun org-element-radio-target-parser ()
  "Parse radio target at point.
</p>

<p>
Return a list whose CAR is `radio-target' and CDR a plist with
`:begin', `:end', `:contents-begin', `:contents-end', `:value'
and `:post-blank' as keywords.
</p>

<p>
Assume point is at the radio target."
  (save-excursion
    (looking-at org-radio-target-regexp)
    (let ((begin (point))
          (contents-begin (match-beginning 1))
          (contents-end (match-end 1))
          (value (org-match-string-no-properties 1))
          (post-blank (progn (goto-char (match-end 0))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'radio-target
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank post-blank
</p>
<p>
:value value)))))
</p>

<p>
(defun org-element-radio-target-interpreter (target contents)
  "Interpret TARGET object as Org syntax.
CONTENTS is the contents of the object."
  (concat "<a id="contents" name="contents">" contents "</a>"))
</p>

<p>
(defun org-element-radio-target-successor ()
  "Search for the next radio-target object.
</p>

<p>
Return value is a cons cell whose CAR is `radio-target' and CDR
is beginning position."
  (save-excursion
    (when (re-search-forward org-radio-target-regexp nil t)
      (cons 'radio-target (match-beginning 0)))))
</p>


<p>
;;;; Statistics Cookie
</p>

<p>
(defun org-element-statistics-cookie-parser ()
  "Parse statistics cookie at point.
</p>

<p>
Return a list whose CAR is `statistics-cookie', and CDR a plist
with `:begin', `:end', `:value' and `:post-blank' keywords.
</p>

<p>
Assume point is at the beginning of the statistics-cookie."
  (save-excursion
    (looking-at "\\[[0-9]*\\(%\\|/[0-9]*\\)\\]")
    (let* ((begin (point))
           (value (buffer-substring-no-properties
                   (match-beginning 0) (match-end 0)))
           (post-blank (progn (goto-char (match-end 0))
                              (skip-chars-forward " \t")))
           (end (point)))
      (list 'statistics-cookie
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:value value
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-statistics-cookie-interpreter (statistics-cookie contents)
  "Interpret STATISTICS-COOKIE object as Org syntax.
CONTENTS is nil."
  (org-element-property :value statistics-cookie))
</p>

<p>
(defun org-element-statistics-cookie-successor ()
  "Search for the next statistics cookie object.
</p>

<p>
Return value is a cons cell whose CAR is `statistics-cookie' and
CDR is beginning position."
  (save-excursion
    (when (re-search-forward "\\[[0-9]*\\(%\\|/[0-9]*\\)\\]" nil t)
      (cons 'statistics-cookie (match-beginning 0)))))
</p>


<p>
;;;; Strike-Through
</p>

<p>
(defun org-element-strike-through-parser ()
  "Parse strike-through object at point.
</p>

<p>
Return a list whose CAR is `strike-through' and CDR is a plist
with `:begin', `:end', `:contents-begin' and `:contents-end' and
`:post-blank' keywords.
</p>

<p>
Assume point is at the first plus sign marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
          (contents-begin (match-beginning 4))
          (contents-end (match-end 4))
          (post-blank (progn (goto-char (match-end 2))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'strike-through
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-strike-through-interpreter (strike-through contents)
  "Interpret STRIKE-THROUGH object as Org syntax.
CONTENTS is the contents of the object."
  (format "<del>%s</del>" contents))
</p>


<p>
;;;; Subscript
</p>

<p>
(defun org-element-subscript-parser ()
  "Parse subscript at point.
</p>

<p>
Return a list whose CAR is `subscript' and CDR a plist with
`:begin', `:end', `:contents-begin', `:contents-end',
`:use-brackets-p' and `:post-blank' as keywords.
</p>

<p>
Assume point is at the underscore."
  (save-excursion
    (unless (bolp) (backward-char))
    (let ((bracketsp (if (looking-at org-match-substring-with-braces-regexp)
                         t
                       (not (looking-at org-match-substring-regexp))))
          (begin (match-beginning 2))
          (contents-begin (or (match-beginning 5)
                              (match-beginning 3)))
          (contents-end (or (match-end 5) (match-end 3)))
          (post-blank (progn (goto-char (match-end 0))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'subscript
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:use-brackets-p bracketsp
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-subscript-interpreter (subscript contents)
  "Interpret SUBSCRIPT object as Org syntax.
CONTENTS is the contents of the object."
  (format
   (if (org-element-property :use-brackets-p subscript) "<sub>%s</sub>" "_%s")
   contents))
</p>

<p>
(defun org-element-sub/superscript-successor ()
  "Search for the next sub/superscript object.
</p>

<p>
Return value is a cons cell whose CAR is either `subscript' or
`superscript' and CDR is beginning position."
  (save-excursion
    (unless (bolp) (backward-char))
    (when (re-search-forward org-match-substring-regexp nil t)
      (cons (if (string= (match-string 2) "_") 'subscript 'superscript)
            (match-beginning 2)))))
</p>


<p>
;;;; Superscript
</p>

<p>
(defun org-element-superscript-parser ()
  "Parse superscript at point.
</p>

<p>
Return a list whose CAR is `superscript' and CDR a plist with
`:begin', `:end', `:contents-begin', `:contents-end',
`:use-brackets-p' and `:post-blank' as keywords.
</p>

<p>
Assume point is at the caret."
  (save-excursion
    (unless (bolp) (backward-char))
    (let ((bracketsp (if (looking-at org-match-substring-with-braces-regexp) t
                       (not (looking-at org-match-substring-regexp))))
          (begin (match-beginning 2))
          (contents-begin (or (match-beginning 5)
                              (match-beginning 3)))
          (contents-end (or (match-end 5) (match-end 3)))
          (post-blank (progn (goto-char (match-end 0))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'superscript
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:use-brackets-p bracketsp
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-superscript-interpreter (superscript contents)
  "Interpret SUPERSCRIPT object as Org syntax.
CONTENTS is the contents of the object."
  (format
   (if (org-element-property :use-brackets-p superscript) "<sup>%s</sup>" "^%s")
   contents))
</p>


<p>
;;;; Table Cell
</p>

<p>
(defun org-element-table-cell-parser ()
  "Parse table cell at point.
</p>

<p>
Return a list whose CAR is `table-cell' and CDR is a plist
containing `:begin', `:end', `:contents-begin', `:contents-end'
and `:post-blank' keywords."
  (looking-at "[ \t]*\\(.*?\\)[ \t]*\\(?:|\\|$\\)")
  (let* ((begin (match-beginning 0))
         (end (match-end 0))
         (contents-begin (match-beginning 1))
         (contents-end (match-end 1)))
    (list 'table-cell
          (list :begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank 0))))
</p>

<p>
(defun org-element-table-cell-interpreter (table-cell contents)
  "Interpret TABLE-CELL element as Org syntax.
CONTENTS is the contents of the cell, or nil."
  (concat  " " contents " |"))
</p>

<p>
(defun org-element-table-cell-successor ()
  "Search for the next table-cell object.
</p>

<p>
Return value is a cons cell whose CAR is `table-cell' and CDR is
beginning position."
  (when (looking-at "[ \t]*.*?[ \t]*\\(|\\|$\\)") (cons 'table-cell (point))))
</p>


<p>
;;;; Target
</p>

<p>
(defun org-element-target-parser ()
  "Parse target at point.
</p>

<p>
Return a list whose CAR is `target' and CDR a plist with
`:begin', `:end', `:value' and `:post-blank' as keywords.
</p>

<p>
Assume point is at the target."
  (save-excursion
    (looking-at org-target-regexp)
    (let ((begin (point))
          (value (org-match-string-no-properties 1))
          (post-blank (progn (goto-char (match-end 0))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'target
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:value value
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-target-interpreter (target contents)
  "Interpret TARGET object as Org syntax.
CONTENTS is nil."
  (format "<a id="s" name="s"></a>" (org-element-property :value target)))
</p>

<p>
(defun org-element-target-successor ()
  "Search for the next target object.
</p>

<p>
Return value is a cons cell whose CAR is `target' and CDR is
beginning position."
  (save-excursion
    (when (re-search-forward org-target-regexp nil t)
      (cons 'target (match-beginning 0)))))
</p>


<p>
;;;; Timestamp
</p>

<p>
(defun org-element-timestamp-parser ()
  "Parse time stamp at point.
</p>

<p>
Return a list whose CAR is `timestamp', and CDR a plist with
`:type', `:raw-value', `:year-start', `:month-start',
`:day-start', `:hour-start', `:minute-start', `:year-end',
`:month-end', `:day-end', `:hour-end', `:minute-end',
`:repeater-type', `:repeater-value', `:repeater-unit',
`:warning-type', `:warning-value', `:warning-unit', `:begin',
`:end' and `:post-blank' keywords.
</p>

<p>
Assume point is at the beginning of the timestamp."
  (save-excursion
    (let* ((begin (point))
           (activep (eq (char-after) ?&lt;))
           (raw-value
            (progn
              (looking-at "\\([<[]\\(%%\\)?.*?\\)[]&gt;]\\(?:--\\([<[].*?[]>]\\)\\)?")
              (match-string-no-properties 0)))
           (date-start (match-string-no-properties 1))
           (date-end (match-string 3))
           (diaryp (match-beginning 2))
           (post-blank (progn (goto-char (match-end 0))
                              (skip-chars-forward " \t")))
           (end (point))
           (time-range
            (and (not diaryp)
                 (string-match
                  "<sup><a id="fnr.11" name="fnr.11" class="footref" href="#fn.11">11</a></sup>?[0-9]:[0-5][0-9]\\(-\\([012]?[0-9]\\):\\([0-5][0-9]\\)\\)"
                  date-start)
                 (cons (string-to-number (match-string 2 date-start))
                       (string-to-number (match-string 3 date-start)))))
           (type (cond (diaryp 'diary)
                       ((and activep (or date-end time-range)) 'active-range)
                       (activep 'active)
                       ((or date-end time-range) 'inactive-range)
                       (t 'inactive)))
           (repeater-props
            (and (not diaryp)
                 (string-match "\\([.+]?\\+\\)\\([0-9]+\\)\\([hdwmy]\\)"
                               raw-value)
                 (list
</p>
<p>
:repeater-type
(let ((type (match-string 1 raw-value)))
  (cond ((equal "<del>+" type) 'catch-up)
        ((equal ".</del>" type) 'restart)
        (t 'cumulate)))
</p>
<p>
:repeater-value (string-to-number (match-string 2 raw-value))
</p>
<p>
       :repeater-unit
       (case (string-to-char (match-string 3 raw-value))
         (?h 'hour) (?d 'day) (?w 'week) (?m 'month) (t 'year)))))
(warning-props
 (and (not diaryp)
      (string-match "\\(-\\)?-\\([0-9]+\\)\\([hdwmy]\\)" raw-value)
      (list
</p>
<p>
:warning-type (if (match-string 1 raw-value) 'first 'all)
</p>
<p>
:warning-value (string-to-number (match-string 2 raw-value))
</p>
<p>
            :warning-unit
            (case (string-to-char (match-string 3 raw-value))
              (?h 'hour) (?d 'day) (?w 'week) (?m 'month) (t 'year)))))
     year-start month-start day-start hour-start minute-start year-end
     month-end day-end hour-end minute-end)
;; Parse date-start.
(unless diaryp
  (let ((date (org-parse-time-string date-start t)))
    (setq year-start (nth 5 date)
          month-start (nth 4 date)
          day-start (nth 3 date)
          hour-start (nth 2 date)
          minute-start (nth 1 date))))
;; Compute date-end.  It can be provided directly in time-stamp,
;; or extracted from time range.  Otherwise, it defaults to the
;; same values as date-start.
(unless diaryp
  (let ((date (and date-end (org-parse-time-string date-end t))))
    (setq year-end (or (nth 5 date) year-start)
          month-end (or (nth 4 date) month-start)
          day-end (or (nth 3 date) day-start)
          hour-end (or (nth 2 date) (car time-range) hour-start)
          minute-end (or (nth 1 date) (cdr time-range) minute-start))))
(list 'timestamp
      (nconc (list :type type
</p>
<p>
:raw-value raw-value
</p>
<p>
:year-start year-start
</p>
<p>
:month-start month-start
</p>
<p>
:day-start day-start
</p>
<p>
:hour-start hour-start
</p>
<p>
:minute-start minute-start
</p>
<p>
:year-end year-end
</p>
<p>
:month-end month-end
</p>
<p>
:day-end day-end
</p>
<p>
:hour-end hour-end
</p>
<p>
:minute-end minute-end
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
      :post-blank post-blank)
repeater-props
warning-props)))))
</p>

<p>
(defun org-element-timestamp-interpreter (timestamp contents)
  "Interpret TIMESTAMP object as Org syntax.
CONTENTS is nil."
  ;; Use `:raw-value' if specified.
  (or (org-element-property :raw-value timestamp)
      ;; Otherwise, build timestamp string.
      (let* ((repeat-string
              (concat
               (case (org-element-property :repeater-type timestamp)
                 (cumulate "+") (catch-up "<del>+") (restart ".</del>"))
               (let ((val (org-element-property :repeater-value timestamp)))
                 (and val (number-to-string val)))
               (case (org-element-property :repeater-unit timestamp)
                 (hour "h") (day "d") (week "w") (month "m") (year "y"))))
             (warning-string
              (concat
               (case (org-element-property :warning-type timestamp)
                 (first "&#x2013;")
                 (all "-"))
               (let ((val (org-element-property :warning-value timestamp)))
                 (and val (number-to-string val)))
               (case (org-element-property :warning-unit timestamp)
                 (hour "h") (day "d") (week "w") (month "m") (year "y"))))
             (build-ts-string
              ;; Build an Org timestamp string from TIME.  ACTIVEP is
              ;; non-nil when time stamp is active.  If WITH-TIME-P is
              ;; non-nil, add a time part.  HOUR-END and MINUTE-END
              ;; specify a time range in the timestamp.  REPEAT-STRING
              ;; is the repeater string, if any.
              (lambda (time activep &amp;optional with-time-p hour-end minute-end)
                (let ((ts (format-time-string
                           (funcall (if with-time-p 'cdr 'car)
                                    org-time-stamp-formats)
                           time)))
                  (when (and hour-end minute-end)
                    (string-match "<sup><a id="fnr.11.100" name="fnr.11.100" class="footref" href="#fn.11">11</a></sup>?[0-9]:[0-5][0-9]" ts)
                    (setq ts
                          (replace-match
                           (format "\\&amp;-%02d:%02d" hour-end minute-end)
                           nil nil ts)))
                  (unless activep (setq ts (format "[%s]" (substring ts 1 -1))))
                  (dolist (s (list repeat-string warning-string))
                    (when (org-string-nw-p s)
                      (setq ts (concat (substring ts 0 -1)
                                       " "
                                       s
                                       (substring ts -1)))))
                  ;; Return value.
                  ts)))
             (type (org-element-property :type timestamp)))
        (case type
          ((active inactive)
           (let* ((minute-start (org-element-property :minute-start timestamp))
                  (minute-end (org-element-property :minute-end timestamp))
                  (hour-start (org-element-property :hour-start timestamp))
                  (hour-end (org-element-property :hour-end timestamp))
                  (time-range-p (and hour-start hour-end minute-start minute-end
                                     (or (/= hour-start hour-end)
                                         (/= minute-start minute-end)))))
             (funcall
              build-ts-string
              (encode-time 0
                           (or minute-start 0)
                           (or hour-start 0)
                           (org-element-property :day-start timestamp)
                           (org-element-property :month-start timestamp)
                           (org-element-property :year-start timestamp))
              (eq type 'active)
              (and hour-start minute-start)
              (and time-range-p hour-end)
              (and time-range-p minute-end))))
          ((active-range inactive-range)
           (let ((minute-start (org-element-property :minute-start timestamp))
                 (minute-end (org-element-property :minute-end timestamp))
                 (hour-start (org-element-property :hour-start timestamp))
                 (hour-end (org-element-property :hour-end timestamp)))
             (concat
              (funcall
               build-ts-string (encode-time
                                0
                                (or minute-start 0)
                                (or hour-start 0)
                                (org-element-property :day-start timestamp)
                                (org-element-property :month-start timestamp)
                                (org-element-property :year-start timestamp))
               (eq type 'active-range)
               (and hour-start minute-start))
              "&#x2013;"
              (funcall build-ts-string
                       (encode-time 0
                                    (or minute-end 0)
                                    (or hour-end 0)
                                    (org-element-property :day-end timestamp)
                                    (org-element-property :month-end timestamp)
                                    (org-element-property :year-end timestamp))
                       (eq type 'active-range)
                       (and hour-end minute-end)))))))))
</p>

<p>
(defun org-element-timestamp-successor ()
  "Search for the next timestamp object.
</p>

<p>
Return value is a cons cell whose CAR is `timestamp' and CDR is
beginning position."
  (save-excursion
    (when (re-search-forward
           (concat org-ts-regexp-both
                   "\\|"
                   "\\(?:<[0-9]+-[0-9]+-[0-9]+[^>\n]+?\\+[0-9]+[dwmy]>\\)"
                   "\\|"
                   "\\(?:<%%\\(?:([^>\n]+)\\)&gt;\\)")
           nil t)
      (cons 'timestamp (match-beginning 0)))))
</p>


<p>
;;;; Underline
</p>

<p>
(defun org-element-underline-parser ()
  "Parse underline object at point.
</p>

<p>
Return a list whose CAR is `underline' and CDR is a plist with
`:begin', `:end', `:contents-begin' and `:contents-end' and
`:post-blank' keywords.
</p>

<p>
Assume point is at the first underscore marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
          (contents-begin (match-beginning 4))
          (contents-end (match-end 4))
          (post-blank (progn (goto-char (match-end 2))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'underline
            (list :begin begin
</p>
<p>
:end end
</p>
<p>
:contents-begin contents-begin
</p>
<p>
:contents-end contents-end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-underline-interpreter (underline contents)
  "Interpret UNDERLINE object as Org syntax.
CONTENTS is the contents of the object."
  (format "<span class="underline">%s</span>" contents))
</p>


<p>
;;;; Verbatim
</p>

<p>
(defun org-element-verbatim-parser ()
  "Parse verbatim object at point.
</p>

<p>
Return a list whose CAR is `verbatim' and CDR is a plist with
`:value', `:begin', `:end' and `:post-blank' keywords.
</p>

<p>
Assume point is at the first equal sign marker."
  (save-excursion
    (unless (bolp) (backward-char 1))
    (looking-at org-emph-re)
    (let ((begin (match-beginning 2))
          (value (org-match-string-no-properties 4))
          (post-blank (progn (goto-char (match-end 2))
                             (skip-chars-forward " \t")))
          (end (point)))
      (list 'verbatim
            (list :value value
</p>
<p>
:begin begin
</p>
<p>
:end end
</p>
<p>
:post-blank post-blank)))))
</p>

<p>
(defun org-element-verbatim-interpreter (verbatim contents)
  "Interpret VERBATIM object as Org syntax.
CONTENTS is nil."
  (format "<code>%s</code>" (org-element-property :value verbatim)))
</p>


<p>

;;; Parsing Element Starting At Point
;;
;; `org-element&#x2013;current-element' is the core function of this section.
;; It returns the Lisp representation of the element starting at
;; point.
;;
;; `org-element&#x2013;current-element' makes use of special modes.  They
;; are activated for fixed element chaining (e.g., `plain-list' &gt;
;; `item') or fixed conditional element chaining (e.g., `headline' &gt;
;; `section').  Special modes are: `first-section', `item',
;; `node-property', `quote-section', `section' and `table-row'.
</p>

<p>
(defun org-element&#x2013;current-element
  (limit &amp;optional granularity special structure)
  "Parse the element starting at point.
</p>

<p>
Return value is a list like (TYPE PROPS) where TYPE is the type
of the element and PROPS a plist of properties associated to the
element.
</p>

<p>
Possible types are defined in `org-element-all-elements'.
</p>

<p>
LIMIT bounds the search.
</p>

<p>
Optional argument GRANULARITY determines the depth of the
recursion.  Allowed values are `headline', `greater-element',
`element', `object' or nil.  When it is broader than `object' (or
nil), secondary values will not be parsed, since they only
contain objects.
</p>

<p>
Optional argument SPECIAL, when non-nil, can be either
`first-section', `item', `node-property', `quote-section',
`section', and `table-row'.
</p>

<p>
If STRUCTURE isn't provided but SPECIAL is set to `item', it will
be computed.
</p>

<p>
This function assumes point is always at the beginning of the
element it has to parse."
  (save-excursion
    (let ((case-fold-search t)
          ;; Determine if parsing depth allows for secondary strings
          ;; parsing.  It only applies to elements referenced in
          ;; `org-element-secondary-value-alist'.
          (raw-secondary-p (and granularity (not (eq granularity 'object)))))
      (cond
       ;; Item.
       ((eq special 'item)
        (org-element-item-parser limit structure raw-secondary-p))
       ;; Table Row.
       ((eq special 'table-row) (org-element-table-row-parser limit))
       ;; Node Property.
       ((eq special 'node-property) (org-element-node-property-parser limit))
       ;; Headline.
       ((org-with-limited-levels (org-at-heading-p))
        (org-element-headline-parser limit raw-secondary-p))
       ;; Sections (must be checked after headline).
       ((eq special 'section) (org-element-section-parser limit))
       ((eq special 'quote-section) (org-element-quote-section-parser limit))
       ((eq special 'first-section)
        (org-element-section-parser
         (or (save-excursion (org-with-limited-levels (outline-next-heading)))
             limit)))
       ;; When not at bol, point is at the beginning of an item or
       ;; a footnote definition: next item is always a paragraph.
       ((not (bolp)) (org-element-paragraph-parser limit (list (point))))
       ;; Planning and Clock.
       ((looking-at org-planning-or-clock-line-re)
        (if (equal (match-string 1) org-clock-string)
            (org-element-clock-parser limit)
          (org-element-planning-parser limit)))
       ;; Inlinetask.
       ((org-at-heading-p)
        (org-element-inlinetask-parser limit raw-secondary-p))
       ;; From there, elements can have affiliated keywords.
       (t (let ((affiliated (org-element&#x2013;collect-affiliated-keywords limit)))
            (cond
             ;; Jumping over affiliated keywords put point off-limits.
             ;; Parse them as regular keywords.
             ((and (cdr affiliated) (&gt;= (point) limit))
              (goto-char (car affiliated))
              (org-element-keyword-parser limit nil))
             ;; LaTeX Environment.
             ((looking-at
               "[ \t]*\\\\begin{[A-Za-z0-9*]+}\\(\\[.*?\\]\\|{.*?}\\)*[ \t]*$")
              (org-element-latex-environment-parser limit affiliated))
             ;; Drawer and Property Drawer.
             ((looking-at org-drawer-regexp)
              (if (equal (match-string 1) "PROPERTIES")
                  (org-element-property-drawer-parser limit affiliated)
                (org-element-drawer-parser limit affiliated)))
             ;; Fixed Width
             ((looking-at "[ \t]*:\\( \\|$\\)")
              (org-element-fixed-width-parser limit affiliated))
             ;; Inline Comments, Blocks, Babel Calls, Dynamic Blocks and
             ;; Keywords.
             ((looking-at "[ \t]*#")
              (goto-char (match-end 0))
              (cond ((looking-at "\\(?: \\|$\\)")
                     (beginning-of-line)
                     (org-element-comment-parser limit affiliated))
                    ((looking-at "\\+BEGIN<sub>\\</sub>\\(\\S-+\\)")
                     (beginning-of-line)
                     (let ((parser (assoc (upcase (match-string 1))
                                          org-element-block-name-alist)))
                       (if parser (funcall (cdr parser) limit affiliated)
                         (org-element-special-block-parser limit affiliated))))
                    ((looking-at "\\+CALL:")
                     (beginning-of-line)
                     (org-element-babel-call-parser limit affiliated))
                    ((looking-at "\\+BEGIN:? ")
                     (beginning-of-line)
                     (org-element-dynamic-block-parser limit affiliated))
                    ((looking-at "\\+\&sect;-+:")
                     (beginning-of-line)
                     (org-element-keyword-parser limit affiliated))
                    (t
                     (beginning-of-line)
                     (org-element-paragraph-parser limit affiliated))))
             ;; Footnote Definition.
             ((looking-at org-footnote-definition-re)
              (org-element-footnote-definition-parser limit affiliated))
             ;; Horizontal Rule.
             ((looking-at "[ \t]*-\\{5,\\}[ \t]*$")
              (org-element-horizontal-rule-parser limit affiliated))
             ;; Diary Sexp.
             ((looking-at "%%(")
              (org-element-diary-sexp-parser limit affiliated))
             ;; Table.
             ((org-at-table-p t) (org-element-table-parser limit affiliated))
             ;; List.
             ((looking-at (org-item-re))
              (org-element-plain-list-parser
               limit affiliated
               (or structure (org-element&#x2013;list-struct limit))))
             ;; Default element: Paragraph.
             (t (org-element-paragraph-parser limit affiliated)))))))))
</p>


<p>
;; Most elements can have affiliated keywords.  When looking for an
;; element beginning, we want to move before them, as they belong to
;; that element, and, in the meantime, collect information they give
;; into appropriate properties.  Hence the following function.
</p>

<p>
(defun org-element&#x2013;collect-affiliated-keywords (limit)
  "Collect affiliated keywords from point down to LIMIT.
</p>

<p>
Return a list whose CAR is the position at the first of them and
CDR a plist of keywords and values and move point to the
beginning of the first line after them.
</p>

<p>
As a special case, if element doesn't start at the beginning of
the line (e.g., a paragraph starting an item), CAR is current
position of point and CDR is nil."
  (if (not (bolp)) (list (point))
    (let ((case-fold-search t)
          (origin (point))
          ;; RESTRICT is the list of objects allowed in parsed
          ;; keywords value.
          (restrict (org-element-restriction 'keyword))
          output)
      (while (and (&lt; (point) limit) (looking-at org-element&#x2013;affiliated-re))
        (let* ((raw-kwd (upcase (match-string 1)))
               ;; Apply translation to RAW-KWD.  From there, KWD is
               ;; the official keyword.
               (kwd (or (cdr (assoc raw-kwd
                                    org-element-keyword-translation-alist))
                        raw-kwd))
               ;; Find main value for any keyword.
               (value
                (save-match-data
                  (org-trim
                   (buffer-substring-no-properties
                    (match-end 0) (point-at-eol)))))
               ;; PARSEDP is non-nil when keyword should have its
               ;; value parsed.
               (parsedp (member kwd org-element-parsed-keywords))
               ;; If KWD is a dual keyword, find its secondary
               ;; value.  Maybe parse it.
               (dualp (member kwd org-element-dual-keywords))
               (dual-value
                (and dualp
                     (let ((sec (org-match-string-no-properties 2)))
                       (if (or (not sec) (not parsedp)) sec
                         (org-element-parse-secondary-string sec restrict)))))
               ;; Attribute a property name to KWD.
               (kwd-sym (and kwd (intern (concat ":" (downcase kwd))))))
          ;; Now set final shape for VALUE.
          (when parsedp
            (setq value (org-element-parse-secondary-string value restrict)))
          (when dualp
            (setq value (and (or value dual-value) (cons value dual-value))))
          (when (or (member kwd org-element-multiple-keywords)
                    ;; Attributes can always appear on multiple lines.
                    (string-match "<sup>ATTR</sup>_" kwd))
            (setq value (cons value (plist-get output kwd-sym))))
          ;; Eventually store the new value in OUTPUT.
          (setq output (plist-put output kwd-sym value))
          ;; Move to next keyword.
          (forward-line)))
      ;; If affiliated keywords are orphaned: move back to first one.
      ;; They will be parsed as a paragraph.
      (when (looking-at "[ \t]*$") (goto-char origin) (setq output nil))
      ;; Return value.
      (cons origin output))))
</p>


<p>

;;; The Org Parser
;;
;; The two major functions here are `org-element-parse-buffer', which
;; parses Org syntax inside the current buffer, taking into account
;; region, narrowing, or even visibility if specified, and
;; `org-element-parse-secondary-string', which parses objects within
;; a given string.
;;
;; The (almost) almighty `org-element-map' allows to apply a function
;; on elements or objects matching some type, and accumulate the
;; resulting values.  In an export situation, it also skips unneeded
;; parts of the parse tree.
</p>

<p>
(defun org-element-parse-buffer (&amp;optional granularity visible-only)
  "Recursively parse the buffer and return structure.
If narrowing is in effect, only parse the visible part of the
buffer.
</p>

<p>
Optional argument GRANULARITY determines the depth of the
recursion.  It can be set to the following symbols:
</p>

<p>
`headline'          Only parse headlines.
`greater-element'   Don't recurse into greater elements excepted
                    headlines and sections.  Thus, elements
                    parsed are the top-level ones.
`element'           Parse everything but objects and plain text.
`object'            Parse the complete buffer (default).
</p>

<p>
When VISIBLE-ONLY is non-nil, don't parse contents of hidden
elements.
</p>

<p>
An element or an objects is represented as a list with the
pattern (TYPE PROPERTIES CONTENTS), where :
</p>

<p>
TYPE is a symbol describing the element or object.  See
`org-element-all-elements' and `org-element-all-objects' for an
exhaustive list of such symbols.  One can retrieve it with
`org-element-type' function.
</p>

<p>
PROPERTIES is the list of attributes attached to the element or
object, as a plist.  Although most of them are specific to the
element or object type, all types share `:begin', `:end',
`:post-blank' and `:parent' properties, which respectively
refer to buffer position where the element or object starts,
ends, the number of white spaces or blank lines after it, and
the element or object containing it.  Properties values can be
obtained by using `org-element-property' function.
</p>

<p>
CONTENTS is a list of elements, objects or raw strings
contained in the current element or object, when applicable.
One can access them with `org-element-contents' function.
</p>

<p>
The Org buffer has `org-data' as type and nil as properties.
`org-element-map' function can be used to find specific elements
or objects within the parse tree.
</p>

<p>
This function assumes that current major mode is `org-mode'."
  (save-excursion
    (goto-char (point-min))
    (org-skip-whitespace)
    (org-element&#x2013;parse-elements
     (point-at-bol) (point-max)
     ;; Start in `first-section' mode so text before the first
     ;; headline belongs to a section.
     'first-section nil granularity visible-only (list 'org-data nil))))
</p>

<p>
(defun org-element-parse-secondary-string (string restriction &amp;optional parent)
  "Recursively parse objects in STRING and return structure.
</p>

<p>
RESTRICTION is a symbol limiting the object types that will be
looked after.
</p>

<p>
Optional argument PARENT, when non-nil, is the element or object
containing the secondary string.  It is used to set correctly
`:parent' property within the string."
  ;; Copy buffer-local variables listed in
  ;; `org-element-object-variables' into temporary buffer.  This is
  ;; required since object parsing is dependent on these variables.
  (let ((pairs (delq nil (mapcar (lambda (var)
                                   (when (boundp var)
                                     (cons var (symbol-value var))))
                                 org-element-object-variables))))
    (with-temp-buffer
      (mapc (lambda (pair) (org-set-local (car pair) (cdr pair))) pairs)
      (insert string)
      (let ((secondary (org-element&#x2013;parse-objects
                        (point-min) (point-max) nil restriction)))
        (when parent
          (mapc (lambda (obj) (org-element-put-property obj :parent parent))
                secondary))
        secondary))))
</p>

<p>
(defun org-element-map
  (data types fun &amp;optional info first-match no-recursion with-affiliated)
  "Map a function on selected elements or objects.
</p>

<p>
DATA is a parse tree, an element, an object, a string, or a list
of such constructs.  TYPES is a symbol or list of symbols of
elements or objects types (see `org-element-all-elements' and
`org-element-all-objects' for a complete list of types).  FUN is
the function called on the matching element or object.  It has to
accept one argument: the element or object itself.
</p>

<p>
When optional argument INFO is non-nil, it should be a plist
holding export options.  In that case, parts of the parse tree
not exportable according to that property list will be skipped.
</p>

<p>
When optional argument FIRST-MATCH is non-nil, stop at the first
match for which FUN doesn't return nil, and return that value.
</p>

<p>
Optional argument NO-RECURSION is a symbol or a list of symbols
representing elements or objects types.  `org-element-map' won't
enter any recursive element or object whose type belongs to that
list.  Though, FUN can still be applied on them.
</p>

<p>
When optional argument WITH-AFFILIATED is non-nil, FUN will also
apply to matching objects within parsed affiliated keywords (see
`org-element-parsed-keywords').
</p>

<p>
Nil values returned from FUN do not appear in the results.
</p>


<p>
Examples:
</p>
<hr  />

<p>
Assuming TREE is a variable containing an Org buffer parse tree,
the following example will return a flat list of all `src-block'
and `example-block' elements in it:
</p>

<p>
\(org-element-map tree '(example-block src-block) 'identity)
</p>

<p>
The following snippet will find the first headline with a level
of 1 and a \"phone\" tag, and will return its beginning position:
</p>

<p>
\(org-element-map tree 'headline
 \(lambda (hl)
   \(and (= (org-element-property :level hl) 1)
        \(member \"phone\" (org-element-property :tags hl))
        \(org-element-property :begin hl)))
 nil t)
</p>

<p>
The next example will return a flat list of all `plain-list' type
elements in TREE that are not a sub-list themselves:
</p>

<p>
\(org-element-map tree 'plain-list 'identity nil nil 'plain-list)
</p>

<p>
Eventually, this example will return a flat list of all `bold'
type objects containing a `latex-snippet' type object, even
looking into captions:
</p>

<p>
  \(org-element-map tree 'bold
   \(lambda (b)
     \(and (org-element-map b 'latex-snippet 'identity nil t) b))
   nil nil nil t)"
  ;; Ensure TYPES and NO-RECURSION are a list, even of one element.
  (unless (listp types) (setq types (list types)))
  (unless (listp no-recursion) (setq no-recursion (list no-recursion)))
  ;; Recursion depth is determined by &#x2013;CATEGORY.
  (let* ((&#x2013;category
          (catch 'found
            (let ((category 'greater-elements))
              (mapc (lambda (type)
                      (cond ((or (memq type org-element-all-objects)
                                 (eq type 'plain-text))
                             ;; If one object is found, the function
                             ;; has to recurse into every object.
                             (throw 'found 'objects))
                            ((not (memq type org-element-greater-elements))
                             ;; If one regular element is found, the
                             ;; function has to recurse, at least,
                             ;; into every element it encounters.
                             (and (not (eq category 'elements))
                                  (setq category 'elements)))))
                    types)
              category)))
         ;; Compute properties for affiliated keywords if necessary.
         (&#x2013;affiliated-alist
          (and with-affiliated
               (mapcar (lambda (kwd)
                         (cons kwd (intern (concat ":" (downcase kwd)))))
                       org-element-affiliated-keywords)))
         &#x2013;acc
         &#x2013;walk-tree
         (&#x2013;walk-tree
          (function
           (lambda (&#x2013;data)
             ;; Recursively walk DATA.  INFO, if non-nil, is a plist
             ;; holding contextual information.
             (let ((&#x2013;type (org-element-type &#x2013;data)))
               (cond
                ((not &#x2013;data))
                ;; Ignored element in an export context.
                ((and info (memq &#x2013;data (plist-get info :ignore-list))))
                ;; List of elements or objects.
                ((not &#x2013;type) (mapc &#x2013;walk-tree &#x2013;data))
                ;; Unconditionally enter parse trees.
                ((eq &#x2013;type 'org-data)
                 (mapc &#x2013;walk-tree (org-element-contents &#x2013;data)))
                (t
                 ;; Check if TYPE is matching among TYPES.  If so,
                 ;; apply FUN to &#x2013;DATA and accumulate return value
                 ;; into &#x2013;ACC (or exit if FIRST-MATCH is non-nil).
                 (when (memq &#x2013;type types)
                   (let ((result (funcall fun &#x2013;data)))
                     (cond ((not result))
                           (first-match (throw '&#x2013;map-first-match result))
                           (t (push result &#x2013;acc)))))
                 ;; If &#x2013;DATA has a secondary string that can contain
                 ;; objects with their type among TYPES, look into it.
                 (when (and (eq &#x2013;category 'objects) (not (stringp &#x2013;data)))
                   (let ((sec-prop
                          (assq &#x2013;type org-element-secondary-value-alist)))
                     (when sec-prop
                       (funcall &#x2013;walk-tree
                                (org-element-property (cdr sec-prop) &#x2013;data)))))
                 ;; If &#x2013;DATA has any affiliated keywords and
                 ;; WITH-AFFILIATED is non-nil, look for objects in
                 ;; them.
                 (when (and with-affiliated
                            (eq &#x2013;category 'objects)
                            (memq &#x2013;type org-element-all-elements))
                   (mapc (lambda (kwd-pair)
                           (let ((kwd (car kwd-pair))
                                 (value (org-element-property
                                         (cdr kwd-pair) &#x2013;data)))
                             ;; Pay attention to the type of value.
                             ;; Preserve order for multiple keywords.
                             (cond
                              ((not value))
                              ((and (member kwd org-element-multiple-keywords)
                                    (member kwd org-element-dual-keywords))
                               (mapc (lambda (line)
                                       (funcall &#x2013;walk-tree (cdr line))
                                       (funcall &#x2013;walk-tree (car line)))
                                     (reverse value)))
                              ((member kwd org-element-multiple-keywords)
                               (mapc (lambda (line) (funcall &#x2013;walk-tree line))
                                     (reverse value)))
                              ((member kwd org-element-dual-keywords)
                               (funcall &#x2013;walk-tree (cdr value))
                               (funcall &#x2013;walk-tree (car value)))
                              (t (funcall &#x2013;walk-tree value)))))
                         &#x2013;affiliated-alist))
                 ;; Determine if a recursion into &#x2013;DATA is possible.
                 (cond
                  ;; &#x2013;TYPE is explicitly removed from recursion.
                  ((memq &#x2013;type no-recursion))
                  ;; &#x2013;DATA has no contents.
                  ((not (org-element-contents &#x2013;data)))
                  ;; Looking for greater elements but &#x2013;DATA is simply
                  ;; an element or an object.
                  ((and (eq &#x2013;category 'greater-elements)
                        (not (memq &#x2013;type org-element-greater-elements))))
                  ;; Looking for elements but &#x2013;DATA is an object.
                  ((and (eq &#x2013;category 'elements)
                        (memq &#x2013;type org-element-all-objects)))
                  ;; In any other case, map contents.
                  (t (mapc &#x2013;walk-tree (org-element-contents &#x2013;data)))))))))))
    (catch '&#x2013;map-first-match
      (funcall &#x2013;walk-tree data)
      ;; Return value in a proper order.
      (nreverse &#x2013;acc))))
(put 'org-element-map 'lisp-indent-function 2)
</p>

<p>
;; The following functions are internal parts of the parser.
;;
;; The first one, `org-element&#x2013;parse-elements' acts at the element's
;; level.
;;
;; The second one, `org-element&#x2013;parse-objects' applies on all objects
;; of a paragraph or a secondary string.  It uses
;; `org-element&#x2013;get-next-object-candidates' to optimize the search of
;; the next object in the buffer.
;;
;; More precisely, that function looks for every allowed object type
;; first.  Then, it discards failed searches, keeps further matches,
;; and searches again types matched behind point, for subsequent
;; calls.  Thus, searching for a given type fails only once, and every
;; object is searched only once at top level (but sometimes more for
;; nested types).
</p>

<p>
(defun org-element&#x2013;parse-elements
  (beg end special structure granularity visible-only acc)
  "Parse elements between BEG and END positions.
</p>

<p>
SPECIAL prioritize some elements over the others.  It can be set
to `first-section', `quote-section', `section' `item' or
`table-row'.
</p>

<p>
When value is `item', STRUCTURE will be used as the current list
structure.
</p>

<p>
GRANULARITY determines the depth of the recursion.  See
`org-element-parse-buffer' for more information.
</p>

<p>
When VISIBLE-ONLY is non-nil, don't parse contents of hidden
elements.
</p>

<p>
Elements are accumulated into ACC."
  (save-excursion
    (goto-char beg)
    ;; Visible only: skip invisible parts at the beginning of the
    ;; element.
    (when (and visible-only (org-invisible-p2))
      (goto-char (min (1+ (org-find-visible)) end)))
    ;; When parsing only headlines, skip any text before first one.
    (when (and (eq granularity 'headline) (not (org-at-heading-p)))
      (org-with-limited-levels (outline-next-heading)))
    ;; Main loop start.
    (while (&lt; (point) end)
      ;; Find current element's type and parse it accordingly to
      ;; its category.
      (let* ((element (org-element&#x2013;current-element
                       end granularity special structure))
             (type (org-element-type element))
             (cbeg (org-element-property :contents-begin element)))
        (goto-char (org-element-property :end element))
        ;; Visible only: skip invisible parts between siblings.
        (when (and visible-only (org-invisible-p2))
          (goto-char (min (1+ (org-find-visible)) end)))
        ;; Fill ELEMENT contents by side-effect.
        (cond
         ;; If element has no contents, don't modify it.
         ((not cbeg))
         ;; Greater element: parse it between `contents-begin' and
         ;; `contents-end'.  Make sure GRANULARITY allows the
         ;; recursion, or ELEMENT is a headline, in which case going
         ;; inside is mandatory, in order to get sub-level headings.
         ((and (memq type org-element-greater-elements)
               (or (memq granularity '(element object nil))
                   (and (eq granularity 'greater-element)
                        (eq type 'section))
                   (eq type 'headline)))
          (org-element&#x2013;parse-elements
           cbeg (org-element-property :contents-end element)
           ;; Possibly switch to a special mode.
           (case type
             (headline
              (if (org-element-property :quotedp element) 'quote-section
                'section))
             (plain-list 'item)
             (property-drawer 'node-property)
             (table 'table-row))
           (and (memq type '(item plain-list))
                (org-element-property :structure element))
           granularity visible-only element))
         ;; ELEMENT has contents.  Parse objects inside, if
         ;; GRANULARITY allows it.
         ((memq granularity '(object nil))
          (org-element&#x2013;parse-objects
           cbeg (org-element-property :contents-end element) element
           (org-element-restriction type))))
        (org-element-adopt-elements acc element)))
    ;; Return result.
    acc))
</p>

<p>
(defun org-element&#x2013;parse-objects (beg end acc restriction)
  "Parse objects between BEG and END and return recursive structure.
</p>

<p>
Objects are accumulated in ACC.
</p>

<p>
RESTRICTION is a list of object successors which are allowed in
the current object."
  (let ((candidates 'initial))
    (save-excursion
      (save-restriction
        (narrow-to-region beg end)
        (goto-char (point-min))
        (while (and (not (eobp))
                    (setq candidates
                          (org-element&#x2013;get-next-object-candidates
                           restriction candidates)))
          (let ((next-object
                 (let ((pos (apply 'min (mapcar 'cdr candidates))))
                   (save-excursion
                     (goto-char pos)
                     (funcall (intern (format "org-element-%s-parser"
                                              (car (rassq pos candidates)))))))))
            ;; 1. Text before any object.  Untabify it.
            (let ((obj-beg (org-element-property :begin next-object)))
              (unless (= (point) obj-beg)
                (setq acc
                      (org-element-adopt-elements
                       acc
                       (replace-regexp-in-string
                        "\t" (make-string tab-width ? )
                        (buffer-substring-no-properties (point) obj-beg))))))
            ;; 2. Object&#x2026;
            (let ((obj-end (org-element-property :end next-object))
                  (cont-beg (org-element-property :contents-begin next-object)))
              ;; Fill contents of NEXT-OBJECT by side-effect, if it has
              ;; a recursive type.
              (when (and cont-beg
                         (memq (car next-object) org-element-recursive-objects))
                (org-element&#x2013;parse-objects
                 cont-beg (org-element-property :contents-end next-object)
                 next-object (org-element-restriction next-object)))
              (setq acc (org-element-adopt-elements acc next-object))
              (goto-char obj-end))))
        ;; 3. Text after last object.  Untabify it.
        (unless (eobp)
          (setq acc
                (org-element-adopt-elements
                 acc
                 (replace-regexp-in-string
                  "\t" (make-string tab-width ? )
                  (buffer-substring-no-properties (point) end)))))
        ;; Result.
        acc))))
</p>

<p>
(defun org-element&#x2013;get-next-object-candidates (restriction objects)
  "Return an alist of candidates for the next object.
</p>

<p>
RESTRICTION is a list of object types, as symbols.  Only
candidates with such types are looked after.
</p>

<p>
OBJECTS is the previous candidates alist.  If it is set to
`initial', no search has been done before, and all symbols in
RESTRICTION should be looked after.
</p>

<p>
Return value is an alist whose CAR is the object type and CDR its
beginning position."
  (delq
   nil
   (if (eq objects 'initial)
       ;; When searching for the first time, look for every successor
       ;; allowed in RESTRICTION.
       (mapcar
        (lambda (res)
          (funcall (intern (format "org-element-%s-successor" res))))
        restriction)
     ;; Focus on objects returned during last search.  Keep those
     ;; still after point.  Search again objects before it.
     (mapcar
      (lambda (obj)
        (if (&gt;= (cdr obj) (point)) obj
          (let* ((type (car obj))
                 (succ (or (cdr (assq type org-element-object-successor-alist))
                           type)))
            (and succ
                 (funcall (intern (format "org-element-%s-successor" succ)))))))
      objects))))
</p>


<p>

;;; Towards A Bijective Process
;;
;; The parse tree obtained with `org-element-parse-buffer' is really
;; a snapshot of the corresponding Org buffer.  Therefore, it can be
;; interpreted and expanded into a string with canonical Org syntax.
;; Hence `org-element-interpret-data'.
;;
;; The function relies internally on
;; `org-element&#x2013;interpret-affiliated-keywords'.
</p>

<p>
;;;###autoload
(defun org-element-interpret-data (data &amp;optional parent)
  "Interpret DATA as Org syntax.
</p>

<p>
DATA is a parse tree, an element, an object or a secondary string
to interpret.
</p>

<p>
Optional argument PARENT is used for recursive calls.  It contains
the element or object containing data, or nil.
</p>

<p>
Return Org syntax as a string."
  (let* ((type (org-element-type data))
         (results
          (cond
           ;; Secondary string.
           ((not type)
            (mapconcat
             (lambda (obj) (org-element-interpret-data obj parent))
             data ""))
           ;; Full Org document.
           ((eq type 'org-data)
            (mapconcat
             (lambda (obj) (org-element-interpret-data obj parent))
             (org-element-contents data) ""))
           ;; Plain text: return it.
           ((stringp data) data)
           ;; Element/Object without contents.
           ((not (org-element-contents data))
            (funcall (intern (format "org-element-%s-interpreter" type))
                     data nil))
           ;; Element/Object with contents.
           (t
            (let* ((greaterp (memq type org-element-greater-elements))
                   (objectp (and (not greaterp)
                                 (memq type org-element-recursive-objects)))
                   (contents
                    (mapconcat
                     (lambda (obj) (org-element-interpret-data obj data))
                     (org-element-contents
                      (if (or greaterp objectp) data
                        ;; Elements directly containing objects must
                        ;; have their indentation normalized first.
                        (org-element-normalize-contents
                         data
                         ;; When normalizing first paragraph of an
                         ;; item or a footnote-definition, ignore
                         ;; first line's indentation.
                         (and (eq type 'paragraph)
                              (equal data (car (org-element-contents parent)))
                              (memq (org-element-type parent)
                                    '(footnote-definition item))))))
                     "")))
              (funcall (intern (format "org-element-%s-interpreter" type))
                       data
                       (if greaterp (org-element-normalize-contents contents)
                         contents)))))))
    (if (memq type '(org-data plain-text nil)) results
      ;; Build white spaces.  If no `:post-blank' property is
      ;; specified, assume its value is 0.
      (let ((post-blank (or (org-element-property :post-blank data) 0)))
        (if (memq type org-element-all-objects)
            (concat results (make-string post-blank 32))
          (concat
           (org-element&#x2013;interpret-affiliated-keywords data)
           (org-element-normalize-string results)
           (make-string post-blank 10)))))))
</p>

<p>
(defun org-element&#x2013;interpret-affiliated-keywords (element)
  "Return ELEMENT's affiliated keywords as Org syntax.
If there is no affiliated keyword, return the empty string."
  (let ((keyword-to-org
         (function
          (lambda (key value)
            (let (dual)
              (when (member key org-element-dual-keywords)
                (setq dual (cdr value) value (car value)))
              (concat "#+" key
                      (and dual
                           (format "[%s]" (org-element-interpret-data dual)))
                      ": "
                      (if (member key org-element-parsed-keywords)
                          (org-element-interpret-data value)
                        value)
                      "\n"))))))
    (mapconcat
     (lambda (prop)
       (let ((value (org-element-property prop element))
             (keyword (upcase (substring (symbol-name prop) 1))))
         (when value
           (if (or (member keyword org-element-multiple-keywords)
                   ;; All attribute keywords can have multiple lines.
                   (string-match "<sup>ATTR</sup>_" keyword))
               (mapconcat (lambda (line) (funcall keyword-to-org keyword line))
                          (reverse value)
                          "")
             (funcall keyword-to-org keyword value)))))
     ;; List all ELEMENT's properties matching an attribute line or an
     ;; affiliated keyword, but ignore translated keywords since they
     ;; cannot belong to the property list.
     (loop for prop in (nth 1 element) by 'cddr
           when (let ((keyword (upcase (substring (symbol-name prop) 1))))
                  (or (string-match "<sup>ATTR</sup>_" keyword)
                      (and
                       (member keyword org-element-affiliated-keywords)
                       (not (assoc keyword
                                   org-element-keyword-translation-alist)))))
           collect prop)
     "")))
</p>

<p>
;; Because interpretation of the parse tree must return the same
;; number of blank lines between elements and the same number of white
;; space after objects, some special care must be given to white
;; spaces.
;;
;; The first function, `org-element-normalize-string', ensures any
;; string different from the empty string will end with a single
;; newline character.
;;
;; The second function, `org-element-normalize-contents', removes
;; global indentation from the contents of the current element.
</p>

<p>
(defun org-element-normalize-string (s)
  "Ensure string S ends with a single newline character.
</p>

<p>
If S isn't a string return it unchanged.  If S is the empty
string, return it.  Otherwise, return a new string with a single
newline character at its end."
  (cond
   ((not (stringp s)) s)
   ((string= "" s) "")
   (t (and (string-match "\\(\n[ \t]*\\)*\\'" s)
           (replace-match "\n" nil nil s)))))
</p>

<p>
(defun org-element-normalize-contents (element &amp;optional ignore-first)
  "Normalize plain text in ELEMENT's contents.
</p>

<p>
ELEMENT must only contain plain text and objects.
</p>

<p>
If optional argument IGNORE-FIRST is non-nil, ignore first line's
indentation to compute maximal common indentation.
</p>

<p>
Return the normalized element that is element with global
indentation removed from its contents.  The function assumes that
indentation is not done with TAB characters."
  (let* ((min-ind most-positive-fixnum)
         find-min-ind                        ; For byte-compiler.
         (find-min-ind
          (function
           ;; Return minimal common indentation within BLOB.  This is
           ;; done by walking recursively BLOB and updating MIN-IND
           ;; along the way.  FIRST-FLAG is non-nil when the first
           ;; string hasn't been seen yet.  It is required as this
           ;; string is the only one whose indentation doesn't happen
           ;; after a newline character.
           (lambda (blob first-flag)
             (dolist (object (org-element-contents blob))
               (when (and first-flag (stringp object))
                 (setq first-flag nil)
                 (string-match "\\`\\( *\\)" object)
                 (let ((len (length (match-string 1 object))))
                   ;; An indentation of zero means no string will be
                   ;; modified.  Quit the process.
                   (if (zerop len) (throw 'zero (setq min-ind 0))
                     (setq min-ind (min len min-ind)))))
               (cond
                ((stringp object)
                 (dolist (line (delq "" (cdr (org-split-string object " *\n"))))
                   (setq min-ind (min (org-get-indentation line) min-ind))))
                ((memq (org-element-type object) org-element-recursive-objects)
                 (funcall find-min-ind object first-flag))))))))
    ;; Find minimal indentation in ELEMENT.
    (catch 'zero (funcall find-min-ind element (not ignore-first)))
    (if (or (zerop min-ind) (= min-ind most-positive-fixnum)) element
      ;; Build ELEMENT back, replacing each string with the same
      ;; string minus common indentation.
      (let* (build                        ; For byte compiler.
             (build
              (function
               (lambda (blob first-flag)
                 ;; Return BLOB with all its strings indentation
                 ;; shortened from MIN-IND white spaces.  FIRST-FLAG
                 ;; is non-nil when the first string hasn't been seen
                 ;; yet.
                 (setcdr (cdr blob)
                         (mapcar
                          #'(lambda (object)
                              (when (and first-flag (stringp object))
                                (setq first-flag nil)
                                (setq object
                                      (replace-regexp-in-string
                                       (format "\\` \\{%d\\}" min-ind)
                                       "" object)))
                              (cond
                               ((stringp object)
                                (replace-regexp-in-string
                                 (format "\n \\{%d\\}" min-ind) "\n" object))
                               ((memq (org-element-type object)
                                      org-element-recursive-objects)
                                (funcall build object first-flag))
                               (t object)))
                          (org-element-contents blob)))
                 blob))))
        (funcall build element (not ignore-first))))))
</p>


<p>

;;; The Toolbox
;;
;; The first move is to implement a way to obtain the smallest element
;; containing point.  This is the job of `org-element-at-point'.  It
;; basically jumps back to the beginning of section containing point
;; and moves, element after element, with
;; `org-element&#x2013;current-element' until the container is found.  Note:
;; When using `org-element-at-point', secondary values are never
;; parsed since the function focuses on elements, not on objects.
;;
;; At a deeper level, `org-element-context' lists all elements and
;; objects containing point.
;;
;; `org-element-nested-p' and `org-element-swap-A-B' may be used
;; internally by navigation and manipulation tools.
</p>

<p>
;;;###autoload
(defun org-element-at-point (&amp;optional keep-trail)
  "Determine closest element around point.
</p>

<p>
Return value is a list like (TYPE PROPS) where TYPE is the type
of the element and PROPS a plist of properties associated to the
element.
</p>

<p>
Possible types are defined in `org-element-all-elements'.
Properties depend on element or object type, but always include
`:begin', `:end', `:parent' and `:post-blank' properties.
</p>

<p>
As a special case, if point is at the very beginning of a list or
sub-list, returned element will be that list instead of the first
item.  In the same way, if point is at the beginning of the first
row of a table, returned element will be the table instead of the
first row.
</p>

<p>
If optional argument KEEP-TRAIL is non-nil, the function returns
a list of elements leading to element at point.  The list's CAR
is always the element at point.  The following positions contain
element's siblings, then parents, siblings of parents, until the
first element of current section."
  (org-with-wide-buffer
   ;; If at a headline, parse it.  It is the sole element that
   ;; doesn't require to know about context.  Be sure to disallow
   ;; secondary string parsing, though.
   (if (org-with-limited-levels (org-at-heading-p))
       (progn
         (beginning-of-line)
         (if (not keep-trail) (org-element-headline-parser (point-max) t)
           (list (org-element-headline-parser (point-max) t))))
     ;; Otherwise move at the beginning of the section containing
     ;; point.
     (catch 'exit
       (let ((origin (point))
             (end (save-excursion
                    (org-with-limited-levels (outline-next-heading)) (point)))
             element type special-flag trail struct prevs parent)
         (org-with-limited-levels
          (if (org-before-first-heading-p)
              ;; In empty lines at buffer's beginning, return nil.
              (progn (goto-char (point-min))
                     (org-skip-whitespace)
                     (when (or (eobp) (&gt; (line-beginning-position) origin))
                       (throw 'exit nil)))
            (org-back-to-heading)
            (forward-line)
            (org-skip-whitespace)
            (when (or (eobp) (&gt; (line-beginning-position) origin))
              ;; In blank lines just after the headline, point still
              ;; belongs to the headline.
              (throw 'exit
                     (progn (skip-chars-backward " \r\t\n")
                            (beginning-of-line)
                            (if (not keep-trail)
                                (org-element-headline-parser (point-max) t)
                              (list (org-element-headline-parser
                                     (point-max) t))))))))
         (beginning-of-line)
         ;; Parse successively each element, skipping those ending
         ;; before original position.
         (while t
           (setq element
                 (org-element&#x2013;current-element end 'element special-flag struct)
                 type (car element))
           (org-element-put-property element :parent parent)
           (when keep-trail (push element trail))
           (cond
            ;; 1. Skip any element ending before point.  Also skip
            ;;    element ending at point when we're sure that another
            ;;    element has started.
            ((let ((elem-end (org-element-property :end element)))
               (when (or (&lt; elem-end origin)
                         (and (= elem-end origin) (/= elem-end end)))
                 (goto-char elem-end))))
            ;; 2. An element containing point is always the element at
            ;;    point.
            ((not (memq type org-element-greater-elements))
             (throw 'exit (if keep-trail trail element)))
            ;; 3. At any other greater element type, if point is
            ;;    within contents, move into it.
            (t
             (let ((cbeg (org-element-property :contents-begin element))
                   (cend (org-element-property :contents-end element)))
               (if (or (not cbeg) (not cend) (&gt; cbeg origin) (&lt; cend origin)
                       ;; Create an anchor for tables and plain lists:
                       ;; when point is at the very beginning of these
                       ;; elements, ignoring affiliated keywords,
                       ;; target them instead of their contents.
                       (and (= cbeg origin) (memq type '(plain-list table)))
                       ;; When point is at contents end, do not move
                       ;; into elements with an explicit ending, but
                       ;; return that element instead.
                       (and (= cend origin)
                            (or (memq type
                                      '(center-block
                                        drawer dynamic-block inlinetask
                                        property-drawer quote-block
                                        special-block))
                                ;; Corner case: if a list ends at the
                                ;; end of a buffer without a final new
                                ;; line, return last element in last
                                ;; item instead.
                                (and (memq type '(item plain-list))
                                     (progn (goto-char cend)
                                            (or (bolp) (not (eobp))))))))
                   (throw 'exit (if keep-trail trail element))
                 (setq parent element)
                 (case type
                   (plain-list
                    (setq special-flag 'item
                          struct (org-element-property :structure element)))
                   (item (setq special-flag nil))
                   (property-drawer
                    (setq special-flag 'node-property struct nil))
                   (table (setq special-flag 'table-row struct nil))
                   (otherwise (setq special-flag nil struct nil)))
                 (setq end cend)
                 (goto-char cbeg)))))))))))
</p>

<p>
;;;###autoload
(defun org-element-context (&amp;optional element)
  "Return closest element or object around point.
</p>

<p>
Return value is a list like (TYPE PROPS) where TYPE is the type
of the element or object and PROPS a plist of properties
associated to it.
</p>

<p>
Possible types are defined in `org-element-all-elements' and
`org-element-all-objects'.  Properties depend on element or
object type, but always include `:begin', `:end', `:parent' and
`:post-blank'.
</p>

<p>
Optional argument ELEMENT, when non-nil, is the closest element
containing point, as returned by `org-element-at-point'.
Providing it allows for quicker computation."
  (catch 'objects-forbidden
    (org-with-wide-buffer
     (let* ((origin (point))
            (element (or element (org-element-at-point)))
            (type (org-element-type element))
            context)
       ;; Check if point is inside an element containing objects or at
       ;; a secondary string.  In that case, narrow buffer to the
       ;; containing area.  Otherwise, return ELEMENT.
       (cond
        ;; At a parsed affiliated keyword, check if we're inside main
        ;; or dual value.
        ((let ((post (org-element-property :post-affiliated element)))
           (and post (&lt; origin post)))
         (beginning-of-line)
         (let ((case-fold-search t)) (looking-at org-element&#x2013;affiliated-re))
         (cond
          ((not (member-ignore-case (match-string 1)
                                    org-element-parsed-keywords))
           (throw 'objects-forbidden element))
          ((&lt; (match-end 0) origin)
           (narrow-to-region (match-end 0) (line-end-position)))
          ((and (match-beginning 2)
                (&gt;= origin (match-beginning 2))
                (&lt; origin (match-end 2)))
           (narrow-to-region (match-beginning 2) (match-end 2)))
          (t (throw 'objects-forbidden element)))
         ;; Also change type to retrieve correct restrictions.
         (setq type 'keyword))
        ;; At an item, objects can only be located within tag, if any.
        ((eq type 'item)
         (let ((tag (org-element-property :tag element)))
           (if (not tag) (throw 'objects-forbidden element)
             (beginning-of-line)
             (search-forward tag (line-end-position))
             (goto-char (match-beginning 0))
             (if (and (&gt;= origin (point)) (&lt; origin (match-end 0)))
                 (narrow-to-region (point) (match-end 0))
               (throw 'objects-forbidden element)))))
        ;; At an headline or inlinetask, objects are located within
        ;; their title.
        ((memq type '(headline inlinetask))
         (goto-char (org-element-property :begin element))
         (skip-chars-forward "*")
         (if (and (&gt; origin (point)) (&lt; origin (line-end-position)))
             (narrow-to-region (point) (line-end-position))
           (throw 'objects-forbidden element)))
        ;; At a paragraph, a table-row or a verse block, objects are
        ;; located within their contents.
        ((memq type '(paragraph table-row verse-block))
         (let ((cbeg (org-element-property :contents-begin element))
               (cend (org-element-property :contents-end element)))
           ;; CBEG is nil for table rules.
           (if (and cbeg cend (&gt;= origin cbeg) (&lt; origin cend))
               (narrow-to-region cbeg cend)
             (throw 'objects-forbidden element))))
        ;; At a parsed keyword, objects are located within value.
        ((eq type 'keyword)
         (if (not (member (org-element-property :key element)
                          org-element-document-properties))
             (throw 'objects-forbidden element)
           (beginning-of-line)
           (search-forward ":")
           (if (and (&gt;= origin (point)) (&lt; origin (line-end-position)))
               (narrow-to-region (point) (line-end-position))
             (throw 'objects-forbidden element))))
        ;; At a planning line, if point is at a timestamp, return it,
        ;; otherwise, return element.
        ((eq type 'planning)
         (dolist (p '(:closed :deadline :scheduled))
           (let ((timestamp (org-element-property p element)))
             (when (and timestamp
                        (&lt;= (org-element-property :begin timestamp) origin)
                        (&gt; (org-element-property :end timestamp) origin))
               (throw 'objects-forbidden timestamp))))
         (throw 'objects-forbidden element))
        (t (throw 'objects-forbidden element)))
       (goto-char (point-min))
       (let ((restriction (org-element-restriction type))
             (parent element)
             (candidates 'initial))
         (catch 'exit
           (while (setq candidates
                        (org-element&#x2013;get-next-object-candidates
                         restriction candidates))
             (let ((closest-cand (rassq (apply 'min (mapcar 'cdr candidates))
                                        candidates)))
               ;; If ORIGIN is before next object in element, there's
               ;; no point in looking further.
               (if (&gt; (cdr closest-cand) origin) (throw 'exit parent)
                 (let* ((object
                         (progn (goto-char (cdr closest-cand))
                                (funcall (intern (format "org-element-%s-parser"
                                                         (car closest-cand))))))
                        (cbeg (org-element-property :contents-begin object))
                        (cend (org-element-property :contents-end object))
                        (obj-end (org-element-property :end object)))
                   (cond
                    ;; ORIGIN is after OBJECT, so skip it.
                    ((&lt;= obj-end origin) (goto-char obj-end))
                    ;; ORIGIN is within a non-recursive object or at
                    ;; an object boundaries: Return that object.
                    ((or (not cbeg) (&lt; origin cbeg) (&gt;= origin cend))
                     (throw 'exit
                            (org-element-put-property object :parent parent)))
                    ;; Otherwise, move within current object and
                    ;; restrict search to the end of its contents.
                    (t (goto-char cbeg)
                       (narrow-to-region (point) cend)
                       (org-element-put-property object :parent parent)
                       (setq parent object
                             restriction (org-element-restriction object)
                             candidates 'initial)))))))
           parent))))))
</p>

<p>
(defun org-element-nested-p (elem-A elem-B)
  "Non-nil when elements ELEM-A and ELEM-B are nested."
  (let ((beg-A (org-element-property :begin elem-A))
        (beg-B (org-element-property :begin elem-B))
        (end-A (org-element-property :end elem-A))
        (end-B (org-element-property :end elem-B)))
    (or (and (&gt;= beg-A beg-B) (&lt;= end-A end-B))
        (and (&gt;= beg-B beg-A) (&lt;= end-B end-A)))))
</p>

<p>
(defun org-element-swap-A-B (elem-A elem-B)
  "Swap elements ELEM-A and ELEM-B.
Assume ELEM-B is after ELEM-A in the buffer.  Leave point at the
end of ELEM-A."
  (goto-char (org-element-property :begin elem-A))
  ;; There are two special cases when an element doesn't start at bol:
  ;; the first paragraph in an item or in a footnote definition.
  (let ((specialp (not (bolp))))
    ;; Only a paragraph without any affiliated keyword can be moved at
    ;; ELEM-A position in such a situation.  Note that the case of
    ;; a footnote definition is impossible: it cannot contain two
    ;; paragraphs in a row because it cannot contain a blank line.
    (if (and specialp
             (or (not (eq (org-element-type elem-B) 'paragraph))
                 (/= (org-element-property :begin elem-B)
                     (org-element-property :contents-begin elem-B))))
        (error "Cannot swap elements"))
    ;; In a special situation, ELEM-A will have no indentation.  We'll
    ;; give it ELEM-B's (which will in, in turn, have no indentation).
    (let* ((ind-B (when specialp
                    (goto-char (org-element-property :begin elem-B))
                    (org-get-indentation)))
           (beg-A (org-element-property :begin elem-A))
           (end-A (save-excursion
                    (goto-char (org-element-property :end elem-A))
                    (skip-chars-backward " \r\t\n")
                    (point-at-eol)))
           (beg-B (org-element-property :begin elem-B))
           (end-B (save-excursion
                    (goto-char (org-element-property :end elem-B))
                    (skip-chars-backward " \r\t\n")
                    (point-at-eol)))
           ;; Store overlays responsible for visibility status.  We
           ;; also need to store their boundaries as they will be
           ;; removed from buffer.
           (overlays
            (cons
             (mapcar (lambda (ov) (list ov (overlay-start ov) (overlay-end ov)))
                     (overlays-in beg-A end-A))
             (mapcar (lambda (ov) (list ov (overlay-start ov) (overlay-end ov)))
                     (overlays-in beg-B end-B))))
           ;; Get contents.
           (body-A (buffer-substring beg-A end-A))
           (body-B (delete-and-extract-region beg-B end-B)))
      (goto-char beg-B)
      (when specialp
        (setq body-B (replace-regexp-in-string "\\`[ \t]*" "" body-B))
        (org-indent-to-column ind-B))
      (insert body-A)
      ;; Restore ex ELEM-A overlays.
      (let ((offset (- beg-B beg-A)))
        (mapc (lambda (ov)
                (move-overlay
                 (car ov) (+ (nth 1 ov) offset) (+ (nth 2 ov) offset)))
              (car overlays))
        (goto-char beg-A)
        (delete-region beg-A end-A)
        (insert body-B)
        ;; Restore ex ELEM-B overlays.
        (mapc (lambda (ov)
                (move-overlay
                 (car ov) (- (nth 1 ov) offset) (- (nth 2 ov) offset)))
              (cdr overlays)))
      (goto-char (org-element-property :end elem-B)))))
</p>

<p>
(provide 'org-element)
</p>

<p>
;; Local variables:
;; generated-autoload-file: "org-loaddefs.el"
;; End:
</p>

<p>
;;; org-element.el ends here
</p>
</div>
</div>

<div id="outline-container-sec-8-8" class="outline-3">
<h3 id="sec-8-8"><span class="section-number-3">8.8</span> ox.el</h3>
<div class="outline-text-3" id="text-8-8">
<p>
;;; ox.el &#x2014; Generic Export Engine for Org Mode
</p>

<p>
;; Copyright (C) 2012-2014 Free Software Foundation, Inc.
</p>

<p>
;; Author: Nicolas Goaziou &lt;n.goaziou at gmail dot com&gt;
;; Keywords: outlines, hypermedia, calendar, wp
</p>

<p>
;; This file is part of GNU Emacs.
</p>

<p>
;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
</p>

<p>
;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
</p>

<p>
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</p>

<p>
;;; Commentary:
;;
;; This library implements a generic export engine for Org, built on
;; its syntactical parser: Org Elements.
;;
;; Besides that parser, the generic exporter is made of three distinct
;; parts:
;;
;; - The communication channel consists in a property list, which is
;;   created and updated during the process.  Its use is to offer
;;   every piece of information, would it be about initial environment
;;   or contextual data, all in a single place.  The exhaustive list
;;   of properties is given in "The Communication Channel" section of
;;   this file.
;;
;; - The transcoder walks the parse tree, ignores or treat as plain
;;   text elements and objects according to export options, and
;;   eventually calls back-end specific functions to do the real
;;   transcoding, concatenating their return value along the way.
;;
;; - The filter system is activated at the very beginning and the very
;;   end of the export process, and each time an element or an object
;;   has been converted.  It is the entry point to fine-tune standard
;;   output from back-end transcoders.  See "The Filter System"
;;   section for more information.
;;
;; The core function is `org-export-as'.  It returns the transcoded
;; buffer as a string.
;;
;; An export back-end is defined with `org-export-define-backend'.
;; This function can also support specific buffer keywords, OPTION
;; keyword's items and filters.  Refer to function's documentation for
;; more information.
;;
;; If the new back-end shares most properties with another one,
;; `org-export-define-derived-backend' can be used to simplify the
;; process.
;;
;; Any back-end can define its own variables.  Among them, those
;; customizable should belong to the `org-export-BACKEND' group.
;;
;; Tools for common tasks across back-ends are implemented in the
;; following part of the file.
;;
;; Then, a wrapper macro for asynchronous export,
;; `org-export-async-start', along with tools to display results. are
;; given in the penultimate part.
;;
;; Eventually, a dispatcher (`org-export-dispatch') for standard
;; back-ends is provided in the last one.
</p>

<p>
;;; Code:
</p>

<p>
(eval-when-compile (require 'cl))
(require 'org-element)
(require 'org-macro)
(require 'ob-exp)
</p>

<p>
(declare-function org-publish "ox-publish" (project &amp;optional force async))
(declare-function org-publish-all "ox-publish" (&amp;optional force async))
(declare-function
 org-publish-current-file "ox-publish" (&amp;optional force async))
(declare-function org-publish-current-project "ox-publish"
                  (&amp;optional force async))
</p>

<p>
(defvar org-publish-project-alist)
(defvar org-table-number-fraction)
(defvar org-table-number-regexp)
</p>


<p>

;;; Internal Variables
;;
;; Among internal variables, the most important is
;; `org-export-options-alist'.  This variable define the global export
;; options, shared between every exporter, and how they are acquired.
</p>

<p>
(defconst org-export-max-depth 19
  "Maximum nesting depth for headlines, counting from 0.")
</p>

<p>
(defconst org-export-options-alist
  '((:author "AUTHOR" nil user-full-name t)
    (:creator "CREATOR" nil org-export-creator-string)
    (:date "DATE" nil nil t)
    (:description "DESCRIPTION" nil nil newline)
    (:email "EMAIL" nil user-mail-address t)
    (:exclude-tags "EXCLUDE<sub>TAGS</sub>" nil org-export-exclude-tags split)
    (:headline-levels nil "H" org-export-headline-levels)
    (:keywords "KEYWORDS" nil nil space)
    (:language "LANGUAGE" nil org-export-default-language t)
    (:preserve-breaks nil "\\n" org-export-preserve-breaks)
    (:section-numbers nil "num" org-export-with-section-numbers)
    (:select-tags "SELECT<sub>TAGS</sub>" nil org-export-select-tags split)
    (:time-stamp-file nil "timestamp" org-export-time-stamp-file)
    (:title "TITLE" nil nil space)
    (:with-archived-trees nil "arch" org-export-with-archived-trees)
    (:with-author nil "author" org-export-with-author)
    (:with-clocks nil "c" org-export-with-clocks)
    (:with-creator nil "creator" org-export-with-creator)
    (:with-date nil "date" org-export-with-date)
    (:with-drawers nil "d" org-export-with-drawers)
    (:with-email nil "email" org-export-with-email)
    (:with-emphasize nil "*" org-export-with-emphasize)
    (:with-entities nil "e" org-export-with-entities)
    (:with-fixed-width nil ":" org-export-with-fixed-width)
    (:with-footnotes nil "f" org-export-with-footnotes)
    (:with-inlinetasks nil "inline" org-export-with-inlinetasks)
    (:with-latex nil "tex" org-export-with-latex)
    (:with-planning nil "p" org-export-with-planning)
    (:with-priority nil "pri" org-export-with-priority)
    (:with-smart-quotes nil "'" org-export-with-smart-quotes)
    (:with-special-strings nil "-" org-export-with-special-strings)
    (:with-statistics-cookies nil "stat" org-export-with-statistics-cookies)
    (:with-sub-superscript nil "^" org-export-with-sub-superscripts)
    (:with-toc nil "toc" org-export-with-toc)
    (:with-tables nil "|" org-export-with-tables)
    (:with-tags nil "tags" org-export-with-tags)
    (:with-tasks nil "tasks" org-export-with-tasks)
    (:with-timestamps nil "&lt;" org-export-with-timestamps)
    (:with-todo-keywords nil "todo" org-export-with-todo-keywords))
  "Alist between export properties and ways to set them.
</p>

<p>
The CAR of the alist is the property name, and the CDR is a list
like (KEYWORD OPTION DEFAULT BEHAVIOR) where:
</p>

<p>
KEYWORD is a string representing a buffer keyword, or nil.  Each
  property defined this way can also be set, during subtree
  export, through a headline property named after the keyword
  with the \"EXPORT<sub>\</sub>" prefix (i.e. DATE keyword and EXPORT<sub>DATE</sub>
  property).
OPTION is a string that could be found in an #+OPTIONS: line.
DEFAULT is the default value for the property.
BEHAVIOR determines how Org should handle multiple keywords for
  the same property.  It is a symbol among:
  nil       Keep old value and discard the new one.
  t         Replace old value with the new one.
  `space'   Concatenate the values, separating them with a space.
  `newline' Concatenate the values, separating them with
            a newline.
  `split'   Split values at white spaces, and cons them to the
            previous list.
</p>

<p>
Values set through KEYWORD and OPTION have precedence over
DEFAULT.
</p>

<p>
All these properties should be back-end agnostic.  Back-end
specific properties are set through `org-export-define-backend'.
Properties redefined there have precedence over these.")
</p>

<p>
(defconst org-export-special-keywords '("FILETAGS" "SETUPFILE" "OPTIONS")
  "List of in-buffer keywords that require special treatment.
These keywords are not directly associated to a property.  The
way they are handled must be hard-coded into
`org-export&#x2013;get-inbuffer-options' function.")
</p>

<p>
(defconst org-export-filters-alist
  '((:filter-bold . org-export-filter-bold-functions)
    (:filter-babel-call . org-export-filter-babel-call-functions)
    (:filter-center-block . org-export-filter-center-block-functions)
    (:filter-clock . org-export-filter-clock-functions)
    (:filter-code . org-export-filter-code-functions)
    (:filter-comment . org-export-filter-comment-functions)
    (:filter-comment-block . org-export-filter-comment-block-functions)
    (:filter-diary-sexp . org-export-filter-diary-sexp-functions)
    (:filter-drawer . org-export-filter-drawer-functions)
    (:filter-dynamic-block . org-export-filter-dynamic-block-functions)
    (:filter-entity . org-export-filter-entity-functions)
    (:filter-example-block . org-export-filter-example-block-functions)
    (:filter-export-block . org-export-filter-export-block-functions)
    (:filter-export-snippet . org-export-filter-export-snippet-functions)
    (:filter-final-output . org-export-filter-final-output-functions)
    (:filter-fixed-width . org-export-filter-fixed-width-functions)
    (:filter-footnote-definition . org-export-filter-footnote-definition-functions)
    (:filter-footnote-reference . org-export-filter-footnote-reference-functions)
    (:filter-headline . org-export-filter-headline-functions)
    (:filter-horizontal-rule . org-export-filter-horizontal-rule-functions)
    (:filter-inline-babel-call . org-export-filter-inline-babel-call-functions)
    (:filter-inline-src-block . org-export-filter-inline-src-block-functions)
    (:filter-inlinetask . org-export-filter-inlinetask-functions)
    (:filter-italic . org-export-filter-italic-functions)
    (:filter-item . org-export-filter-item-functions)
    (:filter-keyword . org-export-filter-keyword-functions)
    (:filter-latex-environment . org-export-filter-latex-environment-functions)
    (:filter-latex-fragment . org-export-filter-latex-fragment-functions)
    (:filter-line-break . org-export-filter-line-break-functions)
    (:filter-link . org-export-filter-link-functions)
    (:filter-node-property . org-export-filter-node-property-functions)
    (:filter-options . org-export-filter-options-functions)
    (:filter-paragraph . org-export-filter-paragraph-functions)
    (:filter-parse-tree . org-export-filter-parse-tree-functions)
    (:filter-plain-list . org-export-filter-plain-list-functions)
    (:filter-plain-text . org-export-filter-plain-text-functions)
    (:filter-planning . org-export-filter-planning-functions)
    (:filter-property-drawer . org-export-filter-property-drawer-functions)
    (:filter-quote-block . org-export-filter-quote-block-functions)
    (:filter-quote-section . org-export-filter-quote-section-functions)
    (:filter-radio-target . org-export-filter-radio-target-functions)
    (:filter-section . org-export-filter-section-functions)
    (:filter-special-block . org-export-filter-special-block-functions)
    (:filter-src-block . org-export-filter-src-block-functions)
    (:filter-statistics-cookie . org-export-filter-statistics-cookie-functions)
    (:filter-strike-through . org-export-filter-strike-through-functions)
    (:filter-subscript . org-export-filter-subscript-functions)
    (:filter-superscript . org-export-filter-superscript-functions)
    (:filter-table . org-export-filter-table-functions)
    (:filter-table-cell . org-export-filter-table-cell-functions)
    (:filter-table-row . org-export-filter-table-row-functions)
    (:filter-target . org-export-filter-target-functions)
    (:filter-timestamp . org-export-filter-timestamp-functions)
    (:filter-underline . org-export-filter-underline-functions)
    (:filter-verbatim . org-export-filter-verbatim-functions)
    (:filter-verse-block . org-export-filter-verse-block-functions))
  "Alist between filters properties and initial values.
</p>

<p>
The key of each association is a property name accessible through
the communication channel.  Its value is a configurable global
variable defining initial filters.
</p>

<p>
This list is meant to install user specified filters.  Back-end
developers may install their own filters using
`org-export-define-backend'.  Filters defined there will always
be prepended to the current list, so they always get applied
first.")
</p>

<p>
(defconst org-export-default-inline-image-rule
  `(("file" .
     ,(format "\\.%s\\'"
              (regexp-opt
               '("png" "jpeg" "jpg" "gif" "tiff" "tif" "xbm"
                 "xpm" "pbm" "pgm" "ppm") t))))
  "Default rule for link matching an inline image.
This rule applies to links with no description.  By default, it
will be considered as an inline image if it targets a local file
whose extension is either \"png\", \"jpeg\", \"jpg\", \"gif\",
\"tiff\", \"tif\", \"xbm\", \"xpm\", \"pbm\", \"pgm\" or \"ppm\".
See `org-export-inline-image-p' for more information about
rules.")
</p>

<p>
(defvar org-export-async-debug nil
  "Non-nil means asynchronous export process should leave data behind.
</p>

<p>
This data is found in the appropriate \"<b>Org Export Process</b>\"
buffer, and in files prefixed with \"org-export-process\" and
located in `temporary-file-directory'.
</p>

<p>
When non-nil, it will also set `debug-on-error' to a non-nil
value in the external process.")
</p>

<p>
(defvar org-export-stack-contents nil
  "Record asynchronously generated export results and processes.
This is an alist: its CAR is the source of the
result (destination file or buffer for a finished process,
original buffer for a running one) and its CDR is a list
containing the back-end used, as a symbol, and either a process
or the time at which it finished.  It is used to build the menu
from `org-export-stack'.")
</p>

<p>
(defvar org-export&#x2013;registered-backends nil
  "List of backends currently available in the exporter.
This variable is set with `org-export-define-backend' and
`org-export-define-derived-backend' functions.")
</p>

<p>
(defvar org-export-dispatch-last-action nil
  "Last command called from the dispatcher.
The value should be a list.  Its CAR is the action, as a symbol,
and its CDR is a list of export options.")
</p>

<p>
(defvar org-export-dispatch-last-position (make-marker)
  "The position where the last export command was created using the dispatcher.
This marker will be used with `C-u C-c C-e' to make sure export repetition
uses the same subtree if the previous command was restricted to a subtree.")
</p>

<p>
;; For compatibility with Org &lt; 8
(defvar org-export-current-backend nil
  "Name, if any, of the back-end used during an export process.
</p>

<p>
Its value is a symbol such as `html', `latex', `ascii', or nil if
the back-end is anonymous (see `org-export-create-backend') or if
there is no export process in progress.
</p>

<p>
It can be used to teach Babel blocks how to act differently
according to the back-end used.")
</p>

<p>

;;; User-configurable Variables
;;
;; Configuration for the masses.
;;
;; They should never be accessed directly, as their value is to be
;; stored in a property list (cf. `org-export-options-alist').
;; Back-ends will read their value from there instead.
</p>

<p>
(defgroup org-export nil
  "Options for exporting Org mode files."
</p>
<p>
:tag "Org Export"
</p>
<p>
:group 'org)
</p>

<p>
(defgroup org-export-general nil
  "General options for export engine."
</p>
<p>
:tag "Org Export General"
</p>
<p>
:group 'org-export)
</p>

<p>
(defcustom org-export-with-archived-trees 'headline
  "Whether sub-trees with the ARCHIVE tag should be exported.
</p>

<p>
This can have three different values:
nil         Do not export, pretend this tree is not present.
t           Do export the entire tree.
`headline'  Only export the headline, but skip the tree below it.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"arch:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(choice
        (const :tag "Not at all" nil)
        (const :tag "Headline only" headline)
        (const :tag "Entirely" t)))
</p>

<p>
(defcustom org-export-with-author t
  "Non-nil means insert author name into the exported file.
This option can also be set with the OPTIONS keyword,
e.g. \"author:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-clocks nil
  "Non-nil means export CLOCK keywords.
This option can also be set with the OPTIONS keyword,
e.g. \"c:t\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-creator 'comment
  "Non-nil means the postamble should contain a creator sentence.
</p>

<p>
The sentence can be set in `org-export-creator-string' and
defaults to \"Generated by Org mode XX in Emacs XXX.\".
</p>

<p>
If the value is `comment' insert it as a comment."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(choice
        (const :tag "No creator sentence" nil)
        (const :tag "Sentence as a comment" comment)
        (const :tag "Insert the sentence" t)))
</p>

<p>
(defcustom org-export-with-date t
  "Non-nil means insert date in the exported document.
This option can also be set with the OPTIONS keyword,
e.g. \"date:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-date-timestamp-format nil
  "Time-stamp format string to use for DATE keyword.
</p>

<p>
The format string, when specified, only applies if date consists
in a single time-stamp.  Otherwise its value will be ignored.
</p>

<p>
See `format-time-string' for details on how to build this
string."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(choice
        (string :tag "Time-stamp format string")
        (const :tag "No format string" nil)))
</p>

<p>
(defcustom org-export-creator-string
  (format "Emacs %s (Org mode %s)"
          emacs-version
          (if (fboundp 'org-version) (org-version) "unknown version"))
  "Information about the creator of the document.
This option can also be set on with the CREATOR keyword."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(string :tag "Creator string"))
</p>

<p>
(defcustom org-export-with-drawers '(not "LOGBOOK")
  "Non-nil means export contents of standard drawers.
</p>

<p>
When t, all drawers are exported.  This may also be a list of
drawer names to export.  If that list starts with `not', only
drawers with such names will be ignored.
</p>

<p>
This variable doesn't apply to properties drawers.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"d:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type '(choice
        (const :tag "All drawers" t)
        (const :tag "None" nil)
        (repeat :tag "Selected drawers"
                (string :tag "Drawer name"))
        (list :tag "Ignored drawers"
              (const :format "" not)
              (repeat :tag "Specify names of drawers to ignore during export"
</p>
<p>
:inline t
(string :tag "Drawer name")))))
</p>

<p>
(defcustom org-export-with-email nil
  "Non-nil means insert author email into the exported file.
This option can also be set with the OPTIONS keyword,
e.g. \"email:t\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-emphasize t
  "Non-nil means interpret <b>word</b>, <i>word</i>, <span class="underline">word</span> and <del>word</del>.
</p>

<p>
If the export target supports emphasizing text, the word will be
typeset in bold, italic, with an underline or strike-through,
respectively.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"*:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-exclude-tags '("noexport")
  "Tags that exclude a tree from export.
</p>

<p>
All trees carrying any of these tags will be excluded from
export.  This is without condition, so even subtrees inside that
carry one of the `org-export-select-tags' will be removed.
</p>

<p>
This option can also be set with the EXCLUDE<sub>TAGS</sub> keyword."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(repeat (string :tag "Tag")))
</p>

<p>
(defcustom org-export-with-fixed-width t
  "Non-nil means lines starting with \":\" will be in fixed width font.
</p>

<p>
This can be used to have pre-formatted text, fragments of code
etc.  For example:
</p>
<pre class="example">
;; Some Lisp examples
(while (defc cnt)
  (ding))
</pre>
<p>
will be looking just like this in also HTML.  See also the QUOTE
keyword.  Not all export backends support this.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"::nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-footnotes t
  "Non-nil means Org footnotes should be exported.
This option can also be set with the OPTIONS keyword,
e.g. \"f:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-latex t
  "Non-nil means process LaTeX environments and fragments.
</p>

<p>
This option can also be set with the OPTIONS line,
e.g. \"tex:verbatim\".  Allowed values are:
</p>

<p>
nil         Ignore math snippets.
`verbatim'  Keep everything in verbatim.
t           Allow export of math snippets."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type '(choice
        (const :tag "Do not process math in any way" nil)
        (const :tag "Interpret math snippets" t)
        (const :tag "Leave math verbatim" verbatim)))
</p>

<p>
(defcustom org-export-headline-levels 3
  "The last level which is still exported as a headline.
</p>

<p>
Inferior levels will usually produce itemize or enumerate lists
when exported, but back-end behaviour may differ.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"H:2\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'integer)
</p>

<p>
(defcustom org-export-default-language "en"
  "The default language for export and clocktable translations, as a string.
This may have an association in
`org-clock-clocktable-language-setup',
`org-export-smart-quotes-alist' and `org-export-dictionary'.
This option can also be set with the LANGUAGE keyword."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(string :tag "Language"))
</p>

<p>
(defcustom org-export-preserve-breaks nil
  "Non-nil means preserve all line breaks when exporting.
This option can also be set with the OPTIONS keyword,
e.g. \"\\n:t\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-entities t
  "Non-nil means interpret entities when exporting.
</p>

<p>
For example, HTML export converts \&alpha; to &amp;alpha; and \&Aring; to
&amp;Aring;.
</p>

<p>
For a list of supported names, see the constant `org-entities'
and the user option `org-entities-user'.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"e:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-inlinetasks t
  "Non-nil means inlinetasks should be exported.
This option can also be set with the OPTIONS keyword,
e.g. \"inline:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-planning nil
  "Non-nil means include planning info in export.
</p>

<p>
Planning info is the line containing either SCHEDULED:,
</p>
<p>
This option can also be set with the OPTIONS keyword,
e.g. \"p:t\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-priority nil
  "Non-nil means include priority cookies in export.
This option can also be set with the OPTIONS keyword,
e.g. \"pri:t\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-section-numbers t
  "Non-nil means add section numbers to headlines when exporting.
</p>

<p>
When set to an integer n, numbering will only happen for
headlines whose relative level is higher or equal to n.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"num:t\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-select-tags '("export")
  "Tags that select a tree for export.
</p>

<p>
If any such tag is found in a buffer, all trees that do not carry
one of these tags will be ignored during export.  Inside trees
that are selected like this, you can still deselect a subtree by
tagging it with one of the `org-export-exclude-tags'.
</p>

<p>
This option can also be set with the SELECT<sub>TAGS</sub> keyword."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(repeat (string :tag "Tag")))
</p>

<p>
(defcustom org-export-with-smart-quotes nil
  "Non-nil means activate smart quotes during export.
This option can also be set with the OPTIONS keyword,
e.g., \"':t\".
</p>

<p>
When setting this to non-nil, you need to take care of
using the correct Babel package when exporting to LaTeX.
E.g., you can load Babel for french like this:
</p>

<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-special-strings t
  "Non-nil means interpret \"\&#x00ad;\", \"&#x2013;\" and \"&#x2014;\" for export.
</p>

<p>
When this option is turned on, these strings will be exported as:
</p>

<p>
 Org     HTML     LaTeX    UTF-8
&#x2013;&#x2014;+-&#x2014;&#x2014;&#x2014;+&#x2013;&#x2014;&#x2014;+-&#x2014;&#x2014;
 \&#x00ad;    &amp;shy;      \&#x00ad;
 &#x2013;    &amp;ndash;    &#x2013;         
 &#x2014;   &amp;mdash;    &#x2014;        
 &#x2026;   &amp;hellip;   \\ldots     
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"-:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-statistics-cookies t
  "Non-nil means include statistics cookies in export.
This option can also be set with the OPTIONS keyword,
e.g. \"stat:nil\""
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-sub-superscripts t
  "Non-nil means interpret \"<sub>\</sub>" and \"<sup>\</sup>" for export.
</p>

<p>
If you want to control how Org displays those characters, see
`org-use-sub-superscripts'.  `org-export-with-sub-superscripts'
used to be an alias for `org-use-sub-superscripts' in Org &lt;8.0,
it is not anymore.
</p>

<p>
When this option is turned on, you can use TeX-like syntax for
sub- and superscripts and see them exported correctly.
</p>

<p>
You can also set the option with #+OPTIONS: ^:t
</p>

<p>
Several characters after \"<sub>\</sub>" or \"<sup>\</sup>" will be considered as a
single item - so grouping with {} is normally not needed.  For
example, the following things will be parsed as single sub- or
superscripts:
</p>

<p>
10<sup>24</sup>   or   10<sup>tau</sup>     several digits will be considered 1 item.
10<sup>-12</sup>  or   10<sup>-tau</sup>    a leading sign with digits or a word
x<sup>2</sup>-y<sup>3</sup>                 will be read as x<sup>2</sup> - y<sup>3</sup>, because items are
                        terminated by almost any nonword/nondigit char.
x<sub>i<sup>2</sup></sub> or   x<sup>(2-i)</sup>    braces or parenthesis do grouping.
</p>

<p>
Still, ambiguity is possible.  So when in doubt, use {} to enclose
the sub/superscript.  If you set this variable to the symbol `{}',
the braces are <b>required</b> in order to trigger interpretations as
sub/superscript.  This can be helpful in documents that need \"<sub>\</sub>"
frequently in plain text."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type '(choice
        (const :tag "Interpret them" t)
        (const :tag "Curly brackets only" {})
        (const :tag "Do not interpret them" nil)))
</p>

<p>
(defcustom org-export-with-toc t
  "Non-nil means create a table of contents in exported files.
</p>

<p>
The TOC contains headlines with levels up
to`org-export-headline-levels'.  When an integer, include levels
up to N in the toc, this may then be different from
`org-export-headline-levels', but it will not be allowed to be
larger than the number of headline levels.  When nil, no table of
contents is made.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"toc:nil\" or \"toc:3\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(choice
        (const :tag "No Table of Contents" nil)
        (const :tag "Full Table of Contents" t)
        (integer :tag "TOC to level")))
</p>

<p>
(defcustom org-export-with-tables t
  "If non-nil, lines starting with \"|\" define a table.
For example:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Name</th>
<th scope="col" class="left">Address</th>
<th scope="col" class="right">Birthday</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Arthur Dent</td>
<td class="left">England</td>
<td class="right">29.2.2100</td>
</tr>
</tbody>
</table>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"|:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-tags t
  "If nil, do not export tags, just remove them from headlines.
</p>

<p>
If this is the symbol `not-in-toc', tags will be removed from
table of contents entries, but still be shown in the headlines of
the document.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"tags:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(choice
        (const :tag "Off" nil)
        (const :tag "Not in TOC" not-in-toc)
        (const :tag "On" t)))
</p>

<p>
(defcustom org-export-with-tasks t
  "Non-nil means include TODO items for export.
</p>

<p>
This may have the following values:
t                    include tasks independent of state.
`todo'               include only tasks that are not yet done.
`done'               include only tasks that are already done.
nil                  ignore all tasks.
list of keywords     include tasks with these keywords.
</p>

<p>
This option can also be set with the OPTIONS keyword,
e.g. \"tasks:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(choice
        (const :tag "All tasks" t)
        (const :tag "No tasks" nil)
        (const :tag "Not-done tasks" todo)
        (const :tag "Only done tasks" done)
        (repeat :tag "Specific TODO keywords"
                (string :tag "Keyword"))))
</p>

<p>
(defcustom org-export-time-stamp-file t
  "Non-nil means insert a time stamp into the exported file.
The time stamp shows when the file was created. This option can
also be set with the OPTIONS keyword, e.g. \"timestamp:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-with-timestamps t
  "Non nil means allow timestamps in export.
</p>

<p>
It can be set to any of the following values:
  t          export all timestamps.
  `active'   export active timestamps only.
  `inactive' export inactive timestamps only.
  nil        do not export timestamps
</p>

<p>
This only applies to timestamps isolated in a paragraph
containing only timestamps.  Other timestamps are always
exported.
</p>

<p>
This option can also be set with the OPTIONS keyword, e.g.
\"&lt;:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(choice
        (const :tag "All timestamps" t)
        (const :tag "Only active timestamps" active)
        (const :tag "Only inactive timestamps" inactive)
        (const :tag "No timestamp" nil)))
</p>

<p>
(defcustom org-export-with-todo-keywords t
  "Non-nil means include TODO keywords in export.
When nil, remove all these keywords from the export.  This option
can also be set with the OPTIONS keyword, e.g.  \"todo:nil\"."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-allow-bind-keywords nil
  "Non-nil means BIND keywords can define local variable values.
This is a potential security risk, which is why the default value
is nil.  You can also allow them through local buffer variables."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-snippet-translation-alist nil
  "Alist between export snippets back-ends and exporter back-ends.
</p>

<p>
This variable allows to provide shortcuts for export snippets.
</p>

<p>
For example, with a value of '\(\(\"h\" . \"html\"\)\), the
HTML back-end will recognize the contents of \"\" as
HTML code while every other back-end will ignore it."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type '(repeat
        (cons (string :tag "Shortcut")
              (string :tag "Back-end"))))
</p>

<p>
(defcustom org-export-coding-system nil
  "Coding system for the exported file."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type 'coding-system)
</p>

<p>
(defcustom org-export-copy-to-kill-ring 'if-interactive
  "Non-nil means pushing export output to the kill ring.
This variable is ignored during asynchronous export."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.3"
</p>
<p>
:type '(choice
        (const :tag "Always" t)
        (const :tag "When export is done interactively" if-interactive)
        (const :tag "Never" nil)))
</p>

<p>
(defcustom org-export-initial-scope 'buffer
  "The initial scope when exporting with `org-export-dispatch'.
This variable can be either set to `buffer' or `subtree'."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type '(choice
        (const :tag "Export current buffer" buffer)
        (const :tag "Export current subtree" subtree)))
</p>

<p>
(defcustom org-export-show-temporary-export-buffer t
  "Non-nil means show buffer after exporting to temp buffer.
When Org exports to a file, the buffer visiting that file is ever
shown, but remains buried.  However, when exporting to
a temporary buffer, that buffer is popped up in a second window.
When this variable is nil, the buffer remains buried also in
these cases."
</p>
<p>
:group 'org-export-general
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-in-background nil
  "Non-nil means export and publishing commands will run in background.
Results from an asynchronous export are never displayed
automatically.  But you can retrieve them with \\[org-export-stack]."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type 'boolean)
</p>

<p>
(defcustom org-export-async-init-file user-init-file
  "File used to initialize external export process.
Value must be an absolute file name.  It defaults to user's
initialization file.  Though, a specific configuration makes the
process faster and the export more portable."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type '(file :must-match t))
</p>

<p>
(defcustom org-export-dispatch-use-expert-ui nil
  "Non-nil means using a non-intrusive `org-export-dispatch'.
In that case, no help buffer is displayed.  Though, an indicator
for current export scope is added to the prompt (\"b\" when
output is restricted to body only, \"s\" when it is restricted to
the current subtree, \"v\" when only visible elements are
considered for export, \"f\" when publishing functions should be
passed the FORCE argument and \"a\" when the export should be
asynchronous).  Also, \[?] allows to switch back to standard
mode."
</p>
<p>
:group 'org-export-general
</p>
<p>
:version "24.4"
</p>
<p>
:package-version '(Org . "8.0")
</p>
<p>
:type 'boolean)
</p>


<p>

;;; Defining Back-ends
;;
;; An export back-end is a structure with `org-export-backend' type
;; and `name', `parent', `transcoders', `options', `filters', `blocks'
;; and `menu' slots.
;;
;; At the lowest level, a back-end is created with
;; `org-export-create-backend' function.
;;
;; A named back-end can be registered with
;; `org-export-register-backend' function.  A registered back-end can
;; later be referred to by its name, with `org-export-get-backend'
;; function.  Also, such a back-end can become the parent of a derived
;; back-end from which slot values will be inherited by default.
;; `org-export-derived-backend-p' can check if a given back-end is
;; derived from a list of back-end names.
;;
;; `org-export-get-all-transcoders', `org-export-get-all-options' and
;; `org-export-get-all-filters' return the full alist of transcoders,
;; options and filters, including those inherited from ancestors.
;;
;; At a higher level, `org-export-define-backend' is the standard way
;; to define an export back-end.  If the new back-end is similar to
;; a registered back-end, `org-export-define-derived-backend' may be
;; used instead.
;;
;; Eventually `org-export-barf-if-invalid-backend' returns an error
;; when a given back-end hasn't been registered yet.
</p>

<p>
(defstruct (org-export-backend (:constructor org-export-create-backend)
                               (:copier nil))
  name parent transcoders options filters blocks menu)
</p>

<p>
(defun org-export-get-backend (name)
  "Return export back-end named after NAME.
NAME is a symbol.  Return nil if no such back-end is found."
  (catch 'found
    (dolist (b org-export&#x2013;registered-backends)
      (when (eq (org-export-backend-name b) name)
        (throw 'found b)))))
</p>

<p>
(defun org-export-register-backend (backend)
  "Register BACKEND as a known export back-end.
BACKEND is a structure with `org-export-backend' type."
  ;; Refuse to register an unnamed back-end.
  (unless (org-export-backend-name backend)
    (error "Cannot register a unnamed export back-end"))
  ;; Refuse to register a back-end with an unknown parent.
  (let ((parent (org-export-backend-parent backend)))
    (when (and parent (not (org-export-get-backend parent)))
      (error "Cannot use unknown \"%s\" back-end as a parent" parent)))
  ;; Register dedicated export blocks in the parser.
  (dolist (name (org-export-backend-blocks backend))
    (add-to-list 'org-element-block-name-alist
                 (cons name 'org-element-export-block-parser)))
  ;; If a back-end with the same name as BACKEND is already
  ;; registered, replace it with BACKEND.  Otherwise, simply add
  ;; BACKEND to the list of registered back-ends.
  (let ((old (org-export-get-backend (org-export-backend-name backend))))
    (if old (setcar (memq old org-export&#x2013;registered-backends) backend)
      (push backend org-export&#x2013;registered-backends))))
</p>

<p>
(defun org-export-barf-if-invalid-backend (backend)
  "Signal an error if BACKEND isn't defined."
  (unless (org-export-backend-p backend)
    (error "Unknown \"%s\" back-end: Aborting export" backend)))
</p>

<p>
(defun org-export-derived-backend-p (backend &amp;rest backends)
  "Non-nil if BACKEND is derived from one of BACKENDS.
BACKEND is an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.  BACKENDS is constituted of symbols."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (when backend
    (catch 'exit
      (while (org-export-backend-parent backend)
        (when (memq (org-export-backend-name backend) backends)
          (throw 'exit t))
        (setq backend
              (org-export-get-backend (org-export-backend-parent backend))))
      (memq (org-export-backend-name backend) backends))))
</p>

<p>
(defun org-export-get-all-transcoders (backend)
  "Return full translation table for BACKEND.
</p>

<p>
BACKEND is an export back-end, as return by, e.g,,
`org-export-create-backend'.  Return value is an alist where
keys are element or object types, as symbols, and values are
transcoders.
</p>

<p>
Unlike to `org-export-backend-transcoders', this function
also returns transcoders inherited from parent back-ends,
if any."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (when backend
    (let ((transcoders (org-export-backend-transcoders backend))
          parent)
      (while (setq parent (org-export-backend-parent backend))
        (setq backend (org-export-get-backend parent))
        (setq transcoders
              (append transcoders (org-export-backend-transcoders backend))))
      transcoders)))
</p>

<p>
(defun org-export-get-all-options (backend)
  "Return export options for BACKEND.
</p>

<p>
BACKEND is an export back-end, as return by, e.g,,
`org-export-create-backend'.  See `org-export-options-alist'
for the shape of the return value.
</p>

<p>
Unlike to `org-export-backend-options', this function also
returns options inherited from parent back-ends, if any."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (when backend
    (let ((options (org-export-backend-options backend))
          parent)
      (while (setq parent (org-export-backend-parent backend))
        (setq backend (org-export-get-backend parent))
        (setq options (append options (org-export-backend-options backend))))
      options)))
</p>

<p>
(defun org-export-get-all-filters (backend)
  "Return complete list of filters for BACKEND.
</p>

<p>
BACKEND is an export back-end, as return by, e.g,,
`org-export-create-backend'.  Return value is an alist where
keys are symbols and values lists of functions.
</p>

<p>
Unlike to `org-export-backend-filters', this function also
returns filters inherited from parent back-ends, if any."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (when backend
    (let ((filters (org-export-backend-filters backend))
          parent)
      (while (setq parent (org-export-backend-parent backend))
        (setq backend (org-export-get-backend parent))
        (setq filters (append filters (org-export-backend-filters backend))))
      filters)))
</p>

<p>
(defun org-export-define-backend (backend transcoders &amp;rest body)
  "Define a new back-end BACKEND.
</p>

<p>
TRANSCODERS is an alist between object or element types and
functions handling them.
</p>

<p>
These functions should return a string without any trailing
space, or nil.  They must accept three arguments: the object or
element itself, its contents or nil when it isn't recursive and
the property list used as a communication channel.
</p>

<p>
Contents, when not nil, are stripped from any global indentation
\(although the relative one is preserved).  They also always end
with a single newline character.
</p>

<p>
If, for a given type, no function is found, that element or
object type will simply be ignored, along with any blank line or
white space at its end.  The same will happen if the function
returns the nil value.  If that function returns the empty
string, the type will be ignored, but the blank lines or white
spaces will be kept.
</p>

<p>
In addition to element and object types, one function can be
associated to the `template' (or `inner-template') symbol and
another one to the `plain-text' symbol.
</p>

<p>
The former returns the final transcoded string, and can be used
to add a preamble and a postamble to document's body.  It must
accept two arguments: the transcoded string and the property list
containing export options.  A function associated to `template'
will not be applied if export has option \"body-only\".
A function associated to `inner-template' is always applied.
</p>

<p>
The latter, when defined, is to be called on every text not
recognized as an element or an object.  It must accept two
arguments: the text string and the information channel.  It is an
appropriate place to protect special chars relative to the
back-end.
</p>

<p>
BODY can start with pre-defined keyword arguments.  The following
keywords are understood:
</p>

<p>
:export-block
</p>

<p>
String, or list of strings, representing block names that
will not be parsed.  This is used to specify blocks that will
contain raw code specific to the back-end.  These blocks
still have to be handled by the relative `export-block' type
translator.
</p>

<p>
:filters-alist
</p>

<p>
Alist between filters and function, or list of functions,
specific to the back-end.  See `org-export-filters-alist' for
a list of all allowed filters.  Filters defined here
shouldn't make a back-end test, as it may prevent back-ends
derived from this one to behave properly.
</p>

<p>
:menu-entry
</p>

<p>
Menu entry for the export dispatcher.  It should be a list
like:
</p>

<p>
'(KEY DESCRIPTION-OR-ORDINAL ACTION-OR-MENU)
</p>

<p>
where :
</p>

<p>
KEY is a free character selecting the back-end.
</p>

<p>
DESCRIPTION-OR-ORDINAL is either a string or a number.
</p>

<p>
If it is a string, is will be used to name the back-end in
its menu entry.  If it is a number, the following menu will
be displayed as a sub-menu of the back-end with the same
KEY.  Also, the number will be used to determine in which
order such sub-menus will appear (lowest first).
</p>

<p>
ACTION-OR-MENU is either a function or an alist.
</p>

<p>
If it is an action, it will be called with four
arguments (booleans): ASYNC, SUBTREEP, VISIBLE-ONLY and
BODY-ONLY.  See `org-export-as' for further explanations on
some of them.
</p>

<p>
If it is an alist, associations should follow the
pattern:
</p>

<p>
'(KEY DESCRIPTION ACTION)
</p>

<p>
where KEY, DESCRIPTION and ACTION are described above.
</p>

<p>
Valid values include:
</p>

<p>
'(?m \"My Special Back-end\" my-special-export-function)
</p>

<p>
or
</p>

<p>
'(?l \"Export to LaTeX\"
     \(?p \"As PDF file\" org-latex-export-to-pdf)
     \(?o \"As PDF file and open\"
         \(lambda (a s v b)
           \(if a (org-latex-export-to-pdf t s v b)
             \(org-open-file
              \(org-latex-export-to-pdf nil s v b)))))))
</p>

<p>
or the following, which will be added to the previous
sub-menu,
</p>

<p>
'(?l 1
    \((?B \"As TEX buffer (Beamer)\" org-beamer-export-as-latex)
     \(?P \"As PDF file (Beamer)\" org-beamer-export-to-pdf)))
</p>

<p>
:options-alist
</p>

<p>
  Alist between back-end specific properties introduced in
  communication channel and how their value are acquired.  See
  `org-export-options-alist' for more information about
  structure of the values."
(declare (indent 1))
(let (blocks filters menu-entry options contents)
  (while (keywordp (car body))
    (case (pop body)
      (:export-block (let ((names (pop body)))
                       (setq blocks (if (consp names) (mapcar 'upcase names)
                                      (list (upcase names))))))
      (:filters-alist (setq filters (pop body)))
      (:menu-entry (setq menu-entry (pop body)))
      (:options-alist (setq options (pop body)))
      (t (pop body))))
  (org-export-register-backend
   (org-export-create-backend :name backend
</p>
<p>
:transcoders transcoders
</p>
<p>
:options options
</p>
<p>
:filters filters
</p>
<p>
:blocks blocks
</p>
<p>
:menu menu-entry))))
</p>

<p>
(defun org-export-define-derived-backend (child parent &amp;rest body)
  "Create a new back-end as a variant of an existing one.
</p>

<p>
CHILD is the name of the derived back-end.  PARENT is the name of
the parent back-end.
</p>

<p>
BODY can start with pre-defined keyword arguments.  The following
keywords are understood:
</p>

<p>
:export-block
</p>

<p>
String, or list of strings, representing block names that
will not be parsed.  This is used to specify blocks that will
contain raw code specific to the back-end.  These blocks
still have to be handled by the relative `export-block' type
translator.
</p>

<p>
:filters-alist
</p>

<p>
Alist of filters that will overwrite or complete filters
defined in PARENT back-end.  See `org-export-filters-alist'
for a list of allowed filters.
</p>

<p>
:menu-entry
</p>

<p>
Menu entry for the export dispatcher.  See
`org-export-define-backend' for more information about the
expected value.
</p>

<p>
:options-alist
</p>

<p>
Alist of back-end specific properties that will overwrite or
complete those defined in PARENT back-end.  Refer to
`org-export-options-alist' for more information about
structure of the values.
</p>

<p>
:translate-alist
</p>

<p>
Alist of element and object types and transcoders that will
overwrite or complete transcode table from PARENT back-end.
Refer to `org-export-define-backend' for detailed information
about transcoders.
</p>

<p>
As an example, here is how one could define \"my-latex\" back-end
as a variant of `latex' back-end with a custom template function:
</p>

<p>
\(org-export-define-derived-backend 'my-latex 'latex
</p>
<p>
:translate-alist '((template . my-latex-template-fun)))
</p>

<p>
The back-end could then be called with, for example:
</p>

<p>
\(org-export-to-buffer 'my-latex \"<b>Test my-latex</b>\")"
(declare (indent 2))
(let (blocks filters menu-entry options transcoders contents)
  (while (keywordp (car body))
    (case (pop body)
      (:export-block (let ((names (pop body)))
                       (setq blocks (if (consp names) (mapcar 'upcase names)
                                      (list (upcase names))))))
      (:filters-alist (setq filters (pop body)))
      (:menu-entry (setq menu-entry (pop body)))
      (:options-alist (setq options (pop body)))
      (:translate-alist (setq transcoders (pop body)))
      (t (pop body))))
  (org-export-register-backend
   (org-export-create-backend :name child
</p>
<p>
:parent parent
</p>
<p>
:transcoders transcoders
</p>
<p>
:options options
</p>
<p>
:filters filters
</p>
<p>
:blocks blocks
</p>
<p>
:menu menu-entry))))
</p>


<p>

;;; The Communication Channel
;;
;; During export process, every function has access to a number of
;; properties.  They are of two types:
;;
;; 1. Environment options are collected once at the very beginning of
;;    the process, out of the original buffer and configuration.
;;    Collecting them is handled by `org-export-get-environment'
;;    function.
;;
;;    Most environment options are defined through the
;;    `org-export-options-alist' variable.
;;
;; 2. Tree properties are extracted directly from the parsed tree,
;;    just before export, by `org-export-collect-tree-properties'.
;;
;; Here is the full list of properties available during transcode
;; process, with their category and their value type.
;;
;; + `:author' :: Author's name.
;;   - category :: option
;;   - type :: string
;;
;; + `:back-end' :: Current back-end used for transcoding.
;;   - category :: tree
;;   - type :: symbol
;;
;; + `:creator' :: String to write as creation information.
;;   - category :: option
;;   - type :: string
;;
;; + `:date' :: String to use as date.
;;   - category :: option
;;   - type :: string
;;
;; + `:description' :: Description text for the current data.
;;   - category :: option
;;   - type :: string
;;
;; + `:email' :: Author's email.
;;   - category :: option
;;   - type :: string
;;
;; + `:exclude-tags' :: Tags for exclusion of subtrees from export
;;      process.
;;   - category :: option
;;   - type :: list of strings
;;
;; + `:export-options' :: List of export options available for current
;;      process.
;;   - category :: none
;;   - type :: list of symbols, among `subtree', `body-only' and
;;      `visible-only'.
;;
;; + `:exported-data' :: Hash table used for memoizing
;;     `org-export-data'.
;;   - category :: tree
;;   - type :: hash table
;;
;; + `:filetags' :: List of global tags for buffer.  Used by
;;   `org-export-get-tags' to get tags with inheritance.
;;   - category :: option
;;   - type :: list of strings
;;
;; + `:footnote-definition-alist' :: Alist between footnote labels and
;;      their definition, as parsed data.  Only non-inlined footnotes
;;      are represented in this alist.  Also, every definition isn't
;;      guaranteed to be referenced in the parse tree.  The purpose of
;;      this property is to preserve definitions from oblivion
;;      (i.e. when the parse tree comes from a part of the original
;;      buffer), it isn't meant for direct use in a back-end.  To
;;      retrieve a definition relative to a reference, use
;;      `org-export-get-footnote-definition' instead.
;;   - category :: option
;;   - type :: alist (STRING . LIST)
;;
;; + `:headline-levels' :: Maximum level being exported as an
;;      headline.  Comparison is done with the relative level of
;;      headlines in the parse tree, not necessarily with their
;;      actual level.
;;   - category :: option
;;   - type :: integer
;;
;; + `:headline-offset' :: Difference between relative and real level
;;      of headlines in the parse tree.  For example, a value of -1
;;      means a level 2 headline should be considered as level
;;      1 (cf. `org-export-get-relative-level').
;;   - category :: tree
;;   - type :: integer
;;
;; + `:headline-numbering' :: Alist between headlines and their
;;      numbering, as a list of numbers
;;      (cf. `org-export-get-headline-number').
;;   - category :: tree
;;   - type :: alist (INTEGER . LIST)
;;
;; + `:id-alist' :: Alist between ID strings and destination file's
;;      path, relative to current directory.  It is used by
;;      `org-export-resolve-id-link' to resolve ID links targeting an
;;      external file.
;;   - category :: option
;;   - type :: alist (STRING . STRING)
;;
;; + `:ignore-list' :: List of elements and objects that should be
;;      ignored during export.
;;   - category :: tree
;;   - type :: list of elements and objects
;;
;; + `:input-file' :: Full path to input file, if any.
;;   - category :: option
;;   - type :: string or nil
;;
;; + `:keywords' :: List of keywords attached to data.
;;   - category :: option
;;   - type :: string
;;
;; + `:language' :: Default language used for translations.
;;   - category :: option
;;   - type :: string
;;
;; + `:parse-tree' :: Whole parse tree, available at any time during
;;      transcoding.
;;   - category :: option
;;   - type :: list (as returned by `org-element-parse-buffer')
;;
;; + `:preserve-breaks' :: Non-nil means transcoding should preserve
;;      all line breaks.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:section-numbers' :: Non-nil means transcoding should add
;;      section numbers to headlines.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:select-tags' :: List of tags enforcing inclusion of sub-trees
;;      in transcoding.  When such a tag is present, subtrees without
;;      it are de facto excluded from the process.  See
;;      `use-select-tags'.
;;   - category :: option
;;   - type :: list of strings
;;
;; + `:time-stamp-file' :: Non-nil means transcoding should insert
;;      a time stamp in the output.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:translate-alist' :: Alist between element and object types and
;;      transcoding functions relative to the current back-end.
;;      Special keys `inner-template', `template' and `plain-text' are
;;      also possible.
;;   - category :: option
;;   - type :: alist (SYMBOL . FUNCTION)
;;
;; + `:with-archived-trees' :: Non-nil when archived subtrees should
;;      also be transcoded.  If it is set to the `headline' symbol,
;;      only the archived headline's name is retained.
;;   - category :: option
;;   - type :: symbol (nil, t, `headline')
;;
;; + `:with-author' :: Non-nil means author's name should be included
;;      in the output.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-clocks' :: Non-nil means clock keywords should be exported.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-creator' :: Non-nil means a creation sentence should be
;;      inserted at the end of the transcoded string.  If the value
;;      is `comment', it should be commented.
;;   - category :: option
;;   - type :: symbol (`comment', nil, t)
;;
;; + `:with-date' :: Non-nil means output should contain a date.
;;   - category :: option
;;   - type :. symbol (nil, t)
;;
;; + `:with-drawers' :: Non-nil means drawers should be exported.  If
;;      its value is a list of names, only drawers with such names
;;      will be transcoded.  If that list starts with `not', drawer
;;      with these names will be skipped.
;;   - category :: option
;;   - type :: symbol (nil, t) or list of strings
;;
;; + `:with-email' :: Non-nil means output should contain author's
;;                   email.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-emphasize' :: Non-nil means emphasized text should be
;;      interpreted.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-fixed-width' :: Non-nil if transcoder should interpret
;;      strings starting with a colon as a fixed-with (verbatim) area.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-footnotes' :: Non-nil if transcoder should interpret
;;      footnotes.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-latex' :: Non-nil means `latex-environment' elements and
;;    `latex-fragment' objects should appear in export output.  When
;;    this property is set to `verbatim', they will be left as-is.
;;   - category :: option
;;   - type :: symbol (`verbatim', nil, t)
;;
;; + `:with-planning' :: Non-nil means transcoding should include
;;      planning info.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-priority' :: Non-nil means transcoding should include
;;      priority cookies.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-smart-quotes' :: Non-nil means activate smart quotes in
;;      plain text.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-special-strings' :: Non-nil means transcoding should
;;      interpret special strings in plain text.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-sub-superscript' :: Non-nil means transcoding should
;;      interpret subscript and superscript.  With a value of "{}",
;;      only interpret those using curly brackets.
;;   - category :: option
;;   - type :: symbol (nil, {}, t)
;;
;; + `:with-tables' :: Non-nil means transcoding should interpret
;;      tables.
;;   - category :: option
;;   - type :: symbol (nil, t)
;;
;; + `:with-tags' :: Non-nil means transcoding should keep tags in
;;      headlines.  A `not-in-toc' value will remove them from the
;;      table of contents, if any, nonetheless.
;;   - category :: option
;;   - type :: symbol (nil, t, `not-in-toc')
;;
;; + `:with-tasks' :: Non-nil means transcoding should include
;;      headlines with a TODO keyword.  A `todo' value will only
;;      include headlines with a todo type keyword while a `done'
;;      value will do the contrary.  If a list of strings is provided,
;;      only tasks with keywords belonging to that list will be kept.
;;   - category :: option
;;   - type :: symbol (t, todo, done, nil) or list of strings
;;
;; + `:with-timestamps' :: Non-nil means transcoding should include
;;      time stamps.  Special value `active' (resp. `inactive') ask to
;;      export only active (resp. inactive) timestamps.  Otherwise,
;;      completely remove them.
;;   - category :: option
;;   - type :: symbol: (`active', `inactive', t, nil)
;;
;; + `:with-toc' :: Non-nil means that a table of contents has to be
;;      added to the output.  An integer value limits its depth.
;;   - category :: option
;;   - type :: symbol (nil, t or integer)
;;
;; + `:with-todo-keywords' :: Non-nil means transcoding should
;;      include TODO keywords.
;;   - category :: option
;;   - type :: symbol (nil, t)
</p>


<p>
;;;; Environment Options
;;
;; Environment options encompass all parameters defined outside the
;; scope of the parsed data.  They come from five sources, in
;; increasing precedence order:
;;
;; - Global variables,
;; - Buffer's attributes,
;; - Options keyword symbols,
;; - Buffer keywords,
;; - Subtree properties.
;;
;; The central internal function with regards to environment options
;; is `org-export-get-environment'.  It updates global variables with
;; "#+BIND:" keywords, then retrieve and prioritize properties from
;; the different sources.
;;
;;  The internal functions doing the retrieval are:
;;  `org-export&#x2013;get-global-options',
;;  `org-export&#x2013;get-buffer-attributes',
;;  `org-export&#x2013;parse-option-keyword',
;;  `org-export&#x2013;get-subtree-options' and
;;  `org-export&#x2013;get-inbuffer-options'
;;
;; Also, `org-export&#x2013;list-bound-variables' collects bound variables
;; along with their value in order to set them as buffer local
;; variables later in the process.
</p>

<p>
(defun org-export-get-environment (&amp;optional backend subtreep ext-plist)
  "Collect export options from the current buffer.
</p>

<p>
Optional argument BACKEND is an export back-end, as returned by
`org-export-create-backend'.
</p>

<p>
When optional argument SUBTREEP is non-nil, assume the export is
done against the current sub-tree.
</p>

<p>
Third optional argument EXT-PLIST is a property list with
external parameters overriding Org default settings, but still
inferior to file-local settings."
  ;; First install #+BIND variables since these must be set before
  ;; global options are read.
  (dolist (pair (org-export&#x2013;list-bound-variables))
    (org-set-local (car pair) (nth 1 pair)))
  ;; Get and prioritize export options&#x2026;
  (org-combine-plists
   ;; &#x2026; from global variables&#x2026;
   (org-export&#x2013;get-global-options backend)
   ;; &#x2026; from an external property list&#x2026;
   ext-plist
   ;; &#x2026; from in-buffer settings&#x2026;
   (org-export&#x2013;get-inbuffer-options backend)
   ;; &#x2026; and from subtree, when appropriate.
   (and subtreep (org-export&#x2013;get-subtree-options backend))
   ;; Eventually add misc. properties.
   (list
</p>
<p>
:back-end
backend
</p>
<p>
:translate-alist (org-export-get-all-transcoders backend)
</p>
<p>
:footnote-definition-alist
;; Footnotes definitions must be collected in the original
;; buffer, as there's no insurance that they will still be in
;; the parse tree, due to possible narrowing.
(let (alist)
  (org-with-wide-buffer
   (goto-char (point-min))
   (while (re-search-forward org-footnote-definition-re nil t)
     (let ((def (save-match-data (org-element-at-point))))
       (when (eq (org-element-type def) 'footnote-definition)
         (push
          (cons (org-element-property :label def)
                (let ((cbeg (org-element-property :contents-begin def)))
                  (when cbeg
                    (org-element&#x2013;parse-elements
                     cbeg (org-element-property :contents-end def)
                     nil nil nil nil (list 'org-data nil)))))
          alist))))
   alist))
</p>
<p>
:id-alist
;; Collect id references.
(let (alist)
  (org-with-wide-buffer
   (goto-char (point-min))
   (while (re-search-forward "\\[\\[id:\\S-+?\\]" nil t)
     (let ((link (org-element-context)))
       (when (eq (org-element-type link) 'link)
         (let* ((id (org-element-property :path link))
                (file (org-id-find-id-file id)))
           (when file
             (push (cons id (file-relative-name file)) alist)))))))
  alist))))
</p>

<p>
(defun org-export&#x2013;parse-option-keyword (options &amp;optional backend)
  "Parse an OPTIONS line and return values as a plist.
Optional argument BACKEND is an export back-end, as returned by,
e.g., `org-export-create-backend'.  It specifies which back-end
specific items to read, if any."
  (let* ((all
          ;; Priority is given to back-end specific options.
          (append (and backend (org-export-get-all-options backend))
                  org-export-options-alist))
         plist)
    (dolist (option all)
      (let ((property (car option))
            (item (nth 2 option)))
        (when (and item
                   (not (plist-member plist property))
                   (string-match (concat "\\(\\`\\|[ \t]\\)"
                                         (regexp-quote item)
                                         ":\\(([^)\n]+)\\|[^ \t\n\r;,.]*\\)")
                                 options))
          (setq plist (plist-put plist
                                 property
                                 (car (read-from-string
                                       (match-string 2 options))))))))
    plist))
</p>

<p>
(defun org-export&#x2013;get-subtree-options (&amp;optional backend)
  "Get export options in subtree at point.
Optional argument BACKEND is an export back-end, as returned by,
e.g., `org-export-create-backend'.  It specifies back-end used
for export.  Return options as a plist."
  ;; For each buffer keyword, create a headline property setting the
  ;; same property in communication channel. The name for the property
  ;; is the keyword with "EXPORT_" appended to it.
  (org-with-wide-buffer
   (let (prop plist)
     ;; Make sure point is at a heading.
     (if (org-at-heading-p) (org-up-heading-safe) (org-back-to-heading t))
     ;; Take care of EXPORT<sub>TITLE</sub>. If it isn't defined, use headline's
     ;; title (with no todo keyword, priority cookie or tag) as its
     ;; fallback value.
     (when (setq prop (or (org-entry-get (point) "EXPORT<sub>TITLE</sub>")
                          (progn (looking-at org-complex-heading-regexp)
                                 (org-match-string-no-properties 4))))
       (setq plist
             (plist-put
              plist :title
              (org-element-parse-secondary-string
               prop (org-element-restriction 'keyword)))))
     ;; EXPORT<sub>OPTIONS</sub> are parsed in a non-standard way.
     (when (setq prop (org-entry-get (point) "EXPORT<sub>OPTIONS</sub>"))
       (setq plist
             (nconc plist (org-export&#x2013;parse-option-keyword prop backend))))
     ;; Handle other keywords.  TITLE keyword is excluded as it has
     ;; been handled already.
     (let ((seen '("TITLE")))
       (mapc
        (lambda (option)
          (let ((property (car option))
                (keyword (nth 1 option)))
            (when (and keyword (not (member keyword seen)))
              (let* ((subtree-prop (concat "EXPORT_" keyword))
                     ;; Export properties are not case-sensitive.
                     (value (let ((case-fold-search t))
                              (org-entry-get (point) subtree-prop))))
                (push keyword seen)
                (when (and value (not (plist-member plist property)))
                  (setq plist
                        (plist-put
                         plist
                         property
                         (cond
                          ;; Parse VALUE if required.
                          ((member keyword org-element-document-properties)
                           (org-element-parse-secondary-string
                            value (org-element-restriction 'keyword)))
                          ;; If BEHAVIOR is `split' expected value is
                          ;; a list of strings, not a string.
                          ((eq (nth 4 option) 'split) (org-split-string value))
                          (t value)))))))))
        ;; Look for both general keywords and back-end specific
        ;; options, with priority given to the latter.
        (append (and backend (org-export-get-all-options backend))
                org-export-options-alist)))
     ;; Return value.
     plist)))
</p>

<p>
(defun org-export&#x2013;get-inbuffer-options (&amp;optional backend)
  "Return current buffer export options, as a plist.
</p>

<p>
Optional argument BACKEND, when non-nil, is an export back-end,
as returned by, e.g., `org-export-create-backend'.  It specifies
which back-end specific options should also be read in the
process.
</p>

<p>
Assume buffer is in Org mode.  Narrowing, if any, is ignored."
  (let* (plist
         get-options                        ; For byte-compiler.
         (case-fold-search t)
         (options (append
                   ;; Priority is given to back-end specific options.
                   (and backend (org-export-get-all-options backend))
                   org-export-options-alist))
         (regexp (format "<sup>[</sup> \t]*#\\+%s:"
                         (regexp-opt (nconc (delq nil (mapcar 'cadr options))
                                            org-export-special-keywords))))
         (find-properties
          (lambda (keyword)
            ;; Return all properties associated to KEYWORD.
            (let (properties)
              (dolist (option options properties)
                (when (equal (nth 1 option) keyword)
                  (pushnew (car option) properties))))))
         (get-options
          (lambda (&amp;optional files plist)
            ;; Recursively read keywords in buffer.  FILES is a list
            ;; of files read so far.  PLIST is the current property
            ;; list obtained.
            (org-with-wide-buffer
             (goto-char (point-min))
             (while (re-search-forward regexp nil t)
               (let ((element (org-element-at-point)))
                 (when (eq (org-element-type element) 'keyword)
                   (let ((key (org-element-property :key element))
                         (val (org-element-property :value element)))
                     (cond
                      ;; Options in `org-export-special-keywords'.
                      ((equal key "SETUPFILE")
                       (let ((file (expand-file-name
                                    (org-remove-double-quotes (org-trim val)))))
                         ;; Avoid circular dependencies.
                         (unless (member file files)
                           (with-temp-buffer
                             (insert (org-file-contents file 'noerror))
                             (let ((org-inhibit-startup t)) (org-mode))
                             (setq plist (funcall get-options
                                                  (cons file files) plist))))))
                      ((equal key "OPTIONS")
                       (setq plist
                             (org-combine-plists
                              plist
                              (org-export&#x2013;parse-option-keyword val backend))))
                      ((equal key "FILETAGS")
                       (setq plist
                             (org-combine-plists
                              plist
                              (list :filetags
                                    (org-uniquify
                                     (append (org-split-string val ":")
                                             (plist-get plist :filetags)))))))
                      (t
                       ;; Options in `org-export-options-alist'.
                       (dolist (property (funcall find-properties key))
                         (let ((behaviour (nth 4 (assq property options))))
                           (setq plist
                                 (plist-put
                                  plist property
                                  ;; Handle value depending on specified
                                  ;; BEHAVIOR.
                                  (case behaviour
                                    (space
                                     (if (not (plist-get plist property))
                                         (org-trim val)
                                       (concat (plist-get plist property)
                                               " "
                                               (org-trim val))))
                                    (newline
                                     (org-trim
                                      (concat (plist-get plist property)
                                              "\n"
                                              (org-trim val))))
                                    (split `(,@(plist-get plist property)
                                             ,@(org-split-string val)))
                                    ('t val)
                                    (otherwise
                                     (if (not (plist-member plist property)) val
                                       (plist-get plist property))))))))))))))
             ;; Return final value.
             plist))))
    ;; Read options in the current buffer.
    (setq plist (funcall get-options
                         (and buffer-file-name (list buffer-file-name)) nil))
    ;; Parse keywords specified in `org-element-document-properties'
    ;; and return PLIST.
    (dolist (keyword org-element-document-properties plist)
      (dolist (property (funcall find-properties keyword))
        (let ((value (plist-get plist property)))
          (when (stringp value)
            (setq plist
                  (plist-put plist property
                             (org-element-parse-secondary-string
                              value (org-element-restriction 'keyword))))))))))
</p>

<p>
(defun org-export&#x2013;get-buffer-attributes ()
  "Return properties related to buffer attributes, as a plist."
  ;; Store full path of input file name, or nil.  For internal use.
  (let ((visited-file (buffer-file-name (buffer-base-buffer))))
    (list :input-file visited-file
</p>
<p>
:title (if (not visited-file) (buffer-name (buffer-base-buffer))
         (file-name-sans-extension
          (file-name-nondirectory visited-file))))))
</p>

<p>
(defun org-export&#x2013;get-global-options (&amp;optional backend)
  "Return global export options as a plist.
Optional argument BACKEND, if non-nil, is an export back-end, as
returned by, e.g., `org-export-create-backend'.  It specifies
which back-end specific export options should also be read in the
process."
  (let (plist
        ;; Priority is given to back-end specific options.
        (all (append (and backend (org-export-get-all-options backend))
                     org-export-options-alist)))
    (dolist (cell all plist)
      (let ((prop (car cell))
            (default-value (nth 3 cell)))
        (unless (or (not default-value) (plist-member plist prop))
          (setq plist
                (plist-put
                 plist
                 prop
                 ;; Eval default value provided.  If keyword is
                 ;; a member of `org-element-document-properties',
                 ;; parse it as a secondary string before storing it.
                 (let ((value (eval (nth 3 cell))))
                   (if (not (stringp value)) value
                     (let ((keyword (nth 1 cell)))
                       (if (member keyword org-element-document-properties)
                           (org-element-parse-secondary-string
                            value (org-element-restriction 'keyword))
                         value)))))))))))
</p>

<p>
(defun org-export&#x2013;list-bound-variables ()
  "Return variables bound from BIND keywords in current buffer.
Also look for BIND keywords in setup files.  The return value is
an alist where associations are (VARIABLE-NAME VALUE)."
  (when org-export-allow-bind-keywords
    (let* (collect-bind                        ; For byte-compiler.
           (collect-bind
            (lambda (files alist)
              ;; Return an alist between variable names and their
              ;; value.  FILES is a list of setup files names read so
              ;; far, used to avoid circular dependencies.  ALIST is
              ;; the alist collected so far.
              (let ((case-fold-search t))
                (org-with-wide-buffer
                 (goto-char (point-min))
                 (while (re-search-forward
                         "<sup>[</sup> \t]*#\\+\\(BIND\\|SETUPFILE\\):" nil t)
                   (let ((element (org-element-at-point)))
                     (when (eq (org-element-type element) 'keyword)
                       (let ((val (org-element-property :value element)))
                         (if (equal (org-element-property :key element) "BIND")
                             (push (read (format "(%s)" val)) alist)
                           ;; Enter setup file.
                           (let ((file (expand-file-name
                                        (org-remove-double-quotes val))))
                             (unless (member file files)
                               (with-temp-buffer
                                 (let ((org-inhibit-startup t)) (org-mode))
                                 (insert (org-file-contents file 'noerror))
                                 (setq alist
                                       (funcall collect-bind
                                                (cons file files)
                                                alist))))))))))
                 alist)))))
      ;; Return value in appropriate order of appearance.
      (nreverse (funcall collect-bind nil nil)))))
</p>


<p>
;;;; Tree Properties
;;
;; Tree properties are information extracted from parse tree.  They
;; are initialized at the beginning of the transcoding process by
;; `org-export-collect-tree-properties'.
;;
;; Dedicated functions focus on computing the value of specific tree
;; properties during initialization.  Thus,
;; `org-export&#x2013;populate-ignore-list' lists elements and objects that
;; should be skipped during export, `org-export&#x2013;get-min-level' gets
;; the minimal exportable level, used as a basis to compute relative
;; level for headlines.  Eventually
;; `org-export&#x2013;collect-headline-numbering' builds an alist between
;; headlines and their numbering.
</p>

<p>
(defun org-export-collect-tree-properties (data info)
  "Extract tree properties from parse tree.
</p>

<p>
DATA is the parse tree from which information is retrieved.  INFO
is a list holding export options.
</p>

<p>
Following tree properties are set or updated:
</p>

<p>
`:exported-data' Hash table used to memoize results from
                 `org-export-data'.
</p>

<p>
`:footnote-definition-alist' List of footnotes definitions in
                   original buffer and current parse tree.
</p>

<p>
`:headline-offset' Offset between true level of headlines and
                   local level.  An offset of -1 means a headline
                   of level 2 should be considered as a level
                   1 headline in the context.
</p>

<p>
`:headline-numbering' Alist of all headlines as key an the
                      associated numbering as value.
</p>

<p>
`:ignore-list'     List of elements that should be ignored during
                   export.
</p>

<p>
Return updated plist."
  ;; Install the parse tree in the communication channel, in order to
  ;; use `org-export-get-genealogy' and al.
  (setq info (plist-put info :parse-tree data))
  ;; Get the list of elements and objects to ignore, and put it into
  ;; `:ignore-list'.  Do not overwrite any user ignore that might have
  ;; been done during parse tree filtering.
  (setq info
        (plist-put info
</p>
<p>
                 :ignore-list
                 (append (org-export&#x2013;populate-ignore-list data info)
                         (plist-get info :ignore-list))))
;; Compute `:headline-offset' in order to be able to use
;; `org-export-get-relative-level'.
(setq info
      (plist-put info
</p>
<p>
                 :headline-offset
                 (- 1 (org-export&#x2013;get-min-level data info))))
;; Update footnotes definitions list with definitions in parse tree.
;; This is required since buffer expansion might have modified
;; boundaries of footnote definitions contained in the parse tree.
;; This way, definitions in `footnote-definition-alist' are bound to
;; match those in the parse tree.
(let ((defs (plist-get info :footnote-definition-alist)))
  (org-element-map data 'footnote-definition
    (lambda (fn)
      (push (cons (org-element-property :label fn)
                  `(org-data nil ,@(org-element-contents fn)))
            defs)))
  (setq info (plist-put info :footnote-definition-alist defs)))
;; Properties order doesn't matter: get the rest of the tree
;; properties.
(nconc
 `(:headline-numbering ,(org-export&#x2013;collect-headline-numbering data info)
</p>
<p>
  :exported-data ,(make-hash-table :test 'eq :size 4001))
info))
</p>

<p>
(defun org-export&#x2013;get-min-level (data options)
  "Return minimum exportable headline's level in DATA.
DATA is parsed tree as returned by `org-element-parse-buffer'.
OPTIONS is a plist holding export options."
  (catch 'exit
    (let ((min-level 10000))
      (mapc
       (lambda (blob)
         (when (and (eq (org-element-type blob) 'headline)
                    (not (org-element-property :footnote-section-p blob))
                    (not (memq blob (plist-get options :ignore-list))))
           (setq min-level (min (org-element-property :level blob) min-level)))
         (when (= min-level 1) (throw 'exit 1)))
       (org-element-contents data))
      ;; If no headline was found, for the sake of consistency, set
      ;; minimum level to 1 nonetheless.
      (if (= min-level 10000) 1 min-level))))
</p>

<p>
(defun org-export&#x2013;collect-headline-numbering (data options)
  "Return numbering of all exportable headlines in a parse tree.
</p>

<p>
DATA is the parse tree.  OPTIONS is the plist holding export
options.
</p>

<p>
Return an alist whose key is a headline and value is its
associated numbering \(in the shape of a list of numbers\) or nil
for a footnotes section."
  (let ((numbering (make-vector org-export-max-depth 0)))
    (org-element-map data 'headline
      (lambda (headline)
        (unless (org-element-property :footnote-section-p headline)
          (let ((relative-level
                 (1- (org-export-get-relative-level headline options))))
            (cons
             headline
             (loop for n across numbering
                   for idx from 0 to org-export-max-depth
                   when (&lt; idx relative-level) collect n
                   when (= idx relative-level) collect (aset numbering idx (1+ n))
                   when (&gt; idx relative-level) do (aset numbering idx 0))))))
      options)))
</p>

<p>
(defun org-export&#x2013;populate-ignore-list (data options)
  "Return list of elements and objects to ignore during export.
DATA is the parse tree to traverse.  OPTIONS is the plist holding
export options."
  (let* (ignore
         walk-data
         ;; First find trees containing a select tag, if any.
         (selected (org-export&#x2013;selected-trees data options))
         (walk-data
          (lambda (data)
            ;; Collect ignored elements or objects into IGNORE-LIST.
            (let ((type (org-element-type data)))
              (if (org-export&#x2013;skip-p data options selected) (push data ignore)
                (if (and (eq type 'headline)
                         (eq (plist-get options :with-archived-trees) 'headline)
                         (org-element-property :archivedp data))
                    ;; If headline is archived but tree below has
                    ;; to be skipped, add it to ignore list.
                    (mapc (lambda (e) (push e ignore))
                          (org-element-contents data))
                  ;; Move into secondary string, if any.
                  (let ((sec-prop
                         (cdr (assq type org-element-secondary-value-alist))))
                    (when sec-prop
                      (mapc walk-data (org-element-property sec-prop data))))
                  ;; Move into recursive objects/elements.
                  (mapc walk-data (org-element-contents data))))))))
    ;; Main call.
    (funcall walk-data data)
    ;; Return value.
    ignore))
</p>

<p>
(defun org-export&#x2013;selected-trees (data info)
  "Return list of headlines and inlinetasks with a select tag in their tree.
DATA is parsed data as returned by `org-element-parse-buffer'.
INFO is a plist holding export options."
  (let* (selected-trees
         walk-data                        ; For byte-compiler.
         (walk-data
          (function
           (lambda (data genealogy)
             (let ((type (org-element-type data)))
               (cond
                ((memq type '(headline inlinetask))
                 (let ((tags (org-element-property :tags data)))
                   (if (loop for tag in (plist-get info :select-tags)
                             thereis (member tag tags))
                       ;; When a select tag is found, mark full
                       ;; genealogy and every headline within the tree
                       ;; as acceptable.
                       (setq selected-trees
                             (append
                              genealogy
                              (org-element-map data '(headline inlinetask)
                                'identity)
                              selected-trees))
                     ;; If at a headline, continue searching in tree,
                     ;; recursively.
                     (when (eq type 'headline)
                       (mapc (lambda (el)
                               (funcall walk-data el (cons data genealogy)))
                             (org-element-contents data))))))
                ((or (eq type 'org-data)
                     (memq type org-element-greater-elements))
                 (mapc (lambda (el) (funcall walk-data el genealogy))
                       (org-element-contents data)))))))))
    (funcall walk-data data nil)
    selected-trees))
</p>

<p>
(defun org-export&#x2013;skip-p (blob options selected)
  "Non-nil when element or object BLOB should be skipped during export.
OPTIONS is the plist holding export options.  SELECTED, when
non-nil, is a list of headlines or inlinetasks belonging to
a tree with a select tag."
  (case (org-element-type blob)
    (clock (not (plist-get options :with-clocks)))
    (drawer
     (let ((with-drawers-p (plist-get options :with-drawers)))
       (or (not with-drawers-p)
           (and (consp with-drawers-p)
                ;; If `:with-drawers' value starts with `not', ignore
                ;; every drawer whose name belong to that list.
                ;; Otherwise, ignore drawers whose name isn't in that
                ;; list.
                (let ((name (org-element-property :drawer-name blob)))
                  (if (eq (car with-drawers-p) 'not)
                      (member-ignore-case name (cdr with-drawers-p))
                    (not (member-ignore-case name with-drawers-p))))))))
    ((footnote-definition footnote-reference)
     (not (plist-get options :with-footnotes)))
    ((headline inlinetask)
     (let ((with-tasks (plist-get options :with-tasks))
           (todo (org-element-property :todo-keyword blob))
           (todo-type (org-element-property :todo-type blob))
           (archived (plist-get options :with-archived-trees))
           (tags (org-element-property :tags blob)))
       (or
        (and (eq (org-element-type blob) 'inlinetask)
             (not (plist-get options :with-inlinetasks)))
        ;; Ignore subtrees with an exclude tag.
        (loop for k in (plist-get options :exclude-tags)
              thereis (member k tags))
        ;; When a select tag is present in the buffer, ignore any tree
        ;; without it.
        (and selected (not (memq blob selected)))
        ;; Ignore commented sub-trees.
        (org-element-property :commentedp blob)
        ;; Ignore archived subtrees if `:with-archived-trees' is nil.
        (and (not archived) (org-element-property :archivedp blob))
        ;; Ignore tasks, if specified by `:with-tasks' property.
        (and todo
             (or (not with-tasks)
                 (and (memq with-tasks '(todo done))
                      (not (eq todo-type with-tasks)))
                 (and (consp with-tasks) (not (member todo with-tasks))))))))
    ((latex-environment latex-fragment) (not (plist-get options :with-latex)))
    (planning (not (plist-get options :with-planning)))
    (statistics-cookie (not (plist-get options :with-statistics-cookies)))
    (table-cell
     (and (org-export-table-has-special-column-p
           (org-export-get-parent-table blob))
          (not (org-export-get-previous-element blob options))))
    (table-row (org-export-table-row-is-special-p blob options))
    (timestamp
     ;; `:with-timestamps' only applies to isolated timestamps
     ;; objects, i.e. timestamp objects in a paragraph containing only
     ;; timestamps and whitespaces.
     (when (let ((parent (org-export-get-parent-element blob)))
             (and (memq (org-element-type parent) '(paragraph verse-block))
                  (not (org-element-map parent
                           (cons 'plain-text
                                 (remq 'timestamp org-element-all-objects))
                         (lambda (obj)
                           (or (not (stringp obj)) (org-string-nw-p obj)))
                         options t))))
       (case (plist-get options :with-timestamps)
         ('nil t)
         (active
          (not (memq (org-element-property :type blob) '(active active-range))))
         (inactive
          (not (memq (org-element-property :type blob)
                     '(inactive inactive-range)))))))))
</p>

<p>

;;; The Transcoder
;;
;; `org-export-data' reads a parse tree (obtained with, i.e.
;; `org-element-parse-buffer') and transcodes it into a specified
;; back-end output.  It takes care of filtering out elements or
;; objects according to export options and organizing the output blank
;; lines and white space are preserved.  The function memoizes its
;; results, so it is cheap to call it within transcoders.
;;
;; It is possible to modify locally the back-end used by
;; `org-export-data' or even use a temporary back-end by using
;; `org-export-data-with-backend'.
;;
;; Internally, three functions handle the filtering of objects and
;; elements during the export.  In particular,
;; `org-export-ignore-element' marks an element or object so future
;; parse tree traversals skip it, `org-export&#x2013;interpret-p' tells which
;; elements or objects should be seen as real Org syntax and
;; `org-export-expand' transforms the others back into their original
;; shape
;;
;; `org-export-transcoder' is an accessor returning appropriate
;; translator function for a given element or object.
</p>

<p>
(defun org-export-transcoder (blob info)
  "Return appropriate transcoder for BLOB.
INFO is a plist containing export directives."
  (let ((type (org-element-type blob)))
    ;; Return contents only for complete parse trees.
    (if (eq type 'org-data) (lambda (blob contents info) contents)
      (let ((transcoder (cdr (assq type (plist-get info :translate-alist)))))
        (and (functionp transcoder) transcoder)))))
</p>

<p>
(defun org-export-data (data info)
  "Convert DATA into current back-end format.
</p>

<p>
DATA is a parse tree, an element or an object or a secondary
string.  INFO is a plist holding export options.
</p>

<p>
Return a string."
  (or (gethash data (plist-get info :exported-data))
      (let* ((type (org-element-type data))
             (results
              (cond
               ;; Ignored element/object.
               ((memq data (plist-get info :ignore-list)) nil)
               ;; Plain text.
               ((eq type 'plain-text)
                (org-export-filter-apply-functions
                 (plist-get info :filter-plain-text)
                 (let ((transcoder (org-export-transcoder data info)))
                   (if transcoder (funcall transcoder data info) data))
                 info))
               ;; Uninterpreted element/object: change it back to Org
               ;; syntax and export again resulting raw string.
               ((not (org-export&#x2013;interpret-p data info))
                (org-export-data
                 (org-export-expand
                  data
                  (mapconcat (lambda (blob) (org-export-data blob info))
                             (org-element-contents data)
                             ""))
                 info))
               ;; Secondary string.
               ((not type)
                (mapconcat (lambda (obj) (org-export-data obj info)) data ""))
               ;; Element/Object without contents or, as a special
               ;; case, headline with archive tag and archived trees
               ;; restricted to title only.
               ((or (not (org-element-contents data))
                    (and (eq type 'headline)
                         (eq (plist-get info :with-archived-trees) 'headline)
                         (org-element-property :archivedp data)))
                (let ((transcoder (org-export-transcoder data info)))
                  (or (and (functionp transcoder)
                           (funcall transcoder data nil info))
                      ;; Export snippets never return a nil value so
                      ;; that white spaces following them are never
                      ;; ignored.
                      (and (eq type 'export-snippet) ""))))
               ;; Element/Object with contents.
               (t
                (let ((transcoder (org-export-transcoder data info)))
                  (when transcoder
                    (let* ((greaterp (memq type org-element-greater-elements))
                           (objectp
                            (and (not greaterp)
                                 (memq type org-element-recursive-objects)))
                           (contents
                            (mapconcat
                             (lambda (element) (org-export-data element info))
                             (org-element-contents
                              (if (or greaterp objectp) data
                                ;; Elements directly containing
                                ;; objects must have their indentation
                                ;; normalized first.
                                (org-element-normalize-contents
                                 data
                                 ;; When normalizing contents of the
                                 ;; first paragraph in an item or
                                 ;; a footnote definition, ignore
                                 ;; first line's indentation: there is
                                 ;; none and it might be misleading.
                                 (when (eq type 'paragraph)
                                   (let ((parent (org-export-get-parent data)))
                                     (and
                                      (eq (car (org-element-contents parent))
                                          data)
                                      (memq (org-element-type parent)
                                            '(footnote-definition item))))))))
                             "")))
                      (funcall transcoder data
                               (if (not greaterp) contents
                                 (org-element-normalize-string contents))
                               info))))))))
        ;; Final result will be memoized before being returned.
        (puthash
         data
         (cond
          ((not results) "")
          ((memq type '(org-data plain-text nil)) results)
          ;; Append the same white space between elements or objects
          ;; as in the original buffer, and call appropriate filters.
          (t
           (let ((results
                  (org-export-filter-apply-functions
                   (plist-get info (intern (format ":filter-%s" type)))
                   (let ((post-blank (or (org-element-property :post-blank data)
                                         0)))
                     (if (memq type org-element-all-elements)
                         (concat (org-element-normalize-string results)
                                 (make-string post-blank ?\n))
                       (concat results (make-string post-blank ?\s))))
                   info)))
             results)))
         (plist-get info :exported-data)))))
</p>

<p>
(defun org-export-data-with-backend (data backend info)
  "Convert DATA into BACKEND format.
</p>

<p>
DATA is an element, an object, a secondary string or a string.
BACKEND is a symbol.  INFO is a plist used as a communication
channel.
</p>

<p>
Unlike to `org-export-with-backend', this function will
recursively convert DATA using BACKEND translation table."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (org-export-data
   data
   ;; Set-up a new communication channel with translations defined in
   ;; BACKEND as the translate table and a new hash table for
   ;; memoization.
   (org-combine-plists
    info
    (list :back-end backend
</p>
<p>
:translate-alist (org-export-get-all-transcoders backend)
;; Size of the hash table is reduced since this function
;; will probably be used on small trees.
</p>
<p>
:exported-data (make-hash-table :test 'eq :size 401)))))
</p>

<p>
(defun org-export&#x2013;interpret-p (blob info)
  "Non-nil if element or object BLOB should be interpreted during export.
If nil, BLOB will appear as raw Org syntax.  Check is done
according to export options INFO, stored as a plist."
  (case (org-element-type blob)
    ;; &#x2026; entities&#x2026;
    (entity (plist-get info :with-entities))
    ;; &#x2026; emphasis&#x2026;
    ((bold italic strike-through underline)
     (plist-get info :with-emphasize))
    ;; &#x2026; fixed-width areas.
    (fixed-width (plist-get info :with-fixed-width))
    ;; &#x2026; LaTeX environments and fragments&#x2026;
    ((latex-environment latex-fragment)
     (let ((with-latex-p (plist-get info :with-latex)))
       (and with-latex-p (not (eq with-latex-p 'verbatim)))))
    ;; &#x2026; sub/superscripts&#x2026;
    ((subscript superscript)
     (let ((sub/super-p (plist-get info :with-sub-superscript)))
       (if (eq sub/super-p '{})
           (org-element-property :use-brackets-p blob)
         sub/super-p)))
    ;; &#x2026; tables&#x2026;
    (table (plist-get info :with-tables))
    (otherwise t)))
</p>

<p>
(defun org-export-expand (blob contents &amp;optional with-affiliated)
  "Expand a parsed element or object to its original state.
</p>

<p>
BLOB is either an element or an object.  CONTENTS is its
contents, as a string or nil.
</p>

<p>
When optional argument WITH-AFFILIATED is non-nil, add affiliated
keywords before output."
  (let ((type (org-element-type blob)))
    (concat (and with-affiliated (memq type org-element-all-elements)
                 (org-element&#x2013;interpret-affiliated-keywords blob))
            (funcall (intern (format "org-element-%s-interpreter" type))
                     blob contents))))
</p>

<p>
(defun org-export-ignore-element (element info)
  "Add ELEMENT to `:ignore-list' in INFO.
</p>

<p>
Any element in `:ignore-list' will be skipped when using
`org-element-map'.  INFO is modified by side effects."
  (plist-put info :ignore-list (cons element (plist-get info :ignore-list))))
</p>


<p>

;;; The Filter System
;;
;; Filters allow end-users to tweak easily the transcoded output.
;; They are the functional counterpart of hooks, as every filter in
;; a set is applied to the return value of the previous one.
;;
;; Every set is back-end agnostic.  Although, a filter is always
;; called, in addition to the string it applies to, with the back-end
;; used as argument, so it's easy for the end-user to add back-end
;; specific filters in the set.  The communication channel, as
;; a plist, is required as the third argument.
;;
;; From the developer side, filters sets can be installed in the
;; process with the help of `org-export-define-backend', which
;; internally stores filters as an alist.  Each association has a key
;; among the following symbols and a function or a list of functions
;; as value.
;;
;; - `:filter-options' applies to the property list containing export
;;   options.  Unlike to other filters, functions in this list accept
;;   two arguments instead of three: the property list containing
;;   export options and the back-end.  Users can set its value through
;;   `org-export-filter-options-functions' variable.
;;
;; - `:filter-parse-tree' applies directly to the complete parsed
;;   tree.  Users can set it through
;;   `org-export-filter-parse-tree-functions' variable.
;;
;; - `:filter-final-output' applies to the final transcoded string.
;;   Users can set it with `org-export-filter-final-output-functions'
;;   variable
;;
;; - `:filter-plain-text' applies to any string not recognized as Org
;;   syntax.  `org-export-filter-plain-text-functions' allows users to
;;   configure it.
;;
;; - `:filter-TYPE' applies on the string returned after an element or
;;   object of type TYPE has been transcoded.  A user can modify
;;   `org-export-filter-TYPE-functions'
;;
;; All filters sets are applied with
;; `org-export-filter-apply-functions' function.  Filters in a set are
;; applied in a LIFO fashion.  It allows developers to be sure that
;; their filters will be applied first.
;;
;; Filters properties are installed in communication channel with
;; `org-export-install-filters' function.
;;
;; Eventually, two hooks (`org-export-before-processing-hook' and
;; `org-export-before-parsing-hook') are run at the beginning of the
;; export process and just before parsing to allow for heavy structure
;; modifications.
</p>


<p>
;;;; Hooks
</p>

<p>
(defvar org-export-before-processing-hook nil
  "Hook run at the beginning of the export process.
</p>

<p>
This is run before include keywords and macros are expanded and
Babel code blocks executed, on a copy of the original buffer
being exported.  Visibility and narrowing are preserved.  Point
is at the beginning of the buffer.
</p>

<p>
Every function in this hook will be called with one argument: the
back-end currently used, as a symbol.")
</p>

<p>
(defvar org-export-before-parsing-hook nil
  "Hook run before parsing an export buffer.
</p>

<p>
This is run after include keywords and macros have been expanded
and Babel code blocks executed, on a copy of the original buffer
being exported.  Visibility and narrowing are preserved.  Point
is at the beginning of the buffer.
</p>

<p>
Every function in this hook will be called with one argument: the
back-end currently used, as a symbol.")
</p>


<p>
;;;; Special Filters
</p>

<p>
(defvar org-export-filter-options-functions nil
  "List of functions applied to the export options.
Each filter is called with two arguments: the export options, as
a plist, and the back-end, as a symbol.  It must return
a property list containing export options.")
</p>

<p>
(defvar org-export-filter-parse-tree-functions nil
  "List of functions applied to the parsed tree.
Each filter is called with three arguments: the parse tree, as
returned by `org-element-parse-buffer', the back-end, as
a symbol, and the communication channel, as a plist.  It must
return the modified parse tree to transcode.")
</p>

<p>
(defvar org-export-filter-plain-text-functions nil
  "List of functions applied to plain text.
Each filter is called with three arguments: a string which
contains no Org syntax, the back-end, as a symbol, and the
communication channel, as a plist.  It must return a string or
nil.")
</p>

<p>
(defvar org-export-filter-final-output-functions nil
  "List of functions applied to the transcoded string.
Each filter is called with three arguments: the full transcoded
string, the back-end, as a symbol, and the communication channel,
as a plist.  It must return a string that will be used as the
final export output.")
</p>


<p>
;;;; Elements Filters
</p>

<p>
(defvar org-export-filter-babel-call-functions nil
  "List of functions applied to a transcoded babel-call.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-center-block-functions nil
  "List of functions applied to a transcoded center block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-clock-functions nil
  "List of functions applied to a transcoded clock.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-comment-functions nil
  "List of functions applied to a transcoded comment.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-comment-block-functions nil
  "List of functions applied to a transcoded comment-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-diary-sexp-functions nil
  "List of functions applied to a transcoded diary-sexp.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-drawer-functions nil
  "List of functions applied to a transcoded drawer.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-dynamic-block-functions nil
  "List of functions applied to a transcoded dynamic-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-example-block-functions nil
  "List of functions applied to a transcoded example-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-export-block-functions nil
  "List of functions applied to a transcoded export-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-fixed-width-functions nil
  "List of functions applied to a transcoded fixed-width.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-footnote-definition-functions nil
  "List of functions applied to a transcoded footnote-definition.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-headline-functions nil
  "List of functions applied to a transcoded headline.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-horizontal-rule-functions nil
  "List of functions applied to a transcoded horizontal-rule.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-inlinetask-functions nil
  "List of functions applied to a transcoded inlinetask.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-item-functions nil
  "List of functions applied to a transcoded item.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-keyword-functions nil
  "List of functions applied to a transcoded keyword.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-latex-environment-functions nil
  "List of functions applied to a transcoded latex-environment.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-node-property-functions nil
  "List of functions applied to a transcoded node-property.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-paragraph-functions nil
  "List of functions applied to a transcoded paragraph.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-plain-list-functions nil
  "List of functions applied to a transcoded plain-list.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-planning-functions nil
  "List of functions applied to a transcoded planning.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-property-drawer-functions nil
  "List of functions applied to a transcoded property-drawer.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-quote-block-functions nil
  "List of functions applied to a transcoded quote block.
Each filter is called with three arguments: the transcoded quote
data, as a string, the back-end, as a symbol, and the
communication channel, as a plist.  It must return a string or
nil.")
</p>

<p>
(defvar org-export-filter-quote-section-functions nil
  "List of functions applied to a transcoded quote-section.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-section-functions nil
  "List of functions applied to a transcoded section.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-special-block-functions nil
  "List of functions applied to a transcoded special block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-src-block-functions nil
  "List of functions applied to a transcoded src-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-table-functions nil
  "List of functions applied to a transcoded table.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-table-cell-functions nil
  "List of functions applied to a transcoded table-cell.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-table-row-functions nil
  "List of functions applied to a transcoded table-row.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-verse-block-functions nil
  "List of functions applied to a transcoded verse block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>


<p>
;;;; Objects Filters
</p>

<p>
(defvar org-export-filter-bold-functions nil
  "List of functions applied to transcoded bold text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-code-functions nil
  "List of functions applied to transcoded code text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-entity-functions nil
  "List of functions applied to a transcoded entity.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-export-snippet-functions nil
  "List of functions applied to a transcoded export-snippet.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-footnote-reference-functions nil
  "List of functions applied to a transcoded footnote-reference.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-inline-babel-call-functions nil
  "List of functions applied to a transcoded inline-babel-call.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-inline-src-block-functions nil
  "List of functions applied to a transcoded inline-src-block.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-italic-functions nil
  "List of functions applied to transcoded italic text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-latex-fragment-functions nil
  "List of functions applied to a transcoded latex-fragment.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-line-break-functions nil
  "List of functions applied to a transcoded line-break.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-link-functions nil
  "List of functions applied to a transcoded link.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-radio-target-functions nil
  "List of functions applied to a transcoded radio-target.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-statistics-cookie-functions nil
  "List of functions applied to a transcoded statistics-cookie.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-strike-through-functions nil
  "List of functions applied to transcoded strike-through text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-subscript-functions nil
  "List of functions applied to a transcoded subscript.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-superscript-functions nil
  "List of functions applied to a transcoded superscript.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-target-functions nil
  "List of functions applied to a transcoded target.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-timestamp-functions nil
  "List of functions applied to a transcoded timestamp.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-underline-functions nil
  "List of functions applied to transcoded underline text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>

<p>
(defvar org-export-filter-verbatim-functions nil
  "List of functions applied to transcoded verbatim text.
Each filter is called with three arguments: the transcoded data,
as a string, the back-end, as a symbol, and the communication
channel, as a plist.  It must return a string or nil.")
</p>


<p>
;;;; Filters Tools
;;
;; Internal function `org-export-install-filters' installs filters
;; hard-coded in back-ends (developer filters) and filters from global
;; variables (user filters) in the communication channel.
;;
;; Internal function `org-export-filter-apply-functions' takes care
;; about applying each filter in order to a given data.  It ignores
;; filters returning a nil value but stops whenever a filter returns
;; an empty string.
</p>

<p>
(defun org-export-filter-apply-functions (filters value info)
  "Call every function in FILTERS.
</p>

<p>
Functions are called with arguments VALUE, current export
back-end's name and INFO.  A function returning a nil value will
be skipped.  If it returns the empty string, the process ends and
VALUE is ignored.
</p>

<p>
Call is done in a LIFO fashion, to be sure that developer
specified filters, if any, are called first."
  (catch 'exit
    (let* ((backend (plist-get info :back-end))
           (backend-name (and backend (org-export-backend-name backend))))
      (dolist (filter filters value)
        (let ((result (funcall filter value backend-name info)))
          (cond ((not result) value)
                ((equal value "") (throw 'exit nil))
                (t (setq value result))))))))
</p>

<p>
(defun org-export-install-filters (info)
  "Install filters properties in communication channel.
INFO is a plist containing the current communication channel.
Return the updated communication channel."
  (let (plist)
    ;; Install user-defined filters with `org-export-filters-alist'
    ;; and filters already in INFO (through ext-plist mechanism).
    (mapc (lambda (p)
            (let* ((prop (car p))
                   (info-value (plist-get info prop))
                   (default-value (symbol-value (cdr p))))
              (setq plist
                    (plist-put plist prop
                               ;; Filters in INFO will be called
                               ;; before those user provided.
                               (append (if (listp info-value) info-value
                                         (list info-value))
                                       default-value)))))
          org-export-filters-alist)
    ;; Prepend back-end specific filters to that list.
    (mapc (lambda (p)
            ;; Single values get consed, lists are appended.
            (let ((key (car p)) (value (cdr p)))
              (when value
                (setq plist
                      (plist-put
                       plist key
                       (if (atom value) (cons value (plist-get plist key))
                         (append value (plist-get plist key))))))))
          (org-export-get-all-filters (plist-get info :back-end)))
    ;; Return new communication channel.
    (org-combine-plists info plist)))
</p>


<p>

;;; Core functions
;;
;; This is the room for the main function, `org-export-as', along with
;; its derivative, `org-export-string-as'.
;; `org-export&#x2013;copy-to-kill-ring-p' determines if output of these
;; function should be added to kill ring.
;;
;; Note that `org-export-as' doesn't really parse the current buffer,
;; but a copy of it (with the same buffer-local variables and
;; visibility), where macros and include keywords are expanded and
;; Babel blocks are executed, if appropriate.
;; `org-export-with-buffer-copy' macro prepares that copy.
;;
;; File inclusion is taken care of by
;; `org-export-expand-include-keyword' and
;; `org-export&#x2013;prepare-file-contents'.  Structure wise, including
;; a whole Org file in a buffer often makes little sense.  For
;; example, if the file contains a headline and the include keyword
;; was within an item, the item should contain the headline.  That's
;; why file inclusion should be done before any structure can be
;; associated to the file, that is before parsing.
;;
;; `org-export-insert-default-template' is a command to insert
;; a default template (or a back-end specific template) at point or in
;; current subtree.
</p>

<p>
(defun org-export-copy-buffer ()
  "Return a copy of the current buffer.
The copy preserves Org buffer-local variables, visibility and
narrowing."
  (let ((copy-buffer-fun (org-export&#x2013;generate-copy-script (current-buffer)))
        (new-buf (generate-new-buffer (buffer-name))))
    (with-current-buffer new-buf
      (funcall copy-buffer-fun)
      (set-buffer-modified-p nil))
    new-buf))
</p>

<p>
(defmacro org-export-with-buffer-copy (&amp;rest body)
  "Apply BODY in a copy of the current buffer.
The copy preserves local variables, visibility and contents of
the original buffer.  Point is at the beginning of the buffer
when BODY is applied."
  (declare (debug t))
  (org-with-gensyms (buf-copy)
    `(let ((,buf-copy (org-export-copy-buffer)))
       (unwind-protect
           (with-current-buffer ,buf-copy
             (goto-char (point-min))
             (progn ,@body))
         (and (buffer-live-p ,buf-copy)
              ;; Kill copy without confirmation.
              (progn (with-current-buffer ,buf-copy
                       (restore-buffer-modified-p nil))
                     (kill-buffer ,buf-copy)))))))
</p>

<p>
(defun org-export&#x2013;generate-copy-script (buffer)
  "Generate a function duplicating BUFFER.
</p>

<p>
The copy will preserve local variables, visibility, contents and
narrowing of the original buffer.  If a region was active in
BUFFER, contents will be narrowed to that region instead.
</p>

<p>
The resulting function can be evaluated at a later time, from
another buffer, effectively cloning the original buffer there.
</p>

<p>
The function assumes BUFFER's major mode is `org-mode'."
  (with-current-buffer buffer
    `(lambda ()
       (let ((inhibit-modification-hooks t))
         ;; Set major mode. Ignore `org-mode-hook' as it has been run
         ;; already in BUFFER.
         (let ((org-mode-hook nil) (org-inhibit-startup t)) (org-mode))
         ;; Copy specific buffer local variables and variables set
         ;; through BIND keywords.
         ,@(let ((bound-variables (org-export&#x2013;list-bound-variables))
                 vars)
             (dolist (entry (buffer-local-variables (buffer-base-buffer)) vars)
               (when (consp entry)
                 (let ((var (car entry))
                       (val (cdr entry)))
                   (and (not (eq var 'org-font-lock-keywords))
                        (or (memq var
                                  '(default-directory
                                     buffer-file-name
                                     buffer-file-coding-system))
                            (assq var bound-variables)
                            (string-match "<sup>\\</sup>\\(org-\\|orgtbl-\\)"
                                          (symbol-name var)))
                        ;; Skip unreadable values, as they cannot be
                        ;; sent to external process.
                        (or (not val) (ignore-errors (read (format "%S" val))))
                        (push `(set (make-local-variable (quote ,var))
                                    (quote ,val))
                              vars))))))
         ;; Whole buffer contents.
         (insert
          ,(org-with-wide-buffer
            (buffer-substring-no-properties
             (point-min) (point-max))))
         ;; Narrowing.
         ,(if (org-region-active-p)
              `(narrow-to-region ,(region-beginning) ,(region-end))
            `(narrow-to-region ,(point-min) ,(point-max)))
         ;; Current position of point.
         (goto-char ,(point))
         ;; Overlays with invisible property.
         ,@(let (ov-set)
             (mapc
              (lambda (ov)
                (let ((invis-prop (overlay-get ov 'invisible)))
                  (when invis-prop
                    (push `(overlay-put
                            (make-overlay ,(overlay-start ov)
                                          ,(overlay-end ov))
                            'invisible (quote ,invis-prop))
                          ov-set))))
              (overlays-in (point-min) (point-max)))
             ov-set)))))
</p>

<p>
;;;###autoload
(defun org-export-as
  (backend &amp;optional subtreep visible-only body-only ext-plist)
  "Transcode current Org buffer into BACKEND code.
</p>

<p>
BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.
</p>

<p>
If narrowing is active in the current buffer, only transcode its
narrowed part.
</p>

<p>
If a region is active, transcode that region.
</p>

<p>
When optional argument SUBTREEP is non-nil, transcode the
sub-tree at point, extracting information from the headline
properties first.
</p>

<p>
When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.
</p>

<p>
When optional argument BODY-ONLY is non-nil, only return body
code, without surrounding template.
</p>

<p>
Optional argument EXT-PLIST, when provided, is a property list
with external parameters overriding Org default settings, but
still inferior to file-local settings.
</p>

<p>
Return code as a string."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (org-export-barf-if-invalid-backend backend)
  (save-excursion
    (save-restriction
      ;; Narrow buffer to an appropriate region or subtree for
      ;; parsing.  If parsing subtree, be sure to remove main headline
      ;; too.
      (cond ((org-region-active-p)
             (narrow-to-region (region-beginning) (region-end)))
            (subtreep
             (org-narrow-to-subtree)
             (goto-char (point-min))
             (forward-line)
             (narrow-to-region (point) (point-max))))
      ;; Initialize communication channel with original buffer
      ;; attributes, unavailable in its copy.
      (let* ((org-export-current-backend (org-export-backend-name backend))
             (info (org-combine-plists
                    (list :export-options
                          (delq nil
                                (list (and subtreep 'subtree)
                                      (and visible-only 'visible-only)
                                      (and body-only 'body-only))))
                    (org-export&#x2013;get-buffer-attributes)))
             tree)
        ;; Update communication channel and get parse tree.  Buffer
        ;; isn't parsed directly.  Instead, a temporary copy is
        ;; created, where include keywords, macros are expanded and
        ;; code blocks are evaluated.
        (org-export-with-buffer-copy
         ;; Run first hook with current back-end's name as argument.
         (run-hook-with-args 'org-export-before-processing-hook
                             (org-export-backend-name backend))
         (org-export-expand-include-keyword)
         ;; Update macro templates since #+INCLUDE keywords might have
         ;; added some new ones.
         (org-macro-initialize-templates)
         (org-macro-replace-all org-macro-templates)
         (org-export-execute-babel-code)
         ;; Update radio targets since keyword inclusion might have
         ;; added some more.
         (org-update-radio-target-regexp)
         ;; Run last hook with current back-end's name as argument.
         (goto-char (point-min))
         (save-excursion
           (run-hook-with-args 'org-export-before-parsing-hook
                               (org-export-backend-name backend)))
         ;; Update communication channel with environment.  Also
         ;; install user's and developer's filters.
         (setq info
               (org-export-install-filters
                (org-combine-plists
                 info (org-export-get-environment backend subtreep ext-plist))))
         ;; Expand export-specific set of macros: Donald Lindsay,
         ;; , xk05@vorlon and rdf.  It must be done
         ;; once regular macros have been expanded, since document
         ;; keywords may contain one of them.
         (org-macro-replace-all
          (list (cons "author"
                      (org-element-interpret-data (plist-get info :author)))
                (cons "date"
                      (org-element-interpret-data (plist-get info :date)))
                ;; EMAIL is not a parsed keyword: store it as-is.
                (cons "email" (or (plist-get info :email) ""))
                (cons "title"
                      (org-element-interpret-data (plist-get info :title)))))
         ;; Call options filters and update export options.  We do not
         ;; use `org-export-filter-apply-functions' here since the
         ;; arity of such filters is different.
         (let ((backend-name (org-export-backend-name backend)))
           (dolist (filter (plist-get info :filter-options))
             (let ((result (funcall filter info backend-name)))
               (when result (setq info result)))))
         ;; Parse buffer and call parse-tree filter on it.
         (setq tree
               (org-export-filter-apply-functions
                (plist-get info :filter-parse-tree)
                (org-element-parse-buffer nil visible-only) info))
         ;; Now tree is complete, compute its properties and add them
         ;; to communication channel.
         (setq info
               (org-combine-plists
                info (org-export-collect-tree-properties tree info)))
         ;; Eventually transcode TREE.  Wrap the resulting string into
         ;; a template.
         (let* ((body (org-element-normalize-string
                       (or (org-export-data tree info) "")))
                (inner-template (cdr (assq 'inner-template
                                           (plist-get info :translate-alist))))
                (full-body (if (not (functionp inner-template)) body
                             (funcall inner-template body info)))
                (template (cdr (assq 'template
                                     (plist-get info :translate-alist)))))
           ;; Remove all text properties since they cannot be
           ;; retrieved from an external process.  Finally call
           ;; final-output filter and return result.
           (org-no-properties
            (org-export-filter-apply-functions
             (plist-get info :filter-final-output)
             (if (or (not (functionp template)) body-only) full-body
               (funcall template full-body info))
             info))))))))
</p>

<p>
;;;###autoload
(defun org-export-string-as (string backend &amp;optional body-only ext-plist)
  "Transcode STRING into BACKEND code.
</p>

<p>
BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.
</p>

<p>
When optional argument BODY-ONLY is non-nil, only return body
code, without preamble nor postamble.
</p>

<p>
Optional argument EXT-PLIST, when provided, is a property list
with external parameters overriding Org default settings, but
still inferior to file-local settings.
</p>

<p>
Return code as a string."
  (with-temp-buffer
    (insert string)
    (let ((org-inhibit-startup t)) (org-mode))
    (org-export-as backend nil nil body-only ext-plist)))
</p>

<p>
;;;###autoload
(defun org-export-replace-region-by (backend)
  "Replace the active region by its export to BACKEND.
BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end."
  (if (not (org-region-active-p))
      (user-error "No active region to replace")
    (let* ((beg (region-beginning))
           (end (region-end))
           (str (buffer-substring beg end)) rpl)
      (setq rpl (org-export-string-as str backend t))
      (delete-region beg end)
      (insert rpl))))
</p>

<p>
;;;###autoload
(defun org-export-insert-default-template (&amp;optional backend subtreep)
  "Insert all export keywords with default values at beginning of line.
</p>

<p>
BACKEND is a symbol referring to the name of a registered export
back-end, for which specific export options should be added to
the template, or `default' for default template.  When it is nil,
the user will be prompted for a category.
</p>

<p>
If SUBTREEP is non-nil, export configuration will be set up
locally for the subtree through node properties."
  (interactive)
  (unless (derived-mode-p 'org-mode) (user-error "Not in an Org mode buffer"))
  (when (and subtreep (org-before-first-heading-p))
    (user-error "No subtree to set export options for"))
  (let ((node (and subtreep (save-excursion (org-back-to-heading t) (point))))
        (backend
         (or backend
             (intern
              (org-completing-read
               "Options category: "
               (cons "default"
                     (mapcar (lambda (b)
                               (symbol-name (org-export-backend-name b)))
                             org-export&#x2013;registered-backends))))))
        options keywords)
    ;; Populate OPTIONS and KEYWORDS.
    (dolist (entry (cond ((eq backend 'default) org-export-options-alist)
                         ((org-export-backend-p backend)
                          (org-export-backend-options backend))
                         (t (org-export-backend-options
                             (org-export-get-backend backend)))))
      (let ((keyword (nth 1 entry))
            (option (nth 2 entry)))
        (cond
         (keyword (unless (assoc keyword keywords)
                    (let ((value
                           (if (eq (nth 4 entry) 'split)
                               (mapconcat 'identity (eval (nth 3 entry)) " ")
                             (eval (nth 3 entry)))))
                      (push (cons keyword value) keywords))))
         (option (unless (assoc option options)
                   (push (cons option (eval (nth 3 entry))) options))))))
    ;; Move to an appropriate location in order to insert options.
    (unless subtreep (beginning-of-line))
    ;; First get TITLE, DATE, AUTHOR and EMAIL if they belong to the
    ;; list of available keywords.
    (when (assoc "TITLE" keywords)
      (let ((title
             (or (let ((visited-file (buffer-file-name (buffer-base-buffer))))
                   (and visited-file
                        (file-name-sans-extension
                         (file-name-nondirectory visited-file))))
                 (buffer-name (buffer-base-buffer)))))
        (if (not subtreep) (insert (format "#+TITLE: %s\n" title))
          (org-entry-put node "EXPORT<sub>TITLE</sub>" title))))
    (when (assoc "DATE" keywords)
      (let ((date (with-temp-buffer (org-insert-time-stamp (current-time)))))
        (if (not subtreep) (insert "#+DATE: " date "\n")
          (org-entry-put node "EXPORT<sub>DATE</sub>" date))))
    (when (assoc "AUTHOR" keywords)
      (let ((author (cdr (assoc "AUTHOR" keywords))))
        (if subtreep (org-entry-put node "EXPORT<sub>AUTHOR</sub>" author)
          (insert
           (format "#+AUTHOR:%s\n"
                   (if (not (org-string-nw-p author)) ""
                     (concat " " author)))))))
    (when (assoc "EMAIL" keywords)
      (let ((email (cdr (assoc "EMAIL" keywords))))
        (if subtreep (org-entry-put node "EXPORT<sub>EMAIL</sub>" email)
          (insert
           (format "#+EMAIL:%s\n"
                   (if (not (org-string-nw-p email)) ""
                     (concat " " email)))))))
    ;; Then (multiple) OPTIONS lines.  Never go past fill-column.
    (when options
      (let ((items
             (mapcar
              #'(lambda (opt) (format "%s:%S" (car opt) (cdr opt)))
              (sort options (lambda (k1 k2) (string&lt; (car k1) (car k2)))))))
        (if subtreep
            (org-entry-put
             node "EXPORT<sub>OPTIONS</sub>" (mapconcat 'identity items " "))
          (while items
            (insert "#+OPTIONS:")
            (let ((width 10))
              (while (and items
                          (&lt; (+ width (length (car items)) 1) fill-column))
                (let ((item (pop items)))
                  (insert " " item)
                  (incf width (1+ (length item))))))
            (insert "\n")))))
    ;; And the rest of keywords.
    (dolist (key (sort keywords (lambda (k1 k2) (string&lt; (car k1) (car k2)))))
      (unless (member (car key) '("TITLE" "DATE" "AUTHOR" "EMAIL"))
        (let ((val (cdr key)))
          (if subtreep (org-entry-put node (concat "EXPORT_" (car key)) val)
            (insert
             (format "#+%s:%s\n"
                     (car key)
                     (if (org-string-nw-p val) (format " %s" val) "")))))))))
</p>

<p>
(defun org-export-expand-include-keyword (&amp;optional included dir)
  "Expand every include keyword in buffer.
Optional argument INCLUDED is a list of included file names along
with their line restriction, when appropriate.  It is used to
avoid infinite recursion.  Optional argument DIR is the current
working directory.  It is used to properly resolve relative
paths."
  (let ((case-fold-search t))
    (goto-char (point-min))
    (while (re-search-forward "<sup>[</sup> \t]*#\\+INCLUDE:" nil t)
      (let ((element (save-match-data (org-element-at-point))))
        (when (eq (org-element-type element) 'keyword)
          (beginning-of-line)
          ;; Extract arguments from keyword's value.
          (let* ((value (org-element-property :value element))
                 (ind (org-get-indentation))
                 (file (and (string-match
                             "<sup>\\</sup>\\(\".+?\"\\|\\S-+\\)\\(?:\\s-+\\|$\\)" value)
                            (prog1 (expand-file-name
                                    (org-remove-double-quotes
                                     (match-string 1 value))
                                    dir)
                              (setq value (replace-match "" nil nil value)))))
                 (lines
                  (and (string-match
                        ":lines <del>\"\\(\\(?:[0-9]</del>\\)?-\\(?:[0-9]+\\)?\\)\""
                        value)
                       (prog1 (match-string 1 value)
                         (setq value (replace-match "" nil nil value)))))
                 (env (cond ((string-match "\\&lt;example\\&gt;" value) 'example)
                            ((string-match "\\&lt;src\\(?: +\\(.*\\)\\)?" value)
                             (match-string 1 value))))
                 ;; Minimal level of included file defaults to the child
                 ;; level of the current headline, if any, or one.  It
                 ;; only applies is the file is meant to be included as
                 ;; an Org one.
                 (minlevel
                  (and (not env)
                       (if (string-match ":minlevel <del>\\([0-9]</del>\\)" value)
                           (prog1 (string-to-number (match-string 1 value))
                             (setq value (replace-match "" nil nil value)))
                         (let ((cur (org-current-level)))
                           (if cur (1+ (org-reduced-level cur)) 1))))))
            ;; Remove keyword.
            (delete-region (point) (progn (forward-line) (point)))
            (cond
             ((not file) nil)
             ((not (file-readable-p file))
              (error "Cannot include file %s" file))
             ;; Check if files has already been parsed.  Look after
             ;; inclusion lines too, as different parts of the same file
             ;; can be included too.
             ((member (list file lines) included)
              (error "Recursive file inclusion: %s" file))
             (t
              (cond
               ((eq env 'example)
                (insert
                 (let ((ind-str (make-string ind ? ))
                       (contents
                        (org-escape-code-in-string
                         (org-export&#x2013;prepare-file-contents file lines))))
                   (format "%s#+BEGIN<sub>EXAMPLE\n</sub>%s%s#+END<sub>EXAMPLE\n</sub>"
                           ind-str contents ind-str))))
               ((stringp env)
                (insert
                 (let ((ind-str (make-string ind ? ))
                       (contents
                        (org-escape-code-in-string
                         (org-export&#x2013;prepare-file-contents file lines))))
                   (format "%s#+BEGIN<sub>SRC</sub> %s\n%s%s#+END<sub>SRC\n</sub>"
                           ind-str env contents ind-str))))
               (t
                (insert
                 (with-temp-buffer
                   (let ((org-inhibit-startup t)) (org-mode))
                   (insert
                    (org-export&#x2013;prepare-file-contents file lines ind minlevel))
                   (org-export-expand-include-keyword
                    (cons (list file lines) included)
                    (file-name-directory file))
                   (buffer-string)))))))))))))
</p>

<p>
(defun org-export&#x2013;prepare-file-contents (file &amp;optional lines ind minlevel)
  "Prepare the contents of FILE for inclusion and return them as a string.
</p>

<p>
When optional argument LINES is a string specifying a range of
lines, include only those lines.
</p>

<p>
Optional argument IND, when non-nil, is an integer specifying the
global indentation of returned contents.  Since its purpose is to
allow an included file to stay in the same environment it was
created \(i.e. a list item), it doesn't apply past the first
headline encountered.
</p>

<p>
Optional argument MINLEVEL, when non-nil, is an integer
specifying the level that any top-level headline in the included
file should have."
  (with-temp-buffer
    (insert-file-contents file)
    (when lines
      (let* ((lines (split-string lines "-"))
             (lbeg (string-to-number (car lines)))
             (lend (string-to-number (cadr lines)))
             (beg (if (zerop lbeg) (point-min)
                    (goto-char (point-min))
                    (forward-line (1- lbeg))
                    (point)))
             (end (if (zerop lend) (point-max)
                    (goto-char (point-min))
                    (forward-line (1- lend))
                    (point))))
        (narrow-to-region beg end)))
    ;; Remove blank lines at beginning and end of contents.  The logic
    ;; behind that removal is that blank lines around include keyword
    ;; override blank lines in included file.
    (goto-char (point-min))
    (org-skip-whitespace)
    (beginning-of-line)
    (delete-region (point-min) (point))
    (goto-char (point-max))
    (skip-chars-backward " \r\t\n")
    (forward-line)
    (delete-region (point) (point-max))
    ;; If IND is set, preserve indentation of include keyword until
    ;; the first headline encountered.
    (when ind
      (unless (eq major-mode 'org-mode)
        (let ((org-inhibit-startup t)) (org-mode)))
      (goto-char (point-min))
      (let ((ind-str (make-string ind ? )))
        (while (not (or (eobp) (looking-at org-outline-regexp-bol)))
          ;; Do not move footnote definitions out of column 0.
          (unless (and (looking-at org-footnote-definition-re)
                       (eq (org-element-type (org-element-at-point))
                           'footnote-definition))
            (insert ind-str))
          (forward-line))))
    ;; When MINLEVEL is specified, compute minimal level for headlines
    ;; in the file (CUR-MIN), and remove stars to each headline so
    ;; that headlines with minimal level have a level of MINLEVEL.
    (when minlevel
      (unless (eq major-mode 'org-mode)
        (let ((org-inhibit-startup t)) (org-mode)))
      (org-with-limited-levels
       (let ((levels (org-map-entries
                      (lambda () (org-reduced-level (org-current-level))))))
         (when levels
           (let ((offset (- minlevel (apply 'min levels))))
             (unless (zerop offset)
               (when org-odd-levels-only (setq offset (* offset 2)))
               ;; Only change stars, don't bother moving whole
               ;; sections.
               (org-map-entries
                (lambda () (if (&lt; offset 0) (delete-char (abs offset))
                        (insert (make-string offset ?*)))))))))))
    (org-element-normalize-string (buffer-string))))
</p>

<p>
(defun org-export-execute-babel-code ()
  "Execute every Babel code in the visible part of current buffer."
  ;; Get a pristine copy of current buffer so Babel references can be
  ;; properly resolved.
  (let ((reference (org-export-copy-buffer)))
    (unwind-protect (let ((org-current-export-file reference))
                      (org-babel-exp-process-buffer))
      (kill-buffer reference))))
</p>

<p>
(defun org-export&#x2013;copy-to-kill-ring-p ()
  "Return a non-nil value when output should be added to the kill ring.
See also `org-export-copy-to-kill-ring'."
  (if (eq org-export-copy-to-kill-ring 'if-interactive)
      (not (or executing-kbd-macro noninteractive))
    (eq org-export-copy-to-kill-ring t)))
</p>


<p>

;;; Tools For Back-Ends
;;
;; A whole set of tools is available to help build new exporters.  Any
;; function general enough to have its use across many back-ends
;; should be added here.
</p>

<p>
;;;; For Affiliated Keywords
;;
;; `org-export-read-attribute' reads a property from a given element
;;  as a plist.  It can be used to normalize affiliated keywords'
;;  syntax.
;;
;; Since captions can span over multiple lines and accept dual values,
;; their internal representation is a bit tricky.  Therefore,
;; `org-export-get-caption' transparently returns a given element's
;; caption as a secondary string.
</p>

<p>
(defun org-export-read-attribute (attribute element &amp;optional property)
  "Turn ATTRIBUTE property from ELEMENT into a plist.
</p>

<p>
When optional argument PROPERTY is non-nil, return the value of
that property within attributes.
</p>

<p>
This function assumes attributes are defined as \":keyword
value\" pairs.  It is appropriate for `:attr<sub>html'</sub> like
properties.
</p>

<p>
All values will become strings except the empty string and
\"nil\", which will become nil.  Also, values containing only
double quotes will be read as-is, which means that \"\" value
will become the empty string."
  (let* ((prepare-value
          (lambda (str)
            (save-match-data
              (cond ((member str '(nil "" "nil")) nil)
                    ((string-match "<sup>\</sup>"\\(\"+\\)?\"$" str)
                     (or (match-string 1 str) ""))
                    (t str)))))
         (attributes
          (let ((value (org-element-property attribute element)))
            (when value
              (let ((s (mapconcat 'identity value " ")) result)
                (while (string-match
                        "\\(?:^\\|[ \t]+\\)\\(:[-a-zA-Z0-9_]+\\)\\([ \t]+\\|$\\)"
                        s)
                  (let ((value (substring s 0 (match-beginning 0))))
                    (push (funcall prepare-value value) result))
                  (push (intern (match-string 1 s)) result)
                  (setq s (substring s (match-end 0))))
                ;; Ignore any string before first property with `cdr'.
                (cdr (nreverse (cons (funcall prepare-value s) result))))))))
    (if property (plist-get attributes property) attributes)))
</p>

<p>
(defun org-export-get-caption (element &amp;optional shortp)
  "Return caption from ELEMENT as a secondary string.
</p>

<p>
When optional argument SHORTP is non-nil, return short caption,
as a secondary string, instead.
</p>

<p>
Caption lines are separated by a white space."
  (let ((full-caption (org-element-property :caption element)) caption)
    (dolist (line full-caption (cdr caption))
      (let ((cap (funcall (if shortp 'cdr 'car) line)))
        (when cap
          (setq caption (nconc (list " ") (copy-sequence cap) caption)))))))
</p>


<p>
;;;; For Derived Back-ends
;;
;; `org-export-with-backend' is a function allowing to locally use
;; another back-end to transcode some object or element.  In a derived
;; back-end, it may be used as a fall-back function once all specific
;; cases have been treated.
</p>

<p>
(defun org-export-with-backend (backend data &amp;optional contents info)
  "Call a transcoder from BACKEND on DATA.
BACKEND is an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.  DATA is an Org element, object, secondary
string or string.  CONTENTS, when non-nil, is the transcoded
contents of DATA element, as a string.  INFO, when non-nil, is
the communication channel used for export, as a plist."
  (when (symbolp backend) (setq backend (org-export-get-backend backend)))
  (org-export-barf-if-invalid-backend backend)
  (let ((type (org-element-type data)))
    (if (memq type '(nil org-data)) (error "No foreign transcoder available")
      (let* ((all-transcoders (org-export-get-all-transcoders backend))
             (transcoder (cdr (assq type all-transcoders))))
        (if (not (functionp transcoder))
            (error "No foreign transcoder available")
          (funcall
           transcoder data contents
           (org-combine-plists
            info (list :back-end backend
</p>
<p>
:translate-alist all-transcoders
</p>
<p>
:exported-data (make-hash-table :test 'eq :size 401)))))))))
</p>


<p>
;;;; For Export Snippets
;;
;; Every export snippet is transmitted to the back-end.  Though, the
;; latter will only retain one type of export-snippet, ignoring
;; others, based on the former's target back-end.  The function
;; `org-export-snippet-backend' returns that back-end for a given
;; export-snippet.
</p>

<p>
(defun org-export-snippet-backend (export-snippet)
  "Return EXPORT-SNIPPET targeted back-end as a symbol.
Translation, with `org-export-snippet-translation-alist', is
applied."
  (let ((back-end (org-element-property :back-end export-snippet)))
    (intern
     (or (cdr (assoc back-end org-export-snippet-translation-alist))
         back-end))))
</p>


<p>
;;;; For Footnotes
;;
;; `org-export-collect-footnote-definitions' is a tool to list
;; actually used footnotes definitions in the whole parse tree, or in
;; a headline, in order to add footnote listings throughout the
;; transcoded data.
;;
;; `org-export-footnote-first-reference-p' is a predicate used by some
;; back-ends, when they need to attach the footnote definition only to
;; the first occurrence of the corresponding label.
;;
;; `org-export-get-footnote-definition' and
;; `org-export-get-footnote-number' provide easier access to
;; additional information relative to a footnote reference.
</p>

<p>
(defun org-export-collect-footnote-definitions (data info)
  "Return an alist between footnote numbers, labels and definitions.
</p>

<p>
DATA is the parse tree from which definitions are collected.
INFO is the plist used as a communication channel.
</p>

<p>
Definitions are sorted by order of references.  They either
appear as Org data or as a secondary string for inlined
footnotes.  Unreferenced definitions are ignored."
  (let* (num-alist
         collect-fn                        ; for byte-compiler.
         (collect-fn
          (function
           (lambda (data)
             ;; Collect footnote number, label and definition in DATA.
             (org-element-map data 'footnote-reference
               (lambda (fn)
                 (when (org-export-footnote-first-reference-p fn info)
                   (let ((def (org-export-get-footnote-definition fn info)))
                     (push
                      (list (org-export-get-footnote-number fn info)
                            (org-element-property :label fn)
                            def)
                      num-alist)
                     ;; Also search in definition for nested footnotes.
                     (when (eq (org-element-property :type fn) 'standard)
                       (funcall collect-fn def)))))
               ;; Don't enter footnote definitions since it will happen
               ;; when their first reference is found.
               info nil 'footnote-definition)))))
    (funcall collect-fn (plist-get info :parse-tree))
    (reverse num-alist)))
</p>

<p>
(defun org-export-footnote-first-reference-p (footnote-reference info)
  "Non-nil when a footnote reference is the first one for its label.
</p>

<p>
FOOTNOTE-REFERENCE is the footnote reference being considered.
INFO is the plist used as a communication channel."
  (let ((label (org-element-property :label footnote-reference)))
    ;; Anonymous footnotes are always a first reference.
    (if (not label) t
      ;; Otherwise, return the first footnote with the same LABEL and
      ;; test if it is equal to FOOTNOTE-REFERENCE.
      (let* (search-refs                ; for byte-compiler.
             (search-refs
              (function
               (lambda (data)
                 (org-element-map data 'footnote-reference
                   (lambda (fn)
                     (cond
                      ((string= (org-element-property :label fn) label)
                       (throw 'exit fn))
                      ;; If FN isn't inlined, be sure to traverse its
                      ;; definition before resuming search.  See
                      ;; comments in `org-export-get-footnote-number'
                      ;; for more information.
                      ((eq (org-element-property :type fn) 'standard)
                       (funcall search-refs
                                (org-export-get-footnote-definition fn info)))))
                   ;; Don't enter footnote definitions since it will
                   ;; happen when their first reference is found.
                   info 'first-match 'footnote-definition)))))
        (eq (catch 'exit (funcall search-refs (plist-get info :parse-tree)))
            footnote-reference)))))
</p>

<p>
(defun org-export-get-footnote-definition (footnote-reference info)
  "Return definition of FOOTNOTE-REFERENCE as parsed data.
INFO is the plist used as a communication channel.  If no such
definition can be found, return the \"DEFINITION NOT FOUND\"
string."
  (let ((label (org-element-property :label footnote-reference)))
    (or (org-element-property :inline-definition footnote-reference)
        (cdr (assoc label (plist-get info :footnote-definition-alist)))
        "DEFINITION NOT FOUND.")))
</p>

<p>
(defun org-export-get-footnote-number (footnote info)
  "Return number associated to a footnote.
</p>

<p>
FOOTNOTE is either a footnote reference or a footnote definition.
INFO is the plist used as a communication channel."
  (let* ((label (org-element-property :label footnote))
         seen-refs
         search-ref                        ; For byte-compiler.
         (search-ref
          (function
           (lambda (data)
             ;; Search footnote references through DATA, filling
             ;; SEEN-REFS along the way.
             (org-element-map data 'footnote-reference
               (lambda (fn)
                 (let ((fn-lbl (org-element-property :label fn)))
                   (cond
                    ;; Anonymous footnote match: return number.
                    ((and (not fn-lbl) (eq fn footnote))
                     (throw 'exit (1+ (length seen-refs))))
                    ;; Labels match: return number.
                    ((and label (string= label fn-lbl))
                     (throw 'exit (1+ (length seen-refs))))
                    ;; Anonymous footnote: it's always a new one.
                    ;; Also, be sure to return nil from the `cond' so
                    ;; `first-match' doesn't get us out of the loop.
                    ((not fn-lbl) (push 'inline seen-refs) nil)
                    ;; Label not seen so far: add it so SEEN-REFS.
                    ;;
                    ;; Also search for subsequent references in
                    ;; footnote definition so numbering follows
                    ;; reading logic.  Note that we don't have to care
                    ;; about inline definitions, since
                    ;; `org-element-map' already traverses them at the
                    ;; right time.
                    ;;
                    ;; Once again, return nil to stay in the loop.
                    ((not (member fn-lbl seen-refs))
                     (push fn-lbl seen-refs)
                     (funcall search-ref
                              (org-export-get-footnote-definition fn info))
                     nil))))
               ;; Don't enter footnote definitions since it will
               ;; happen when their first reference is found.
               info 'first-match 'footnote-definition)))))
    (catch 'exit (funcall search-ref (plist-get info :parse-tree)))))
</p>


<p>
;;;; For Headlines
;;
;; `org-export-get-relative-level' is a shortcut to get headline
;; level, relatively to the lower headline level in the parsed tree.
;;
;; `org-export-get-headline-number' returns the section number of an
;; headline, while `org-export-number-to-roman' allows to convert it
;; to roman numbers.
;;
;; `org-export-low-level-p', `org-export-first-sibling-p' and
;; `org-export-last-sibling-p' are three useful predicates when it
;; comes to fulfill the `:headline-levels' property.
;;
;; `org-export-get-tags', `org-export-get-category' and
;; `org-export-get-node-property' extract useful information from an
;; headline or a parent headline.  They all handle inheritance.
;;
;; `org-export-get-alt-title' tries to retrieve an alternative title,
;; as a secondary string, suitable for table of contents.  It falls
;; back onto default title.
</p>

<p>
(defun org-export-get-relative-level (headline info)
  "Return HEADLINE relative level within current parsed tree.
INFO is a plist holding contextual information."
  (+ (org-element-property :level headline)
     (or (plist-get info :headline-offset) 0)))
</p>

<p>
(defun org-export-low-level-p (headline info)
  "Non-nil when HEADLINE is considered as low level.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
A low level headlines has a relative level greater than
`:headline-levels' property value.
</p>

<p>
Return value is the difference between HEADLINE relative level
and the last level being considered as high enough, or nil."
  (let ((limit (plist-get info :headline-levels)))
    (when (wholenump limit)
      (let ((level (org-export-get-relative-level headline info)))
        (and (&gt; level limit) (- level limit))))))
</p>

<p>
(defun org-export-get-headline-number (headline info)
  "Return HEADLINE numbering as a list of numbers.
INFO is a plist holding contextual information."
  (cdr (assoc headline (plist-get info :headline-numbering))))
</p>

<p>
(defun org-export-numbered-headline-p (headline info)
  "Return a non-nil value if HEADLINE element should be numbered.
INFO is a plist used as a communication channel."
  (let ((sec-num (plist-get info :section-numbers))
        (level (org-export-get-relative-level headline info)))
    (if (wholenump sec-num) (&lt;= level sec-num) sec-num)))
</p>

<p>
(defun org-export-number-to-roman (n)
  "Convert integer N into a roman numeral."
  (let ((roman '((1000 . "M") (900 . "CM") (500 . "D") (400 . "CD")
                 ( 100 . "C") ( 90 . "XC") ( 50 . "L") ( 40 . "XL")
                 (  10 . "X") (  9 . "IX") (  5 . "V") (  4 . "IV")
                 (   1 . "I")))
        (res ""))
    (if (&lt;= n 0)
        (number-to-string n)
      (while roman
        (if (&gt;= n (caar roman))
            (setq n (- n (caar roman))
                  res (concat res (cdar roman)))
          (pop roman)))
      res)))
</p>

<p>
(defun org-export-get-tags (element info &amp;optional tags inherited)
  "Return list of tags associated to ELEMENT.
</p>

<p>
ELEMENT has either an `headline' or an `inlinetask' type.  INFO
is a plist used as a communication channel.
</p>

<p>
Select tags (see `org-export-select-tags') and exclude tags (see
`org-export-exclude-tags') are removed from the list.
</p>

<p>
When non-nil, optional argument TAGS should be a list of strings.
Any tag belonging to this list will also be removed.
</p>

<p>
When optional argument INHERITED is non-nil, tags can also be
inherited from parent headlines and FILETAGS keywords."
  (org-remove-if
   (lambda (tag) (or (member tag (plist-get info :select-tags))
                (member tag (plist-get info :exclude-tags))
                (member tag tags)))
   (if (not inherited) (org-element-property :tags element)
     ;; Build complete list of inherited tags.
     (let ((current-tag-list (org-element-property :tags element)))
       (mapc
        (lambda (parent)
          (mapc
           (lambda (tag)
             (when (and (memq (org-element-type parent) '(headline inlinetask))
                        (not (member tag current-tag-list)))
               (push tag current-tag-list)))
           (org-element-property :tags parent)))
        (org-export-get-genealogy element))
       ;; Add FILETAGS keywords and return results.
       (org-uniquify (append (plist-get info :filetags) current-tag-list))))))
</p>

<p>
(defun org-export-get-node-property (property blob &amp;optional inherited)
  "Return node PROPERTY value for BLOB.
</p>

<p>
PROPERTY is an upcase symbol (i.e. `:COOKIE<sub>DATA'</sub>).  BLOB is an
element or object.
</p>

<p>
If optional argument INHERITED is non-nil, the value can be
inherited from a parent headline.
</p>

<p>
Return value is a string or nil."
  (let ((headline (if (eq (org-element-type blob) 'headline) blob
                    (org-export-get-parent-headline blob))))
    (if (not inherited) (org-element-property property blob)
      (let ((parent headline) value)
        (catch 'found
          (while parent
            (when (plist-member (nth 1 parent) property)
              (throw 'found (org-element-property property parent)))
            (setq parent (org-element-property :parent parent))))))))
</p>

<p>
(defun org-export-get-category (blob info)
  "Return category for element or object BLOB.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
CATEGORY is automatically inherited from a parent headline, from
</p>
<p>
fail, the fall-back value is \"???\"."
  (or (let ((headline (if (eq (org-element-type blob) 'headline) blob
                        (org-export-get-parent-headline blob))))
        ;; Almost like `org-export-node-property', but we cannot trust
        ;; `plist-member' as every headline has a `:CATEGORY'
        ;; property, would it be nil or equal to "???" (which has the
        ;; same meaning).
        (let ((parent headline) value)
          (catch 'found
            (while parent
              (let ((category (org-element-property :CATEGORY parent)))
                (and category (not (equal "???" category))
                     (throw 'found category)))
              (setq parent (org-element-property :parent parent))))))
      (org-element-map (plist-get info :parse-tree) 'keyword
        (lambda (kwd)
          (when (equal (org-element-property :key kwd) "CATEGORY")
            (org-element-property :value kwd)))
        info 'first-match)
      (let ((file (plist-get info :input-file)))
        (and file (file-name-sans-extension (file-name-nondirectory file))))
      "???"))
</p>

<p>
(defun org-export-get-alt-title (headline info)
  "Return alternative title for HEADLINE, as a secondary string.
INFO is a plist used as a communication channel.  If no optional
title is defined, fall-back to the regular title."
  (or (org-element-property :alt-title headline)
      (org-element-property :title headline)))
</p>

<p>
(defun org-export-first-sibling-p (headline info)
  "Non-nil when HEADLINE is the first sibling in its sub-tree.
INFO is a plist used as a communication channel."
  (not (eq (org-element-type (org-export-get-previous-element headline info))
           'headline)))
</p>

<p>
(defun org-export-last-sibling-p (headline info)
  "Non-nil when HEADLINE is the last sibling in its sub-tree.
INFO is a plist used as a communication channel."
  (not (org-export-get-next-element headline info)))
</p>


<p>
;;;; For Keywords
;;
;; `org-export-get-date' returns a date appropriate for the document
;;  to about to be exported.  In particular, it takes care of
;;  `org-export-date-timestamp-format'.
</p>

<p>
(defun org-export-get-date (info &amp;optional fmt)
  "Return date value for the current document.
</p>

<p>
INFO is a plist used as a communication channel.  FMT, when
non-nil, is a time format string that will be applied on the date
if it consists in a single timestamp object.  It defaults to
`org-export-date-timestamp-format' when nil.
</p>

<p>
A proper date can be a secondary string, a string or nil.  It is
meant to be translated with `org-export-data' or alike."
  (let ((date (plist-get info :date))
        (fmt (or fmt org-export-date-timestamp-format)))
    (cond ((not date) nil)
          ((and fmt
                (not (cdr date))
                (eq (org-element-type (car date)) 'timestamp))
           (org-timestamp-format (car date) fmt))
          (t date))))
</p>


<p>
;;;; For Links
;;
;; `org-export-solidify-link-text' turns a string into a safer version
;; for links, replacing most non-standard characters with hyphens.
;;
;; `org-export-get-coderef-format' returns an appropriate format
;; string for coderefs.
;;
;; `org-export-inline-image-p' returns a non-nil value when the link
;; provided should be considered as an inline image.
;;
;; `org-export-resolve-fuzzy-link' searches destination of fuzzy links
;; (i.e. links with "fuzzy" as type) within the parsed tree, and
;; returns an appropriate unique identifier when found, or nil.
;;
;; `org-export-resolve-id-link' returns the first headline with
;; specified id or custom-id in parse tree, the path to the external
;; file with the id or nil when neither was found.
;;
;; `org-export-resolve-coderef' associates a reference to a line
;; number in the element it belongs, or returns the reference itself
;; when the element isn't numbered.
</p>

<p>
(defun org-export-solidify-link-text (s)
  "Take link text S and make a safe target out of it."
  (save-match-data
    (mapconcat 'identity (org-split-string s "[<sup>a</sup>-zA-Z0-9_.-:]+") "-")))
</p>

<p>
(defun org-export-get-coderef-format (path desc)
  "Return format string for code reference link.
PATH is the link path.  DESC is its description."
  (save-match-data
    (cond ((not desc) "%s")
          ((string-match (regexp-quote (concat "(" path ")")) desc)
           (replace-match "%s" t t desc))
          (t desc))))
</p>

<p>
(defun org-export-inline-image-p (link &amp;optional rules)
  "Non-nil if LINK object points to an inline image.
</p>

<p>
Optional argument is a set of RULES defining inline images.  It
is an alist where associations have the following shape:
</p>

<p>
\(TYPE . REGEXP)
</p>

<p>
Applying a rule means apply REGEXP against LINK's path when its
type is TYPE.  The function will return a non-nil value if any of
the provided rules is non-nil.  The default rule is
`org-export-default-inline-image-rule'.
</p>

<p>
This only applies to links without a description."
  (and (not (org-element-contents link))
       (let ((case-fold-search t)
             (rules (or rules org-export-default-inline-image-rule)))
         (catch 'exit
           (mapc
            (lambda (rule)
              (and (string= (org-element-property :type link) (car rule))
                   (string-match (cdr rule)
                                 (org-element-property :path link))
                   (throw 'exit t)))
            rules)
           ;; Return nil if no rule matched.
           nil))))
</p>

<p>
(defun org-export-resolve-coderef (ref info)
  "Resolve a code reference REF.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
Return associated line number in source code, or REF itself,
depending on src-block or example element's switches."
  (org-element-map (plist-get info :parse-tree) '(example-block src-block)
    (lambda (el)
      (with-temp-buffer
        (insert (org-trim (org-element-property :value el)))
        (let* ((label-fmt (regexp-quote
                           (or (org-element-property :label-fmt el)
                               org-coderef-label-format)))
               (ref-re
                (format "^.*?\&sect;-.*?\\([ \t]*\\(%s\\)\\)[ \t]*$"
                        (replace-regexp-in-string "%s" ref label-fmt nil t))))
          ;; Element containing REF is found.  Resolve it to either
          ;; a label or a line number, as needed.
          (when (re-search-backward ref-re nil t)
            (cond
             ((org-element-property :use-labels el) ref)
             ((eq (org-element-property :number-lines el) 'continued)
              (+ (org-export-get-loc el info) (line-number-at-pos)))
             (t (line-number-at-pos)))))))
    info 'first-match))
</p>

<p>
(defun org-export-resolve-fuzzy-link (link info)
  "Return LINK destination.
</p>

<p>
INFO is a plist holding contextual information.
</p>

<p>
Return value can be an object, an element, or nil:
</p>

<ul class="org-ul">
<li>If LINK path matches a target object (i.e. <a id="path" name="path"></a>) return it.
</li>

<li>If LINK path exactly matches the name affiliated keyword
\(i.e. #+NAME: path) of an element, return that element.
</li>

<li>If LINK path exactly matches any headline name, return that
element.  If more than one headline share that name, priority
will be given to the one with the closest common ancestor, if
any, or the first one in the parse tree otherwise.
</li>

<li>Otherwise, return nil.
</li>
</ul>

<p>
Assume LINK type is \"fuzzy\".  White spaces are not
significant."
  (let* ((raw-path (org-element-property :path link))
         (match-title-p (eq (aref raw-path 0) ?*))
         ;; Split PATH at white spaces so matches are space
         ;; insensitive.
         (path (org-split-string
                (if match-title-p (substring raw-path 1) raw-path)))
         ;; Cache for destinations that are not position dependent.
         (link-cache
          (or (plist-get info :resolve-fuzzy-link-cache)
              (plist-get (setq info (plist-put info :resolve-fuzzy-link-cache
                                               (make-hash-table :test 'equal)))
</p>
<p>
                     :resolve-fuzzy-link-cache)))
     (cached (gethash path link-cache 'not-found)))
(cond
 ;; Destination is not position dependent: use cached value.
 ((and (not match-title-p) (not (eq cached 'not-found))) cached)
 ;; First try to find a matching "<a id="path" name="path"></a>" unless user specified
 ;; he was looking for a headline (path starts with a "*"
 ;; character).
 ((and (not match-title-p)
       (let ((match (org-element-map (plist-get info :parse-tree) 'target
                      (lambda (blob)
                        (and (equal (org-split-string
                                     (org-element-property :value blob))
                                    path)
                             blob))
                      info 'first-match)))
         (and match (puthash path match link-cache)))))
 ;; Then try to find an element with a matching "#+NAME: path"
 ;; affiliated keyword.
 ((and (not match-title-p)
       (let ((match (org-element-map (plist-get info :parse-tree)
                        org-element-all-elements
                      (lambda (el)
                        (let ((name (org-element-property :name el)))
                          (when (and name
                                     (equal (org-split-string name) path))
                            el)))
                      info 'first-match)))
         (and match (puthash path match link-cache)))))
 ;; Last case: link either points to a headline or to nothingness.
 ;; Try to find the source, with priority given to headlines with
 ;; the closest common ancestor.  If such candidate is found,
 ;; return it, otherwise return nil.
 (t
  (let ((find-headline
         (function
          ;; Return first headline whose `:raw-value' property is
          ;; NAME in parse tree DATA, or nil.  Statistics cookies
          ;; are ignored.
          (lambda (name data)
            (org-element-map data 'headline
              (lambda (headline)
                (when (equal (org-split-string
                              (replace-regexp-in-string
                               "\\[[0-9]+%\\]\\|\\[[0-9]+/[0-9]+\\]" ""
                               (org-element-property :raw-value headline)))
                             name)
                  headline))
              info 'first-match)))))
    ;; Search among headlines sharing an ancestor with link, from
    ;; closest to farthest.
    (catch 'exit
      (mapc
       (lambda (parent)
         (let ((foundp (funcall find-headline path parent)))
           (when foundp (throw 'exit foundp))))
       (let ((parent-hl (org-export-get-parent-headline link)))
         (if (not parent-hl) (list (plist-get info :parse-tree))
           (cons parent-hl (org-export-get-genealogy parent-hl)))))
      ;; No destination found: return nil.
      (and (not match-title-p) (puthash path nil link-cache))))))))
</p>

<p>
(defun org-export-resolve-id-link (link info)
  "Return headline referenced as LINK destination.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
Return value can be the headline element matched in current parse
tree, a file name or nil.  Assume LINK type is either \"id\" or
\"custom-id\"."
  (let ((id (org-element-property :path link)))
    ;; First check if id is within the current parse tree.
    (or (org-element-map (plist-get info :parse-tree) 'headline
          (lambda (headline)
            (when (or (string= (org-element-property :ID headline) id)
                      (string= (org-element-property :CUSTOM<sub>ID</sub> headline) id))
              headline))
          info 'first-match)
        ;; Otherwise, look for external files.
        (cdr (assoc id (plist-get info :id-alist))))))
</p>

<p>
(defun org-export-resolve-radio-link (link info)
  "Return radio-target object referenced as LINK destination.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
Return value can be a radio-target object or nil.  Assume LINK
has type \"radio\"."
  (let ((path (replace-regexp-in-string
               "[ \r\t\n]+" " " (org-element-property :path link))))
    (org-element-map (plist-get info :parse-tree) 'radio-target
      (lambda (radio)
        (and (eq (compare-strings
                  (replace-regexp-in-string
                   "[ \r\t\n]+" " " (org-element-property :value radio))
                  nil nil path nil nil t)
                 t)
             radio))
      info 'first-match)))
</p>


<p>
;;;; For References
;;
;; `org-export-get-ordinal' associates a sequence number to any object
;; or element.
</p>

<p>
(defun org-export-get-ordinal (element info &amp;optional types predicate)
  "Return ordinal number of an element or object.
</p>

<p>
ELEMENT is the element or object considered.  INFO is the plist
used as a communication channel.
</p>

<p>
Optional argument TYPES, when non-nil, is a list of element or
object types, as symbols, that should also be counted in.
Otherwise, only provided element's type is considered.
</p>

<p>
Optional argument PREDICATE is a function returning a non-nil
value if the current element or object should be counted in.  It
accepts two arguments: the element or object being considered and
the plist used as a communication channel.  This allows to count
only a certain type of objects (i.e. inline images).
</p>

<p>
Return value is a list of numbers if ELEMENT is a headline or an
item.  It is nil for keywords.  It represents the footnote number
for footnote definitions and footnote references.  If ELEMENT is
a target, return the same value as if ELEMENT was the closest
table, item or headline containing the target.  In any other
case, return the sequence number of ELEMENT among elements or
objects of the same type."
  ;; Ordinal of a target object refer to the ordinal of the closest
  ;; table, item, or headline containing the object.
  (when (eq (org-element-type element) 'target)
    (setq element
          (loop for parent in (org-export-get-genealogy element)
                when
                (memq
                 (org-element-type parent)
                 '(footnote-definition footnote-reference headline item
                                       table))
                return parent)))
  (case (org-element-type element)
    ;; Special case 1: A headline returns its number as a list.
    (headline (org-export-get-headline-number element info))
    ;; Special case 2: An item returns its number as a list.
    (item (let ((struct (org-element-property :structure element)))
            (org-list-get-item-number
             (org-element-property :begin element)
             struct
             (org-list-prevs-alist struct)
             (org-list-parents-alist struct))))
    ((footnote-definition footnote-reference)
     (org-export-get-footnote-number element info))
    (otherwise
     (let ((counter 0))
       ;; Increment counter until ELEMENT is found again.
       (org-element-map (plist-get info :parse-tree)
           (or types (org-element-type element))
         (lambda (el)
           (cond
            ((eq element el) (1+ counter))
            ((not predicate) (incf counter) nil)
            ((funcall predicate el info) (incf counter) nil)))
         info 'first-match)))))
</p>


<p>
;;;; For Src-Blocks
;;
;; `org-export-get-loc' counts number of code lines accumulated in
;; src-block or example-block elements with a "+n" switch until
;; a given element, excluded.  Note: "-n" switches reset that count.
;;
;; `org-export-unravel-code' extracts source code (along with a code
;; references alist) from an `element-block' or `src-block' type
;; element.
;;
;; `org-export-format-code' applies a formatting function to each line
;; of code, providing relative line number and code reference when
;; appropriate.  Since it doesn't access the original element from
;; which the source code is coming, it expects from the code calling
;; it to know if lines should be numbered and if code references
;; should appear.
;;
;; Eventually, `org-export-format-code-default' is a higher-level
;; function (it makes use of the two previous functions) which handles
;; line numbering and code references inclusion, and returns source
;; code in a format suitable for plain text or verbatim output.
</p>

<p>
(defun org-export-get-loc (element info)
  "Return accumulated lines of code up to ELEMENT.
</p>

<p>
INFO is the plist used as a communication channel.
</p>

<p>
ELEMENT is excluded from count."
  (let ((loc 0))
    (org-element-map (plist-get info :parse-tree)
        `(src-block example-block ,(org-element-type element))
      (lambda (el)
        (cond
         ;; ELEMENT is reached: Quit the loop.
         ((eq el element))
         ;; Only count lines from src-block and example-block elements
         ;; with a "+n" or "-n" switch.  A "-n" switch resets counter.
         ((not (memq (org-element-type el) '(src-block example-block))) nil)
         ((let ((linums (org-element-property :number-lines el)))
            (when linums
              ;; Accumulate locs or reset them.
              (let ((lines (org-count-lines
                            (org-trim (org-element-property :value el)))))
                (setq loc (if (eq linums 'new) lines (+ loc lines))))))
          ;; Return nil to stay in the loop.
          nil)))
      info 'first-match)
    ;; Return value.
    loc))
</p>

<p>
(defun org-export-unravel-code (element)
  "Clean source code and extract references out of it.
</p>

<p>
ELEMENT has either a `src-block' an `example-block' type.
</p>

<p>
Return a cons cell whose CAR is the source code, cleaned from any
reference and protective comma and CDR is an alist between
relative line number (integer) and name of code reference on that
line (string)."
  (let* ((line 0) refs
         ;; Get code and clean it.  Remove blank lines at its
         ;; beginning and end.
         (code (replace-regexp-in-string
                "\\`\\([ \t]*\n\\)+" ""
                (replace-regexp-in-string
                 "\\([ \t]*\n\\)*[ \t]*\\'" "\n"
                 (org-element-property :value element))))
         ;; Get format used for references.
         (label-fmt (regexp-quote
                     (or (org-element-property :label-fmt element)
                         org-coderef-label-format)))
         ;; Build a regexp matching a loc with a reference.
         (with-ref-re
          (format "^.*?\&sect;-.*?\\([ \t]*\\(%s\\)[ \t]*\\)$"
                  (replace-regexp-in-string
                   "%s" "\\([-a-zA-Z0-9_ ]+\\)" label-fmt nil t))))
    ;; Return value.
    (cons
     ;; Code with references removed.
     (org-element-normalize-string
      (mapconcat
       (lambda (loc)
         (incf line)
         (if (not (string-match with-ref-re loc)) loc
           ;; Ref line: remove ref, and signal its position in REFS.
           (push (cons line (match-string 3 loc)) refs)
           (replace-match "" nil nil loc 1)))
       (org-split-string code "\n") "\n"))
     ;; Reference alist.
     refs)))
</p>

<p>
(defun org-export-format-code (code fun &amp;optional num-lines ref-alist)
  "Format CODE by applying FUN line-wise and return it.
</p>

<p>
CODE is a string representing the code to format.  FUN is
a function.  It must accept three arguments: a line of
code (string), the current line number (integer) or nil and the
reference associated to the current line (string) or nil.
</p>

<p>
Optional argument NUM-LINES can be an integer representing the
number of code lines accumulated until the current code.  Line
numbers passed to FUN will take it into account.  If it is nil,
FUN's second argument will always be nil.  This number can be
obtained with `org-export-get-loc' function.
</p>

<p>
Optional argument REF-ALIST can be an alist between relative line
number (i.e. ignoring NUM-LINES) and the name of the code
reference on it.  If it is nil, FUN's third argument will always
be nil.  It can be obtained through the use of
`org-export-unravel-code' function."
  (let ((&#x2013;locs (org-split-string code "\n"))
        (&#x2013;line 0))
    (org-element-normalize-string
     (mapconcat
      (lambda (&#x2013;loc)
        (incf &#x2013;line)
        (let ((&#x2013;ref (cdr (assq &#x2013;line ref-alist))))
          (funcall fun &#x2013;loc (and num-lines (+ num-lines &#x2013;line)) &#x2013;ref)))
      &#x2013;locs "\n"))))
</p>

<p>
(defun org-export-format-code-default (element info)
  "Return source code from ELEMENT, formatted in a standard way.
</p>

<p>
ELEMENT is either a `src-block' or `example-block' element.  INFO
is a plist used as a communication channel.
</p>

<p>
This function takes care of line numbering and code references
inclusion.  Line numbers, when applicable, appear at the
beginning of the line, separated from the code by two white
spaces.  Code references, on the other hand, appear flushed to
the right, separated by six white spaces from the widest line of
code."
  ;; Extract code and references.
  (let* ((code-info (org-export-unravel-code element))
         (code (car code-info))
         (code-lines (org-split-string code "\n")))
    (if (null code-lines) ""
      (let* ((refs (and (org-element-property :retain-labels element)
                        (cdr code-info)))
             ;; Handle line numbering.
             (num-start (case (org-element-property :number-lines element)
                          (continued (org-export-get-loc element info))
                          (new 0)))
             (num-fmt
              (and num-start
                   (format "%%%ds  "
                           (length (number-to-string
                                    (+ (length code-lines) num-start))))))
             ;; Prepare references display, if required.  Any reference
             ;; should start six columns after the widest line of code,
             ;; wrapped with parenthesis.
             (max-width
              (+ (apply 'max (mapcar 'length code-lines))
                 (if (not num-start) 0 (length (format num-fmt num-start))))))
        (org-export-format-code
         code
         (lambda (loc line-num ref)
           (let ((number-str (and num-fmt (format num-fmt line-num))))
             (concat
              number-str
              loc
              (and ref
                   (concat (make-string
                            (- (+ 6 max-width)
                               (+ (length loc) (length number-str))) ? )
                           (format "(%s)" ref))))))
         num-start refs)))))
</p>


<p>
;;;; For Tables
;;
;; `org-export-table-has-special-column-p' and and
;; `org-export-table-row-is-special-p' are predicates used to look for
;; meta-information about the table structure.
;;
;; `org-table-has-header-p' tells when the rows before the first rule
;;  should be considered as table's header.
;;
;; `org-export-table-cell-width', `org-export-table-cell-alignment'
;; and `org-export-table-cell-borders' extract information from
;; a table-cell element.
;;
;; `org-export-table-dimensions' gives the number on rows and columns
;; in the table, ignoring horizontal rules and special columns.
;; `org-export-table-cell-address', given a table-cell object, returns
;; the absolute address of a cell. On the other hand,
;; `org-export-get-table-cell-at' does the contrary.
;;
;; `org-export-table-cell-starts-colgroup-p',
;; `org-export-table-cell-ends-colgroup-p',
;; `org-export-table-row-starts-rowgroup-p',
;; `org-export-table-row-ends-rowgroup-p',
;; `org-export-table-row-starts-header-p' and
;; `org-export-table-row-ends-header-p' indicate position of current
;; row or cell within the table.
</p>

<p>
(defun org-export-table-has-special-column-p (table)
  "Non-nil when TABLE has a special column.
All special columns will be ignored during export."
  ;; The table has a special column when every first cell of every row
  ;; has an empty value or contains a symbol among "/", "#", "!", "$",
  ;; "*" "_" and "^".  Though, do not consider a first row containing
  ;; only empty cells as special.
  (let ((special-column-p 'empty))
    (catch 'exit
      (mapc
       (lambda (row)
         (when (eq (org-element-property :type row) 'standard)
           (let ((value (org-element-contents
                         (car (org-element-contents row)))))
             (cond ((member value '(("/") ("#") ("!") ("$") ("*") ("_") ("^")))
                    (setq special-column-p 'special))
                   ((not value))
                   (t (throw 'exit nil))))))
       (org-element-contents table))
      (eq special-column-p 'special))))
</p>

<p>
(defun org-export-table-has-header-p (table info)
  "Non-nil when TABLE has a header.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
A table has a header when it contains at least two row groups."
  (let ((cache (or (plist-get info :table-header-cache)
                   (plist-get (setq info
                                    (plist-put info :table-header-cache
                                               (make-hash-table :test 'eq)))
</p>
<p>
                          :table-header-cache))))
(or (gethash table cache)
    (let ((rowgroup 1) row-flag)
      (puthash
       table
       (org-element-map table 'table-row
         (lambda (row)
           (cond
            ((&gt; rowgroup 1) t)
            ((and row-flag (eq (org-element-property :type row) 'rule))
             (incf rowgroup) (setq row-flag nil))
            ((and (not row-flag) (eq (org-element-property :type row)
                                     'standard))
             (setq row-flag t) nil)))
         info 'first-match)
       cache)))))
</p>

<p>
(defun org-export-table-row-is-special-p (table-row info)
  "Non-nil if TABLE-ROW is considered special.
</p>

<p>
INFO is a plist used as the communication channel.
</p>

<p>
All special rows will be ignored during export."
  (when (eq (org-element-property :type table-row) 'standard)
    (let ((first-cell (org-element-contents
                       (car (org-element-contents table-row)))))
      ;; A row is special either when&#x2026;
      (or
       ;; &#x2026; it starts with a field only containing "/",
       (equal first-cell '("/"))
       ;; &#x2026; the table contains a special column and the row start
       ;; with a marking character among, "^", "_", "$" or "!",
       (and (org-export-table-has-special-column-p
             (org-export-get-parent table-row))
            (member first-cell '(("^") ("_") ("$") ("!"))))
       ;; &#x2026; it contains only alignment cookies and empty cells.
       (let ((special-row-p 'empty))
         (catch 'exit
           (mapc
            (lambda (cell)
              (let ((value (org-element-contents cell)))
                ;; Since VALUE is a secondary string, the following
                ;; checks avoid expanding it with `org-export-data'.
                (cond ((not value))
                      ((and (not (cdr value))
                            (stringp (car value))
                            (string-match "\\`&lt;[lrc]?\\([0-9]+\\)?&gt;\\'"
                                          (car value)))
                       (setq special-row-p 'cookie))
                      (t (throw 'exit nil)))))
            (org-element-contents table-row))
           (eq special-row-p 'cookie)))))))
</p>

<p>
(defun org-export-table-row-group (table-row info)
  "Return TABLE-ROW's group number, as an integer.
</p>

<p>
INFO is a plist used as the communication channel.
</p>

<p>
Return value is the group number, as an integer, or nil for
special rows and rows separators.  First group is also table's
header."
  (let ((cache (or (plist-get info :table-row-group-cache)
                   (plist-get (setq info
                                    (plist-put info :table-row-group-cache
                                               (make-hash-table :test 'eq)))
</p>
<p>
                          :table-row-group-cache))))
(cond ((gethash table-row cache))
      ((eq (org-element-property :type table-row) 'rule) nil)
      (t (let ((group 0) row-flag)
           (org-element-map (org-export-get-parent table-row) 'table-row
             (lambda (row)
               (if (eq (org-element-property :type row) 'rule)
                   (setq row-flag nil)
                 (unless row-flag (incf group) (setq row-flag t)))
               (when (eq table-row row) (puthash table-row group cache)))
             info 'first-match))))))
</p>

<p>
(defun org-export-table-cell-width (table-cell info)
  "Return TABLE-CELL contents width.
</p>

<p>
INFO is a plist used as the communication channel.
</p>

<p>
Return value is the width given by the last width cookie in the
same column as TABLE-CELL, or nil."
  (let* ((row (org-export-get-parent table-cell))
         (table (org-export-get-parent row))
         (cells (org-element-contents row))
         (columns (length cells))
         (column (- columns (length (memq table-cell cells))))
         (cache (or (plist-get info :table-cell-width-cache)
                    (plist-get (setq info
                                     (plist-put info :table-cell-width-cache
                                                (make-hash-table :test 'eq)))
</p>
<p>
                           :table-cell-width-cache)))
     (width-vector (or (gethash table cache)
                       (puthash table (make-vector columns 'empty) cache)))
     (value (aref width-vector column)))
(if (not (eq value 'empty)) value
  (let (cookie-width)
    (dolist (row (org-element-contents table)
                 (aset width-vector column cookie-width))
      (when (org-export-table-row-is-special-p row info)
        ;; In a special row, try to find a width cookie at COLUMN.
        (let* ((value (org-element-contents
                       (elt (org-element-contents row) column)))
               (cookie (car value)))
          ;; The following checks avoid expanding unnecessarily
          ;; the cell with `org-export-data'.
          (when (and value
                     (not (cdr value))
                     (stringp cookie)
                     (string-match "\\`&lt;[lrc]?\\([0-9]+\\)?&gt;\\'" cookie)
                     (match-string 1 cookie))
            (setq cookie-width
                  (string-to-number (match-string 1 cookie)))))))))))
</p>

<p>
(defun org-export-table-cell-alignment (table-cell info)
  "Return TABLE-CELL contents alignment.
</p>

<p>
INFO is a plist used as the communication channel.
</p>

<p>
Return alignment as specified by the last alignment cookie in the
same column as TABLE-CELL.  If no such cookie is found, a default
alignment value will be deduced from fraction of numbers in the
column (see `org-table-number-fraction' for more information).
Possible values are `left', `right' and `center'."
  ;; Load `org-table-number-fraction' and `org-table-number-regexp'.
  (require 'org-table)
  (let* ((row (org-export-get-parent table-cell))
         (table (org-export-get-parent row))
         (cells (org-element-contents row))
         (columns (length cells))
         (column (- columns (length (memq table-cell cells))))
         (cache (or (plist-get info :table-cell-alignment-cache)
                    (plist-get (setq info
                                     (plist-put info :table-cell-alignment-cache
                                                (make-hash-table :test 'eq)))
</p>
<p>
                           :table-cell-alignment-cache)))
     (align-vector (or (gethash table cache)
                       (puthash table (make-vector columns nil) cache))))
(or (aref align-vector column)
    (let ((number-cells 0)
          (total-cells 0)
          cookie-align
          previous-cell-number-p)
      (dolist (row (org-element-contents (org-export-get-parent row)))
        (cond
         ;; In a special row, try to find an alignment cookie at
         ;; COLUMN.
         ((org-export-table-row-is-special-p row info)
          (let ((value (org-element-contents
                        (elt (org-element-contents row) column))))
            ;; Since VALUE is a secondary string, the following
            ;; checks avoid useless expansion through
            ;; `org-export-data'.
            (when (and value
                       (not (cdr value))
                       (stringp (car value))
                       (string-match "\\`&lt;\\([lrc]\\)?\\([0-9]+\\)?&gt;\\'"
                                     (car value))
                       (match-string 1 (car value)))
              (setq cookie-align (match-string 1 (car value))))))
         ;; Ignore table rules.
         ((eq (org-element-property :type row) 'rule))
         ;; In a standard row, check if cell's contents are
         ;; expressing some kind of number.  Increase NUMBER-CELLS
         ;; accordingly.  Though, don't bother if an alignment
         ;; cookie has already defined cell's alignment.
         ((not cookie-align)
          (let ((value (org-export-data
                        (org-element-contents
                         (elt (org-element-contents row) column))
                        info)))
            (incf total-cells)
            ;; Treat an empty cell as a number if it follows
            ;; a number.
            (if (not (or (string-match org-table-number-regexp value)
                         (and (string= value "") previous-cell-number-p)))
                (setq previous-cell-number-p nil)
              (setq previous-cell-number-p t)
              (incf number-cells))))))
      ;; Return value.  Alignment specified by cookies has
      ;; precedence over alignment deduced from cell's contents.
      (aset align-vector
            column
            (cond ((equal cookie-align "l") 'left)
                  ((equal cookie-align "r") 'right)
                  ((equal cookie-align "c") 'center)
                  ((&gt;= (/ (float number-cells) total-cells)
                       org-table-number-fraction)
                   'right)
                  (t 'left)))))))
</p>

<p>
(defun org-export-table-cell-borders (table-cell info)
  "Return TABLE-CELL borders.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
Return value is a list of symbols, or nil.  Possible values are:
`top', `bottom', `above', `below', `left' and `right'.  Note:
`top' (resp. `bottom') only happen for a cell in the first
row (resp. last row) of the table, ignoring table rules, if any.
</p>

<p>
Returned borders ignore special rows."
  (let* ((row (org-export-get-parent table-cell))
         (table (org-export-get-parent-table table-cell))
         borders)
    ;; Top/above border?  TABLE-CELL has a border above when a rule
    ;; used to demarcate row groups can be found above.  Hence,
    ;; finding a rule isn't sufficient to push `above' in BORDERS:
    ;; another regular row has to be found above that rule.
    (let (rule-flag)
      (catch 'exit
        (mapc (lambda (row)
                (cond ((eq (org-element-property :type row) 'rule)
                       (setq rule-flag t))
                      ((not (org-export-table-row-is-special-p row info))
                       (if rule-flag (throw 'exit (push 'above borders))
                         (throw 'exit nil)))))
              ;; Look at every row before the current one.
              (cdr (memq row (reverse (org-element-contents table)))))
        ;; No rule above, or rule found starts the table (ignoring any
        ;; special row): TABLE-CELL is at the top of the table.
        (when rule-flag (push 'above borders))
        (push 'top borders)))
    ;; Bottom/below border? TABLE-CELL has a border below when next
    ;; non-regular row below is a rule.
    (let (rule-flag)
      (catch 'exit
        (mapc (lambda (row)
                (cond ((eq (org-element-property :type row) 'rule)
                       (setq rule-flag t))
                      ((not (org-export-table-row-is-special-p row info))
                       (if rule-flag (throw 'exit (push 'below borders))
                         (throw 'exit nil)))))
              ;; Look at every row after the current one.
              (cdr (memq row (org-element-contents table))))
        ;; No rule below, or rule found ends the table (modulo some
        ;; special row): TABLE-CELL is at the bottom of the table.
        (when rule-flag (push 'below borders))
        (push 'bottom borders)))
    ;; Right/left borders?  They can only be specified by column
    ;; groups.  Column groups are defined in a row starting with "/".
    ;; Also a column groups row only contains "&lt;", "&lt;&gt;", "&gt;" or blank
    ;; cells.
    (catch 'exit
      (let ((column (let ((cells (org-element-contents row)))
                      (- (length cells) (length (memq table-cell cells))))))
        (mapc
         (lambda (row)
           (unless (eq (org-element-property :type row) 'rule)
             (when (equal (org-element-contents
                           (car (org-element-contents row)))
                          '("/"))
               (let ((column-groups
                      (mapcar
                       (lambda (cell)
                         (let ((value (org-element-contents cell)))
                           (when (member value '(("&lt;") ("&lt;&gt;") ("&gt;") nil))
                             (car value))))
                       (org-element-contents row))))
                 ;; There's a left border when previous cell, if
                 ;; any, ends a group, or current one starts one.
                 (when (or (and (not (zerop column))
                                (member (elt column-groups (1- column))
                                        '("&gt;" "&lt;&gt;")))
                           (member (elt column-groups column) '("&lt;" "&lt;&gt;")))
                   (push 'left borders))
                 ;; There's a right border when next cell, if any,
                 ;; starts a group, or current one ends one.
                 (when (or (and (/= (1+ column) (length column-groups))
                                (member (elt column-groups (1+ column))
                                        '("&lt;" "&lt;&gt;")))
                           (member (elt column-groups column) '("&gt;" "&lt;&gt;")))
                   (push 'right borders))
                 (throw 'exit nil)))))
         ;; Table rows are read in reverse order so last column groups
         ;; row has precedence over any previous one.
         (reverse (org-element-contents table)))))
    ;; Return value.
    borders))
</p>

<p>
(defun org-export-table-cell-starts-colgroup-p (table-cell info)
  "Non-nil when TABLE-CELL is at the beginning of a row group.
INFO is a plist used as a communication channel."
  ;; A cell starts a column group either when it is at the beginning
  ;; of a row (or after the special column, if any) or when it has
  ;; a left border.
  (or (eq (org-element-map (org-export-get-parent table-cell) 'table-cell
            'identity info 'first-match)
          table-cell)
      (memq 'left (org-export-table-cell-borders table-cell info))))
</p>

<p>
(defun org-export-table-cell-ends-colgroup-p (table-cell info)
  "Non-nil when TABLE-CELL is at the end of a row group.
INFO is a plist used as a communication channel."
  ;; A cell ends a column group either when it is at the end of a row
  ;; or when it has a right border.
  (or (eq (car (last (org-element-contents
                         (org-export-get-parent table-cell))))
             table-cell)
      (memq 'right (org-export-table-cell-borders table-cell info))))
</p>

<p>
(defun org-export-table-row-starts-rowgroup-p (table-row info)
  "Non-nil when TABLE-ROW is at the beginning of a column group.
INFO is a plist used as a communication channel."
  (unless (or (eq (org-element-property :type table-row) 'rule)
              (org-export-table-row-is-special-p table-row info))
    (let ((borders (org-export-table-cell-borders
                    (car (org-element-contents table-row)) info)))
      (or (memq 'top borders) (memq 'above borders)))))
</p>

<p>
(defun org-export-table-row-ends-rowgroup-p (table-row info)
  "Non-nil when TABLE-ROW is at the end of a column group.
INFO is a plist used as a communication channel."
  (unless (or (eq (org-element-property :type table-row) 'rule)
              (org-export-table-row-is-special-p table-row info))
    (let ((borders (org-export-table-cell-borders
                    (car (org-element-contents table-row)) info)))
      (or (memq 'bottom borders) (memq 'below borders)))))
</p>

<p>
(defun org-export-table-row-starts-header-p (table-row info)
  "Non-nil when TABLE-ROW is the first table header's row.
INFO is a plist used as a communication channel."
  (and (org-export-table-has-header-p
        (org-export-get-parent-table table-row) info)
       (org-export-table-row-starts-rowgroup-p table-row info)
       (= (org-export-table-row-group table-row info) 1)))
</p>

<p>
(defun org-export-table-row-ends-header-p (table-row info)
  "Non-nil when TABLE-ROW is the last table header's row.
INFO is a plist used as a communication channel."
  (and (org-export-table-has-header-p
        (org-export-get-parent-table table-row) info)
       (org-export-table-row-ends-rowgroup-p table-row info)
       (= (org-export-table-row-group table-row info) 1)))
</p>

<p>
(defun org-export-table-row-number (table-row info)
  "Return TABLE-ROW number.
INFO is a plist used as a communication channel.  Return value is
zero-based and ignores separators.  The function returns nil for
special columns and separators."
  (when (and (eq (org-element-property :type table-row) 'standard)
             (not (org-export-table-row-is-special-p table-row info)))
    (let ((number 0))
      (org-element-map (org-export-get-parent-table table-row) 'table-row
        (lambda (row)
          (cond ((eq row table-row) number)
                ((eq (org-element-property :type row) 'standard)
                 (incf number) nil)))
        info 'first-match))))
</p>

<p>
(defun org-export-table-dimensions (table info)
  "Return TABLE dimensions.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
Return value is a CONS like (ROWS . COLUMNS) where
ROWS (resp. COLUMNS) is the number of exportable
rows (resp. columns)."
  (let (first-row (columns 0) (rows 0))
    ;; Set number of rows, and extract first one.
    (org-element-map table 'table-row
      (lambda (row)
        (when (eq (org-element-property :type row) 'standard)
          (incf rows)
          (unless first-row (setq first-row row)))) info)
    ;; Set number of columns.
    (org-element-map first-row 'table-cell (lambda (cell) (incf columns)) info)
    ;; Return value.
    (cons rows columns)))
</p>

<p>
(defun org-export-table-cell-address (table-cell info)
  "Return address of a regular TABLE-CELL object.
</p>

<p>
TABLE-CELL is the cell considered.  INFO is a plist used as
a communication channel.
</p>

<p>
Address is a CONS cell (ROW . COLUMN), where ROW and COLUMN are
zero-based index.  Only exportable cells are considered.  The
function returns nil for other cells."
  (let* ((table-row (org-export-get-parent table-cell))
         (row-number (org-export-table-row-number table-row info)))
    (when row-number
      (cons row-number
            (let ((col-count 0))
              (org-element-map table-row 'table-cell
                (lambda (cell)
                  (if (eq cell table-cell) col-count (incf col-count) nil))
                info 'first-match))))))
</p>

<p>
(defun org-export-get-table-cell-at (address table info)
  "Return regular table-cell object at ADDRESS in TABLE.
</p>

<p>
Address is a CONS cell (ROW . COLUMN), where ROW and COLUMN are
zero-based index.  TABLE is a table type element.  INFO is
a plist used as a communication channel.
</p>

<p>
If no table-cell, among exportable cells, is found at ADDRESS,
return nil."
  (let ((column-pos (cdr address)) (column-count 0))
    (org-element-map
        ;; Row at (car address) or nil.
        (let ((row-pos (car address)) (row-count 0))
          (org-element-map table 'table-row
            (lambda (row)
              (cond ((eq (org-element-property :type row) 'rule) nil)
                    ((= row-count row-pos) row)
                    (t (incf row-count) nil)))
            info 'first-match))
        'table-cell
      (lambda (cell)
        (if (= column-count column-pos) cell
          (incf column-count) nil))
      info 'first-match)))
</p>


<p>
;;;; For Tables Of Contents
;;
;; `org-export-collect-headlines' builds a list of all exportable
;; headline elements, maybe limited to a certain depth.  One can then
;; easily parse it and transcode it.
;;
;; Building lists of tables, figures or listings is quite similar.
;; Once the generic function `org-export-collect-elements' is defined,
;; `org-export-collect-tables', `org-export-collect-figures' and
;; `org-export-collect-listings' can be derived from it.
</p>

<p>
(defun org-export-collect-headlines (info &amp;optional n)
  "Collect headlines in order to build a table of contents.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
When optional argument N is an integer, it specifies the depth of
the table of contents.  Otherwise, it is set to the value of the
last headline level.  See `org-export-headline-levels' for more
information.
</p>

<p>
Return a list of all exportable headlines as parsed elements.
Footnote sections, if any, will be ignored."
  (let ((limit (plist-get info :headline-levels)))
    (setq n (if (wholenump n) (min n limit) limit))
    (org-element-map (plist-get info :parse-tree) 'headline
      #'(lambda (headline)
          (unless (org-element-property :footnote-section-p headline)
            (let ((level (org-export-get-relative-level headline info)))
              (and (&lt;= level n) headline))))
      info)))
</p>

<p>
(defun org-export-collect-elements (type info &amp;optional predicate)
  "Collect referenceable elements of a determined type.
</p>

<p>
TYPE can be a symbol or a list of symbols specifying element
types to search.  Only elements with a caption are collected.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
When non-nil, optional argument PREDICATE is a function accepting
one argument, an element of type TYPE.  It returns a non-nil
value when that element should be collected.
</p>

<p>
Return a list of all elements found, in order of appearance."
  (org-element-map (plist-get info :parse-tree) type
    (lambda (element)
      (and (org-element-property :caption element)
           (or (not predicate) (funcall predicate element))
           element))
    info))
</p>

<p>
(defun org-export-collect-tables (info)
  "Build a list of tables.
INFO is a plist used as a communication channel.
</p>

<p>
Return a list of table elements with a caption."
  (org-export-collect-elements 'table info))
</p>

<p>
(defun org-export-collect-figures (info predicate)
  "Build a list of figures.
</p>

<p>
INFO is a plist used as a communication channel.  PREDICATE is
a function which accepts one argument: a paragraph element and
whose return value is non-nil when that element should be
collected.
</p>

<p>
A figure is a paragraph type element, with a caption, verifying
PREDICATE.  The latter has to be provided since a \"figure\" is
a vague concept that may depend on back-end.
</p>

<p>
Return a list of elements recognized as figures."
  (org-export-collect-elements 'paragraph info predicate))
</p>

<p>
(defun org-export-collect-listings (info)
  "Build a list of src blocks.
</p>

<p>
INFO is a plist used as a communication channel.
</p>

<p>
Return a list of src-block elements with a caption."
  (org-export-collect-elements 'src-block info))
</p>


<p>
;;;; Smart Quotes
;;
;; The main function for the smart quotes sub-system is
;; `org-export-activate-smart-quotes', which replaces every quote in
;; a given string from the parse tree with its "smart" counterpart.
;;
;; Dictionary for smart quotes is stored in
;; `org-export-smart-quotes-alist'.
;;
;; Internally, regexps matching potential smart quotes (checks at
;; string boundaries are also necessary) are defined in
;; `org-export-smart-quotes-regexps'.
</p>

<p>
(defconst org-export-smart-quotes-alist
  '(("da"
     ;; one may use: &#x2026;, "&#x2026;", &#x2026;, or '&#x2026;'.
     ;; <a href="http://sproget.dk/raad-og-regler/retskrivningsregler/retskrivningsregler/a7-40-60/a7-58-anforselstegn/">http://sproget.dk/raad-og-regler/retskrivningsregler/retskrivningsregler/a7-40-60/a7-58-anforselstegn/</a>
     ;; LaTeX quotes require Babel!
     (opening-double-quote :utf-8 "" :html "&amp;raquo;" :latex "&gt;&gt;"
</p>
<p>
                      :texinfo "@guillemetright{}")
(closing-double-quote :utf-8 "" :html "&amp;laquo;" :latex "&lt;&lt;"
</p>
<p>
                      :texinfo "@guillemetleft{}")
(opening-single-quote :utf-8 "" :html "&amp;rsaquo;" :latex "\\frq{}"
</p>
<p>
                      :texinfo "@guilsinglright{}")
(closing-single-quote :utf-8 "" :html "&amp;lsaquo;" :latex "\\flq{}"
</p>
<p>
                       :texinfo "@guilsingleft{}")
 (apostrophe :utf-8 "" :html "&amp;rsquo;"))
("de"
 (opening-double-quote :utf-8 "" :html "&amp;bdquo;" :latex "\"`"
</p>
<p>
                      :texinfo "@quotedblbase{}")
(closing-double-quote :utf-8 "" :html "&amp;ldquo;" :latex "\"'"
</p>
<p>
                      :texinfo "@quotedblleft{}")
(opening-single-quote :utf-8 "" :html "&amp;sbquo;" :latex "\\glq{}"
</p>
<p>
                      :texinfo "@quotesinglbase{}")
(closing-single-quote :utf-8 "" :html "&amp;lsquo;" :latex "\\grq{}"
</p>
<p>
                       :texinfo "@quoteleft{}")
 (apostrophe :utf-8 "" :html "&amp;rsquo;"))
("en"
 (opening-double-quote :utf-8 "" :html "&amp;ldquo;" :latex "``" :texinfo "``")
 (closing-double-quote :utf-8 "" :html "&amp;rdquo;" :latex "''" :texinfo "''")
 (opening-single-quote :utf-8 "" :html "&amp;lsquo;" :latex "`" :texinfo "`")
 (closing-single-quote :utf-8 "" :html "&amp;rsquo;" :latex "'" :texinfo "'")
 (apostrophe :utf-8 "" :html "&amp;rsquo;"))
("es"
 (opening-double-quote :utf-8 "" :html "&amp;laquo;" :latex "\\guillemotleft{}"
</p>
<p>
                      :texinfo "@guillemetleft{}")
(closing-double-quote :utf-8 "" :html "&amp;raquo;" :latex "\\guillemotright{}"
</p>
<p>
                       :texinfo "@guillemetright{}")
 (opening-single-quote :utf-8 "" :html "&amp;ldquo;" :latex "``" :texinfo "``")
 (closing-single-quote :utf-8 "" :html "&amp;rdquo;" :latex "''" :texinfo "''")
 (apostrophe :utf-8 "" :html "&amp;rsquo;"))
("fr"
 (opening-double-quote :utf-8 "" :html "&amp;laquo;&amp;nbsp;" :latex "\\og "
</p>
<p>
                      :texinfo "@guillemetleft{}@tie{}")
(closing-double-quote :utf-8 "" :html "&amp;nbsp;&amp;raquo;" :latex "\\fg{}"
</p>
<p>
                      :texinfo "@tie{}@guillemetright{}")
(opening-single-quote :utf-8 "" :html "&amp;laquo;&amp;nbsp;" :latex "\\og "
</p>
<p>
                      :texinfo "@guillemetleft{}@tie{}")
(closing-single-quote :utf-8 "" :html "&amp;nbsp;&amp;raquo;" :latex "\\fg{}"
</p>
<p>
                       :texinfo "@tie{}@guillemetright{}")
 (apostrophe :utf-8 "" :html "&amp;rsquo;"))
("no"
 ;; <a href="https://nn.wikipedia.org/wiki/Sitatteikn">https://nn.wikipedia.org/wiki/Sitatteikn</a>
 (opening-double-quote :utf-8 "" :html "&amp;laquo;" :latex "\\guillemotleft{}"
</p>
<p>
                      :texinfo "@guillemetleft{}")
(closing-double-quote :utf-8 "" :html "&amp;raquo;" :latex "\\guillemotright{}"
</p>
<p>
                       :texinfo "@guillemetright{}")
 (opening-single-quote :utf-8 "" :html "&amp;lsquo;" :latex "`" :texinfo "`")
 (closing-single-quote :utf-8 "" :html "&amp;rsquo;" :latex "'" :texinfo "'")
 (apostrophe :utf-8 "" :html "&amp;rsquo;"))
("nb"
 ;; <a href="https://nn.wikipedia.org/wiki/Sitatteikn">https://nn.wikipedia.org/wiki/Sitatteikn</a>
 (opening-double-quote :utf-8 "" :html "&amp;laquo;" :latex "\\guillemotleft{}"
</p>
<p>
                      :texinfo "@guillemetleft{}")
(closing-double-quote :utf-8 "" :html "&amp;raquo;" :latex "\\guillemotright{}"
</p>
<p>
                       :texinfo "@guillemetright{}")
 (opening-single-quote :utf-8 "" :html "&amp;lsquo;" :latex "`" :texinfo "`")
 (closing-single-quote :utf-8 "" :html "&amp;rsquo;" :latex "'" :texinfo "'")
 (apostrophe :utf-8 "" :html "&amp;rsquo;"))
("nn"
 ;; <a href="https://nn.wikipedia.org/wiki/Sitatteikn">https://nn.wikipedia.org/wiki/Sitatteikn</a>
 (opening-double-quote :utf-8 "" :html "&amp;laquo;" :latex "\\guillemotleft{}"
</p>
<p>
                      :texinfo "@guillemetleft{}")
(closing-double-quote :utf-8 "" :html "&amp;raquo;" :latex "\\guillemotright{}"
</p>
<p>
                         :texinfo "@guillemetright{}")
   (opening-single-quote :utf-8 "" :html "&amp;lsquo;" :latex "`" :texinfo "`")
   (closing-single-quote :utf-8 "" :html "&amp;rsquo;" :latex "'" :texinfo "'")
   (apostrophe :utf-8 "" :html "&amp;rsquo;"))
  ("sv"
   ;; based on <a href="https://sv.wikipedia.org/wiki/Citattecken">https://sv.wikipedia.org/wiki/Citattecken</a>
   (opening-double-quote :utf-8 "" :html "&amp;rdquo;" :latex "" :texinfo "")
   (closing-double-quote :utf-8 "" :html "&amp;rdquo;" :latex "" :texinfo "")
   (opening-single-quote :utf-8 "" :html "&amp;rsquo;" :latex "" :texinfo "`")
   (closing-single-quote :utf-8 "" :html "&amp;rsquo;" :latex "" :texinfo "'")
   (apostrophe :utf-8 "" :html "&amp;rsquo;"))
  )
"Smart quotes translations.
</p>

<p>
Alist whose CAR is a language string and CDR is an alist with
quote type as key and a plist associating various encodings to
their translation as value.
</p>

<p>
A quote type can be any symbol among `opening-double-quote',
`closing-double-quote', `opening-single-quote',
`closing-single-quote' and `apostrophe'.
</p>

<p>
Valid encodings include `:utf-8', `:html', `:latex' and
`:texinfo'.
</p>

<p>
If no translation is found, the quote character is left as-is.")
</p>

<p>
(defconst org-export-smart-quotes-regexps
  (list
   ;; Possible opening quote at beginning of string.
   "\\`\\([\"']\\)\\(\\w\\|\\s.\\|\\s_\\|\\s(\\)"
   ;; Possible closing quote at beginning of string.
   "\\`\\([\"']\\)\\(\\s-\\|\\s)\\|\\s.\\)"
   ;; Possible apostrophe at beginning of string.
   "\\`\\('\\)\&sect;-"
   ;; Opening single and double quotes.
   "\\(?:\\s-\\|\\s(\\)\\([\"']\\)\\(?:\\w\\|\\s.\\|\\s_\\)"
   ;; Closing single and double quotes.
   "\\(?:\\w\\|\\s.\\|\\s_\\)\\([\"']\\)\\(?:\\s-\\|\\s)\\|\\s.\\)"
   ;; Apostrophe.
   "\&sect;-\\('\\)\&sect;-"
   ;; Possible opening quote at end of string.
   "\\(?:\\s-\\|\\s(\\)\\([\"']\\)\\'"
   ;; Possible closing quote at end of string.
   "\\(?:\\w\\|\\s.\\|\\s_\\)\\([\"']\\)\\'"
   ;; Possible apostrophe at end of string.
   "\&sect;-\\('\\)\\'")
  "List of regexps matching a quote or an apostrophe.
In every regexp, quote or apostrophe matched is put in group 1.")
</p>

<p>
(defun org-export-activate-smart-quotes (s encoding info &amp;optional original)
  "Replace regular quotes with \"smart\" quotes in string S.
</p>

<p>
ENCODING is a symbol among `:html', `:latex', `:texinfo' and
`:utf-8'.  INFO is a plist used as a communication channel.
</p>

<p>
The function has to retrieve information about string
surroundings in parse tree.  It can only happen with an
unmodified string.  Thus, if S has already been through another
process, a non-nil ORIGINAL optional argument will provide that
original string.
</p>

<p>
Return the new string."
  (if (equal s "") ""
    (let* ((prev (org-export-get-previous-element (or original s) info))
           ;; Try to be flexible when computing number of blanks
           ;; before object.  The previous object may be a string
           ;; introduced by the back-end and not completely parsed.
           (pre-blank (and prev
                           (or (org-element-property :post-blank prev)
                               ;; A string with missing `:post-blank'
                               ;; property.
                               (and (stringp prev)
                                    (string-match " *\\'" prev)
                                    (length (match-string 0 prev)))
                               ;; Fallback value.
                               0)))
           (next (org-export-get-next-element (or original s) info))
           (get-smart-quote
            (lambda (q type)
              ;; Return smart quote associated to a give quote Q, as
              ;; a string.  TYPE is a symbol among `open', `close' and
              ;; `apostrophe'.
              (let ((key (case type
                           (apostrophe 'apostrophe)
                           (open (if (equal "'" q) 'opening-single-quote
                                   'opening-double-quote))
                           (otherwise (if (equal "'" q) 'closing-single-quote
                                        'closing-double-quote)))))
                (or (plist-get
                     (cdr (assq key
                                (cdr (assoc (plist-get info :language)
                                            org-export-smart-quotes-alist))))
                     encoding)
                    q)))))
      (if (or (equal "\"" s) (equal "'" s))
          ;; Only a quote: no regexp can match.  We have to check both
          ;; sides and decide what to do.
          (cond ((and (not prev) (not next)) s)
                ((not prev) (funcall get-smart-quote s 'open))
                ((and (not next) (zerop pre-blank))
                 (funcall get-smart-quote s 'close))
                ((not next) s)
                ((zerop pre-blank) (funcall get-smart-quote s 'apostrophe))
                (t (funcall get-smart-quote 'open)))
        ;; 1. Replace quote character at the beginning of S.
        (cond
         ;; Apostrophe?
         ((and prev (zerop pre-blank)
               (string-match (nth 2 org-export-smart-quotes-regexps) s))
          (setq s (replace-match
                   (funcall get-smart-quote (match-string 1 s) 'apostrophe)
                   nil t s 1)))
         ;; Closing quote?
         ((and prev (zerop pre-blank)
               (string-match (nth 1 org-export-smart-quotes-regexps) s))
          (setq s (replace-match
                   (funcall get-smart-quote (match-string 1 s) 'close)
                   nil t s 1)))
         ;; Opening quote?
         ((and (or (not prev) (&gt; pre-blank 0))
               (string-match (nth 0 org-export-smart-quotes-regexps) s))
          (setq s (replace-match
                   (funcall get-smart-quote (match-string 1 s) 'open)
                   nil t s 1))))
        ;; 2. Replace quotes in the middle of the string.
        (setq s (replace-regexp-in-string
                 ;; Opening quotes.
                 (nth 3 org-export-smart-quotes-regexps)
                 (lambda (text)
                   (funcall get-smart-quote (match-string 1 text) 'open))
                 s nil t 1))
        (setq s (replace-regexp-in-string
                 ;; Closing quotes.
                 (nth 4 org-export-smart-quotes-regexps)
                 (lambda (text)
                   (funcall get-smart-quote (match-string 1 text) 'close))
                 s nil t 1))
        (setq s (replace-regexp-in-string
                 ;; Apostrophes.
                 (nth 5 org-export-smart-quotes-regexps)
                 (lambda (text)
                   (funcall get-smart-quote (match-string 1 text) 'apostrophe))
                 s nil t 1))
        ;; 3. Replace quote character at the end of S.
        (cond
         ;; Apostrophe?
         ((and next (string-match (nth 8 org-export-smart-quotes-regexps) s))
          (setq s (replace-match
                   (funcall get-smart-quote (match-string 1 s) 'apostrophe)
                   nil t s 1)))
         ;; Closing quote?
         ((and (not next)
               (string-match (nth 7 org-export-smart-quotes-regexps) s))
          (setq s (replace-match
                   (funcall get-smart-quote (match-string 1 s) 'close)
                   nil t s 1)))
         ;; Opening quote?
         ((and next (string-match (nth 6 org-export-smart-quotes-regexps) s))
          (setq s (replace-match
                   (funcall get-smart-quote (match-string 1 s) 'open)
                   nil t s 1))))
        ;; Return string with smart quotes.
        s))))
</p>

<p>
;;;; Topology
;;
;; Here are various functions to retrieve information about the
;; neighborhood of a given element or object.  Neighbors of interest
;; are direct parent (`org-export-get-parent'), parent headline
;; (`org-export-get-parent-headline'), first element containing an
;; object, (`org-export-get-parent-element'), parent table
;; (`org-export-get-parent-table'), previous element or object
;; (`org-export-get-previous-element') and next element or object
;; (`org-export-get-next-element').
;;
;; `org-export-get-genealogy' returns the full genealogy of a given
;; element or object, from closest parent to full parse tree.
</p>

<p>
(defsubst org-export-get-parent (blob)
  "Return BLOB parent or nil.
BLOB is the element or object considered."
  (org-element-property :parent blob))
</p>

<p>
(defun org-export-get-genealogy (blob)
  "Return full genealogy relative to a given element or object.
</p>

<p>
BLOB is the element or object being considered.
</p>

<p>
Ancestors are returned from closest to farthest, the last one
being the full parse tree."
  (let (genealogy (parent blob))
    (while (setq parent (org-element-property :parent parent))
      (push parent genealogy))
    (nreverse genealogy)))
</p>

<p>
(defun org-export-get-parent-headline (blob)
  "Return BLOB parent headline or nil.
BLOB is the element or object being considered."
  (let ((parent blob))
    (while (and (setq parent (org-element-property :parent parent))
                (not (eq (org-element-type parent) 'headline))))
    parent))
</p>

<p>
(defun org-export-get-parent-element (object)
  "Return first element containing OBJECT or nil.
OBJECT is the object to consider."
  (let ((parent object))
    (while (and (setq parent (org-element-property :parent parent))
                (memq (org-element-type parent) org-element-all-objects)))
    parent))
</p>

<p>
(defun org-export-get-parent-table (object)
  "Return OBJECT parent table or nil.
OBJECT is either a `table-cell' or `table-element' type object."
  (let ((parent object))
    (while (and (setq parent (org-element-property :parent parent))
                (not (eq (org-element-type parent) 'table))))
    parent))
</p>

<p>
(defun org-export-get-previous-element (blob info &amp;optional n)
  "Return previous element or object.
</p>

<p>
BLOB is an element or object.  INFO is a plist used as
a communication channel.  Return previous exportable element or
object, a string, or nil.
</p>

<p>
When optional argument N is a positive integer, return a list
containing up to N siblings before BLOB, from farthest to
closest.  With any other non-nil value, return a list containing
all of them."
  (let ((siblings
         ;; An object can belong to the contents of its parent or
         ;; to a secondary string.  We check the latter option
         ;; first.
         (let ((parent (org-export-get-parent blob)))
           (or (let ((sec-value (org-element-property
                                 (cdr (assq (org-element-type parent)
                                            org-element-secondary-value-alist))
                                 parent)))
                 (and (memq blob sec-value) sec-value))
               (org-element-contents parent))))
        prev)
    (catch 'exit
      (mapc (lambda (obj)
              (cond ((memq obj (plist-get info :ignore-list)))
                    ((null n) (throw 'exit obj))
                    ((not (wholenump n)) (push obj prev))
                    ((zerop n) (throw 'exit prev))
                    (t (decf n) (push obj prev))))
            (cdr (memq blob (reverse siblings))))
      prev)))
</p>

<p>
(defun org-export-get-next-element (blob info &amp;optional n)
  "Return next element or object.
</p>

<p>
BLOB is an element or object.  INFO is a plist used as
a communication channel.  Return next exportable element or
object, a string, or nil.
</p>

<p>
When optional argument N is a positive integer, return a list
containing up to N siblings after BLOB, from closest to farthest.
With any other non-nil value, return a list containing all of
them."
  (let ((siblings
         ;; An object can belong to the contents of its parent or to
         ;; a secondary string.  We check the latter option first.
         (let ((parent (org-export-get-parent blob)))
           (or (let ((sec-value (org-element-property
                                 (cdr (assq (org-element-type parent)
                                            org-element-secondary-value-alist))
                                 parent)))
                 (cdr (memq blob sec-value)))
               (cdr (memq blob (org-element-contents parent))))))
        next)
    (catch 'exit
      (mapc (lambda (obj)
              (cond ((memq obj (plist-get info :ignore-list)))
                    ((null n) (throw 'exit obj))
                    ((not (wholenump n)) (push obj next))
                    ((zerop n) (throw 'exit (nreverse next)))
                    (t (decf n) (push obj next))))
            siblings)
      (nreverse next))))
</p>


<p>
;;;; Translation
;;
;; `org-export-translate' translates a string according to the language
;; specified by the LANGUAGE keyword.  `org-export-dictionary' contains
;; the dictionary used for the translation.
</p>

<p>
(defconst org-export-dictionary
  '(("%e %n: %c"
     ("fr" :default "%e %n : %c" :html "%e&amp;nbsp;%n&amp;nbsp;: %c"))
    ("Author"
     ("ca" :default "Autor")
     ("cs" :default "Autor")
     ("da" :default "Forfatter")
     ("de" :default "Autor")
     ("eo" :html "A&amp;#365;toro")
     ("es" :default "Autor")
     ("fi" :html "Tekij&amp;auml;")
     ("fr" :default "Auteur")
     ("hu" :default "Szerz&amp;otilde;")
     ("is" :html "H&amp;ouml;fundur")
     ("it" :default "Autore")
     ("ja" :html "&amp;#33879;&amp;#32773;" :utf-8 "")
     ("nl" :default "Auteur")
     ("no" :default "Forfatter")
     ("nb" :default "Forfatter")
     ("nn" :default "Forfattar")
     ("pl" :default "Autor")
     ("ru" :html "&amp;#1040;&amp;#1074;&amp;#1090;&amp;#1086;&amp;#1088;" :utf-8 "")
     ("sv" :html "F&amp;ouml;rfattare")
     ("uk" :html "&amp;#1040;&amp;#1074;&amp;#1090;&amp;#1086;&amp;#1088;" :utf-8 "")
     ("zh-CN" :html "&amp;#20316;&amp;#32773;" :utf-8 "")
     ("zh-TW" :html "&amp;#20316;&amp;#32773;" :utf-8 ""))
    ("Date"
     ("ca" :default "Data")
     ("cs" :default "Datum")
     ("da" :default "Dato")
     ("de" :default "Datum")
     ("eo" :default "Dato")
     ("es" :default "Fecha")
     ("fi" :html "P&amp;auml;iv&amp;auml;m&amp;auml;&amp;auml;r&amp;auml;")
     ("hu" :html "D&amp;aacute;tum")
     ("is" :default "Dagsetning")
     ("it" :default "Data")
     ("ja" :html "&amp;#26085;&amp;#20184;" :utf-8 "")
     ("nl" :default "Datum")
     ("no" :default "Dato")
     ("nb" :default "Dato")
     ("nn" :default "Dato")
     ("pl" :default "Data")
     ("ru" :html "&amp;#1044;&amp;#1072;&amp;#1090;&amp;#1072;" :utf-8 "")
     ("sv" :default "Datum")
     ("uk" :html "&amp;#1044;&amp;#1072;&amp;#1090;&amp;#1072;" :utf-8 "")
     ("zh-CN" :html "&amp;#26085;&amp;#26399;" :utf-8 "")
     ("zh-TW" :html "&amp;#26085;&amp;#26399;" :utf-8 ""))
    ("Equation"
     ("da" :default "Ligning")
     ("de" :default "Gleichung")
     ("es" :html "Ecuaci&amp;oacute;n" :default "Ecuacin")
     ("fr" :ascii "Equation" :default "quation")
     ("no" :default "Ligning")
     ("nb" :default "Ligning")
     ("nn" :default "Likning")
     ("sv" :default "Ekvation")
     ("zh-CN" :html "&amp;#26041;&amp;#31243;" :utf-8 ""))
    ("Figure"
     ("da" :default "Figur")
     ("de" :default "Abbildung")
     ("es" :default "Figura")
     ("ja" :html "&amp;#22259;" :utf-8 "")
     ("no" :default "Illustrasjon")
     ("nb" :default "Illustrasjon")
     ("nn" :default "Illustrasjon")
     ("sv" :default "Illustration")
     ("zh-CN" :html "&amp;#22270;" :utf-8 ""))
    ("Figure %d:"
     ("da" :default "Figur %d")
     ("de" :default "Abbildung %d:")
     ("es" :default "Figura %d:")
     ("fr" :default "Figure %d :" :html "Figure&amp;nbsp;%d&amp;nbsp;:")
     ("ja" :html "&amp;#22259;%d: " :utf-8 "%d: ")
     ("no" :default "Illustrasjon %d")
     ("nb" :default "Illustrasjon %d")
     ("nn" :default "Illustrasjon %d")
     ("sv" :default "Illustration %d")
     ("zh-CN" :html "&amp;#22270;%d&amp;nbsp;" :utf-8 "%d "))
    ("Footnotes"
     ("ca" :html "Peus de p&amp;agrave;gina")
     ("cs" :default "Pozn\xe1mky pod carou")
     ("da" :default "Fodnoter")
     ("de" :html "Fu&amp;szlig;noten" :default "Funoten")
     ("eo" :default "Piednotoj")
     ("es" :html "Nota al pie de p&amp;aacute;gina" :default "Nota al pie de pgina")
     ("fi" :default "Alaviitteet")
     ("fr" :default "Notes de bas de page")
     ("hu" :html "L&amp;aacute;bjegyzet")
     ("is" :html "Aftanm&amp;aacute;lsgreinar")
     ("it" :html "Note a pi&amp;egrave; di pagina")
     ("ja" :html "&amp;#33050;&amp;#27880;" :utf-8 "")
     ("nl" :default "Voetnoten")
     ("no" :default "Fotnoter")
     ("nb" :default "Fotnoter")
     ("nn" :default "Fotnotar")
     ("pl" :default "Przypis")
     ("ru" :html "&amp;#1057;&amp;#1085;&amp;#1086;&amp;#1089;&amp;#1082;&amp;#1080;" :utf-8 "")
     ("sv" :default "Fotnoter")
     ("uk" :html "&amp;#1055;&amp;#1088;&amp;#1080;&amp;#1084;&amp;#1110;&amp;#1090;&amp;#1082;&amp;#1080;"
</p>
<p>
  :utf-8 "")
 ("zh-CN" :html "&amp;#33050;&amp;#27880;" :utf-8 "")
 ("zh-TW" :html "&amp;#33139;&amp;#35387;" :utf-8 ""))
("List of Listings"
 ("da" :default "Programmer")
 ("de" :default "Programmauflistungsverzeichnis")
 ("es" :default "Indice de Listados de programas")
 ("fr" :default "Liste des programmes")
 ("no" :default "Dataprogrammer")
 ("nb" :default "Dataprogrammer")
 ("zh-CN" :html "&amp;#20195;&amp;#30721;&amp;#30446;&amp;#24405;" :utf-8 ""))
("List of Tables"
 ("da" :default "Tabeller")
 ("de" :default "Tabellenverzeichnis")
 ("es" :default "Indice de tablas")
 ("fr" :default "Liste des tableaux")
 ("no" :default "Tabeller")
 ("nb" :default "Tabeller")
 ("nn" :default "Tabeller")
 ("sv" :default "Tabeller")
 ("zh-CN" :html "&amp;#34920;&amp;#26684;&amp;#30446;&amp;#24405;" :utf-8 ""))
("Listing %d:"
 ("da" :default "Program %d")
 ("de" :default "Programmlisting %d")
 ("es" :default "Listado de programa %d")
 ("fr" :default "Programme %d :" :html "Programme&amp;nbsp;%d&amp;nbsp;:")
 ("no" :default "Dataprogram")
 ("nb" :default "Dataprogram")
 ("zh-CN" :html "&amp;#20195;&amp;#30721;%d&amp;nbsp;" :utf-8 "%d "))
("See section %s"
 ("da" :default "jvnfr afsnit %s")
 ("de" :default "siehe Abschnitt %s")
 ("es" :default "vea seccion %s")
 ("fr" :default "cf. section %s")
 ("zh-CN" :html "&amp;#21442;&amp;#35265;&amp;#31532;%d&amp;#33410;" :utf-8 "%s"))
("Table"
 ("de" :default "Tabelle")
 ("es" :default "Tabla")
 ("fr" :default "Tableau")
 ("ja" :html "&amp;#34920;" :utf-8 "")
 ("zh-CN" :html "&amp;#34920;" :utf-8 ""))
("Table %d:"
 ("da" :default "Tabel %d")
 ("de" :default "Tabelle %d")
 ("es" :default "Tabla %d")
 ("fr" :default "Tableau %d :")
 ("ja" :html "&amp;#34920;%d:" :utf-8 "%d:")
 ("no" :default "Tabell %d")
 ("nb" :default "Tabell %d")
 ("nn" :default "Tabell %d")
 ("sv" :default "Tabell %d")
 ("zh-CN" :html "&amp;#34920;%d&amp;nbsp;" :utf-8 "%d "))
("Table of Contents"
 ("ca" :html "&amp;Iacute;ndex")
 ("cs" :default "Obsah")
 ("da" :default "Indhold")
 ("de" :default "Inhaltsverzeichnis")
 ("eo" :default "Enhavo")
 ("es" :html "&amp;Iacute;ndice")
 ("fi" :html "Sis&amp;auml;llysluettelo")
 ("fr" :ascii "Sommaire" :default "Table des matires")
 ("hu" :html "Tartalomjegyz&amp;eacute;k")
 ("is" :default "Efnisyfirlit")
 ("it" :default "Indice")
 ("ja" :html "&amp;#30446;&amp;#27425;" :utf-8 "")
 ("nl" :default "Inhoudsopgave")
 ("no" :default "Innhold")
 ("nb" :default "Innhold")
 ("nn" :default "Innhald")
 ("pl" :html "Spis tre&amp;#x015b;ci")
 ("ru" :html "&amp;#1057;&amp;#1086;&amp;#1076;&amp;#1077;&amp;#1088;&amp;#1078;&amp;#1072;&amp;#1085;&amp;#1080;&amp;#1077;"
</p>
<p>
    :utf-8 "")
   ("sv" :html "Inneh&amp;aring;ll")
   ("uk" :html "&amp;#1047;&amp;#1084;&amp;#1110;&amp;#1089;&amp;#1090;" :utf-8 "")
   ("zh-CN" :html "&amp;#30446;&amp;#24405;" :utf-8 "")
   ("zh-TW" :html "&amp;#30446;&amp;#37636;" :utf-8 ""))
  ("Unknown reference"
   ("da" :default "ukendt reference")
   ("de" :default "Unbekannter Verweis")
   ("es" :default "referencia desconocida")
   ("fr" :ascii "Destination inconnue" :default "Rfrence inconnue")
   ("zh-CN" :html "&amp;#26410;&amp;#30693;&amp;#24341;&amp;#29992;" :utf-8 "")))
"Dictionary for export engine.
</p>

<p>
Alist whose CAR is the string to translate and CDR is an alist
whose CAR is the language string and CDR is a plist whose
properties are possible charsets and values translated terms.
</p>

<p>
It is used as a database for `org-export-translate'. Since this
function returns the string as-is if no translation was found,
the variable only needs to record values different from the
entry.")
</p>

<p>
(defun org-export-translate (s encoding info)
  "Translate string S according to language specification.
</p>

<p>
ENCODING is a symbol among `:ascii', `:html', `:latex', `:latin1'
and `:utf-8'.  INFO is a plist used as a communication channel.
</p>

<p>
Translation depends on `:language' property. Return the
translated string. If no translation is found, try to fall back
to `:default' encoding. If it fails, return S."
  (let* ((lang (plist-get info :language))
         (translations (cdr (assoc lang
                                   (cdr (assoc s org-export-dictionary))))))
    (or (plist-get translations encoding)
        (plist-get translations :default)
        s)))
</p>


<p>

;;; Asynchronous Export
;;
;; `org-export-async-start' is the entry point for asynchronous
;; export.  It recreates current buffer (including visibility,
;; narrowing and visited file) in an external Emacs process, and
;; evaluates a command there.  It then applies a function on the
;; returned results in the current process.
;;
;; At a higher level, `org-export-to-buffer' and `org-export-to-file'
;; allow to export to a buffer or a file, asynchronously or not.
;;
;; `org-export-output-file-name' is an auxiliary function meant to be
;; used with `org-export-to-file'.  With a given extension, it tries
;; to provide a canonical file name to write export output to.
;;
;; Asynchronously generated results are never displayed directly.
;; Instead, they are stored in `org-export-stack-contents'.  They can
;; then be retrieved by calling `org-export-stack'.
;;
;; Export Stack is viewed through a dedicated major mode
;;`org-export-stack-mode' and tools: `org-export-stack-refresh',
;;`org-export-stack-delete', `org-export-stack-view' and
;;`org-export-stack-clear'.
;;
;; For back-ends, `org-export-add-to-stack' add a new source to stack.
;; It should be used whenever `org-export-async-start' is called.
</p>

<p>
(defmacro org-export-async-start  (fun &amp;rest body)
  "Call function FUN on the results returned by BODY evaluation.
</p>

<p>
BODY evaluation happens in an asynchronous process, from a buffer
which is an exact copy of the current one.
</p>

<p>
Use `org-export-add-to-stack' in FUN in order to register results
in the stack.
</p>

<p>
This is a low level function.  See also `org-export-to-buffer'
and `org-export-to-file' for more specialized functions."
  (declare (indent 1) (debug t))
  (org-with-gensyms (process temp-file copy-fun proc-buffer coding)
    ;; Write the full sexp evaluating BODY in a copy of the current
    ;; buffer to a temporary file, as it may be too long for program
    ;; args in `start-process'.
    `(with-temp-message "Initializing asynchronous export process"
       (let ((,copy-fun (org-export&#x2013;generate-copy-script (current-buffer)))
             (,temp-file (make-temp-file "org-export-process"))
             (,coding buffer-file-coding-system))
         (with-temp-file ,temp-file
           (insert
            ;; Null characters (from variable values) are inserted
            ;; within the file.  As a consequence, coding system for
            ;; buffer contents will not be recognized properly.  So,
            ;; we make sure it is the same as the one used to display
            ;; the original buffer.
            (format ";; -*- coding: %s; -*-\n%S"
                    ,coding
                    `(with-temp-buffer
                       (when org-export-async-debug '(setq debug-on-error t))
                       ;; Ignore `kill-emacs-hook' and code evaluation
                       ;; queries from Babel as we need a truly
                       ;; non-interactive process.
                       (setq kill-emacs-hook nil
                             org-babel-confirm-evaluate-answer-no t)
                       ;; Initialize export framework.
                       (require 'ox)
                       ;; Re-create current buffer there.
                       (funcall ,,copy-fun)
                       (restore-buffer-modified-p nil)
                       ;; Sexp to evaluate in the buffer.
                       (print (progn ,,@body))))))
         ;; Start external process.
         (let* ((process-connection-type nil)
                (,proc-buffer (generate-new-buffer-name "<b>Org Export Process</b>"))
                (,process
                 (start-process
                  "org-export-process" ,proc-buffer
                  (expand-file-name invocation-name invocation-directory)
                  "-Q" "&#x2013;batch"
                  "-l" org-export-async-init-file
                  "-l" ,temp-file)))
           ;; Register running process in stack.
           (org-export-add-to-stack (get-buffer ,proc-buffer) nil ,process)
           ;; Set-up sentinel in order to catch results.
           (let ((handler ,fun))
             (set-process-sentinel
              ,process
              `(lambda (p status)
                 (let ((proc-buffer (process-buffer p)))
                   (when (eq (process-status p) 'exit)
                     (unwind-protect
                         (if (zerop (process-exit-status p))
                             (unwind-protect
                                 (let ((results
                                        (with-current-buffer proc-buffer
                                          (goto-char (point-max))
                                          (backward-sexp)
                                          (read (current-buffer)))))
                                   (funcall ,handler results))
                               (unless org-export-async-debug
                                 (and (get-buffer proc-buffer)
                                      (kill-buffer proc-buffer))))
                           (org-export-add-to-stack proc-buffer nil p)
                           (ding)
                           (message "Process '%s' exited abnormally" p))
                       (unless org-export-async-debug
                         (delete-file ,,temp-file)))))))))))))
</p>

<p>
;;;###autoload
(defun org-export-to-buffer
  (backend buffer
           &amp;optional async subtreep visible-only body-only ext-plist
           post-process)
  "Call `org-export-as' with output to a specified buffer.
</p>

<p>
BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.
</p>

<p>
BUFFER is the name of the output buffer.  If it already exists,
it will be erased first, otherwise, it will be created.
</p>

<p>
A non-nil optional argument ASYNC means the process should happen
asynchronously.  The resulting buffer should then be accessible
through the `org-export-stack' interface.  When ASYNC is nil, the
buffer is displayed if `org-export-show-temporary-export-buffer'
is non-nil.
</p>

<p>
Optional arguments SUBTREEP, VISIBLE-ONLY, BODY-ONLY and
EXT-PLIST are similar to those used in `org-export-as', which
see.
</p>

<p>
Optional argument POST-PROCESS is a function which should accept
no argument.  It is always called within the current process,
from BUFFER, with point at its beginning.  Export back-ends can
use it to set a major mode there, e.g,
</p>

<p>
\(defun org-latex-export-as-latex
  \(&amp;optional async subtreep visible-only body-only ext-plist)
  \(interactive)
  \(org-export-to-buffer 'latex \"<b>Org LATEX Export</b>\"
    async subtreep visible-only body-only ext-plist (lambda () (LaTeX-mode))))
</p>

<p>
This function returns BUFFER."
  (declare (indent 2))
  (if async
      (org-export-async-start
          `(lambda (output)
             (with-current-buffer (get-buffer-create ,buffer)
               (erase-buffer)
               (setq buffer-file-coding-system ',buffer-file-coding-system)
               (insert output)
               (goto-char (point-min))
               (org-export-add-to-stack (current-buffer) ',backend)
               (ignore-errors (funcall ,post-process))))
        `(org-export-as
          ',backend ,subtreep ,visible-only ,body-only ',ext-plist))
    (let ((output
           (org-export-as backend subtreep visible-only body-only ext-plist))
          (buffer (get-buffer-create buffer))
          (encoding buffer-file-coding-system))
      (when (and (org-string-nw-p output) (org-export&#x2013;copy-to-kill-ring-p))
        (org-kill-new output))
      (with-current-buffer buffer
        (erase-buffer)
        (setq buffer-file-coding-system encoding)
        (insert output)
        (goto-char (point-min))
        (and (functionp post-process) (funcall post-process)))
      (when org-export-show-temporary-export-buffer
        (switch-to-buffer-other-window buffer))
      buffer)))
</p>

<p>
;;;###autoload
(defun org-export-to-file
  (backend file &amp;optional async subtreep visible-only body-only ext-plist
           post-process)
  "Call `org-export-as' with output to a specified file.
</p>

<p>
BACKEND is either an export back-end, as returned by, e.g.,
`org-export-create-backend', or a symbol referring to
a registered back-end.  FILE is the name of the output file, as
a string.
</p>

<p>
A non-nil optional argument ASYNC means the process should happen
asynchronously.  The resulting buffer will then be accessible
through the `org-export-stack' interface.
</p>

<p>
Optional arguments SUBTREEP, VISIBLE-ONLY, BODY-ONLY and
EXT-PLIST are similar to those used in `org-export-as', which
see.
</p>

<p>
Optional argument POST-PROCESS is called with FILE as its
argument and happens asynchronously when ASYNC is non-nil.  It
has to return a file name, or nil.  Export back-ends can use this
to send the output file through additional processing, e.g,
</p>

<p>
\(defun org-latex-export-to-latex
  \(&amp;optional async subtreep visible-only body-only ext-plist)
  \(interactive)
  \(let ((outfile (org-export-output-file-name \".tex\" subtreep)))
    \(org-export-to-file 'latex outfile
      async subtreep visible-only body-only ext-plist
      \(lambda (file) (org-latex-compile file)))
</p>

<p>
The function returns either a file name returned by POST-PROCESS,
or FILE."
  (declare (indent 2))
  (if (not (file-writable-p file)) (error "Output file not writable")
    (let ((encoding (or org-export-coding-system buffer-file-coding-system)))
      (if async
          (org-export-async-start
              `(lambda (file)
                 (org-export-add-to-stack (expand-file-name file) ',backend))
            `(let ((output
                    (org-export-as
                     ',backend ,subtreep ,visible-only ,body-only
                     ',ext-plist)))
               (with-temp-buffer
                 (insert output)
                 (let ((coding-system-for-write ',encoding))
                   (write-file ,file)))
               (or (ignore-errors (funcall ',post-process ,file)) ,file)))
        (let ((output (org-export-as
                       backend subtreep visible-only body-only ext-plist)))
          (with-temp-buffer
            (insert output)
            (let ((coding-system-for-write encoding))
              (write-file file)))
          (when (and (org-export&#x2013;copy-to-kill-ring-p) (org-string-nw-p output))
            (org-kill-new output))
          ;; Get proper return value.
          (or (and (functionp post-process) (funcall post-process file))
              file))))))
</p>

<p>
(defun org-export-output-file-name (extension &amp;optional subtreep pub-dir)
  "Return output file's name according to buffer specifications.
</p>

<p>
EXTENSION is a string representing the output file extension,
with the leading dot.
</p>

<p>
With a non-nil optional argument SUBTREEP, try to determine
output file's name by looking for \"EXPORT<sub>FILE</sub><sub>NAME\</sub>" property
of subtree at point.
</p>

<p>
When optional argument PUB-DIR is set, use it as the publishing
directory.
</p>

<p>
When optional argument VISIBLE-ONLY is non-nil, don't export
contents of hidden elements.
</p>

<p>
Return file name as a string."
  (let* ((visited-file (buffer-file-name (buffer-base-buffer)))
         (base-name
          ;; File name may come from EXPORT<sub>FILE</sub><sub>NAME</sub> subtree
          ;; property, assuming point is at beginning of said
          ;; sub-tree.
          (file-name-sans-extension
           (or (and subtreep
                    (org-entry-get
                     (save-excursion
                       (ignore-errors (org-back-to-heading) (point)))
                     "EXPORT<sub>FILE</sub><sub>NAME</sub>" t))
               ;; File name may be extracted from buffer's associated
               ;; file, if any.
               (and visited-file (file-name-nondirectory visited-file))
               ;; Can't determine file name on our own: Ask user.
               (let ((read-file-name-function
                      (and org-completion-use-ido 'ido-read-file-name)))
                 (read-file-name
                  "Output file: " pub-dir nil nil nil
                  (lambda (name)
                    (string= (file-name-extension name t) extension)))))))
         (output-file
          ;; Build file name.  Enforce EXTENSION over whatever user
          ;; may have come up with.  PUB-DIR, if defined, always has
          ;; precedence over any provided path.
          (cond
           (pub-dir
            (concat (file-name-as-directory pub-dir)
                    (file-name-nondirectory base-name)
                    extension))
           ((file-name-absolute-p base-name) (concat base-name extension))
           (t (concat (file-name-as-directory ".") base-name extension)))))
    ;; If writing to OUTPUT-FILE would overwrite original file, append
    ;; EXTENSION another time to final name.
    (if (and visited-file (org-file-equal-p visited-file output-file))
        (concat output-file extension)
      output-file)))
</p>

<p>
(defun org-export-add-to-stack (source backend &amp;optional process)
  "Add a new result to export stack if not present already.
</p>

<p>
SOURCE is a buffer or a file name containing export results.
BACKEND is a symbol representing export back-end used to generate
it.
</p>

<p>
Entries already pointing to SOURCE and unavailable entries are
removed beforehand.  Return the new stack."
  (setq org-export-stack-contents
        (cons (list source backend (or process (current-time)))
              (org-export-stack-remove source))))
</p>

<p>
(defun org-export-stack ()
  "Menu for asynchronous export results and running processes."
  (interactive)
  (let ((buffer (get-buffer-create "<b>Org Export Stack</b>")))
    (set-buffer buffer)
    (when (zerop (buffer-size)) (org-export-stack-mode))
    (org-export-stack-refresh)
    (pop-to-buffer buffer))
  (message "Type \"q\" to quit, \"?\" for help"))
</p>

<p>
(defun org-export&#x2013;stack-source-at-point ()
  "Return source from export results at point in stack."
  (let ((source (car (nth (1- (org-current-line)) org-export-stack-contents))))
    (if (not source) (error "Source unavailable, please refresh buffer")
      (let ((source-name (if (stringp source) source (buffer-name source))))
        (if (save-excursion
              (beginning-of-line)
              (looking-at (concat ".* +" (regexp-quote source-name) "$")))
            source
          ;; SOURCE is not consistent with current line.  The stack
          ;; view is outdated.
          (error "Source unavailable; type `g' to update buffer"))))))
</p>

<p>
(defun org-export-stack-clear ()
  "Remove all entries from export stack."
  (interactive)
  (setq org-export-stack-contents nil))
</p>

<p>
(defun org-export-stack-refresh (&amp;rest dummy)
  "Refresh the asynchronous export stack.
DUMMY is ignored.  Unavailable sources are removed from the list.
Return the new stack."
  (let ((inhibit-read-only t))
    (org-preserve-lc
     (erase-buffer)
     (insert (concat
              (let ((counter 0))
                (mapconcat
                 (lambda (entry)
                   (let ((proc-p (processp (nth 2 entry))))
                     (concat
                      ;; Back-end.
                      (format " %-12s  " (or (nth 1 entry) ""))
                      ;; Age.
                      (let ((data (nth 2 entry)))
                        (if proc-p (format " %6s  " (process-status data))
                          ;; Compute age of the results.
                          (org-format-seconds
                           "%4h:%.2m  "
                           (float-time (time-since data)))))
                      ;; Source.
                      (format " %s"
                              (let ((source (car entry)))
                                (if (stringp source) source
                                  (buffer-name source)))))))
                 ;; Clear stack from exited processes, dead buffers or
                 ;; non-existent files.
                 (setq org-export-stack-contents
                       (org-remove-if-not
                        (lambda (el)
                          (if (processp (nth 2 el))
                              (buffer-live-p (process-buffer (nth 2 el)))
                            (let ((source (car el)))
                              (if (bufferp source) (buffer-live-p source)
                                (file-exists-p source)))))
                        org-export-stack-contents)) "\n")))))))
</p>

<p>
(defun org-export-stack-remove (&amp;optional source)
  "Remove export results at point from stack.
If optional argument SOURCE is non-nil, remove it instead."
  (interactive)
  (let ((source (or source (org-export&#x2013;stack-source-at-point))))
    (setq org-export-stack-contents
          (org-remove-if (lambda (el) (equal (car el) source))
                         org-export-stack-contents))))
</p>

<p>
(defun org-export-stack-view (&amp;optional in-emacs)
  "View export results at point in stack.
With an optional prefix argument IN-EMACS, force viewing files
within Emacs."
  (interactive "P")
  (let ((source (org-export&#x2013;stack-source-at-point)))
    (cond ((processp source)
           (org-switch-to-buffer-other-window (process-buffer source)))
          ((bufferp source) (org-switch-to-buffer-other-window source))
          (t (org-open-file source in-emacs)))))
</p>

<p>
(defvar org-export-stack-mode-map
  (let ((km (make-sparse-keymap)))
    (define-key km " " 'next-line)
    (define-key km "n" 'next-line)
    (define-key km "\C-n" 'next-line)
    (define-key km [down] 'next-line)
    (define-key km "p" 'previous-line)
    (define-key km "\C-p" 'previous-line)
    (define-key km "\C-?" 'previous-line)
    (define-key km [up] 'previous-line)
    (define-key km "C" 'org-export-stack-clear)
    (define-key km "v" 'org-export-stack-view)
    (define-key km (kbd "RET") 'org-export-stack-view)
    (define-key km "d" 'org-export-stack-remove)
    km)
  "Keymap for Org Export Stack.")
</p>

<p>
(define-derived-mode org-export-stack-mode special-mode "Org-Stack"
  "Mode for displaying asynchronous export stack.
</p>

<p>
Type \\[org-export-stack] to visualize the asynchronous export
stack.
</p>

<p>
In an Org Export Stack buffer, use \\&lt;org-export-stack-mode-map&gt;\\[org-export-stack-view] to view export output
on current line, \\[org-export-stack-remove] to remove it from the stack and \\[org-export-stack-clear] to clear
stack completely.
</p>

<p>
Removing entries in an Org Export Stack buffer doesn't affect
files or buffers, only the display.
</p>

<p>
\\{org-export-stack-mode-map}"
  (abbrev-mode 0)
  (auto-fill-mode 0)
  (setq buffer-read-only t
        buffer-undo-list t
        truncate-lines t
        header-line-format
        '(:eval
          (format "  %-12s | %6s | %s" "Back-End" "Age" "Source")))
  (org-add-hook 'post-command-hook 'org-export-stack-refresh nil t)
  (set (make-local-variable 'revert-buffer-function)
       'org-export-stack-refresh))
</p>


<p>

;;; The Dispatcher
;;
;; `org-export-dispatch' is the standard interactive way to start an
;; export process.  It uses `org-export&#x2013;dispatch-ui' as a subroutine
;; for its interface, which, in turn, delegates response to key
;; pressed to `org-export&#x2013;dispatch-action'.
</p>

<p>
;;;###autoload
(defun org-export-dispatch (&amp;optional arg)
  "Export dispatcher for Org mode.
</p>

<p>
It provides an access to common export related tasks in a buffer.
Its interface comes in two flavors: standard and expert.
</p>

<p>
While both share the same set of bindings, only the former
displays the valid keys associations in a dedicated buffer.
Scrolling (resp. line-wise motion) in this buffer is done with
SPC and DEL (resp. C-n and C-p) keys.
</p>

<p>
Set variable `org-export-dispatch-use-expert-ui' to switch to one
flavor or the other.
</p>

<p>
When ARG is \\[universal-argument], repeat the last export action, with the same set
of options used back then, on the current buffer.
</p>

<p>
When ARG is \\[universal-argument] \\[universal-argument], display the asynchronous export stack."
  (interactive "P")
  (let* ((input
          (cond ((equal arg '(16)) '(stack))
                ((and arg org-export-dispatch-last-action))
                (t (save-window-excursion
                     (unwind-protect
                         (progn
                           ;; Remember where we are
                           (move-marker org-export-dispatch-last-position
                                        (point)
                                        (org-base-buffer (current-buffer)))
                           ;; Get and store an export command
                           (setq org-export-dispatch-last-action
                                 (org-export&#x2013;dispatch-ui
                                  (list org-export-initial-scope
                                        (and org-export-in-background 'async))
                                  nil
                                  org-export-dispatch-use-expert-ui)))
                       (and (get-buffer "<b>Org Export Dispatcher</b>")
                            (kill-buffer "<b>Org Export Dispatcher</b>")))))))
         (action (car input))
         (optns (cdr input)))
    (unless (memq 'subtree optns)
      (move-marker org-export-dispatch-last-position nil))
    (case action
      ;; First handle special hard-coded actions.
      (template (org-export-insert-default-template nil optns))
      (stack (org-export-stack))
      (publish-current-file
       (org-publish-current-file (memq 'force optns) (memq 'async optns)))
      (publish-current-project
       (org-publish-current-project (memq 'force optns) (memq 'async optns)))
      (publish-choose-project
       (org-publish (assoc (org-icompleting-read
                            "Publish project: "
                            org-publish-project-alist nil t)
                           org-publish-project-alist)
                    (memq 'force optns)
                    (memq 'async optns)))
      (publish-all (org-publish-all (memq 'force optns) (memq 'async optns)))
      (otherwise
       (save-excursion
         (when arg
           ;; Repeating command, maybe move cursor to restore subtree
           ;; context.
           (if (eq (marker-buffer org-export-dispatch-last-position)
                   (org-base-buffer (current-buffer)))
               (goto-char org-export-dispatch-last-position)
             ;; We are in a different buffer, forget position.
             (move-marker org-export-dispatch-last-position nil)))
         (funcall action
                  ;; Return a symbol instead of a list to ease
                  ;; asynchronous export macro use.
                  (and (memq 'async optns) t)
                  (and (memq 'subtree optns) t)
                  (and (memq 'visible optns) t)
                  (and (memq 'body optns) t)))))))
</p>

<p>
(defun org-export&#x2013;dispatch-ui (options first-key expertp)
  "Handle interface for `org-export-dispatch'.
</p>

<p>
OPTIONS is a list containing current interactive options set for
export.  It can contain any of the following symbols:
`body'    toggles a body-only export
`subtree' restricts export to current subtree
`visible' restricts export to visible part of buffer.
`force'   force publishing files.
`async'   use asynchronous export process
</p>

<p>
FIRST-KEY is the key pressed to select the first level menu.  It
is nil when this menu hasn't been selected yet.
</p>

<p>
EXPERTP, when non-nil, triggers expert UI.  In that case, no help
buffer is provided, but indications about currently active
options are given in the prompt.  Moreover, \[?] allows to switch
back to standard interface."
  (let* ((fontify-key
          (lambda (key &amp;optional access-key)
            ;; Fontify KEY string.  Optional argument ACCESS-KEY, when
            ;; non-nil is the required first-level key to activate
            ;; KEY.  When its value is t, activate KEY independently
            ;; on the first key, if any.  A nil value means KEY will
            ;; only be activated at first level.
            (if (or (eq access-key t) (eq access-key first-key))
                (org-propertize key 'face 'org-warning)
              key)))
         (fontify-value
          (lambda (value)
            ;; Fontify VALUE string.
            (org-propertize value 'face 'font-lock-variable-name-face)))
         ;; Prepare menu entries by extracting them from registered
         ;; back-ends and sorting them by access key and by ordinal,
         ;; if any.
         (entries
          (sort (sort (delq nil
                            (mapcar 'org-export-backend-menu
                                    org-export&#x2013;registered-backends))
                      (lambda (a b)
                        (let ((key-a (nth 1 a))
                              (key-b (nth 1 b)))
                          (cond ((and (numberp key-a) (numberp key-b))
                                 (&lt; key-a key-b))
                                ((numberp key-b) t)))))
                'car-less-than-car))
         ;; Compute a list of allowed keys based on the first key
         ;; pressed, if any.  Some keys
         ;; (?<sup>B</sup>, ?<sup>V</sup>, ?<sup>S</sup>, ?<sup>F</sup>, ?<sup>A</sup>, ?&amp;, ?# and ?q) are always
         ;; available.
         (allowed-keys
          (nconc (list 2 22 19 6 1)
                 (if (not first-key) (org-uniquify (mapcar 'car entries))
                   (let (sub-menu)
                     (dolist (entry entries (sort (mapcar 'car sub-menu) '&lt;))
                       (when (eq (car entry) first-key)
                         (setq sub-menu (append (nth 2 entry) sub-menu))))))
                 (cond ((eq first-key ?P) (list ?f ?p ?x ?a))
                       ((not first-key) (list ?P)))
                 (list ?&amp; ?#)
                 (when expertp (list ??))
                 (list ?q)))
         ;; Build the help menu for standard UI.
         (help
          (unless expertp
            (concat
             ;; Options are hard-coded.
             (format "[%s] Body only:    %s           [%s] Visible only:     %s
\[%s] Export scope: %s       [%s] Force publishing: %s
\[%s] Async export: %s\n\n"
                     (funcall fontify-key "C-b" t)
                     (funcall fontify-value
                              (if (memq 'body options) "On " "Off"))
                     (funcall fontify-key "C-v" t)
                     (funcall fontify-value
                              (if (memq 'visible options) "On " "Off"))
                     (funcall fontify-key "C-s" t)
                     (funcall fontify-value
                              (if (memq 'subtree options) "Subtree" "Buffer "))
                     (funcall fontify-key "C-f" t)
                     (funcall fontify-value
                              (if (memq 'force options) "On " "Off"))
                     (funcall fontify-key "C-a" t)
                     (funcall fontify-value
                              (if (memq 'async options) "On " "Off")))
             ;; Display registered back-end entries.  When a key
             ;; appears for the second time, do not create another
             ;; entry, but append its sub-menu to existing menu.
             (let (last-key)
               (mapconcat
                (lambda (entry)
                  (let ((top-key (car entry)))
                    (concat
                     (unless (eq top-key last-key)
                       (setq last-key top-key)
                       (format "\n[%s] %s\n"
                               (funcall fontify-key (char-to-string top-key))
                               (nth 1 entry)))
                     (let ((sub-menu (nth 2 entry)))
                       (unless (functionp sub-menu)
                         ;; Split sub-menu into two columns.
                         (let ((index -1))
                           (concat
                            (mapconcat
                             (lambda (sub-entry)
                               (incf index)
                               (format
                                (if (zerop (mod index 2)) "    [%s] %-26s"
                                  "[%s] %s\n")
                                (funcall fontify-key
                                         (char-to-string (car sub-entry))
                                         top-key)
                                (nth 1 sub-entry)))
                             sub-menu "")
                            (when (zerop (mod index 2)) "\n"))))))))
                entries ""))
             ;; Publishing menu is hard-coded.
             (format "\n[%s] Publish
    [%s] Current file              [%s] Current project
    [%s] Choose project            [%s] All projects\n\n\n"
                     (funcall fontify-key "P")
                     (funcall fontify-key "f" ?P)
                     (funcall fontify-key "p" ?P)
                     (funcall fontify-key "x" ?P)
                     (funcall fontify-key "a" ?P))
             (format "[%s] Export stack                  [%s] Insert template\n"
                     (funcall fontify-key "&amp;" t)
                     (funcall fontify-key "#" t))
             (format "[%s] %s"
                     (funcall fontify-key "q" t)
                     (if first-key "Main menu" "Exit")))))
         ;; Build prompts for both standard and expert UI.
         (standard-prompt (unless expertp "Export command: "))
         (expert-prompt
          (when expertp
            (format
             "Export command (C-%s%s%s%s%s) [%s]: "
             (if (memq 'body options) (funcall fontify-key "b" t) "b")
             (if (memq 'visible options) (funcall fontify-key "v" t) "v")
             (if (memq 'subtree options) (funcall fontify-key "s" t) "s")
             (if (memq 'force options) (funcall fontify-key "f" t) "f")
             (if (memq 'async options) (funcall fontify-key "a" t) "a")
             (mapconcat (lambda (k)
                          ;; Strip control characters.
                          (unless (&lt; k 27) (char-to-string k)))
                        allowed-keys "")))))
    ;; With expert UI, just read key with a fancy prompt.  In standard
    ;; UI, display an intrusive help buffer.
    (if expertp
        (org-export&#x2013;dispatch-action
         expert-prompt allowed-keys entries options first-key expertp)
      ;; At first call, create frame layout in order to display menu.
      (unless (get-buffer "<b>Org Export Dispatcher</b>")
        (delete-other-windows)
        (org-switch-to-buffer-other-window
         (get-buffer-create "<b>Org Export Dispatcher</b>"))
        (setq cursor-type nil
              header-line-format "Use SPC, DEL, C-n or C-p to navigate.")
        ;; Make sure that invisible cursor will not highlight square
        ;; brackets.
        (set-syntax-table (copy-syntax-table))
        (modify-syntax-entry ?\[ "w"))
      ;; At this point, the buffer containing the menu exists and is
      ;; visible in the current window.  So, refresh it.
      (with-current-buffer "<b>Org Export Dispatcher</b>"
        ;; Refresh help.  Maintain display continuity by re-visiting
        ;; previous window position.
        (let ((pos (window-start)))
          (erase-buffer)
          (insert help)
          (set-window-start nil pos)))
      (org-fit-window-to-buffer)
      (org-export&#x2013;dispatch-action
       standard-prompt allowed-keys entries options first-key expertp))))
</p>

<p>
(defun org-export&#x2013;dispatch-action
  (prompt allowed-keys entries options first-key expertp)
  "Read a character from command input and act accordingly.
</p>

<p>
PROMPT is the displayed prompt, as a string.  ALLOWED-KEYS is
a list of characters available at a given step in the process.
ENTRIES is a list of menu entries.  OPTIONS, FIRST-KEY and
EXPERTP are the same as defined in `org-export&#x2013;dispatch-ui',
which see.
</p>

<p>
Toggle export options when required.  Otherwise, return value is
a list with action as CAR and a list of interactive export
options as CDR."
  (let (key)
    ;; Scrolling: when in non-expert mode, act on motion keys (C-n,
    ;; C-p, SPC, DEL).
    (while (and (setq key (read-char-exclusive prompt))
                (not expertp)
                (memq key '(14 16 ?\s ?\d)))
      (case key
        (14 (if (not (pos-visible-in-window-p (point-max)))
                (ignore-errors (scroll-up 1))
              (message "End of buffer")
              (sit-for 1)))
        (16 (if (not (pos-visible-in-window-p (point-min)))
                (ignore-errors (scroll-down 1))
              (message "Beginning of buffer")
              (sit-for 1)))
        (?\s (if (not (pos-visible-in-window-p (point-max)))
                 (scroll-up nil)
               (message "End of buffer")
               (sit-for 1)))
        (?\d (if (not (pos-visible-in-window-p (point-min)))
                 (scroll-down nil)
               (message "Beginning of buffer")
               (sit-for 1)))))
    (cond
     ;; Ignore undefined associations.
     ((not (memq key allowed-keys))
      (ding)
      (unless expertp (message "Invalid key") (sit-for 1))
      (org-export&#x2013;dispatch-ui options first-key expertp))
     ;; q key at first level aborts export.  At second level, cancel
     ;; first key instead.
     ((eq key ?q) (if (not first-key) (error "Export aborted")
                    (org-export&#x2013;dispatch-ui options nil expertp)))
     ;; Help key: Switch back to standard interface if expert UI was
     ;; active.
     ((eq key ??) (org-export&#x2013;dispatch-ui options first-key nil))
     ;; Send request for template insertion along with export scope.
     ((eq key ?#) (cons 'template (memq 'subtree options)))
     ;; Switch to asynchronous export stack.
     ((eq key ?&amp;) '(stack))
     ;; Toggle options: C-b (2) C-v (22) C-s (19) C-f (6) C-a (1).
     ((memq key '(2 22 19 6 1))
      (org-export&#x2013;dispatch-ui
       (let ((option (case key (2 'body) (22 'visible) (19 'subtree)
                           (6 'force) (1 'async))))
         (if (memq option options) (remq option options)
           (cons option options)))
       first-key expertp))
     ;; Action selected: Send key and options back to
     ;; `org-export-dispatch'.
     ((or first-key (functionp (nth 2 (assq key entries))))
      (cons (cond
             ((not first-key) (nth 2 (assq key entries)))
             ;; Publishing actions are hard-coded.  Send a special
             ;; signal to `org-export-dispatch'.
             ((eq first-key ?P)
              (case key
                (?f 'publish-current-file)
                (?p 'publish-current-project)
                (?x 'publish-choose-project)
                (?a 'publish-all)))
             ;; Return first action associated to FIRST-KEY + KEY
             ;; path. Indeed, derived backends can share the same
             ;; FIRST-KEY.
             (t (catch 'found
                  (mapc (lambda (entry)
                          (let ((match (assq key (nth 2 entry))))
                            (when match (throw 'found (nth 2 match)))))
                        (member (assq first-key entries) entries)))))
            options))
     ;; Otherwise, enter sub-menu.
     (t (org-export&#x2013;dispatch-ui options key expertp)))))
</p>



<p>
(provide 'ox)
</p>

<p>
;; Local variables:
;; generated-autoload-file: "org-loaddefs.el"
;; End:
</p>

<p>
;;; ox.el ends here
</p>
</div>
</div>
</div>


<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> bnf2xml&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ebnf">ebnf</span>&#xa0;<span class="parser">parser</span></span></h2>
<div class="outline-text-2" id="text-9">
<div class="org-src-container">

<pre class="src src-elisp">(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">bnf2xml</span>)
(interactive)
(shell-command bnf2xml)
(insert results at point)
(append-results-to-buffer-or-file)
</pre>
</div>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> BNF parser:</h3>
<div class="outline-text-3" id="text-9-1">
<p>
        recursively does lookups from L to R
        that stops (returns) if terminals are found.
for each LHS item
</p>
<ol class="org-ol">
<li>search for each RHS, or failing that, &#x2026;
</li>
<li>try to match it (a terminal) against input
</li>
</ol>
<p>
If all LHS items on a line finally get matched to terminals: done.
</p>

<p>
LHS : RHS
&lt;a&gt; : &lt;b&gt;
&lt;b&gt; : &lt;c&gt; &lt;b&gt;
&lt;b&gt; : &lt;d&gt; &lt;b&gt;
&lt;d&gt; : &lt;e&gt;
</p>

<p>
Any RHS with no LHS in a bnf table is terminal.
c and d are terminal (no c and d on LHS)
d isn't ever found so e is questionable
</p>

<p>
What that does is group how terminals are matched, and so one can,
with a full bnf file, have a language specified (ie, C) is one use.
</p>


<p>
<code>=============================</code>
this was the initial design
before functions were 
</p>
<div class="org-src-container">

<pre class="src src-language"></pre>
</div>
<p>
hardly writen yet
<code>=============================</code>
</p>


<p>
this implementation was mostly written in early to early '90s when you
couldn't hardly find / download such things (before XML, mid-90's)
development was halted by 1) college  2) health emergencies 3) money
too bad.  not that xml isn't nice.
</p>

<p>
This parser byte compiles (makes op codes) of the BNF table.
It's a multi-line table.  NOTE: input string is seen as flat
there's no "lines of input of file" - none
</p>

<p>
                                <i>/ -&#x2014; BnfSym -&#x2014;
WHAT IS last ?                  /</i> LogLHS uses it to tell FindRHS "fake logical match
                                <i>/ ignore / don't do any action (record, pop, any)
word4symbol, symbol4word        /</i> dictionary lookup / uncrack op code table
SVec3 ssBNFv3 ;                 <i>/ BNF text file v3{string, line, word in line}
DVec1&lt;long, uint&gt; slRHSv1 ;        /</i> RHS symbols for a line (after byte compiles bnf table)
SVec2 ssTRMv2 ;                 <i>/ list of terminal strings (last symbol+1 = termbase, 
                                /</i> ssTRMv2[symb-termbase]=terminal string)
                                <i>/ (for indexing each input char to bnf terminal char table)
DVec2&lt;long, uint&gt; slLHSv2 ;         /</i> LHS symbols for a line
                                <i>/ -&#x2014; Parse -&#x2014;
/</i> all four pushed after each successful search
<i>/ and _found (ones pushed in search) is remarked depending on ret<sub>val</sub>
DVec1&lt;long, uint&gt; lresv1<sub>found</sub> ; /</i> T/F per group
DVec1&lt;long, uint&gt; lresv1<sub>found</sub><sub>item</sub> ; <i>/ T/F  per item
DVec1&lt;long, uint&gt; lresv1<sub>rec</sub><sub>lvl</sub> ; /</i> how deep
                                <i>/ so print can know if repeat push due to recursive search
                                /</i> no of the other pushes can be used to show repeasts
                                <i>/ possible to not push if not necessary?  but using logic for when
                                /</i> to push removes what happened (if you did want to trace failed
<i>/ matches) and could get complicated
DVec1&lt;long, uint&gt; lresv1<sub>line</sub> ;  /</i> current atline of
DVec1&lt;long, uint&gt; lresv1<sub>n</sub> ;     <i>/ n of line[n] == symb if any
DVec1&lt;long, uint&gt; lresv1<sub>symb</sub> ;  /</i> symbol if any
</p>

<p>
        <i>/ these support a "quick find" only of top of search
        /</i> and report is only input and line # really
DVec1&lt;long, uint&gt; slResV1 ;        <i>/ Results vec, pushed, List of symbols for input.
DVec1&lt;long, uint&gt; slSymbLineV1 ; /</i> list of lines numbers matched, pushed
DVec1&lt;long, uint&gt; slSymbV1 ;        <i>/ Index for ea. symbol in ssTRMv2 for input.
                                /</i> A convenience since option based.
                                // list made just before exit by listing slResV1
</p>

<p>
SVec2 ssStrV2 ;                        <i>/ List of matched words in input from BNF file
                                /</i> (no caps for common, etc).
                                <i>/ list made just before exit by listing slResV1
                                /</i> -&#x2014; Program codes for matches -&#x2014;
DVec1&lt;long, uint&gt; slMapedTrmV1 ; <i>/ prog id for terminal strings
                                /</i> ss, "str / str" table
                                <i>/ sl, "str / long" (string / number)
                                /</i> (has nothing to do with parsing)
</p>


<p>
ret<sub>val</sub>  is 0 False no !retval, 1 true yes ret<sub>val</sub>
        (unsigned int) -1 is a special yes check for in one place
</p>


<p>
"this is a FIRST LEVEL parse; this rule file can (in turn)
 define more complicated rule files which can then in
 turn be used to parse more complicated files"
</p>

<p>
Sat Jul  2 21:50:26 EDT 2011
</p>

<p>
HOW?? (took me an hour to remmeber)
</p>
<ul class="org-ul">
<li>each parsed input can be a new bnf line
(instead of getting input from FileArr, recycled)
</li>
<li>after being parsed it needs end up being
the form this parser reads (basic bnf)
</li>
</ul>
<p>
INTERNALS
</p>
<ul class="org-ul">
<li>FileArr(filename)-&gt;BnfSym(file)-&gt;BnfParse(txt)-&gt;FindRHS(txt, syms)
c++ Parse:BnfParse:BnfSym:FileArr
</li>
<li>BnfSym has no specification of what terminals are
any RHS with no LHS is mapped as 'terminal'
</li>
<li>the built in terminators {=,&lt;,&gt;,\t,:,|, ,',"} seem limiting
on a 1st parse but if bnf is recyled they are the target format
(are muted, bnf terminators used to read final input).
</li>
<li>but what IS limiting is built-in operators (&amp;,|,=,~)
These reduce size of final RHS LHS table provide search rules.
A 2nd level bnf can combine ot act like new ones.
<ul class="org-ul">
<li>I'm unsure if that has the same cost.
</li>
</ul>
</li>
</ul>
<p>
WHAT IS VARIABLE 'last' ?
        LogLHS uses it to tell FindRHS "fake logical match - ignore"
        LogLHS -&gt; MatchLHS -&gt; FindRHS (which must know it's fake)
</p>

<p>
orig. bnf features
        &amp; is implied always by bnf form and
                &lt;ab&gt; : &lt;a&gt; &lt;b&gt;
        bnf parser can list recursive matches (a recursive searcher)
                &lt;white&gt; : &lt;whitechar&gt; &lt;white&gt;
</p>

<p>
3 enhacements, meant to be strong yet still basic
</p>

<ol class="org-ol">
<li>| logical search operator - for tech. reasons
</li>

<li>==  is for simpler callers to limit matching to a dictionary
(otherwise a simple caller couldn't read report: too comlicated)
(also a bnf shortcut: "find these [terminal] or quit")
     with &lt;repl&gt; and &lt;sys&gt; (see features)
</li>

<li>3 REPORT : 
a) simple reflection of input matched
b) a quick report showing top line, symbols, and words
   matched (highest line fully matched)
   NOTE: based on report a, not report c
c) extended report dump of all non-failed searches
   trace what you need
</li>
</ol>

<p>
FindRHS can be invoke to begin at whatever line for which symb.
</p>

<p>
todo, if ever: search enhancements
</p>

<p>
ex. to specify groups &lt;being&gt; &lt;end&gt; that "fail one skip the rest of group"
search enhancements, operators, anything to reduce table, extend searching,
or reduce needless searching smartly / by standards
</p>

<p>
support for OPS was added later and (I hope) is completely
separable from the basic code (don't use them in bnf
and the more complex yet separate code is never used)
</p>

<p>
<b>/
/</b>
        TODOS
</p>
<ul class="org-ul">
<li>simple reflexion requires more though to print
&lt;w&gt; : &lt;wc&gt; &lt;w&gt; 
&lt;w&gt; : w &lt;wc&gt; &lt;w&gt; /w /w
&#x2013;&gt;        W " " W " " /W /W
&lt;a&gt; &lt;a&gt; &lt;b&gt; is inf rec
</li>
<li>the fact that ie, 9 30 W 9 30 W repeated pushes
likely means something (ie, logLHS last 0)
maybe never needs to push or pop
        though easily skipped
</li>
</ul>

<p>
// Sat Oct 13 17:05:58 EDT 2012
</p>

<p>
// printing results better&#x2026;
</p>

<p>
two basic ways:
</p>

<ol class="org-ol">
<li>some complicated way that pushes only "wanted info"
</li>
</ol>
<p>
*2)  push all that didn't fail, extra data, and you can
    trace into what you want l8tr
</p>

<p>
    done
*/
</p>


<p>
<code>=============================</code>
this was the initial design
before functions were 
hardly writen yet
<code>=============================</code>
</p>

<p>
/*
Report generation for parser:
        Lvec2 ComTab () const ;
        Svec2 ComStr () const ;
ex. "look at room"
ComTab:
        3                        10                9                4                        8
        3                        200                300                400                        500
ComSym:
        &lt;com&gt;                &lt;verb&gt;        &lt;prep&gt;        &lt;article&gt;        &lt;noun&gt;
        command                look        at                the                        room
*/
</p>

<p>
// &#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;
/*
Contents of Symbol table:
</p>

<ul class="org-ul">
<li>The recursive algorithm only needs unique symbols
</li>
</ul>
<p>
in place of long form, thus:
        char *strtok( char *string1, const char *string2 );
can be (is) used to identify tokens to symbolize.
</p>

<ul class="org-ul">
<li>Symbols have to express whether their token is terminal (T/F &amp;mask).
</li>

<li>The table must contain references to use to match tokens
</li>
</ul>
<p>
        (note that most terminals are not characters).
*/
// &#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;
/*
</p>

<p>
**        Note that the below ignores the difficulty in actually providing the 
correct solution when substitution, identity, and other such features exist.
        Symbols for partial matches musted be pushed as found and poped
if a full statement can't be matched.  Some statements will not need to be
matched.  Complete information on all previous operations would be 
hard to maintain and hard to analyze.
        The sol. is notated somewhat in the source code.  A parameter is used
to keep track of whether the current frame is a frame which will cause all
of the input to be matched.  Frames which aren't responsible in this manner
do not cause the solutions stack to be poped.
</p>

<ol class="org-ol">
<li>find a matching RHS element (noting first is on line 0)
</li>
<li>STARTS on same line as LHS
</li>
</ol>
<p>
1.1R if exits
        2 determin lhs elements
        2.1 if &lt;&gt;== found, do 2.2 else 3.1
        2.2 * matches aggregates to pre-defined terminals
</p>
<ol class="org-ol">
<li>feed &lt;&gt; to rhs MUST return 1 (or return char *)
if ( !(FindRHS(match, atline)) ) // note: we don't want atline changed now&#x2026;
</li>
<li>match &lt;&gt; to terminal and return result
</li>
<li>lhs should be listed to rhs
</li>
</ol>
<p>
3.1 if () found: () here groups logics
</p>
<ul class="org-ul">
<li>start from inner most () (&amp; recurse ?)
</li>
</ul>
<p>
3.2 first | found
</p>
<ul class="org-ul">
<li>feed left and right to this function return |
</li>
<li>this is where to add other logicals
</li>
</ul>
<p>
3.3 feed remaining to rhs, return with &amp;&amp; logic
        a. if T return T
        b. if symlst () (the set?) F, match terminal(s)
</p>
<ol class="org-ol">
<li>match downward only
</li>
<li>match () RHS
</li>
<li>' ','\t','\r','\n' are term separators, ret T?
</li>
<li>if F and ! end line, keep checking
</li>
</ol>
<p>
1.2E if not exits LHS item was terminal, ret T
*/
// &#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;
</p>


<p>
// &#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;
/*
        Notes in source specify a difference from the process below.
        The aim of the notes is to define avail. syntax
<b>/
/</b>
</p>
<ol class="org-ol">
<li>find a matching RHS element (noting first is on line 0)
</li>
<li>STARTS on same line as LHS
</li>
</ol>
<p>
1.1R if exits
        2 determin lhs elements
        2.1 if &lt;&gt;== found, do 2.2 else 3.1
        2.2 * matches aggregates to pre-defined terminals
</p>
<ol class="org-ol">
<li>feed &lt;&gt; to rhs MUST return 1 (or return char *)
if ( !(FindRHS(match, atline)) ) // note: we don't want atline changed now&#x2026;
</li>
<li>match &lt;&gt; to terminal and return result
</li>
<li>lhs should be listed to rhs
</li>
</ol>
<p>
3.1 if () found: () here groups logics
() never found in first level parse - see PROC: list symbols
3.2 an | found
</p>
<ul class="org-ul">
<li>feed left and right to this function return |
</li>
<li>this is where to add other logicals
</li>
</ul>
<p>
3.3 feed remaining to rhs, return with &amp;&amp; logic
        a. if T return T
        b. if symlst () (the set?) F, match terminal(s)
</p>
<ol class="org-ol">
<li>match downward only
</li>
<li>match () RHS
</li>
<li>r','\n' are term separators, ret T?
</li>
<li>if F and ! end line, keep checking
</li>
</ol>
<p>
1.2E if not exits LHS item was terminal, ret T
</p>

<p>
PROC: list symbols:
</p>
<ul class="org-ul">
<li>use start, end idecies
</li>
<li>=
(if symb exits after <code>)
		AndLhs(st, end(OP</code>)) || AndLhs(OP=+1, end)
</li>
<li>|
do
find end
AndLhs(st, end(OP|))
st = OP+1 end = st
until finished
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">return logic</td>
</tr>
</tbody>
</table>
</li>
<li>~ not
same as | except !(&#x2026;) in symbol table 
is in form <code>...</code> 
</li>
<li>&amp;
do
AndLhs(st) to findrhs
++st 
until st==end
&amp; return logic
</li>
</ul>
<p>
*/
// &#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;
/*
Table Build Format:
        note that: 6|&gt;5rhs and 8t&gt;5rhs; 
                                1|2= allows term determination: (!RHS&gt;lhs)
start        guess                guess                        finish
rlll        1 2|143                1 26143                        3 4165                
rlllll        2 23|342        2 236342                4 451564
rllll        3 4=s|s+s        3 47868??                5 6218
rltt        4 tttt                4 9??                        6 9
rttt        5 t                5 (10)                        7 (10&#x2026;)
</p>

<p>
NOTE: 8,9,&gt;10 are terminal that are stored for matching
PROCESS: rhs and lhs are stored seperately
        rhs is a 1 to &#x2026; count
        lhs is the same - but terminals must have a symbol
                differing from bnf identifiers - so they have a 
                number higher than any of those&#x2026;
        termbase is the lowest non bnf identifier in table
        termstr[lhs[i]-termbase] is a terminal to match
</p>

<p>
Q: sym for ea. term in rhs or one for ea. rhs ?
A: 1 uniq. for ea. + lookup allows efficient storage&#x2026;
           &#x2013;&gt; AND easy lookup
</p>

<p>
OOPS: or (|) begins at 1 - 0 will be the unassigned constant
</p>

<p>
ANTIQUITY:
</p>
<ul class="org-ul">
<li>no assignment for operators; they are assumed first (1,2,&#x2026;)
</li>
<li>this is a FIRST LEVEL parse; this rule file can (in turn)
</li>
</ul>
<p>
    define more complicated rule files which can then in
        turn be used to parse more complicated files
*/        
// &#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;&#x2014;
.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> rdf2rdf&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rdf">rdf</span>&#xa0;<span class="parser">parser</span></span></h2>
<div class="outline-text-2" id="text-10">
<div class="org-src-container">

<pre class="src src-elisp">(<span style="color: #00ffff;">defun</span> <span style="color: #87cefa;">rdf2rdf</span>)
(interactive)
(shell-command bnf2xml)
(insert results at point)
(append-results-to-buffer-or-file)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> n3&#xa0;&#xa0;&#xa0;<span class="tag"><span class="src">src</span>&#xa0;<span class="n3">n3</span></span></h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> ttl</h3>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> docs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="doc">doc</span></span></h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> w3-rec&#xa0;&#xa0;&#xa0;<span class="tag"><span class="doc">doc</span></span></h3>
<div class="outline-text-3" id="text-12-1">
<div class="org-src-container">

<pre class="src src-elisp">(w3m-find-file index w3-rec)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> xslt&#xa0;&#xa0;&#xa0;<span class="tag"><span class="parser">parser</span>&#xa0;<span class="rdf">rdf</span>&#xa0;<span class="debug">debug</span></span></h2>
<div class="outline-text-2" id="text-13">
</div><div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1"><span class="section-number-3">13.1</span> XSLT w3-rec</h3>
<div class="outline-text-3" id="text-13-1">
<div class="org-src-container">

<pre class="src src-xslt">&lt;!-- Category: instruction --&gt;
&lt;xsl:copy
  copy-namespaces? = "yes" | "no"
  inherit-namespaces? = "yes" | "no"
  use-attribute-sets? = qnames
  type? = qname
  validation? = "strict" | "lax" | "preserve" | "strip"&gt;
  &lt;!-- Content: sequence-constructor --&gt;
&lt;/xsl:copy&gt;
</pre>
</div>
<p>
Abstract
</p>

<p>
This specification defines the syntax and semantics of XSLT 2.0, a language
for transforming XML documents into other XML documents.
</p>

<p>
XSLT 2.0 is a revised version of the XSLT 1.0 Recommendation [XSLT 1.0]
published on 16 November 1999.
</p>

<p>
XSLT 2.0 is designed to be used in conjunction with XPath 2.0, which is
defined in [XPath 2.0]. XSLT shares the same data model as XPath 2.0, which is
defined in [Data Model], and it uses the library of functions and operators
defined in [Functions and Operators].
</p>

<p>
XSLT 2.0 also includes optional facilities to serialize the results of a
transformation, by means of an interface to the serialization component
described in [XSLT and XQuery Serialization].
</p>

<p>
This document contains hyperlinks to specific sections or definitions within
other documents in this family of specifications. These links are indicated
visually by a superscript identifying the target specification: for example XP
for XPath, DM for the XDM data model, FO for Functions and Operators.
</p>

<p>
Status of this Document
</p>

<p>
This section describes the status of this document at the time of its
publication. Other documents may supersede this document. A list of current
W3C publications and the latest revision of this technical report can be found
in the W3C technical reports index at <a href="http://www.w3.org/TR/">http://www.w3.org/TR/</a>.
</p>

<p>
This Recommendation builds on the success of [XSLT 1.0], which was published
on 16 November 1999. Many new features have been added to the language (see 
J.2 New Functionality) while retaining a high level of backwards compatibility
(see J.1 Incompatible Changes). The changes have been designed to meet the
requirements for XSLT 2.0 described in [XSLT 2.0 Requirements]. The way in
which each requirement has been addressed is outlined in I Checklist of
Requirements.
</p>

<p>
XSLT 2.0 depends on a number of other specifications that have progressed to
Recommendation status at the same time: see [XPath 2.0], [Data Model], 
[Functions and Operators], and [XSLT and XQuery Serialization]. These
subsidiary documents are also referenced in the specification of XQuery 1.0.
</p>

<p>
This document has been produced by the XSL Working Group, which is part of the
XML Activity. The document has been reviewed by W3C Members and other
interested parties, and is endorsed by the Director. It is a stable document
and may be used as reference material or cited as a normative reference from
another document. W3C's role in making the Recommendation is to draw attention
to the specification and to promote its widespread deployment. This enhances
the functionality and interoperability of the Web.
</p>

<p>
A small number of editorial corrections and clarifications have been made to
the document since it was published as a Proposed Recommendation on 21
November 2006. These changes are listed at J.2.4 Changes since Proposed
Recommendation.
</p>

<p>
Please record any comments about this document in W3C's public Bugzilla system
(instructions can be found at <a href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>). If
access to that system is not feasible, you may send your comments to the W3C
XSLT/XPath/XQuery public comments mailing list, public-qt-comments@w3.org. It
is helpful to include the string [XSLT] in the subject line of your comment,
whether made in Bugzilla or in email. Each Bugzilla entry and email message
should contain only one comment. Archives of the comments and responses are
available at <a href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.
</p>

<p>
General public discussion of XSLT takes place on the XSL-List forum.
</p>

<p>
This document was produced by a group operating under the 5 February 2004 W3C
Patent Policy. W3C maintains a public list of any patent disclosures made in
connection with the deliverables of the group; that page also includes
instructions for disclosing a patent. An individual who has actual knowledge
of a patent which the individual believes contains Essential Claim(s) must
disclose the information in accordance with section 6 of the W3C Patent Policy
.
</p>

<p>
Table of Contents
</p>

<p>
1 Introduction
    1.1 What is XSLT?
    1.2 What's New in XSLT 2.0?
2 Concepts
    2.1 Terminology
    2.2 Notation
    2.3 Initiating a Transformation
    2.4 Executing a Transformation
    2.5 The Evaluation Context
    2.6 Parsing and Serialization
    2.7 Extensibility
    2.8 Stylesheets and XML Schemas
    2.9 Error Handling
3 Stylesheet Structure
    3.1 XSLT Namespace
    3.2 Reserved Namespaces
    3.3 Extension Attributes
    3.4 XSLT Media Type
    3.5 Standard Attributes
    3.6 Stylesheet Element
        3.6.1 The default-collation attribute
        3.6.2 User-defined Data Elements
    3.7 Simplified Stylesheet Modules
    3.8 Backwards-Compatible Processing
    3.9 Forwards-Compatible Processing
    3.10 Combining Stylesheet Modules
        3.10.1 Locating Stylesheet Modules
        3.10.2 Stylesheet Inclusion
        3.10.3 Stylesheet Import
    3.11 Embedded Stylesheet Modules
    3.12 Conditional Element Inclusion
    3.13 Built-in Types
    3.14 Importing Schema Components
4 Data Model
    4.1 XML Versions
    4.2 Stripping Whitespace from the Stylesheet
    4.3 Stripping Type Annotations from a Source Tree
    4.4 Stripping Whitespace from a Source Tree
    4.5 Attribute Types and DTD Validation
    4.6 Limits
    4.7 Disable Output Escaping
5 Features of the XSLT Language
    5.1 Qualified Names
    5.2 Unprefixed QNames in Expressions and Patterns
    5.3 Expressions
    5.4 The Static and Dynamic Context
        5.4.1 Initializing the Static Context
        5.4.2 Additional Static Context Components used by XSLT
        5.4.3 Initializing the Dynamic Context
            5.4.3.1 Maintaining Position: the Focus
            5.4.3.2 Other components of the XPath Dynamic Context
        5.4.4 Additional Dynamic Context Components used by XSLT
    5.5 Patterns
        5.5.1 Examples of Patterns
        5.5.2 Syntax of Patterns
        5.5.3 The Meaning of a Pattern
        5.5.4 Errors in Patterns
    5.6 Attribute Value Templates
    5.7 Sequence Constructors
        5.7.1 Constructing Complex Content
        5.7.2 Constructing Simple Content
        5.7.3 Namespace Fixup
    5.8 URI References
6 Template Rules
    6.1 Defining Templates
    6.2 Defining Template Rules
    6.3 Applying Template Rules
    6.4 Conflict Resolution for Template Rules
    6.5 Modes
    6.6 Built-in Template Rules
    6.7 Overriding Template Rules
7 Repetition
8 Conditional Processing
    8.1 Conditional Processing with xsl:if
    8.2 Conditional Processing with xsl:choose
9 Variables and Parameters
    9.1 Variables
    9.2 Parameters
    9.3 Values of Variables and Parameters
    9.4 Creating implicit document nodes
    9.5 Global Variables and Parameters
    9.6 Local Variables and Parameters
    9.7 Scope of Variables
    9.8 Circular Definitions
10 Callable Components
    10.1 Named Templates
        10.1.1 Passing Parameters to Templates
        10.1.2 Tunnel Parameters
    10.2 Named Attribute Sets
    10.3 Stylesheet Functions
11 Creating Nodes and Sequences
    11.1 Literal Result Elements
        11.1.1 Setting the Type Annotation for Literal Result Elements
        11.1.2 Attribute Nodes for Literal Result Elements
        11.1.3 Namespace Nodes for Literal Result Elements
        11.1.4 Namespace Aliasing
    11.2 Creating Element Nodes Using xsl:element
        11.2.1 Setting the Type Annotation for a Constructed Element Node
    11.3 Creating Attribute Nodes Using xsl:attribute
        11.3.1 Setting the Type Annotation for a Constructed Attribute Node
    11.4 Creating Text Nodes
        11.4.1 Literal Text Nodes
        11.4.2 Creating Text Nodes Using xsl:text
        11.4.3 Generating Text with xsl:value-of
    11.5 Creating Document Nodes
    11.6 Creating Processing Instructions
    11.7 Creating Namespace Nodes
    11.8 Creating Comments
    11.9 Copying Nodes
        11.9.1 Shallow Copy
        11.9.2 Deep Copy
    11.10 Constructing Sequences
12 Numbering
    12.1 Formatting a Supplied Number
    12.2 Numbering based on Position in a Document
    12.3 Number to String Conversion Attributes
13 Sorting
    13.1 The xsl:sort Element
        13.1.1 The Sorting Process
        13.1.2 Comparing Sort Key Values
        13.1.3 Sorting Using Collations
    13.2 Creating a Sorted Sequence
    13.3 Processing a Sequence in Sorted Order
14 Grouping
    14.1 The Current Group
    14.2 The Current Grouping Key
    14.3 The xsl:for-each-group Element
    14.4 Examples of Grouping
15 Regular Expressions
    15.1 The xsl:analyze-string instruction
    15.2 Captured Substrings
    15.3 Examples of Regular Expression Matching
16 Additional Functions
    16.1 Multiple Source Documents
    16.2 Reading Text Files
    16.3 Keys
        16.3.1 The xsl:key Declaration
        16.3.2 The key Function
    16.4 Number Formatting
        16.4.1 Defining a Decimal Format
        16.4.2 Processing the Picture String
        16.4.3 Analysing the Picture String
        16.4.4 Formatting the Number
    16.5 Formatting Dates and Times
        16.5.1 The Picture String
        16.5.2 The Language, Calendar, and Country Arguments
        16.5.3 Examples of Date and Time Formatting
    16.6 Miscellaneous Additional Functions
        16.6.1 current
        16.6.2 unparsed-entity-uri
        16.6.3 unparsed-entity-public-id
        16.6.4 generate-id
        16.6.5 system-property
17 Messages
18 Extensibility and Fallback
    18.1 Extension Functions
        18.1.1 Testing Availability of Functions
        18.1.2 Calling Extension Functions
        18.1.3 External Objects
        18.1.4 Testing Availability of Types
    18.2 Extension Instructions
        18.2.1 Designating an Extension Namespace
        18.2.2 Testing Availability of Instructions
        18.2.3 Fallback
19 Final Result Trees
    19.1 Creating Final Result Trees
    19.2 Validation
        19.2.1 Validating Constructed Elements and Attributes
            19.2.1.1 Validation using the [xsl:]validation Attribute
            19.2.1.2 Validation using the [xsl:]type Attribute
            19.2.1.3 The Validation Process
        19.2.2 Validating Document Nodes
20 Serialization
    20.1 Character Maps
    20.2 Disabling Output Escaping
21 Conformance
    21.1 Basic XSLT Processor
    21.2 Schema-Aware XSLT Processor
    21.3 Serialization Feature
    21.4 Backwards Compatibility Feature
</p>

<p>
Appendices
</p>

<p>
A References
    A.1 Normative References
    A.2 Other References
B The XSLT Media Type
    B.1 Registration of MIME Media Type application/xslt+xml
    B.2 Fragment Identifiers
C Glossary (Non-Normative)
D Element Syntax Summary (Non-Normative)
E Summary of Error Conditions (Non-Normative)
F Checklist of Implementation-Defined Features (Non-Normative)
G Schema for XSLT Stylesheets (Non-Normative)
H Acknowledgements (Non-Normative)
I Checklist of Requirements (Non-Normative)
J Changes from XSLT 1.0 (Non-Normative)
    J.1 Incompatible Changes
        J.1.1 Tree construction: whitespace stripping
        J.1.2 Changes in Serialization Behavior
        J.1.3 Backwards Compatibility Behavior
        J.1.4 Incompatibility in the Absence of a Schema
        J.1.5 Compatibility in the Presence of a Schema
        J.1.6 XPath 2.0 Backwards Compatibility
    J.2 New Functionality
        J.2.1 Pervasive changes
        J.2.2 Major Features
        J.2.3 Minor Changes
        J.2.4 Changes since Proposed Recommendation
</p>

<hr  />

<p>
1 Introduction
</p>

<p>
1.1 What is XSLT?
</p>

<p>
This specification defines the syntax and semantics of the XSLT 2.0 language.
</p>

<p>
[Definition: A transformation in the XSLT language is expressed in the form of
a stylesheet, whose syntax is well-formed XML [XML 1.0] conforming to the
Namespaces in XML Recommendation [Namespaces in XML 1.0].]
</p>

<p>
A stylesheet generally includes elements that are defined by XSLT as well as
elements that are not defined by XSLT. XSLT-defined elements are distinguished
by use of the namespace <a href="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</a> (see 3.1 XSLT
Namespace), which is referred to in this specification as the XSLT namespace.
Thus this specification is a definition of the syntax and semantics of the
XSLT namespace.
</p>

<p>
The term stylesheet reflects the fact that one of the important roles of XSLT
is to add styling information to an XML source document, by transforming it
into a document consisting of XSL formatting objects (see [Extensible
Stylesheet Language (XSL)]), or into another presentation-oriented format such
as HTML, XHTML, or SVG. However, XSLT is used for a wide range of
transformation tasks, not exclusively for formatting and presentation
applications.
</p>

<p>
A transformation expressed in XSLT describes rules for transforming zero or
more source trees into one or more result trees. The structure of these trees
is described in [Data Model]. The transformation is achieved by a set of 
template rules. A template rule associates a pattern, which matches nodes in
the source document, with a sequence constructor. In many cases, evaluating
the sequence constructor will cause new nodes to be constructed, which can be
used to produce part of a result tree. The structure of the result trees can
be completely different from the structure of the source trees. In
constructing a result tree, nodes from the source trees can be filtered and
reordered, and arbitrary structure can be added. This mechanism allows a 
stylesheet to be applicable to a wide class of documents that have similar
source tree structures.
</p>

<p>
[Definition: A stylesheet may consist of several stylesheet modules, contained
in different XML documents. For a given transformation, one of these functions
as the principal stylesheet module. The complete stylesheet is assembled by
finding the stylesheet modules referenced directly or indirectly from the
principal stylesheet module using xsl:include and xsl:import elements: see 
3.10.2 Stylesheet Inclusion and 3.10.3 Stylesheet Import.]
</p>

<p>
1.2 What's New in XSLT 2.0?
</p>

<p>
XSLT 1.0 was published in November 1999, and version 2.0 represents a
significant increase in the capability of the language. A detailed list of
changes is included in J Changes from XSLT 1.0. XSLT 2.0 has been developed in
parallel with XPath 2.0 (see [XPath 2.0]), so the changes to XPath must be
considered alongside the changes to XSLT.
</p>

<p>
2 Concepts
</p>

<p>
2.1 Terminology
</p>

<p>
For a full glossary of terms, see C Glossary.
</p>

<p>
[Definition: The software responsible for transforming source trees into
result trees using an XSLT stylesheet is referred to as the processor. This is
sometimes expanded to XSLT processor to avoid any confusion with other
processors, for example an XML processor.]
</p>

<p>
[Definition: A specific product that performs the functions of an XSLT
processor is referred to as an implementation ].
</p>

<p>
[Definition: The term result tree is used to refer to any tree constructed by 
instructions in the stylesheet. A result tree is either a final result tree or
a temporary tree.]
</p>

<p>
[Definition: A final result tree is a result tree that forms part of the final
output of a transformation. Once created, the contents of a final result tree
are not accessible within the stylesheet itself.] The xsl:result-document
instruction always creates a final result tree, and a final result tree may
also be created implicitly by the initial template. The conditions under which
this happens are described in 2.4 Executing a Transformation. A final result
tree may be serialized as described in 20 Serialization.
</p>

<p>
[Definition: The term source tree means any tree provided as input to the
transformation. This includes the document containing the initial context node
if any, documents containing nodes supplied as the values of stylesheet
parameters, documents obtained from the results of functions such as document,
doc^ FO, and collection<sup>FO</sup>, and documents returned by extension functions or
extension instructions. In the context of a particular XSLT instruction, the
term source tree means any tree provided as input to that instruction; this
may be a source tree of the transformation as a whole, or it may be a 
temporary tree produced during the course of the transformation.]
</p>

<p>
[Definition: The term temporary tree means any tree that is neither a source
tree nor a final result tree.] Temporary trees are used to hold intermediate
results during the execution of the transformation.
</p>

<p>
In this specification the phrases must, must not, should, should not, may, 
required, and recommended are to be interpreted as described in [RFC2119].
</p>

<p>
Where the phrase must, must not, or required relates to the behavior of the
XSLT processor, then an implementation is not conformant unless it behaves as
specified, subject to the more detailed rules in 21 Conformance.
</p>

<p>
Where the phrase must, must not, or required relates to a stylesheet, then the
processor must enforce this constraint on stylesheets by reporting an error if
the constraint is not satisfied.
</p>

<p>
Where the phrase should, should not, or recommended relates to a stylesheet,
then a processor may produce warning messages if the constraint is not
satisfied, but must not treat this as an error.
</p>

<p>
[Definition: In this specification, the term implementation-defined refers to
a feature where the implementation is allowed some flexibility, and where the
choices made by the implementation must be described in documentation that
accompanies any conformance claim.]
</p>

<p>
[Definition: The term implementation-dependent refers to a feature where the
behavior may vary from one implementation to another, and where the vendor is
not expected to provide a full specification of the behavior.] (This might
apply, for example, to limits on the size of source documents that can be
transformed.)
</p>

<p>
In all cases where this specification leaves the behavior
implementation-defined or implementation-dependent, the implementation has the
option of providing mechanisms that allow the user to influence the behavior.
</p>

<p>
A paragraph labeled as a Note or described as an example is non-normative.
</p>

<p>
Many terms used in this document are defined in the XPath specification [XPath
2.0] or the XDM specification [Data Model]. Particular attention is drawn to
the following:
</p>

<ul class="org-ul">
<li>[Definition: The term atomization is defined in Section 2.4.2 Atomization^
XP. It is a process that takes as input a sequence of nodes and atomic
values, and returns a sequence of atomic values, in which the nodes are
replaced by their typed values as defined in [Data Model].] For some nodes
(for example, elements with element-only content), atomization generates a
dynamic error.
</li>

<li>[Definition: The term typed value is defined in Section 5.15 typed-value
Accessor<sup>DM</sup>. Every node except an element defined in the schema with
element-only content has a typed value. For example, the typed value of an
attribute of type xs:IDREFS is a sequence of zero or more xs:IDREF values.
]
</li>

<li>[Definition: The term string value is defined in Section 5.13 string-value
Accessor<sup>DM</sup>. Every node has a string value. For example, the string value
of an element is the concatenation of the string values of all its
descendant text nodes.]
</li>

<li>[Definition: The term XPath 1.0 compatibility mode is defined in Section
2.1.1 Static Context<sup>XP</sup>. This is a setting in the static context of an
XPath expression; it has two values, true and false. When the value is set
to true, the semantics of function calls and certain other operations are
adjusted to give a greater degree of backwards compatibility between XPath
2.0 and XPath 1.0.]
</li>
</ul>

<p>
[Definition: The term core function means a function that is specified in 
[Functions and Operators] and that is in the standard function namespace.]
</p>

<p>
2.2 Notation
</p>

<p>
[Definition: An XSLT element is an element in the XSLT namespace whose syntax
and semantics are defined in this specification.] For a non-normative list of
XSLT elements, see D Element Syntax Summary.
</p>

<p>
In this document the specification of each XSLT element is preceded by a
summary of its syntax in the form of a model for elements of that element
type. A full list of all these specifications can be found in D Element Syntax
Summary. The meaning of syntax summary notation is as follows:
</p>

<ul class="org-ul">
<li>An attribute that is required is shown with its name in bold. An attribute
that may be omitted is shown with a question mark following its name.
</li>

<li>An attribute that is deprecated is shown in a grayed font within square
brackets.
</li>

<li>The string that occurs in the place of an attribute value specifies the
allowed values of the attribute. If this is surrounded by curly brackets
({&#x2026;}), then the attribute value is treated as an attribute value
template, and the string occurring within curly brackets specifies the
allowed values of the result of evaluating the attribute value template.
Alternative allowed values are separated by |. A quoted string indicates a
value equal to that specific string. An unquoted, italicized name
specifies a particular type of value.

<p>
In all cases where this specification states that the value of an
attribute must be one of a limited set of values, leading and trailing
whitespace in the attribute value is ignored. In the case of an attribute
value template, this applies to the effective value obtained when the
attribute value template is expanded.
</p>
</li>

<li>Unless the element is required to be empty, the model element contains a
comment specifying the allowed content. The allowed content is specified
in a similar way to an element type declaration in XML; sequence
constructor means that any mixture of text nodes, literal result elements,
extension instructions, and XSLT elements from the instruction category is
allowed; other-declarations means that any mixture of XSLT elements from
the declaration category, other than xsl:import, is allowed, together with
user-defined data elements.
</li>

<li>The element is prefaced by comments indicating if it belongs to the
instruction category or declaration category or both. The category of an
element only affects whether it is allowed in the content of elements that
allow a sequence constructor or other-declarations.
</li>
</ul>

<p>
Example: Syntax Notation
</p>

<p>
This example illustrates the notation used to describe XSLT elements.
</p>

<p>
&lt;!&#x2013; Category: instruction &#x2013;&gt;
&lt;xsl:example-element
  select = expression
  debug? = { "yes" | "no" }&gt;
  &lt;!&#x2013; Content: ((xsl:variable | xsl:param)*, xsl:sequence) &#x2013;&gt;
&lt;/xsl:example-element&gt;
</p>

<p>
This example defines a (non-existent) element xsl:example-element. The element
is classified as an instruction. It takes a mandatory select attribute, whose
value is an XPath expression, and an optional debug attribute, whose value 
must be either yes or no; the curly brackets indicate that the value can be
defined as an attribute value template, allowing a value such as debug="
{$debug}", where the variable debug is evaluated to yield "yes" or "no" at
run-time.
</p>

<p>
The content of an xsl:example-element instruction is defined to be a sequence
of zero or more xsl:variable and xsl:param elements, followed by an 
xsl:sequence element.
</p>

<p>
[ERR XTSE0010] A static error is signaled if an XSLT-defined element is used
in a context where it is not permitted, if a required attribute is omitted, or
if the content of the element does not correspond to the content that is
allowed for the element.
</p>

<p>
Attributes are validated as follows. These rules apply to the value of the
attribute after removing leading and trailing whitespace.
</p>

<ul class="org-ul">
<li>[ERR XTSE0020] It is a static error if an attribute (other than an
attribute written using curly brackets in a position where an attribute
value template is permitted) contains a value that is not one of the
permitted values for that attribute.
</li>

<li>[ERR XTDE0030] It is a non-recoverable dynamic error if the effective
value of an attribute written using curly brackets, in a position where an
attribute value template is permitted, is a value that is not one of the
permitted values for that attribute. If the processor is able to detect
the error statically (for example, when any XPath expressions within the
curly brackets can be evaluated statically), then the processor may
optionally signal this as a static error.
</li>
</ul>

<p>
Special rules apply if the construct appears in part of the stylesheet that is
processed with forwards-compatible behavior: see 3.9 Forwards-Compatible
Processing.
</p>

<p>
[Definition: Some constructs defined in this specification are described as
being deprecated. The use of this term implies that stylesheet authors should
not use the construct, and that the construct may be removed in a later
version of this specification.] All constructs that are deprecated in this
specification are also (as it happens) optional features that implementations
are not required to provide.
</p>

<p>
Note:
</p>

<p>
This working draft includes a non-normative XML Schema for XSLT stylesheet
modules (see G Schema for XSLT Stylesheets). The syntax summaries described in
this section are normative.
</p>

<p>
XSLT defines a set of standard functions which are additional to those defined
in [Functions and Operators]. The signatures of these functions are described
using the same notation as used in [Functions and Operators]. The names of
these functions are all in the standard function namespace.
</p>

<p>
2.3 Initiating a Transformation
</p>

<p>
This document does not specify any application programming interfaces or other
interfaces for initiating a transformation. This section, however, describes
the information that is supplied when a transformation is initiated. Except
where otherwise indicated, the information is required.
</p>

<p>
Implementations may allow a transformation to run as two or more phases, for
example parsing, compilation and execution. Such a distinction is outside the
scope of this specification, which treats transformation as a single process
controlled using a set of stylesheet modules, supplied in the form of XML
documents.
</p>

<p>
The following information is supplied to execute a transformation:
</p>

<ul class="org-ul">
<li>The stylesheet module that is to act as the principal stylesheet module
for the transformation. The complete stylesheet is assembled by
recursively expanding the xsl:import and xsl:include declarations in the
principal stylesheet module, as described in 3.10.2 Stylesheet Inclusion
and 3.10.3 Stylesheet Import.
</li>

<li>A set (possibly empty) of values for stylesheet parameters (see 9.5 Global
Variables and Parameters). These values are available for use within 
expressions in the stylesheet.
</li>

<li>[Definition: A node that acts as the initial context node for the
transformation. This node is accessible within the stylesheet as the
initial value of the XPath expressions . (dot) and self::node(), as
described in 5.4.3.1 Maintaining Position: the Focus].

<p>
If no initial context node is supplied, then the context item, context
position, and context size will initially be undefined, and the evaluation
of any expression that references these values will result in a dynamic
error. (Note that the initial context size and context position will
always be 1 (one) when an initial context node is supplied, and will be
undefined if no initial context node is supplied).
</p>
</li>

<li>Optionally, the name of a named template which is to be executed as the
entry point to the transformation. This template must exist within the 
stylesheet. If no named template is supplied, then the transformation
starts with the template rule that best matches the initial context node,
according to the rules defined in 6.4 Conflict Resolution for Template
Rules. Either a named template, or an initial context node, or both, must
be supplied.
</li>

<li>Optionally, an initial mode. This must either be the default mode, or a
mode that is explicitly named in the mode attribute of an xsl:template
declaration within the stylesheet. If an initial mode is supplied, then in
searching for the template rule that best matches the initial context node
, the processor considers only those rules that apply to the initial mode.
If no initial mode is supplied, the default mode is used.
</li>

<li>A base output URI. [Definition:  The base output URI is a URI to be used
as the base URI when resolving a relative URI allocated to a final result
tree. If the transformation generates more than one final result tree,
then typically each one will be allocated a URI relative to this base URI.
] The way in which a base output URI is established is 
implementation-defined.
</li>

<li>A mechanism for obtaining a document node and a media type, given an
absolute URI. The total set of available documents (modeled as a mapping
from URIs to document nodes) forms part of the context for evaluating
XPath expressions, specifically the doc^ FO function. The XSLT document
function additionally requires the media type of the resource
representation, for use in interpreting any fragment identifier present
within a URI Reference.

<p>
Note:
</p>

<p>
The set of documents that are available to the stylesheet is 
implementation-dependent, as is the processing that is carried out to
construct a tree representing the resource retrieved using a given URI.
Some possible ways of constructing a document (specifically, rules for
constructing a document from an Infoset or from a PSVI) are described in 
[Data Model].
</p>
</li>
</ul>

<p>
[ERR XTDE0040] It is a non-recoverable dynamic error if the invocation of the 
stylesheet specifies a template name that does not match the expanded-QName of
a named template defined in the stylesheet.
</p>

<p>
[ERR XTDE0045] It is a non-recoverable dynamic error if the invocation of the 
stylesheet specifies an initial mode (other than the default mode) that does
not match the expanded-QName in the mode attribute of any template defined in
the stylesheet.
</p>

<p>
[ERR XTDE0047] It is a non-recoverable dynamic error if the invocation of the 
stylesheet specifies both an initial mode and an initial template.
</p>

<p>
[ERR XTDE0050] It is a non-recoverable dynamic error if the stylesheet that is
invoked declares a visible stylesheet parameter with required="yes" and no
value for this parameter is supplied during the invocation of the stylesheet.
A stylesheet parameter is visible if it is not masked by another global
variable or parameter with the same name and higher import precedence.
</p>

<p>
[Definition: The transformation is performed by evaluating an initial template
. If a named template is supplied when the transformation is initiated, then
this is the initial template; otherwise, the initial template is the template
rule selected according to the rules of the xsl:apply-templates instruction
for processing the initial context node in the initial mode.]
</p>

<p>
Parameters passed to the transformation by the client application are matched
against stylesheet parameters (see 9.5 Global Variables and Parameters), not
against the template parameters declared within the initial template. All 
template parameters within the initial template to be executed will take their
default values.
</p>

<p>
[ERR XTDE0060] It is a non-recoverable dynamic error if the initial template
defines a template parameter that specifies required="yes".
</p>

<p>
A stylesheet can process further source documents in addition to those
supplied when the transformation is invoked. These additional documents can be
loaded using the functions document (see 16.1 Multiple Source Documents) or 
doc^ FO or collection<sup>FO</sup> (see [Functions and Operators]), or they can be
supplied as stylesheet parameters (see 9.5 Global Variables and Parameters),
or as the result of an extension function (see 18.1 Extension Functions).
</p>

<p>
2.4 Executing a Transformation
</p>

<p>
[Definition: A stylesheet contains a set of template rules (see 6 Template
Rules). A template rule has three parts: a pattern that is matched against
nodes, a (possibly empty) set of template parameters, and a sequence
constructor that is evaluated to produce a sequence of items.] In many cases
these items are newly constructed nodes, which are then written to a result
tree.
</p>

<p>
A transformation as a whole is executed by evaluating the sequence constructor
of the initial template as described in 5.7 Sequence Constructors.
</p>

<p>
If the initial template has an as attribute, then the result sequence of the
initial template is checked against the required type in the same way as for
any other template. If this result sequence is non-empty, then it is used to
construct an implicit final result tree, following the rules described in 
5.7.1 Constructing Complex Content: the effect is as if the initial template T
were called by an implicit template of the form:
</p>

<p>
&lt;xsl:template name="IMPLICIT"&gt;
  &lt;xsl:result-document href=""&gt;
    &lt;xsl:call-template name="T"/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</p>

<p>
An implicit result tree is also created when the result sequence is empty,
provided that no xsl:result-document instruction has been evaluated during the
course of the transformation. In this situation the implicit result tree will
consist of a document node with no children.
</p>

<p>
Note:
</p>

<p>
This means that there is always at least one result tree. It also means that
if the content of the initial template is a single xsl:result-document
instruction, as in the example above, then only one result tree is produced,
not two. It is useful to make the result document explicit as this is the only
way of invoking document-level validation.
</p>

<p>
If the result of the initial template is non-empty, and an explicit 
xsl:result-document instruction has been evaluated with the empty attribute
href="", then an error will occur [see ERR XTDE1490], since it is not possible
to create two final result trees with the same URI.
</p>

<p>
A sequence constructor is a sequence of sibling nodes in the stylesheet, each
of which is either an XSLT instruction, a literal result element, a text node,
or an extension instruction.
</p>

<p>
[Definition: An instruction is either an XSLT instruction or an extension
instruction.]
</p>

<p>
[Definition: An XSLT instruction is an XSLT element whose syntax summary in
this specification contains the annotation &lt;!&#x2013; category: instruction &#x2013;&gt;.]
</p>

<p>
Extension instructions are described in 18.2 Extension Instructions.
</p>

<p>
The main categories of XSLT instruction are as follows:
</p>

<ul class="org-ul">
<li>instructions that create new nodes: xsl:document, xsl:element, 
xsl:attribute, xsl:processing-instruction, xsl:comment, xsl:value-of, 
xsl:text, xsl:namespace;
</li>

<li>an instruction that returns an arbitrary sequence by evaluating an XPath
expression: xsl:sequence;
</li>

<li>instructions that cause conditional or repeated evaluation of nested
instructions: xsl:if, xsl:choose, xsl:for-each, xsl:for-each-group;
</li>

<li>instructions that invoke templates: xsl:apply-templates, xsl:apply-imports
, xsl:call-template, xsl:next-match;
</li>

<li>Instructions that declare variables: xsl:variable, xsl:param;
</li>

<li>other specialized instructions: xsl:number, xsl:analyze-string, 
xsl:message, xsl:result-document.
</li>
</ul>

<p>
Often, a sequence constructor will include an xsl:apply-templates instruction,
which selects a sequence of nodes to be processed. Each of the selected nodes
is processed by searching the stylesheet for a matching template rule and
evaluating the sequence constructor of that template rule. The resulting
sequences of items are concatenated, in order, to give the result of the 
xsl:apply-templates instruction, as described in 6.3 Applying Template Rules;
this sequence is often added to a result tree. Since the sequence constructors
of the selected template rules may themselves contain xsl:apply-templates
instructions, this results in a cycle of selecting nodes, identifying template
rules, constructing sequences, and constructing result trees, that recurses
through a source tree.
</p>

<p>
2.5 The Evaluation Context
</p>

<p>
The results of some expressions and instructions in a stylesheet may depend on
information provided contextually. This context information is divided into
two categories: the static context, which is known during static analysis of
the stylesheet, and the dynamic context, which is not known until the
stylesheet is evaluated. Although information in the static context is known
at analysis time, it is sometimes used during stylesheet evaluation.
</p>

<p>
Some context information can be set by means of declarations within the
stylesheet itself. For example, the namespace bindings used for any XPath
expression are determined by the namespace declarations present in containing
elements in the stylesheet. Other information may be supplied externally or
implicitly: an example is the current date and time.
</p>

<p>
The context information used in processing an XSLT stylesheet includes as a
subset all the context information required when evaluating XPath expressions.
The XPath 2.0 specification defines a static and dynamic context that the host
language (in this case, XSLT) may initialize, which affects the results of
XPath expressions used in that context. XSLT augments the context with
additional information: this additional information is used firstly by XSLT
constructs outside the scope of XPath (for example, the xsl:sort element), and
secondly, by functions that are defined in the XSLT specification (such as key
and format-number) that are available for use in XPath expressions appearing
within a stylesheet.
</p>

<p>
The static context for an expression or other construct in a stylesheet is
determined by the place in which it appears lexically. The details vary for
different components of the static context, but in general, elements within a
stylesheet module affect the static context for their descendant elements
within the same stylesheet module.
</p>

<p>
The dynamic context is maintained as a stack. When an instruction or
expression is evaluated, it may add dynamic context information to the stack;
when evaluation is complete, the dynamic context reverts to its previous
state. An expression that accesses information from the dynamic context always
uses the value at the top of the stack.
</p>

<p>
The most commonly used component of the dynamic context is the context item.
This is an implicit variable whose value is the item (it may be a node or an
atomic value) currently being processed. The value of the context item can be
referenced within an XPath expression using the expression . (dot).
</p>

<p>
Full details of the static and dynamic context are provided in 5.4 The Static
and Dynamic Context.
</p>

<p>
2.6 Parsing and Serialization
</p>

<p>
An XSLT stylesheet describes a process that constructs a set of final result
trees from a set of source trees.
</p>

<p>
The stylesheet does not describe how a source tree is constructed. Some
possible ways of constructing source trees are described in [Data Model].
Frequently an implementation will operate in conjunction with an XML parser
(or more strictly, in the terminology of [XML 1.0], an XML processor), to
build a source tree from an input XML document. An implementation may also
provide an application programming interface allowing the tree to be
constructed directly, or allowing it to be supplied in the form of a DOM
Document object (see [DOM Level 2]). This is outside the scope of this
specification. Users should be aware, however, that since the input to the
transformation is a tree conforming to the XDM data model as described in 
[Data Model], constructs that might exist in the original XML document, or in
the DOM, but which are not within the scope of the data model, cannot be
processed by the stylesheet and cannot be guaranteed to remain unchanged in
the transformation output. Such constructs include CDATA section boundaries,
the use of entity references, and the DOCTYPE declaration and internal DTD
subset.
</p>

<p>
[Definition: A frequent requirement is to output a final result tree as an XML
document (or in other formats such as HTML). This process is referred to as 
serialization.]
</p>

<p>
Like parsing, serialization is not part of the transformation process, and it
is not required that an XSLT processor must be able to perform serialization.
However, for pragmatic reasons, this specification describes declarations (the
xsl:output element and the xsl:character-map declarations, see 20
Serialization), and attributes on the xsl:result-document instruction, that
allow a stylesheet to specify the desired properties of a serialized output
file. When serialization is not being performed, either because the
implementation does not support the serialization option, or because the user
is executing the transformation in a way that does not invoke serialization,
then the content of the xsl:output and xsl:character-map declarations has no
effect. Under these circumstances the processor may report any errors in an 
xsl:output or xsl:character-map declaration, or in the serialization
attributes of xsl:result-document, but is not required to do so.
</p>

<p>
2.7 Extensibility
</p>

<p>
XSLT defines a number of features that allow the language to be extended by
implementers, or, if implementers choose to provide the capability, by users.
These features have been designed, so far as possible, so that they can be
used without sacrificing interoperability. Extensions other than those
explicitly defined in this specification are not permitted.
</p>

<p>
These features are all based on XML namespaces; namespaces are used to ensure
that the extensions provided by one implementer do not clash with those of a
different implementer.
</p>

<p>
The most common way of extending the language is by providing additional
functions, which can be invoked from XPath expressions. These are known as 
extension functions, and are described in 18.1 Extension Functions.
</p>

<p>
It is also permissible to extend the language by providing new instructions.
These are referred to as extension instructions, and are described in 18.2
Extension Instructions. A stylesheet that uses extension instructions must
declare that it is doing so by using the [xsl:]extension-element-prefixes
attribute.
</p>

<p>
Extension instructions and extension functions defined according to these
rules may be provided by the implementer of the XSLT processor, and the
implementer may also provide facilities to allow users to create further
extension instructions and extension functions.
</p>

<p>
This specification defines how extension instructions and extension functions
are invoked, but the facilities for creating new extension instructions and
extension functions are implementation-defined. For further details, see 18
Extensibility and Fallback.
</p>

<p>
The XSLT language can also be extended by the use of extension attributes (see
3.3 Extension Attributes), and by means of user-defined data elements (see 
3.6.2 User-defined Data Elements).
</p>

<p>
2.8 Stylesheets and XML Schemas
</p>

<p>
An XSLT stylesheet can make use of information from a schema. An XSLT
transformation can take place in the absence of a schema (and, indeed, in the
absence of a DTD), but where the source document has undergone schema validity
assessment, the XSLT processor has access to the type information associated
with individual nodes, not merely to the untyped text.
</p>

<p>
Information from a schema can be used both statically (when the stylesheet is
compiled), and dynamically (during evaluation of the stylesheet to transform a
source document).
</p>

<p>
There are places within a stylesheet, and within XPath expressions and 
patterns in a stylesheet, where it is possible to refer to named type
definitions in a schema, or to element and attribute declarations. For
example, it is possible to declare the types expected for the parameters of a
function. This is done using the SequenceType^ XP syntax defined in [XPath
2.0].
</p>

<p>
[Definition: Type definitions and element and attribute declarations are
referred to collectively as schema components.]
</p>

<p>
[Definition: The schema components that may be referenced by name in a 
stylesheet are referred to as the in-scope schema components. This set is the
same throughout all the modules of a stylesheet.]
</p>

<p>
The conformance rules for XSLT 2.0, defined in 21 Conformance, distinguish
between a basic XSLT processor and a schema-aware XSLT processor. As the names
suggest, a basic XSLT processor does not support the features of XSLT that
require access to schema information, either statically or dynamically. A 
stylesheet that works with a basic XSLT processor will produce the same
results with a schema-aware XSLT processor provided that the source documents
are untyped (that is, they are not validated against a schema). However, if
source documents are validated against a schema then the results may be
different from the case where they are not validated. Some constructs that
work on untyped data may fail with typed data (for example, an attribute of
type xs:date cannot be used as an argument of the substring<sup>FO</sup> function) and
other constructs may produce different results depending on the data type (for
example, given the element &lt;product price="10.00" discount="2.00"/&gt;, the
expression @price gt @discount will return true if the attributes have type
xs:decimal, but will return false if they are untyped).
</p>

<p>
There is a standard set of type definitions that are always available as 
in-scope schema components in every stylesheet. These are defined in 3.13
Built-in Types. The set of built-in types varies between a basic XSLT
processor and a schema-aware XSLT processor.
</p>

<p>
The remainder of this section describes facilities that are available only
with a schema-aware XSLT processor.
</p>

<p>
Additional schema components (type definitions, element declarations, and
attribute declarations) may be added to the in-scope schema components by
means of the xsl:import-schema declaration in a stylesheet.
</p>

<p>
The xsl:import-schema declaration may reference an external schema document by
means of a URI, or it may contain an inline xs:schema element.
</p>

<p>
It is only necessary to import a schema explicitly if one or more of its 
schema components are referenced explicitly by name in the stylesheet; it is
not necessary to import a schema merely because the stylesheet is used to
process a source document that has been assessed against that schema. It is
possible to make use of the information resulting from schema assessment (for
example, the fact that a particular attribute holds a date) even if no schema
has been imported by the stylesheet.
</p>

<p>
Further, importing a schema does not of itself say anything about the type of
the source document that the stylesheet is expected to process. The imported
type definitions can be used for temporary nodes or for nodes on a result tree
just as much as for nodes in source documents. It is possible to make
assertions about the type of an input document by means of tests within the 
stylesheet. For example:
</p>

<p>
Example: Asserting the Required Type of the Source Document
</p>

<p>
&lt;xsl:template match="document-node(schema-element(my:invoice))" priority="2"&gt;
. . .
&lt;/xsl:template&gt;
</p>

<p>
&lt;xsl:template match="document-node()" priority="1"&gt;
  &lt;xsl:message terminate="yes"&gt;Source document is not an invoice&lt;/xsl:message&gt;
&lt;/xsl:template&gt;
</p>

<p>
This example will cause the transformation to fail with an error message
unless the document element of the source document is valid against the
top-level element declaration my:invoice, and has been annotated as such.
</p>

<p>
It is possible that a source document may contain nodes whose type annotation
is not one of the types imported by the stylesheet. This creates a potential
problem because in the case of an expression such as data(.) instance of
xs:integer the system needs to know whether the type named in the type
annotation of the context node is derived by restriction from the type
xs:integer. This information is not explicitly available in an XDM tree, as
defined in [Data Model]. The implementation may choose one of several
strategies for dealing with this situation:
</p>

<ol class="org-ol">
<li>The processor may signal a non-recoverable dynamic error if a source
document is found to contain a type annotation that is not known to the
processor.
</li>

<li>The processor may maintain additional metadata, beyond that described in 
[Data Model], that allows the source document to be processed as if all
the necessary schema information had been imported using xsl:import-schema
. Such metadata might be held in the data structure representing the
source document itself, or it might be held in a system catalog or
repository.
</li>

<li>The processor may be configured to use a fixed set of schemas, which are
automatically used to validate all source documents before they can be
supplied as input to a transformation. In this case it is impossible for a
source document to have a type annotation that the processor is not aware
of.
</li>

<li>The processor may be configured to treat the source document as if no
schema processing had been performed, that is, effectively to strip all
type annotations from elements and attributes on input, marking them
instead as having type xs:untyped and xs:untypedAtomic respectively.
</li>
</ol>

<p>
Where a stylesheet author chooses to make assertions about the types of nodes
or of variables and parameters, it is possible for an XSLT processor to
perform static analysis of the stylesheet (that is, analysis in the absence of
any source document). Such analysis may reveal errors that would otherwise not
be discovered until the transformation is actually executed. An XSLT processor
is not required to perform such static type-checking. Under some circumstances
(see 2.9 Error Handling) type errors that are detected early may be reported
as static errors. In addition an implementation may report any condition found
during static analysis as a warning, provided that this does not prevent the
stylesheet being evaluated as described by this specification.
</p>

<p>
A stylesheet can also control the type annotations of nodes that it constructs
in a final result tree, or in temporary trees. This can be done in a number of
ways.
</p>

<ul class="org-ul">
<li>It is possible to request explicit validation of a complete document, that
is, a tree rooted at a document node. This applies both to temporary trees
constructed using the xsl:document (or xsl:copy) instruction and also to 
final result trees constructed using xsl:result-document. Validation is
either strict or lax, as described in [XML Schema Part 1]. If validation
of a result tree fails (strictly speaking, if the outcome of the validity
assessment is invalid), then the transformation fails, but in all other
cases, the element and attribute nodes of the tree will be annotated with
the names of the types to which these nodes conform. These type
annotations will be discarded if the result tree is serialized as an XML
document, but they remain available when the result tree is passed to an
application (perhaps another stylesheet) for further processing.
</li>

<li>It is also possible to validate individual element and attribute nodes as
they are constructed. This is done using the type and validation
attributes of the xsl:element, xsl:attribute, xsl:copy, and xsl:copy-of
instructions, or the xsl:type and xsl:validation attributes of a literal
result element.
</li>

<li>When elements, attributes, or document nodes are copied, either explicitly
using the xsl:copy or xsl:copy-of instructions, or implicitly when nodes
in a sequence are attached to a new parent node, the options validation=
"strip" and validation="preserve" are available, to control whether
existing type annotations are to be retained or not.
</li>
</ul>

<p>
When nodes in a temporary tree are validated, type information is available
for use by operations carried out on the temporary tree, in the same way as
for a source document that has undergone schema assessment.
</p>

<p>
For details of how validation of element and attribute nodes works, see 19.2
Validation.
</p>

<p>
2.9 Error Handling
</p>

<p>
[Definition: An error that is detected by examining a stylesheet before
execution starts (that is, before the source document and values of stylesheet
parameters are available) is referred to as a static error.]
</p>

<p>
Errors classified in this specification as static errors must be signaled by
all implementations: that is, the processor must indicate that the error is
present. A static error must be signaled even if it occurs in a part of the 
stylesheet that is never evaluated. Static errors are never recoverable. After
signaling a static error, a processor may continue for the purpose of
signaling additional errors, but it must eventually terminate abnormally
without producing any final result tree.
</p>

<p>
There is an exception to this rule when the stylesheet specifies 
forwards-compatible behavior (see 3.9 Forwards-Compatible Processing).
</p>

<p>
Generally, errors in the structure of the stylesheet, or in the syntax of
XPath expressions contained in the stylesheet, are classified as static errors
. Where this specification states that an element in the stylesheet must or 
must not appear in a certain position, or that it must or must not have a
particular attribute, or that an attribute must or must not have a value
satisfying specified conditions, then any contravention of this rule is a
static error unless otherwise specified.
</p>

<p>
[Definition: An error that is not detected until a source document is being
transformed is referred to as a dynamic error.]
</p>

<p>
[Definition: Some dynamic errors are classed as recoverable errors. When a
recoverable error occurs, this specification allows the processor either to
signal the error (by reporting the error condition and terminating execution)
or to take a defined recovery action and continue processing.] It is 
implementation-defined whether the error is signaled or the recovery action is
taken.
</p>

<p>
[Definition: If an implementation chooses to recover from a recoverable
dynamic error, it must take the optional recovery action defined for that
error condition in this specification.]
</p>

<p>
When the implementation makes the choice between signaling a dynamic error or
recovering, it is not restricted in how it makes the choice; for example, it 
may provide options that can be set by the user. When an implementation
chooses to recover from a dynamic error, it may also take other action, such
as logging a warning message.
</p>

<p>
[Definition: A dynamic error that is not recoverable is referred to as a 
non-recoverable dynamic error. When a non-recoverable dynamic error occurs,
the processor must signal the error, and the transformation fails.]
</p>

<p>
Because different implementations may optimize execution of the stylesheet in
different ways, the detection of dynamic errors is to some degree 
implementation-dependent. In cases where an implementation is able to produce
the final result trees without evaluating a particular construct, the
implementation is never required to evaluate that construct solely in order to
determine whether doing so causes a dynamic error. For example, if a variable
is declared but never referenced, an implementation may choose whether or not
to evaluate the variable declaration, which means that if evaluating the
variable declaration causes a dynamic error, some implementations will signal
this error and others will not.
</p>

<p>
There are some cases where this specification requires that a construct must
not be evaluated: for example, the content of an xsl:if instruction must not
be evaluated if the test condition is false. This means that an implementation
must not signal any dynamic errors that would arise if the construct were
evaluated.
</p>

<p>
An implementation may signal a dynamic error before any source document is
available, but only if it can determine that the error would be signaled for
every possible source document and every possible set of parameter values. For
example, some circularity errors fall into this category: see 9.8 Circular
Definitions.
</p>

<p>
The XPath specification states (see Section 2.3.1 Kinds of Errors<sup>XP</sup>) that if
any expression (at any level) can be evaluated during the analysis phase
(because all its explicit operands are known and it has no dependencies on the
dynamic context), then any error in performing this evaluation may be reported
as a static error. For XPath expressions used in an XSLT stylesheet, however,
any such errors must not be reported as static errors in the stylesheet unless
they would occur in every possible evaluation of that stylesheet; instead,
they must be signaled as dynamic errors, and signaled only if the XPath
expression is actually evaluated.
</p>

<p>
Example: Errors in Constant Subexpressions
</p>

<p>
An XPath processor may report statically that the expression 1 div 0 fails
with a "divide by zero" error. But suppose this XPath expression occurs in an
XSLT construct such as:
</p>

<p>
&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
</p>

<p>
Then the XSLT processor must not report an error, because the relevant XPath
construct appears in a context where it will never be executed by an XSLT 2.0
processor. (An XSLT 1.0 processor will execute this code successfully,
returning positive infinity, because it uses double arithmetic rather than
decimal arithmetic.)
</p>

<p>
[Definition: Certain errors are classified as type errors. A type error occurs
when the value supplied as input to an operation is of the wrong type for that
operation, for example when an integer is supplied to an operation that
expects a node.] If a type error occurs in an instruction that is actually
evaluated, then it must be signaled in the same way as a non-recoverable
dynamic error. Alternatively, an implementation may signal a type error during
the analysis phase in the same way as a static error, even if it occurs in
part of the stylesheet that is never evaluated, provided it can establish that
execution of a particular construct would never succeed.
</p>

<p>
It is implementation-defined whether type errors are signaled statically.
</p>

<p>
Example: A Type Error
</p>

<p>
The following construct contains a type error, because 42 is not allowed as an
operand of the xsl:apply-templates instruction. An implementation may
optionally signal this as a static error, even though the offending
instruction will never be evaluated, and the type error would therefore never
be signaled as a dynamic error.
</p>

<p>
&lt;xsl:if test="false()"&gt;
  &lt;xsl:apply-templates select="42"/&gt;
&lt;/xsl:if&gt;
</p>

<p>
On the other hand, in the following example it is not possible to determine
statically whether the operand of xsl:apply-templates will have a suitable
dynamic type. An implementation may produce a warning in such cases, but it 
must not treat it as an error.
</p>

<p>
&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:apply-templates select="$p"/&gt;
&lt;/xsl:template&gt;
</p>

<p>
If more than one error arises, an implementation is not required to signal any
errors other than the first one that it detects. It is 
implementation-dependent which of the several errors is signaled. This applies
both to static errors and to dynamic errors. An implementation is allowed to
signal more than one error, but if any errors have been signaled, it must not
finish as if the transformation were successful.
</p>

<p>
When a transformation signals one or more dynamic errors, the final state of
any persistent resources updated by the transformation is 
implementation-dependent. Implementations are not required to restore such
resources to their initial state. In particular, where a transformation
produces multiple result documents, it is possible that one or more serialized
result documents may be written successfully before the transformation
terminates, but the application cannot rely on this behavior.
</p>

<p>
Everything said above about error handling applies equally to errors in
evaluating XSLT instructions, and errors in evaluating XPath expressions.
Static errors and dynamic errors may occur in both cases.
</p>

<p>
[Definition: If a transformation has successfully produced a final result tree
, it is still possible that errors may occur in serializing the result tree.
For example, it may be impossible to serialize the result tree using the
encoding selected by the user. Such an error is referred to as a serialization
error.] If the processor performs serialization, then it must do so as
specified in 20 Serialization, and in particular it must signal any
serialization errors that occur.
</p>

<p>
Errors are identified by a QName. For errors defined in this specification,
the namespace of the QName is always <a href="http://www.w3.org/2005/xqt-errors">http://www.w3.org/2005/xqt-errors</a> (and is
therefore not given explicitly), while the local part is an 8-character code
in the form PPSSNNNN. Here PP is always XT (meaning XSLT), and SS is one of SE
(static error), DE (dynamic error), RE (recoverable dynamic error), or TE
(type error). Note that the allocation of an error to one of these categories
is purely for convenience and carries no normative implications about the way
the error is handled. Many errors, for example, can be reported either
dynamically or statically.
</p>

<p>
These error codes are used to label error conditions in this specification,
and are summarized in E Summary of Error Conditions). They are provided
primarily for ease of reference. Implementations may use these codes when
signaling errors, but they are not required to do so. An API specification,
however, may require the use of error codes based on these QNames. Additional
errors defined by an implementation (or by an application) may use QNames in
an implementation-defined (or user-defined) namespace without risk of
collision.
</p>

<p>
Errors defined in the [XPath 2.0] and [Functions and Operators] specifications
use QNames with a similar structure, in the same namespace. When errors occur
in processing XPath expressions, an XSLT processor should use the original
error code reported by the XPath processor, unless a more specific XSLT error
code is available.
</p>

<p>
3 Stylesheet Structure
</p>

<p>
[Definition: A stylesheet consists of one or more stylesheet modules, each one
forming all or part of an XML document.]
</p>

<p>
Note:
</p>

<p>
A stylesheet module is represented by an XDM element node (see [Data Model]). 
In the case of a standard stylesheet module, this will be an xsl:stylesheet or
xsl:transform element. In the case of a simplified stylesheet module, it can
be any element (not in the XSLT namespace) that has an xsl:version attribute.
</p>

<p>
Although stylesheet modules will commonly be maintained in the form of
documents conforming to XML 1.0 or XML 1.1, this specification does not
mandate such a representation. As with source trees, the way in which
stylesheet modules are constructed, from textual XML or otherwise, is outside
the scope of this specification.
</p>

<p>
A stylesheet module is either a standard stylesheet module or a simplified
stylesheet module:
</p>

<ul class="org-ul">
<li>[Definition: A standard stylesheet module is a tree, or part of a tree,
consisting of an xsl:stylesheet or xsl:transform element (see 3.6
Stylesheet Element) together with its descendant nodes and associated
attributes and namespaces.]
</li>

<li>[Definition: A simplified stylesheet module is a tree, or part of a tree,
consisting of a literal result element together with its descendant nodes
and associated attributes and namespaces. This element is not itself in
the XSLT namespace, but it must have an xsl:version attribute, which
implies that it must have a namespace node that declares a binding for the
XSLT namespace. For further details see 3.7 Simplified Stylesheet Modules.
]
</li>
</ul>

<p>
Both forms of stylesheet module (standard and simplified) can exist either as
an entire XML document, or embedded as part of another XML document, typically
but not necessarily a source document that is to be processed using the
stylesheet.
</p>

<p>
[Definition: A standalone stylesheet module is a stylesheet module that
comprises the whole of an XML document.]
</p>

<p>
[Definition: An embedded stylesheet module is a stylesheet module that is
embedded within another XML document, typically the source document that is
being transformed.] (see 3.11 Embedded Stylesheet Modules).
</p>

<p>
There are thus four kinds of stylesheet module:
</p>

<p>
standalone standard stylesheet modules
standalone simplified stylesheet modules
embedded standard stylesheet modules
embedded simplified stylesheet modules
</p>

<p>
3.1 XSLT Namespace
</p>

<p>
[Definition: The XSLT namespace has the URI 
<a href="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</a>. It is used to identify elements,
attributes, and other names that have a special meaning defined in this
specification.]
</p>

<p>
Note:
</p>

<p>
The 1999 in the URI indicates the year in which the URI was allocated by the
W3C. It does not indicate the version of XSLT being used, which is specified
by attributes (see 3.6 Stylesheet Element and 3.7 Simplified Stylesheet
Modules).
</p>

<p>
XSLT processors must use the XML namespaces mechanism [Namespaces in XML 1.0]
to recognize elements and attributes from this namespace. Elements from the
XSLT namespace are recognized only in the stylesheet and not in the source
document. The complete list of XSLT-defined elements is specified in D Element
Syntax Summary. Implementations must not extend the XSLT namespace with
additional elements or attributes. Instead, any extension must be in a
separate namespace. Any namespace that is used for additional instruction
elements must be identified by means of the extension instruction mechanism
specified in 18.2 Extension Instructions.
</p>

<p>
This specification uses a prefix of xsl: for referring to elements in the XSLT
namespace. However, XSLT stylesheets are free to use any prefix, provided that
there is a namespace declaration that binds the prefix to the URI of the XSLT
namespace.
</p>

<p>
Note:
</p>

<p>
Throughout this specification, an element or attribute that is in no
namespace, or an expanded-QName whose namespace part is an empty sequence, is
referred to as having a null namespace URI.
</p>

<p>
Note:
</p>

<p>
The conventions used for the names of XSLT elements, attributes and functions
are that names are all lower-case, use hyphens to separate words, and use
abbreviations only if they already appear in the syntax of a related language
such as XML or HTML. Names of types defined in XML Schema however, are
regarded as single words and are capitalized exactly as in XML Schema. This
sometimes leads to composite function names such as current-dateTime<sup>FO</sup>.
</p>

<p>
3.2 Reserved Namespaces
</p>

<p>
[Definition: The XSLT namespace, together with certain other namespaces
recognized by an XSLT processor, are classified as reserved namespaces and 
must be used only as specified in this and related specifications.] The
reserved namespaces are those listed below.
</p>

<ul class="org-ul">
<li>The XSLT namespace, described in 3.1 XSLT Namespace, is reserved.
</li>

<li>[Definition: The standard function namespace 
<a href="http://www.w3.org/2005/xpath-functions">http://www.w3.org/2005/xpath-functions</a> is used for functions in the
function library defined in [Functions and Operators] and standard
functions defined in this specification.]
</li>

<li>[Definition: The XML namespace, defined in [Namespaces in XML 1.0] as 
<a href="http://www.w3.org/XML/1998/namespace">http://www.w3.org/XML/1998/namespace</a>, is used for attributes such as
xml:lang, xml:space, and xml:id.]
</li>

<li>[Definition: The schema namespace <a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a> is used
as defined in [XML Schema Part 1] ]. In a stylesheet this namespace may be
used to refer to built-in schema datatypes and to the constructor
functions associated with those datatypes.
</li>

<li>[Definition: The schema instance namespace 
<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a> is used as defined in [XML
Schema Part 1] ]. Attributes in this namespace, if they appear in a 
stylesheet, are treated by the XSLT processor in the same way as any other
attributes.
</li>
</ul>

<p>
Reserved namespaces may be used without restriction to refer to the names of
elements and attributes in source documents and result documents. As far as
the XSLT processor is concerned, reserved namespaces other than the XSLT
namespace may be used without restriction in the names of literal result
elements and user-defined data elements, and in the names of attributes of
literal result elements or of XSLT elements: but other processors may impose
restrictions or attach special meaning to them. Reserved namespaces must not
be used, however, in the names of stylesheet-defined objects such as variables
and stylesheet functions.
</p>

<p>
Note:
</p>

<p>
With the exception of the XML namespace, any of the above namespaces that are
used in a stylesheet must be explicitly declared with a namespace declaration.
Although conventional prefixes are used for these namespaces in this
specification, any prefix may be used in a user stylesheet.
</p>

<p>
[ERR XTSE0080] It is a static error to use a reserved namespace in the name of
a named template, a mode, an attribute set, a key, a decimal-format, a 
variable or parameter, a stylesheet function, a named output definition, or a 
character map.
</p>

<p>
3.3 Extension Attributes
</p>

<p>
[Definition: An element from the XSLT namespace may have any attribute not
from the XSLT namespace, provided that the expanded-QName (see [XPath 2.0]) of
the attribute has a non-null namespace URI. These attributes are referred to
as extension attributes.] The presence of an extension attribute must not
cause the final result trees produced by the transformation to be different
from the result trees that a conformant XSLT 2.0 processor might produce. They
must not cause the processor to fail to signal an error that a conformant
processor is required to signal. This means that an extension attribute must
not change the effect of any instruction except to the extent that the effect
is implementation-defined or implementation-dependent.
</p>

<p>
Furthermore, if serialization is performed using one of the serialization
methods xml, xhtml, html, or text described in 20 Serialization, the presence
of an extension attribute must not cause the serializer to behave in a way
that is inconsistent with the mandatory provisions of that specification.
</p>

<p>
Note:
</p>

<p>
Extension attributes may be used to modify the behavior of extension functions
and extension instructions. They may be used to select processing options in
cases where the specification leaves the behavior implementation-defined or 
implementation-dependent. They may also be used for optimization hints, for
diagnostics, or for documentation.
</p>

<p>
Extension attributes may also be used to influence the behavior of the
serialization methods xml, xhtml, html, or text, to the extent that the
behavior of the serialization method is implementation-defined or 
implementation-dependent. For example, an extension attribute might be used to
define the amount of indentation to be used when indent="yes" is specified. If
a serialization method other than one of these four is requested (using a
prefixed QName in the method parameter) then extension attributes may
influence its behavior in arbitrary ways. Extension attributes must not be
used to cause the four standard serialization methods to behave in a
non-conformant way, for example by failing to report serialization errors that
a serializer is required to report. An implementation that wishes to provide
such options must create a new serialization method for the purpose.
</p>

<p>
An implementation that does not recognize the name of an extension attribute,
or that does not recognize its value, must perform the transformation as if
the extension attribute were not present. As always, it is permissible to
produce warning messages.
</p>

<p>
The namespace used for an extension attribute will be copied to the result
tree in the normal way if it is in scope for a literal result element. This
can be prevented using the [xsl:]exclude-result-prefixes attribute.
</p>

<p>
Example: An Extension Attribute for xsl:message
</p>

<p>
The following code might be used to indicate to a particular implementation
that the xsl:message instruction is to ask the user for confirmation before
continuing with the transformation:
</p>

<p>
&lt;xsl:message
    abc:pause="yes"
    xmlns:abc="<a href="http://vendor.example.com/xslt/extensions">http://vendor.example.com/xslt/extensions</a>"&gt;Phase 1 complete&lt;/xsl:message&gt;
</p>

<p>
Implementations that do not recognize the namespace 
<a href="http://vendor.example.com/xslt/extensions">http://vendor.example.com/xslt/extensions</a> will simply ignore the extra
attribute, and evaluate the xsl:message instruction in the normal way.
</p>

<p>
[ERR XTSE0090] It is a static error for an element from the XSLT namespace to
have an attribute whose namespace is either null (that is, an attribute with
an unprefixed name) or the XSLT namespace, other than attributes defined for
the element in this document.
</p>

<p>
3.4 XSLT Media Type
</p>

<p>
The media type application/xslt+xml will be registered for XSLT stylesheet
modules.
</p>

<p>
The proposed definition of the media type is at B The XSLT Media Type
</p>

<p>
This media type should be used for an XML document containing a standard
stylesheet module at its top level, and it may also be used for a simplified
stylesheet module. It should not be used for an XML document containing an 
embedded stylesheet module.
</p>

<p>
3.5 Standard Attributes
</p>

<p>
[Definition: There are a number of standard attributes that may appear on any 
XSLT element: specifically version, exclude-result-prefixes,
extension-element-prefixes, xpath-default-namespace, default-collation, and
use-when.]
</p>

<p>
These attributes may also appear on a literal result element, but in this
case, to distinguish them from user-defined attributes, the names of the
attributes are in the XSLT namespace. They are thus typically written as
xsl:version, xsl:exclude-result-prefixes, xsl:extension-element-prefixes,
xsl:xpath-default-namespace, xsl:default-collation, or xsl:use-when.
</p>

<p>
It is recommended that all these attributes should also be permitted on 
extension instructions, but this is at the discretion of the implementer of
each extension instruction. They may also be permitted on user-defined data
elements, though they will only have any useful effect in the case of data
elements that are designed to behave like XSLT declarations or instructions.
</p>

<p>
In the following descriptions, these attributes are referred to generically as
[xsl:]version, and so on.
</p>

<p>
These attributes all affect the element they appear on, together with any
elements and attributes that have that element as an ancestor. The two forms
with and without the XSLT namespace have the same effect; the XSLT namespace
is used for the attribute if and only if its parent element is not in the XSLT
namespace.
</p>

<p>
In the case of [xsl:]version, [xsl:]xpath-default-namespace, and [xsl:]
default-collation, the value can be overridden by a different value for the
same attribute appearing on a descendant element. The effective value of the
attribute for a particular stylesheet element is determined by the innermost 
ancestor-or-self element on which the attribute appears.
</p>

<p>
In an embedded stylesheet module, standard attributes appearing on ancestors
of the outermost element of the stylesheet module have no effect.
</p>

<p>
In the case of [xsl:]exclude-result-prefixes and [xsl:]
extension-element-prefixes the values are cumulative. For these attributes,
the value is given as a whitespace-separated list of namespace prefixes, and
the effective value for an element is the combined set of namespace URIs
designated by the prefixes that appear in this attribute for that element and
any of its ancestor elements. Again, the two forms with and without the XSLT
namespace are equivalent.
</p>

<p>
The effect of the [xsl:]use-when attribute is described in 3.12 Conditional
Element Inclusion.
</p>

<p>
Because these attributes may appear on any XSLT element, they are not listed
in the syntax summary of each individual element. Instead they are listed and
described in the entry for the xsl:stylesheet and xsl:transform elements only.
This reflects the fact that these attributes are often used on the 
xsl:stylesheet element only, in which case they apply to the entire stylesheet
module.
</p>

<p>
Note that the effect of these attributes does not extend to stylesheet modules
referenced by xsl:include or xsl:import declarations.
</p>

<p>
For the detailed effect of each attribute, see the following sections:
</p>

<p>
[xsl:]version
</p>

<p>
see 3.8 Backwards-Compatible Processing and 3.9 Forwards-Compatible
Processing
</p>

<p>
[xsl:]xpath-default-namespace
</p>

<p>
see 5.2 Unprefixed QNames in Expressions and Patterns
</p>

<p>
[xsl:]exclude-result-prefixes
</p>

<p>
see 11.1.3 Namespace Nodes for Literal Result Elements
</p>

<p>
[xsl:]extension-element-prefixes
</p>

<p>
see 18.2 Extension Instructions
</p>

<p>
[xsl:]use-when
</p>

<p>
see 3.12 Conditional Element Inclusion
</p>

<p>
[xsl:]default-collation
</p>

<p>
see 3.6.1 The default-collation attribute
</p>

<p>
3.6 Stylesheet Element
</p>

<p>
&lt;xsl:stylesheet
  id? = id
  extension-element-prefixes? = tokens
  exclude-result-prefixes? = tokens
  version = number
  xpath-default-namespace? = uri
  default-validation? = "preserve" | "strip"
  default-collation? = uri-list
  input-type-annotations? = "preserve" | "strip" | "unspecified"&gt;
  &lt;!&#x2013; Content: (xsl:import*, other-declarations) &#x2013;&gt;
&lt;/xsl:stylesheet&gt;
</p>

<p>
&lt;xsl:transform
  id? = id
  extension-element-prefixes? = tokens
  exclude-result-prefixes? = tokens
  version = number
  xpath-default-namespace? = uri
  default-validation? = "preserve" | "strip"
  default-collation? = uri-list
  input-type-annotations? = "preserve" | "strip" | "unspecified"&gt;
  &lt;!&#x2013; Content: (xsl:import*, other-declarations) &#x2013;&gt;
&lt;/xsl:transform&gt;
</p>

<p>
A stylesheet module is represented by an xsl:stylesheet element in an XML
document. xsl:transform is allowed as a synonym for xsl:stylesheet; everything
this specification says about the xsl:stylesheet element applies equally to 
xsl:transform.
</p>

<p>
An xsl:stylesheet element must have a version attribute, indicating the
version of XSLT that the stylesheet module requires.
</p>

<p>
[ERR XTSE0110] The value of the version attribute must be a number:
specifically, it must be a a valid instance of the type xs:decimal as defined
in [XML Schema Part 2]. For this version of XSLT, the value should normally be
2.0. A value of 1.0 indicates that the stylesheet module was written with the
intention that it should be processed using an XSLT 1.0 processor.
</p>

<p>
If a stylesheet that specifies [xsl:]version="1.0" in the outermost element of
the principal stylesheet module (that is, version="1.0" in the case of a 
standard stylesheet module, or xsl:version="1.0" in the case of a simplified
stylesheet module) is submitted to an XSLT 2.0 processor, the processor should
output a warning advising the user of possible incompatibilities, unless the
user has requested otherwise. The processor must then process the stylesheet
using the rules for backwards-compatible behavior. These rules require that if
the processor does not support backwards-compatible behavior, it must signal
an error and must not execute the transformation.
</p>

<p>
When the value of the version attribute is greater than 2.0, 
forwards-compatible behavior is enabled (see 3.9 Forwards-Compatible
Processing).
</p>

<p>
Note:
</p>

<p>
XSLT 1.0 allowed the [xsl:]version attribute to take any numeric value, and
specified that if the value was not equal to 1.0, the stylesheet would be
executed in forwards compatible mode. XSLT 2.0 continues to allow the
attribute to take any unsigned decimal value. A software product that includes
both an XSLT 1.0 processor and an XSLT 2.0 processor (or that can execute as
either) may use the [xsl:]version attribute to decide which processor to
invoke; such behavior is outside the scope of this specification. When the
stylesheet is executed with an XSLT 2.0 processor, the value 1.0 is taken to
indicate that the stylesheet module was written with XSLT 1.0 in mind: if this
value appears on the outermost element of the principal stylesheet module then
an XSLT 2.0 processor will either reject the stylesheet or execute it in
backwards compatible mode, as described above. Setting version="2.0" indicates
that the stylesheet is to be executed with neither backwards nor forwards
compatible behavior enabled. Any other value less than 2.0 enables backwards
compatible behavior, while any value greater than 2.0 enables forwards
compatible behavior.
</p>

<p>
When developing a stylesheet that is designed to execute under either XSLT 1.0
or XSLT 2.0, the recommended practice is to create two alternative stylesheet
modules, one specifying version="1.0", and the other specifying version="2.0";
these modules can use xsl:include or xsl:import to incorporate the common
code. When running under an XSLT 1.0 processor, the version="1.0" module can
be selected as the principal stylesheet module; when running under an XSLT 2.0
processor, the version="2.0" module can be selected as the principal
stylesheet module. Stylesheet modules that are included or imported should
specify version="2.0" if they make use of XSLT 2.0 facilities, and version=
"1.0" otherwise.
</p>

<p>
The effect of the input-type-annotations attribute is described in 4.3
Stripping Type Annotations from a Source Tree.
</p>

<p>
The default-validation attribute defines the default value of the validation
attribute of all xsl:document, xsl:element, xsl:attribute, xsl:copy, 
xsl:copy-of, and xsl:result-document instructions, and of the xsl:validation
attribute of all literal result elements. It also determines the validation
applied to the implicit final result tree created in the absence of an 
xsl:result-document instruction. This default applies within the stylesheet
module: it does not extend to included or imported stylesheet modules. If the
attribute is omitted, the default is strip. The permitted values are preserve
and strip. For details of the effect of this attribute, see 19.2 Validation.
</p>

<p>
[ERR XTSE0120] An xsl:stylesheet element must not have any text node children.
(This rule applies after stripping of whitespace text nodes as described in 
4.2 Stripping Whitespace from the Stylesheet.)
</p>

<p>
[Definition: An element occurring as a child of an xsl:stylesheet element is
called a top-level element.]
</p>

<p>
[Definition: Top-level elements fall into two categories: declarations, and
user-defined data elements. Top-level elements whose names are in the XSLT
namespace are declarations. Top-level elements in any other namespace are 
user-defined data elements (see 3.6.2 User-defined Data Elements)].
</p>

<p>
The declaration elements permitted in the xsl:stylesheet element are:
</p>

<p>
xsl:import
xsl:include
xsl:attribute-set
xsl:character-map
xsl:decimal-format
xsl:function
xsl:import-schema
xsl:key
xsl:namespace-alias
xsl:output
xsl:param
xsl:preserve-space
xsl:strip-space
xsl:template
xsl:variable
</p>

<p>
Note that the xsl:variable and xsl:param elements can act either as 
declarations or as instructions. A global variable or parameter is defined
using a declaration; a local variable or parameter using an instruction.
</p>

<p>
If there are xsl:import elements, these must come before any other elements.
Apart from this, the child elements of the xsl:stylesheet element may appear
in any order. The ordering of these elements does not affect the results of
the transformation unless there are conflicting declarations (for example, two
template rules with the same priority that match the same node). In general,
it is an error for a stylesheet to contain such conflicting declarations, but
in some cases the processor is allowed to recover from the error by choosing
the declaration that appears last in the stylesheet.
</p>

<p>
3.6.1 The default-collation attribute
</p>

<p>
The default-collation attribute is a standard attribute that may appear on any
element in the XSLT namespace, or (as xsl:default-collation) on a literal
result element.
</p>

<p>
The attribute is used to specify the default collation used by all XPath
expressions appearing in the attributes of this element, or attributes of
descendant elements, unless overridden by another default-collation attribute
on an inner element. It also determines the collation used by certain XSLT
constructs (such as xsl:key and xsl:for-each-group) within its scope.
</p>

<p>
The value of the attribute is a whitespace-separated list of collation URIs. 
If any of these URIs is a relative URI, then it is resolved relative to the
base URI of the attribute's parent element. If the implementation recognizes
one or more of the resulting absolute collation URIs, then it uses the first
one that it recognizes as the default collation.
</p>

<p>
[ERR XTSE0125] It is a static error if the value of an [xsl:]default-collation
attribute, after resolving against the base URI, contains no URI that the
implementation recognizes as a collation URI.
</p>

<p>
Note:
</p>

<p>
The reason the attribute allows a list of collation URIs is that collation
URIs will often be meaningful only to one particular XSLT implementation.
Stylesheets designed to run with several different implementations can
therefore specify several different collation URIs, one for use with each. To
avoid the above error condition, it is possible to specify the Unicode
Codepoint Collation as the last collation URI in the list.
</p>

<p>
The [xsl:]default-collation attribute does not affect the collation used by
xsl:sort.
</p>

<p>
3.6.2 User-defined Data Elements
</p>

<p>
[Definition: In addition to declarations, the xsl:stylesheet element may
contain any element not from the XSLT namespace, provided that the 
expanded-QName of the element has a non-null namespace URI. Such elements are
referred to as user-defined data elements.]
</p>

<p>
[ERR XTSE0130] It is a static error if the xsl:stylesheet element has a child
element whose name has a null namespace URI.
</p>

<p>
An implementation may attach an implementation-defined meaning to user-defined
data elements that appear in particular namespaces. The set of namespaces that
are recognized for such data elements is implementation-defined. The presence
of a user-defined data element must not change the behavior of XSLT elements
and functions defined in this document; for example, it is not permitted for a
user-defined data element to specify that xsl:apply-templates should use
different rules to resolve conflicts. The constraints on what user-defined
data elements can and cannot do are exactly the same as the constraints on 
extension attributes, described in 3.3 Extension Attributes. Thus, an
implementation is always free to ignore user-defined data elements, and must
ignore such data elements without giving an error if it does not recognize the
namespace URI.
</p>

<p>
User-defined data elements can provide, for example,
</p>

<ul class="org-ul">
<li>information used by extension instructions or extension functions (see 18
Extensibility and Fallback),
</li>

<li>information about what to do with any final result tree,
</li>

<li>information about how to construct source trees,
</li>

<li>optimization hints for the processor,
</li>

<li>metadata about the stylesheet,
</li>

<li>structured documentation for the stylesheet.
</li>
</ul>

<p>
A user-defined data element must not precede an xsl:import element within a 
stylesheet module [see ERR XTSE0200]
</p>

<p>
3.7 Simplified Stylesheet Modules
</p>

<p>
A simplified syntax is allowed for a stylesheet module that defines only a
single template rule for the document node. The stylesheet module may consist
of just a literal result element (see 11.1 Literal Result Elements) together
with its contents. The literal result element must have an xsl:version
attribute (and it must therefore also declare the XSLT namespace). Such a
stylesheet module is equivalent to a standard stylesheet module whose 
xsl:stylesheet element contains a template rule containing the literal result
element, minus its xsl:version attribute; the template rule has a match 
pattern of /.
</p>

<p>
Example: A Simplified Stylesheet
</p>

<p>
For example:
</p>

<p>
&lt;html xsl:version="2.0"
      xmlns:xsl="<a href="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</a>"
      xmlns="<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</p>

<p>
has the same meaning as
</p>

<p>
&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="<a href="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</a>"
                xmlns="<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</p>

<p>
Note that it is not possible, using a simplified stylesheet, to request that
the serialized output contains a DOCTYPE declaration. This can only be done by
using a standard stylesheet module, and using the xsl:output element.
</p>

<p>
More formally, a simplified stylesheet module is equivalent to the standard
stylesheet module that would be generated by applying the following
transformation to the simplified stylesheet module, invoking the
transformation by calling the named template expand, with the containing
literal result element as the context node:
</p>

<p>
&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="<a href="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</a>"&gt;
</p>

<p>
&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match"&gt;/&lt;/xsl:attribute&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  
</p>

<p>
&lt;/xsl:stylesheet&gt;
</p>

<p>
[ERR XTSE0150] A literal result element that is used as the outermost element
of a simplified stylesheet module must have an xsl:version attribute. This
indicates the version of XSLT that the stylesheet requires. For this version
of XSLT, the value will normally be 2.0; the value must be a valid instance of
the type xs:decimal as defined in [XML Schema Part 2].
</p>

<p>
Other literal result elements may also have an xsl:version attribute. When the
xsl:version attribute is numerically less than 2.0, backwards-compatible
processing behavior is enabled (see 3.8 Backwards-Compatible Processing). When
the xsl:version attribute is numerically greater than 2.0, forwards-compatible
behavior is enabled (see 3.9 Forwards-Compatible Processing).
</p>

<p>
The allowed content of a literal result element when used as a simplified
stylesheet is the same as when it occurs within a sequence constructor. Thus,
a literal result element used as the document element of a simplified
stylesheet cannot contain declarations. Simplified stylesheets therefore
cannot use global variables, stylesheet parameters, stylesheet functions, keys
, attribute-sets, or output definitions. In turn this means that the only
useful way to initiate the transformation is to supply a document node as the 
initial context node, to be matched by the implicit match="/" template rule
using the default mode.
</p>

<p>
3.8 Backwards-Compatible Processing
</p>

<p>
[Definition: An element enables backwards-compatible behavior for itself, its
attributes, its descendants and their attributes if it has an [xsl:]version
attribute (see 3.5 Standard Attributes) whose value is less than 2.0.]
</p>

<p>
An element that has an [xsl:]version attribute whose value is greater than or
equal to 2.0 disables backwards-compatible behavior for itself, its
attributes, its descendants and their attributes. The compatibility behavior
established by an element overrides any compatibility behavior established by
an ancestor element.
</p>

<p>
If an attribute containing an XPath expression is processed with
backwards-compatible behavior, then the expression is evaluated with XPath 1.0
compatibility mode set to true. For details of this mode, see Section 2.1.1
Static Context<sup>XP</sup>. Furthermore, in such an expression any function call for
which no implementation is available (unless it uses the standard function
namespace) is bound to a fallback error function whose effect when evaluated
is to raise a dynamic error [see ERR XTDE1425] . The effect is that with
backwards-compatible behavior enabled, calls on extension functions that are
not available in a particular implementation do not cause an error unless the
function call is actually evaluated. For further details, see 18.1 Extension
Functions.
</p>

<p>
Note:
</p>

<p>
This might appear to contradict the specification of XPath 2.0, which states
that a static error [XPST0017] is raised when an expression contains a call to
a function that is not present (with matching name and arity) in the static
context. This apparent contradiction is resolved by specifying that the XSLT
processor constructs a static context for the expression in which every
possible function name and arity (other than names in the standard function
namespace) is present; when no other implementation of the function is
available, the function call is bound to a fallback error function whose
run-time effect is to raise a dynamic error.
</p>

<p>
Certain XSLT constructs also produce different results when
backwards-compatible behavior is enabled. This is described separately for
each such construct.
</p>

<p>
These rules do not apply to the xsl:output element, whose version attribute
has an entirely different purpose: it is used to define the version of the
output method to be used for serialization.
</p>

<p>
Note:
</p>

<p>
By making use of backwards-compatible behavior, it is possible to write the
stylesheet in a way that ensures that its results when processed with an XSLT
2.0 processor are identical to the effects of processing the same stylesheet
using an XSLT 1.0 processor. The differences are described (non-normatively)
in J.1 Incompatible Changes. To assist with transition, some parts of a
stylesheet may be processed with backwards compatible behavior enabled, and
other parts with this behavior disabled. All data values manipulated by an
XSLT 2.0 processor are defined by the XDM data model, whether or not the
relevant expressions use backwards compatible behavior. Because the same data
model is used in both cases, expressions are fully composable. The result of
evaluating instructions or expressions with backwards compatible behavior is
fully defined in the XSLT 2.0 and XPath 2.0 specifications, it is not defined
by reference to the XSLT 1.0 and XPath 1.0 specifications.
</p>

<p>
It is implementation-defined whether a particular XSLT 2.0 implementation
supports backwards-compatible behavior.
</p>

<p>
[ERR XTDE0160] If an implementation does not support backwards-compatible
behavior, then it is a non-recoverable dynamic error if any element is
evaluated that enables backwards-compatible behavior.
</p>

<p>
Note:
</p>

<p>
To write a stylesheet that works with both XSLT 1.0 and 2.0 processors, while
making selective use of XSLT 2.0 facilities, it is necessary to understand
both the rules for backwards-compatible behavior in XSLT 2.0, and the rules
for forwards-compatible behavior in XSLT 1.0. If the xsl:stylesheet element
specifies version="2.0", then an XSLT 1.0 processor will ignore XSLT 2.0 
declarations that were not defined in XSLT 1.0, for example xsl:function and 
xsl:import-schema. If any new XSLT 2.0 instructions are used (for example 
xsl:analyze-string or xsl:namespace), or if new XPath 2.0 features are used
(for example, new functions, or syntax such as conditional expressions, or
calls to a function defined using xsl:function), then the stylesheet must
provide fallback behavior that relies on XSLT 1.0 and XPath 1.0 facilities
only. The fallback behavior can be invoked by using the xsl:fallback
instruction, or by testing the results of the function-available or 
element-available functions, or by testing the value of the xsl:version
property returned by the system-property function.
</p>

<p>
3.9 Forwards-Compatible Processing
</p>

<p>
The intent of forwards-compatible behavior is to make it possible to write a
stylesheet that takes advantage of features introduced in some version of XSLT
subsequent to XSLT 2.0, while retaining the ability to execute the stylesheet
with an XSLT 2.0 processor using appropriate fallback behavior.
</p>

<p>
It is always possible to write conditional code to run under different XSLT
versions by using the use-when feature described in 3.12 Conditional Element
Inclusion. The rules for forwards-compatible behavior supplement this
mechanism in two ways:
</p>

<ul class="org-ul">
<li>certain constructs in the stylesheet that mean nothing to an XSLT 2.0
processor are ignored, rather than being treated as errors.
</li>

<li>explicit fallback behavior can be defined for instructions defined in a
future XSLT release, using the xsl:fallback instruction.
</li>
</ul>

<p>
The detailed rules follow.
</p>

<p>
[Definition: An element enables forwards-compatible behavior for itself, its
attributes, its descendants and their attributes if it has an [xsl:]version
attribute (see 3.5 Standard Attributes) whose value is greater than 2.0.]
</p>

<p>
An element that has an [xsl:]version attribute whose value is less than or
equal to 2.0 disables forwards-compatible behavior for itself, its attributes,
its descendants and their attributes. The compatibility behavior established
by an element overrides any compatibility behavior established by an ancestor
element.
</p>

<p>
These rules do not apply to the version attribute of the xsl:output element,
which has an entirely different purpose: it is used to define the version of
the output method to be used for serialization.
</p>

<p>
Within a section of a stylesheet where forwards-compatible behavior is
enabled:
</p>

<ul class="org-ul">
<li>if an element in the XSLT namespace appears as a child of the 
xsl:stylesheet element, and XSLT 2.0 does not allow such elements to occur
as children of the xsl:stylesheet element, then the element and its
content must be ignored.
</li>

<li>if an element has an attribute that XSLT 2.0 does not allow the element to
have, then the attribute must be ignored.
</li>

<li>if an element in the XSLT namespace appears as part of a sequence
constructor, and XSLT 2.0 does not allow such elements to appear as part
of a sequence constructor, then:

<ol class="org-ol">
<li>If the element has one or more xsl:fallback children, then no error is
reported either statically or dynamically, and the result of
evaluating the instruction is the concatenation of the sequences
formed by evaluating the sequence constructors within its xsl:fallback
children, in document order. Siblings of the xsl:fallback elements are
ignored, even if they are valid XSLT 2.0 instructions.
</li>

<li>If the element has no xsl:fallback children, then a static error is
reported in the same way as if forwards-compatible behavior were not
enabled.
</li>
</ol>
</li>
</ul>

<p>
Example: Forwards Compatible Behavior
</p>

<p>
For example, an XSLT 2.0 processor will process the following stylesheet
without error, although the stylesheet includes elements from the XSLT
namespace that are not defined in this specification:
</p>

<p>
&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="<a href="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</a>"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</p>

<p>
Note:
</p>

<p>
If a stylesheet depends crucially on a declaration introduced by a version of
XSLT after 2.0, then the stylesheet can use an xsl:message element with
terminate="yes" (see 17 Messages) to ensure that implementations that conform
to an earlier version of XSLT will not silently ignore the declaration.
</p>

<p>
Example: Testing the XSLT Version
</p>

<p>
For example,
</p>

<p>
&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="<a href="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</a>"&gt;
</p>

<p>
&lt;xsl:important-new-17.0-declaration/&gt;
</p>

<p>
  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &#x2026;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  &#x2026;
&lt;/xsl:stylesheet&gt;
</p>

<p>
3.10 Combining Stylesheet Modules
</p>

<p>
XSLT provides two mechanisms to construct a stylesheet from multiple 
stylesheet modules:
</p>

<ul class="org-ul">
<li>an inclusion mechanism that allows stylesheet modules to be combined
without changing the semantics of the modules being combined, and
</li>

<li>an import mechanism that allows stylesheet modules to override each other.
</li>
</ul>

<p>
3.10.1 Locating Stylesheet Modules
</p>

<p>
The include and import mechanisms use two declarations, xsl:include and 
xsl:import, which are defined in the sections that follow.
</p>

<p>
These declarations use an href attribute, whose value is a URI reference, to
identify the stylesheet module to be included or imported. If the value of
this attribute is a relative URI, it is resolved as described in 5.8 URI
References.
</p>

<p>
After resolving against the base URI, the way in which the URI reference is
used to locate a representation of a stylesheet module, and the way in which
the stylesheet module is constructed from that representation, are 
implementation-defined. In particular, it is implementation-defined which URI
schemes are supported, whether fragment identifiers are supported, and what
media types are supported. Conventionally, the URI is a reference to a
resource containing the stylesheet module as a source XML document, or it may
include a fragment identifier that selects an embedded stylesheet module
within a source XML document; but the implementation is free to use other
mechanisms to locate the stylesheet module identified by the URI reference.
</p>

<p>
The referenced stylesheet module may be any of the four kinds of stylesheet
module: that is, it may be standalone or embedded, and it may be standard or 
simplified. If it is a simplified stylesheet module then it is transformed
into the equivalent standard stylesheet module by applying the transformation
described in 3.7 Simplified Stylesheet Modules.
</p>

<p>
Implementations may choose to accept URI references containing a fragment
identifier defined by reference to the XPointer specification (see [XPointer
Framework]). Note that if the implementation does not support the use of
fragment identifiers in the URI reference, then it will not be possible to
include an embedded stylesheet module.
</p>

<p>
[ERR XTSE0165] It is a static error if the processor is not able to retrieve
the resource identified by the URI reference, or if the resource that is
retrieved does not contain a stylesheet module conforming to this
specification.
</p>

<p>
3.10.2 Stylesheet Inclusion
</p>

<p>
&lt;!&#x2013; Category: declaration &#x2013;&gt;
&lt;xsl:include
  href = uri-reference /&gt;
</p>

<p>
A stylesheet module may include another stylesheet module using an xsl:include
declaration.
</p>

<p>
The xsl:include declaration has a required href attribute whose value is a URI
reference identifying the stylesheet module to be included. This attribute is
used as described in 3.10.1 Locating Stylesheet Modules.
</p>

<p>
[ERR XTSE0170] An xsl:include element must be a top-level element.
</p>

<p>
[Definition: A stylesheet level is a collection of stylesheet modules
connected using xsl:include declarations: specifically, two stylesheet modules
A and B are part of the same stylesheet level if one of them includes the
other by means of an xsl:include declaration, or if there is a third
stylesheet module C that is in the same stylesheet level as both A and B.]
</p>

<p>
[Definition: The declarations within a stylesheet level have a total ordering
known as declaration order. The order of declarations within a stylesheet
level is the same as the document order that would result if each stylesheet
module were inserted textually in place of the xsl:include element that
references it.] In other respects, however, the effect of xsl:include is not
equivalent to the effect that would be obtained by textual inclusion.
</p>

<p>
[ERR XTSE0180] It is a static error if a stylesheet module directly or
indirectly includes itself.
</p>

<p>
Note:
</p>

<p>
It is not intrinsically an error for a stylesheet to include the same module
more than once. However, doing so can cause errors because of duplicate
definitions. Such multiple inclusions are less obvious when they are indirect.
For example, if stylesheet B includes stylesheet A, stylesheet C includes
stylesheet A, and stylesheet D includes both stylesheet B and stylesheet C,
then A will be included indirectly by D twice. If all of B, C and D are used
as independent stylesheets, then the error can be avoided by separating
everything in B other than the inclusion of A into a separate stylesheet B'
and changing B to contain just inclusions of B' and A, similarly for C, and
then changing D to include A, B', C'.
</p>

<p>
3.10.3 Stylesheet Import
</p>

<p>
&lt;!&#x2013; Category: declaration &#x2013;&gt;
&lt;xsl:import
  href = uri-reference /&gt;
</p>

<p>
A stylesheet module may import another stylesheet module using an xsl:import 
declaration. Importing a stylesheet module is the same as including it (see 
3.10.2 Stylesheet Inclusion) except that template rules and other declarations
in the importing module take precedence over template rules and declarations
in the imported module; this is described in more detail below.
</p>

<p>
The xsl:import declaration has a required href attribute whose value is a URI
reference identifying the stylesheet module to be included. This attribute is
used as described in 3.10.1 Locating Stylesheet Modules.
</p>

<p>
[ERR XTSE0190] An xsl:import element must be a top-level element.
</p>

<p>
[ERR XTSE0200] The xsl:import element children must precede all other element
children of an xsl:stylesheet element, including any xsl:include element
children and any user-defined data elements.
</p>

<p>
Example: Using xsl:import
</p>

<p>
For example,
</p>

<p>
&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="<a href="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</a>"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;
</p>

<p>
[Definition: The stylesheet levels making up a stylesheet are treated as
forming an import tree. In the import tree, each stylesheet level has one
child for each xsl:import declaration that it contains.] The ordering of the
children is the declaration order of the xsl:import declarations within their
stylesheet level.
</p>

<p>
[Definition: A declaration D in the stylesheet is defined to have lower import
precedence than another declaration E if the stylesheet level containing D
would be visited before the stylesheet level containing E in a post-order
traversal of the import tree (that is, a traversal of the import tree in which
a stylesheet level is visited after its children). Two declarations within the
same stylesheet level have the same import precedence.]
</p>

<p>
For example, suppose
</p>

<ul class="org-ul">
<li>stylesheet module A imports stylesheet modules B and C in that order;
</li>

<li>stylesheet module B imports stylesheet module D;
</li>

<li>stylesheet module C imports stylesheet module E.
</li>
</ul>

<p>
Then the import tree has the following structure:
</p>

<p>
A
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>

<tr>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
B       C
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
D       E
</p>

<p>
The order of import precedence (lowest first) is D, B, E, C, A.
</p>

<p>
In general, a declaration with higher import precedence takes precedence over
a declaration with lower import precedence. This is defined in detail for each
kind of declaration.
</p>

<p>
[ERR XTSE0210] It is a static error if a stylesheet module directly or
indirectly imports itself.
</p>

<p>
Note:
</p>

<p>
The case where a stylesheet module with a particular URI is imported several
times is not treated specially. The effect is exactly the same as if several
stylesheet modules with different URIs but identical content were imported.
This might or might not cause an error, depending on the content of the
stylesheet module.
</p>

<p>
3.11 Embedded Stylesheet Modules
</p>

<p>
An embedded stylesheet module is a stylesheet module whose containing element
is not the outermost element of the containing XML document. Both standard
stylesheet modules and simplified stylesheet modules may be embedded in this
way.
</p>

<p>
Two situations where embedded stylesheets may be useful are:
</p>

<ul class="org-ul">
<li>The stylesheet may be embedded in the source document to be transformed.
</li>

<li>The stylesheet may be embedded in an XML document that describes a
sequence of processing of which the XSLT transformation forms just one
part.
</li>
</ul>

<p>
The xsl:stylesheet element may have an id attribute to facilitate reference to
the stylesheet module within the containing document.
</p>

<p>
Note:
</p>

<p>
In order for such an attribute value to be used as a fragment identifier in a
URI, the XDM attribute node must generally have the is-id property: see 
Section 5.5 is-id Accessor<sup>DM</sup>. This property will typically be set if the
attribute is defined in a DTD as being of type ID, or if is defined in a
schema as being of type xs:ID. It is also necessary that the media type of the
containing document should support the use of ID values as fragment
identifiers. Such support is widespread in existing products, and is expected
to be endorsed in respect of the media type application/xml by a future
revision of [RFC3023].
</p>

<p>
An alternative, if the implementation supports it, is to use an xml:id
attribute. XSLT allows this attribute (like other namespaced attributes) to
appear on any XSLT element.
</p>

<p>
Example: The xml-stylesheet Processing Instruction
</p>

<p>
The following example shows how the xml-stylesheet processing instruction (see
[XML Stylesheet]) can be used to allow a source document to contain its own
stylesheet. The URI reference uses a relative URI with a fragment identifier
to locate the xsl:stylesheet element:
</p>

<p>
&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;head&gt;
&lt;xsl:stylesheet id="style1"
                version="2.0"
                xmlns:xsl="<a href="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</a>"
                xmlns:fo="<a href="http://www.w3.org/1999/XSL/Format">http://www.w3.org/1999/XSL/Format</a>"&gt;
&lt;xsl:import href="doc.xsl"/&gt;
&lt;xsl:template match="id('foo')"&gt;
  &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="xsl:stylesheet"&gt;
  &lt;!&#x2013; ignore &#x2013;&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;para id="foo"&gt;
&#x2026;
&lt;/para&gt;
&lt;/body&gt;
&lt;/doc&gt;
</p>

<p>
Note:
</p>

<p>
A stylesheet module that is embedded in the document to which it is to be
applied typically needs to contain a template rule that specifies that 
xsl:stylesheet elements are to be ignored.
</p>

<p>
Note:
</p>

<p>
The above example uses the pseudo-attribute type="application/xslt+xml" in the
xml-stylesheet processing instruction to denote an XSLT stylesheet. This usage
is subject to confirmation: see 3.4 XSLT Media Type. In the absence of a
registered media type for XSLT stylesheets, some vendors' products have
adopted different conventions, notably type="text/xsl".
</p>

<p>
Note:
</p>

<p>
Support for the xml-stylesheet processing instruction is not required for
conformance with this Recommendation. Implementations are not constrained in
the mechanisms they use to identify a stylesheet when a transformation is
initiated: see 2.3 Initiating a Transformation.
</p>

<p>
3.12 Conditional Element Inclusion
</p>

<p>
Any element in the XSLT namespace may have a use-when attribute whose value is
an XPath expression that can be evaluated statically. If the attribute is
present and the effective boolean value<sup>XP</sup> of the expression is false, then
the element, together with all the nodes having that element as an ancestor,
is effectively excluded from the stylesheet module. When a node is effectively
excluded from a stylesheet module the stylesheet module has the same effect as
if the node were not there. Among other things this means that no static or
dynamic errors will be reported in respect of the element and its contents,
other than errors in the use-when attribute itself.
</p>

<p>
Note:
</p>

<p>
This does not apply to XML parsing or validation errors, which will be
reported in the usual way. It also does not apply to attributes that are
necessarily processed before [xsl:]use-when, examples being xml:space and
[xsl:]xpath-default-namespace.
</p>

<p>
A literal result element, or any other element within a stylesheet module that
is not in the XSLT namespace, may similarly carry an xsl:use-when attribute.
</p>

<p>
If the xsl:stylesheet or xsl:transform element itself is effectively excluded,
the effect is to exclude all the children of the xsl:stylesheet or 
xsl:transform element, but not the xsl:stylesheet or xsl:transform element or
its attributes.
</p>

<p>
Note:
</p>

<p>
This allows all the declarations that depend on the same condition to be
included in one stylesheet module, and for their inclusion or exclusion to be
controlled by a single use-when attribute at the level of the module.
</p>

<p>
Conditional element exclusion happens after stripping of whitespace text nodes
from the stylesheet, as described in 4.2 Stripping Whitespace from the
Stylesheet.
</p>

<p>
There are no syntactic constraints on the XPath expression that can be used as
the value of the use-when attribute. However, there are severe constraints on
the information provided in its evaluation context. These constraints are
designed to ensure that the expression can be evaluated at the earliest
possible stage of stylesheet processing, without any dependency on information
contained in the stylesheet itself or in any source document.
</p>

<p>
Specifically, the components of the static and dynamic context are defined by
the following two tables:
</p>

<p>
Static Context Components for use-when Expressions              
</p>
<!-- This HTML table template is generated by emacs 24.3.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;Component&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>

<p>
Dynamic Context Components for use-when Expressions              
</p>
<!-- This HTML table template is generated by emacs 24.3.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>

<p>
Within a stylesheet module, all expressions contained in [xsl:]use-when
attributes are evaluated in a single execution scope<sup>FO</sup>. This need not be the
same execution scope as that used for [xsl]:use-when expressions in other
stylesheet modules, or as that used when evaluating XPath expressions
appearing elsewhere in the stylesheet module. This means that a function such
as current-date<sup>FO</sup> will return the same result when called in different [xsl:]
use-when expressions within the same stylesheet module, but will not
necessarily return the same result as the same call in an [xsl:]use-when
expression within a different stylesheet module, or as a call on the same
function executed during the transformation proper.
</p>

<p>
The use of [xsl:]use-when is illustrated in the following examples.
</p>

<p>
Example: Using Conditional Exclusion to Achieve Portability
</p>

<p>
This example demonstrates the use of the use-when attribute to achieve
portability of a stylesheet across schema-aware and non-schema-aware
processors.
</p>

<p>
&lt;xsl:import-schema schema-location="<a href="http://example.com/schema">http://example.com/schema</a>"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;
</p>

<p>
&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</p>

<p>
&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</p>

<p>
The effect of these declarations is that a non-schema-aware processor ignores
the xsl:import-schema declaration and the first template rule, and therefore
generates no errors in respect of the schema-related constructs in these
declarations.
</p>

<p>
Example: Including Variant Stylesheet Modules
</p>

<p>
This example includes different stylesheet modules depending on which XSLT
processor is in use.
</p>

<p>
&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;
</p>

<p>
3.13 Built-in Types
</p>

<p>
Every XSLT 2.0 processor includes the following named type definitions in the 
in-scope schema components:
</p>

<ul class="org-ul">
<li>All the primitive atomic types defined in [XML Schema Part 2], with the
exception of xs:NOTATION. That is: xs:string, xs:boolean, xs:decimal,
xs:double, xs:float, xs:date, xs:time, xs:dateTime, xs:duration, xs:QName,
xs:anyURI, xs:gDay, xs:gMonthDay, xs:gMonth, xs:gYearMonth, xs:gYear,
xs:base64Binary, and xs:hexBinary.
</li>

<li>The derived atomic type xs:integer defined in [XML Schema Part 2].
</li>

<li>The types xs:anyType and xs:anySimpleType.
</li>

<li>The following types defined in [XPath 2.0]: xs:yearMonthDuration, 
xs:dayTimeDuration, xs:anyAtomicType, xs:untyped, and xs:untypedAtomic.
</li>
</ul>

<p>
A schema-aware XSLT processor additionally supports:
</p>

<ul class="org-ul">
<li>All other built-in types defined in [XML Schema Part 2]
</li>

<li>User-defined types, and element and attribute declarations, that are
imported using an xsl:import-schema declaration as described in 3.14
Importing Schema Components. These may include both simple and complex
types.
</li>
</ul>

<p>
Note:
</p>

<p>
The names that are imported from the XML Schema namespace do not include all
the names of top-level types defined in either the Schema for Schemas or the
Schema for Datatypes. The Schema for Datatypes, as well as defining built-in
types such as xs:integer and xs:double, also defines types that are intended
for use only within the Schema for DataTypes, such as xs:derivationControl. A 
stylesheet that is designed to process XML Schema documents as its input or
output may import the Schema for Schemas.
</p>

<p>
An implementation may define mechanisms that allow additional schema
components to be added to the in-scope schema components for the stylesheet.
For example, the mechanisms used to define extension functions (see 18.1
Extension Functions) may also be used to import the types used in the
interface to such functions.
</p>

<p>
These schema components are the only ones that may be referenced in XPath
expressions within the stylesheet, or in the [xsl:]type and as attributes of
those elements that permit these attributes.
</p>

<p>
For a Basic XSLT Processor, schema built-in types that are not included in the
static context (for example, xs:NCName) are "unknown types" in the sense of 
Section 2.5.4 SequenceType Matching<sup>XP</sup>. In the language of that section, a
Basic XSLT Processor must be able to determine whether these unknown types are
derived from known schema types such as xs:string. The purpose of this rule is
to ensure that system functions such as local-name-from-QName<sup>FO</sup>, which is
defined to return an xs:NCName, behave correctly. A stylesheet that uses a
Basic XSLT Processor will not be able to test whether the returned value is an
xs:NCName, but it will be able to use it as if it were an xs:string.
</p>

<p>
3.14 Importing Schema Components
</p>

<p>
Note:
</p>

<p>
The facilities described in this section are not available with a basic XSLT
processor. They require a schema-aware XSLT processor, as described in 21
Conformance.
</p>

<p>
&lt;!&#x2013; Category: declaration &#x2013;&gt;
&lt;xsl:import-schema
  namespace? = uri-reference
  schema-location? = uri-reference&gt;
  &lt;!&#x2013; Content: xs:schema? &#x2013;&gt;
&lt;/xsl:import-schema&gt;
</p>

<p>
The xsl:import-schema declaration is used to identify schema components (that
is, top-level type definitions and top-level element and attribute
declarations) that need to be available statically, that is, before any source
document is available. Names of such components used statically within the 
stylesheet must refer to an in-scope schema component, which means they must
either be built-in types as defined in 3.13 Built-in Types, or they must be
imported using an xsl:import-schema declaration.
</p>

<p>
The xsl:import-schema declaration identifies a namespace containing the names
of the components to be imported (or indicates that components whose names are
in no namespace are to be imported). The effect is that the names of top-level
element and attribute declarations and type definitions from this namespace
(or non-namespace) become available for use within XPath expressions in the 
stylesheet, and within other stylesheet constructs such as the type and as
attributes of various XSLT elements.
</p>

<p>
The same schema components are available in all stylesheet modules; importing
components in one stylesheet module makes them available throughout the 
stylesheet.
</p>

<p>
The namespace and schema-location attributes are both optional.
</p>

<p>
If the xsl:import-schema element contains an xs:schema element, then the
schema-location attribute must be absent, and the namespace attribute must
either have the same value as the targetNamespace attribute of the xs:schema
element (if present), or must be absent, in which case its effective value is
that of the targetNamespace attribute of the xs:schema element if present or
the zero-length string otherwise.
</p>

<p>
[ERR XTSE0215] It is a static error if an xsl:import-schema element that
contains an xs:schema element has a schema-location attribute, or if it has a
namespace attribute that conflicts with the target namespace of the contained
schema.
</p>

<p>
If two xsl:import-schema declarations specify the same namespace, or if both
specify no namespace, then only the one with highest import precedence is
used. If this leaves more than one, then all the declarations at the highest
import precedence are used (which may cause conflicts, as described below).
</p>

<p>
After discarding any xsl:import-schema declarations under the above rule, the
effect of the remaining xsl:import-schema declarations is defined in terms of
a hypothetical document called the synthetic schema document, which is
constructed as follows. The synthetic schema document defines an arbitrary
target namespace that is different from any namespace actually used by the
application, and it contains xs:import elements corresponding one-for-one with
the xsl:import-schema declarations in the stylesheet, with the following
correspondence:
</p>

<ul class="org-ul">
<li>The namespace attribute of the xs:import element is copied from the
namespace attribute of the xsl:import-schema declaration if it is 
explicitly present, or is implied by the targetNamespace attribute of a
contained xs:schema element, and is absent if it is absent.
</li>

<li>The schemaLocation attribute of the xs:import element is copied from the
schema-location attribute of the xsl:import-schema declaration if present,
and is absent if it is absent. If there is a contained xs:schema element,
the effective value of the schemaLocation attribute is a URI referencing a
document containing a copy of the xs:schema element.
</li>

<li>The base URI of the xs:import element is the same as the base URI of the 
xsl:import-schema declaration.
</li>
</ul>

<p>
The schema components included in the in-scope schema components (that is, the
components whose names are available for use within the stylesheet) are the
top-level element and attribute declarations and type definitions that are
available for reference within the synthetic schema document. See [XML Schema
Part 1] (section 4.2.3, References to schema components across namespaces).
</p>

<p>
[ERR XTSE0220] It is a static error if the synthetic schema document does not
satisfy the constraints described in [XML Schema Part 1] (section 5.1, Errors
in Schema Construction and Structure). This includes, without loss of
generality, conflicts such as multiple definitions of the same name.
</p>

<p>
Note:
</p>

<p>
The synthetic schema document does not need to be constructed by a real
implementation. It is purely a mechanism for defining the semantics of 
xsl:import-schema in terms of rules that already exist within the XML Schema
specification. In particular, it implicitly defines the rules that determine
whether the set of xsl:import-schema declarations are mutually consistent.
</p>

<p>
These rules do not cause names to be imported transitively. The fact that a
name is available for reference within a schema document A does not of itself
make the name available for reference in a stylesheet that imports the target
namespace of schema document A. (See [XML Schema Part 1] section 3.15.3,
Constraints on XML Representations of Schemas.) The stylesheet must import all
the namespaces containing names that it actually references.
</p>

<p>
The namespace attribute indicates that a schema for the given namespace is
required by the stylesheet. This information may be enough on its own to
enable an implementation to locate the required schema components. The
namespace attribute may be omitted to indicate that a schema for names in no
namespace is being imported. The zero-length string is not a valid namespace
URI, and is therefore not a valid value for the namespace attribute.
</p>

<p>
The schema-location attribute is a URI Reference that gives a hint indicating
where a schema document or other resource containing the required definitions
may be found. It is likely that a schema-aware XSLT processor will be able to
process a schema document found at this location.
</p>

<p>
The XML Schema specification gives implementations flexibility in how to
handle multiple imports for the same namespace. Multiple imports do not cause
errors if the definitions do not conflict.
</p>

<p>
A consequence of these rules is that it is not intrinsically an error if no
schema document can be located for a namespace identified in an 
xsl:import-schema declaration. This will cause an error only if it results in
the stylesheet containing references to names that have not been imported.
</p>

<p>
An inline schema document (using an xs:schema element as a child of the
xsl:import-schema element) has the same status as an external schema document,
in the sense that it acts as a hint for a source of schema components in the
relevant namespace. To ensure that the inline schema document is always used,
it is advisable to use a target namespace that is unique to this schema
document.
</p>

<p>
The use of a namespace in an xsl:import-schema declaration does not by itself
associate any namespace prefix with the namespace. If names from the namespace
are used within the stylesheet module then a namespace declaration must be
included in the stylesheet module, in the usual way.
</p>

<p>
Example: An Inline Schema Document
</p>

<p>
The following example shows an inline schema document. This declares a simple
type local:yes-no, which the stylesheet then uses in the declaration of a
variable.
</p>

<p>
The example assumes the namespace declaration xmlns:local="
<a href="http://localhost/ns/yes-no">http://localhost/ns/yes-no</a>"
</p>

<p>
&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="<a href="http://localhost/ns/yes-no">http://localhost/ns/yes-no</a>"
             xmlns:xs="<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>"&gt;
    &lt;xs:simpleType name="local:yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;
</p>

<p>
&lt;xs:variable name="condition" select="'yes'" as="local:yes-no"/&gt;
</p>

<p>
4 Data Model
</p>

<p>
The data model used by XSLT is the XPath 2.0 and XQuery 1.0 data model (XDM),
as defined in [Data Model]. XSLT operates on source, result and stylesheet
documents using the same data model.
</p>

<p>
This section elaborates on some particular features of XDM as it is used by
XSLT:
</p>

<p>
The rules in 4.2 Stripping Whitespace from the Stylesheet and 4.4 Stripping
Whitespace from a Source Tree make use of the concept of a whitespace text
node.
</p>

<p>
[Definition: A whitespace text node is a text node whose content consists
entirely of whitespace characters (that is, #x09, #x0A, #x0D, or #x20).]
</p>

<p>
Note:
</p>

<p>
Features of a source XML document that are not represented in the XDM tree
will have no effect on the operation of an XSLT stylesheet. Examples of such
features are entity references, CDATA sections, character references,
whitespace within element tags, and the choice of single or double quotes
around attribute values.
</p>

<p>
4.1 XML Versions
</p>

<p>
The XDM data model defined in [Data Model] is capable of representing either
an XML 1.0 document (conforming to [XML 1.0] and [Namespaces in XML 1.0]) or
an XML 1.1 document (conforming to [XML 1.1] and [Namespaces in XML 1.1]), and
it makes no distinction between the two. In principle, therefore, XSLT 2.0 can
be used with either of these XML versions.
</p>

<p>
Construction of the XDM tree is outside the scope of this specification, so
XSLT 2.0 places no formal requirements on an XSLT processor to accept input
from either XML 1.0 documents or XML 1.1 documents or both. This specification
does define a serialization capability (see 20 Serialization), though from a
conformance point of view it is an optional feature. Although facilities are
described for serializing the XDM tree as either XML 1.0 or XML 1.1 (and
controlling the choice), there is again no formal requirement on an XSLT
processor to support either or both of these XML versions as serialization
targets.
</p>

<p>
Because the XDM tree is the same whether the original document was XML 1.0 or
XML 1.1, the semantics of XSLT processing do not depend on the version of XML
used by the original document. There is no reason in principle why all the
input and output documents used in a single transformation must conform to the
same version of XML.
</p>

<p>
Some of the syntactic constructs in XSLT 2.0 and XPath 2.0, for example the
productions Char^ XML and NCName^ Names, are defined by reference to the XML
and XML Namespaces specifications. There are slight variations between the XML
1.0 and XML 1.1 versions of these productions. Implementations may support
either version; it is recommended that an XSLT 2.0 processor that implements
the 1.1 versions should also provide a mode that supports the 1.0 versions. It
is thus implementation-defined whether the XSLT processor supports XML 1.0
with XML Namespaces 1.0, or XML 1.1 with XML Namespaces 1.1, or supports both
versions at user option.
</p>

<p>
Note:
</p>

<p>
The specification referenced as [Namespaces in XML 1.0] was actually published
without a version number.
</p>

<p>
At the time of writing there is no published version of [XML Schema Part 2]
that references the XML 1.1 specifications. This means that data types such as
xs:NCName and xs:ID are constrained by the XML 1.0 rules, and do not allow the
full range of values permitted by XML 1.1. This situation will not be resolved
until a new version of [XML Schema Part 2] becomes available; in the meantime,
it is recommended that implementers wishing to support XML 1.1 should consult 
[XML Schema 1.0 and XML 1.1] for guidance. An XSLT 2.0 processor that supports
XML 1.1 should implement the rules in later versions of [XML Schema Part 2] as
they become available.
</p>

<p>
4.2 Stripping Whitespace from the Stylesheet
</p>

<p>
The tree representing the stylesheet is preprocessed as follows:
</p>

<ol class="org-ol">
<li>All comments and processing instructions are removed.
</li>

<li>Any text nodes that are now adjacent to each other are merged.
</li>

<li>Any whitespace text node that satisfies both the following conditions is
removed from the tree:

<ul class="org-ul">
<li>The parent of the text node is not an xsl:text element
</li>

<li>The text node does not have an ancestor element that has an xml:space
attribute with a value of preserve, unless there is a closer ancestor
element having an xml:space attribute with a value of default.
</li>
</ul>
</li>

<li>Any whitespace text node whose parent is one of the following elements is
removed from the tree, regardless of any xml:space attributes:

<p>
xsl:analyze-string
xsl:apply-imports
xsl:apply-templates
xsl:attribute-set
xsl:call-template
xsl:character-map
xsl:choose
xsl:next-match
xsl:stylesheet
xsl:transform
</p>
</li>

<li>Any whitespace text node whose following-sibling node is an xsl:param or 
xsl:sort element is removed from the tree, regardless of any xml:space
attributes.
</li>
</ol>

<p>
[ERR XTSE0260] Within an XSLT element that is required to be empty, any
content other than comments or processing instructions, including any 
whitespace text node preserved using the xml:space="preserve" attribute, is a 
static error.
</p>

<p>
Note:
</p>

<p>
Using xml:space="preserve" in parts of the stylesheet that contain sequence
constructors will cause all text nodes in that part of the stylesheet,
including those that contain whitespace only, to be copied to the result of
the sequence constructor. When the result of the sequence constructor is used
to form the content of an element, this can cause errors if such text nodes
are followed by attribute nodes generated using xsl:attribute.
</p>

<p>
Note:
</p>

<p>
If an xml:space attribute is specified on a literal result element, it will be
copied to the result tree in the same way as any other attribute.
</p>

<p>
4.3 Stripping Type Annotations from a Source Tree
</p>

<p>
[Definition: The term type annotation is used in this specification to refer
to the value returned by the dm:type-name accessor of a node: see Section 5.14
type-name Accessor<sup>DM</sup>.]
</p>

<p>
There is sometimes a requirement to write stylesheets that produce the same
results whether or not the source documents have been validated against a
schema. To achieve this, an option is provided to remove any type annotations
on element and attribute nodes in a source tree, replacing them with an
annotation of xs:untyped in the case of element nodes, and xs:untypedAtomic in
the case of attribute nodes.
</p>

<p>
Such stripping of type annotations can be requested by specifying
input-type-annotations="strip" on the xsl:stylesheet element. This attribute
has three permitted values: strip, preserve, and unspecified. The default
value is unspecified. Stripping of type annotations takes place if at least
one stylesheet module in the stylesheet specifies input-type-annotations=
"strip".
</p>

<p>
[ERR XTSE0265] It is a static error if there is a stylesheet module in the 
stylesheet that specifies input-type-annotations="strip" and another 
stylesheet module that specifies input-type-annotations="preserve".
</p>

<p>
The source trees to which this applies are the same as those affected by 
xsl:strip-space and xsl:preserve-space: see 4.4 Stripping Whitespace from a
Source Tree.
</p>

<p>
When type annotations are stripped, the following changes are made to the
source tree:
</p>

<ul class="org-ul">
<li>The type annotation of every element node is changed to xs:untyped
</li>

<li>The type annotation of every attribute node is changed to xs:untypedAtomic
</li>

<li>The typed value of every element and attribute node is set to be the same
as its string value, as an instance of xs:untypedAtomic.
</li>

<li>The is-nilled property of every element node is set to false.
</li>
</ul>

<p>
The values of the is-id and is-idrefs properties are not changed.
</p>

<p>
Note:
</p>

<p>
Stripping type annotations does not necessarily return the document to the
state it would be in had validation not taken place. In particular, any
defaulted elements and attributes that were added to the tree by the
validation process will still be present , and elements and attributes
validated as IDs will still be accessible using the id^ FO function.
</p>

<p>
4.4 Stripping Whitespace from a Source Tree
</p>

<p>
A source tree supplied as input to the transformation process may contain 
whitespace text nodes that are of no interest, and that do not need to be
retained by the transformation. Conceptually, an XSLT processor makes a copy
of the source tree from which unwanted whitespace text nodes have been
removed. This process is referred to as whitespace stripping.
</p>

<p>
For the purposes of this section, the term source tree means the document
containing the initial context node, and any document returned by the
functions document, doc^ FO, or collection<sup>FO</sup>. It does not include documents
passed as the values of stylesheet parameters or returned from extension
functions.
</p>

<p>
The stripping process takes as input a set of element names whose child 
whitespace text nodes are to be preserved. The way in which this set of
element names is established using the xsl:strip-space and xsl:preserve-space
declarations is described later in this section.
</p>

<p>
A whitespace text node is preserved if either of the following apply:
</p>

<ul class="org-ul">
<li>The element name of the parent of the text node is in the set of
whitespace-preserving element names.
</li>

<li>An ancestor element of the text node has an xml:space attribute with a
value of preserve, and no closer ancestor element has xml:space with a
value of default.
</li>
</ul>

<p>
Otherwise, the whitespace text node is stripped.
</p>

<p>
The xml:space attributes are not removed from the tree.
</p>

<p>
&lt;!&#x2013; Category: declaration &#x2013;&gt;
&lt;xsl:strip-space
  elements = tokens /&gt;
</p>

<p>
&lt;!&#x2013; Category: declaration &#x2013;&gt;
&lt;xsl:preserve-space
  elements = tokens /&gt;
</p>

<p>
The set of whitespace-preserving element names is specified by xsl:strip-space
and xsl:preserve-space declarations. Whether an element name is included in
the set of whitespace-preserving names is determined by the best match among
all the xsl:strip-space or xsl:preserve-space declarations: it is included if
and only if there is no match or the best match is an xsl:preserve-space
element. The xsl:strip-space and xsl:preserve-space elements each have an
elements attribute whose value is a whitespace-separated list of NameTests^ XP
; an element name matches an xsl:strip-space or xsl:preserve-space element if
it matches one of the NameTests^ XP. An element matches a NameTest^ XP if and
only if the NameTest^ XP would be true for the element as an XPath node test.
When more than one xsl:strip-space and xsl:preserve-space element matches, the
best matching element is determined by the best matching NameTest^ XP. This is
determined in the same way as with template rules:
</p>

<ul class="org-ul">
<li>First, any match with lower import precedence than another match is
ignored.
</li>

<li>Next, any match that has a lower default priority than the default
priority of another match is ignored.
</li>
</ul>

<p>
[ERR XTRE0270] It is a recoverable dynamic error if this leaves more than one
match, unless all the matched declarations are equivalent (that is, they are
all xsl:strip-space or they are all xsl:preserve-space). The optional recovery
action is to select, from the matches that are left, the one that occurs last
in declaration order.
</p>

<p>
If an element in a source document has a type annotation that is a simple type
or a complex type with simple content, then any whitespace text nodes among
its children are preserved, regardless of any xsl:strip-space declarations.
The reason for this is that stripping a whitespace text node from an element
with simple content could make the element invalid: for example, it could
cause the minLength facet to be violated.
</p>

<p>
Stripping of type annotations happens before stripping of whitespace text
nodes, so this situation will not occur if input-type-annotations="strip" is
specified.
</p>

<p>
Note:
</p>

<p>
In [Data Model], processes are described for constructing an XDM tree from an
Infoset or from a PSVI. Those processes deal with whitespace according to
their own rules, and the provisions in this section apply to the resulting
tree. In practice this means that elements that are defined in a DTD or a
Schema to contain element-only content will have whitespace text nodes
stripped, regardless of the xsl:strip-space and xsl:preserve-space
declarations in the stylesheet.
</p>

<p>
However, source trees are not necessarily constructed using those processes;
indeed, they are not necessarily constructed by parsing XML documents. Nothing
in the XSLT specification constrains how the source tree is constructed, or
what happens to whitespace text nodes during its construction. The provisions
in this section relate only to whitespace text nodes that are present in the
tree supplied as input to the XSLT processor. The XSLT processor cannot
preserve whitespace text nodes unless they were actually present in the
supplied tree.
</p>

<p>
4.5 Attribute Types and DTD Validation
</p>

<p>
The mapping from the Infoset to the XDM data model, described in [Data Model],
does not retain attribute types. This means, for example, that an attribute
described in the DTD as having attribute type NMTOKENS will be annotated in 
the XDM tree as xs:untypedAtomic rather than xs:NMTOKENS, and its typed value
will consist of a single xs:untypedAtomic value rather than a sequence of
xs:NMTOKEN values.
</p>

<p>
Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in
the XDM tree as having the is-id or is-idrefs properties. It is these
properties, rather than any type annotation, that are examined by the
functions id^ FO and idref^ FO described in [Functions and Operators].
</p>

<p>
4.6 Limits
</p>

<p>
The XDM data model (see [Data Model]) leaves it to the host language to define
limits. This section describes the limits that apply to XSLT.
</p>

<p>
Limits on some primitive data types are defined in [XML Schema Part 2]. Other
limits, listed below, are implementation-defined. Note that this does not
necessarily mean that each limit must be a simple constant: it may vary
depending on environmental factors such as available resources.
</p>

<p>
The following limits are implementation-defined:
</p>

<ol class="org-ol">
<li>For the xs:decimal type, the maximum number of decimal digits (the
totalDigits facet). This must be at least 18 digits. (Note, however, that
support for the full value range of xs:unsignedLong requires 20 digits.)
</li>

<li>For the types xs:date, xs:time, xs:dateTime, xs:gYear, and xs:gYearMonth:
the range of values of the year component, which must be at least +0001 to
+9999; and the maximum number of fractional second digits, which must be
at least 3.
</li>

<li>For the xs:duration type: the maximum absolute values of the years,
months, days, hours, minutes, and seconds components.
</li>

<li>For the xs:yearMonthDuration type: the maximum absolute value, expressed
as an integer number of months.
</li>

<li>For the xs:dayTimeDuration type: the maximum absolute value, expressed as
a decimal number of seconds.
</li>

<li>For the types xs:string, xs:hexBinary, xs:base64Binary, xs:QName,
xs:anyURI, xs:NOTATION, and types derived from them: the maximum length of
the value.
</li>

<li>For sequences, the maximum number of items in a sequence.
</li>
</ol>

<p>
4.7 Disable Output Escaping
</p>

<p>
For backwards compatibility reasons, XSLT 2.0 continues to support the
disable-output-escaping feature introduced in XSLT 1.0. This is an optional
feature and implementations are not required to support it. A new facility,
that of named character maps (see 20.1 Character Maps) is introduced in XSLT
2.0. It provides similar capabilities to disable-output-escaping, but without
distorting the data model.
</p>

<p>
If an implementation supports the disable-output-escaping attribute of 
xsl:text and xsl:value-of, (see 20.2 Disabling Output Escaping), then the data
model for trees constructed by the processor is augmented with a boolean value
representing the value of this property. This boolean value, however, can be
set only within a final result tree that is being passed to the serializer.
</p>

<p>
Conceptually, each character in a text node on such a result tree has a
boolean property indicating whether the serializer is to disable the normal
rules for escaping of special characters (for example, outputting of &amp; as &amp;
amp;) in respect of this character or attribute node.
</p>

<p>
Note:
</p>

<p>
In practice, the nodes in a final result tree will often be streamed directly
from the XSLT processor to the serializer. In such an implementation,
disable-output-escaping can be viewed not so much a property stored with nodes
in the tree, but rather as additional information passed across the interface
between the XSLT processor and the serializer.
</p>

<p>
5 Features of the XSLT Language
</p>

<p>
5.1 Qualified Names
</p>

<p>
The name of a stylesheet-defined object, specifically a named template, a mode
, an attribute set, a key, a decimal-format, a variable or parameter, a 
stylesheet function, a named output definition, or a character map is
specified as a QName using the syntax for QName^ Names as defined in 
[Namespaces in XML 1.0].
</p>

<p>
[Definition: A QName is always written in the form (NCName ":")? NCName, that
is, a local name optionally preceded by a namespace prefix. When two QNames
are compared, however, they are considered equal if the corresponding 
expanded-QNames are the same, as described below.]
</p>

<p>
Because an atomic value of type xs:QName is sometimes referred to loosely as a
QName, this specification also uses the term lexical QName to emphasize that
it is referring to a QName^ Names in its lexical form rather than its expanded
form. This term is used especially when strings containing lexical QNames are
manipulated as run-time values.
</p>

<p>
[Definition: A lexical QName is a string representing a QName in the form
(NCName ":")? NCName, that is, a local name optionally preceded by a namespace
prefix.]
</p>

<p>
[Definition: A string in the form of a lexical QName may occur as the value of
an attribute node in a stylesheet module, or within an XPath expression
contained in such an attribute node, or as the result of evaluating an XPath
expression contained in such an attribute node. The element containing this
attribute node is referred to as the defining element of the QName.]
</p>

<p>
[Definition: An expanded-QName contains a pair of values, namely a local name
and an optional namespace URI. It may also contain a namespace prefix. Two
expanded-QNames are equal if the namespace URIs are the same (or both absent)
and the local names are the same. The prefix plays no part in the comparison,
but is used only if the expanded-QName needs to be converted back to a string.
]
</p>

<p>
If the QName has a prefix, then the prefix is expanded into a URI reference
using the namespace declarations in effect on its defining element. The 
expanded-QName consisting of the local part of the name and the possibly null
URI reference is used as the name of the object. The default namespace of the
defining element (see Section 6.2 Element Nodes<sup>DM</sup>) is not used for unprefixed
names.
</p>

<p>
There are three cases where the default namespace of the defining element is
used when expanding an unprefixed QName:
</p>

<ol class="org-ol">
<li>Where a QName is used to define the name of an element being constructed.
This applies both to cases where the name is known statically (that is,
the name of a literal result element) and to cases where it is computed
dynamically (the value of the name attribute of the xsl:element
instruction).
</li>

<li>The default namespace is used when expanding the first argument of the
function element-available.
</li>

<li>The default namespace applies to any unqualified element names appearing
in the cdata-section-elements attribute of xsl:output or 
xsl:result-document
</li>
</ol>

<p>
In the case of an unprefixed QName used as a NameTest within an XPath 
expression (see 5.3 Expressions) , and in certain other contexts, the
namespace to be used in expanding the QName may be specified by means of the
[xsl:]xpath-default-namespace attribute, as specified in 5.2 Unprefixed QNames
in Expressions and Patterns.
</p>

<p>
[ERR XTSE0280] In the case of a prefixed QName used as the value of an
attribute in the stylesheet, or appearing within an XPath expression in the
stylesheet, it is a static error if the defining element has no namespace node
whose name matches the prefix of the QName.
</p>

<p>
[ERR XTDE0290] Where the result of evaluating an XPath expression (or an
attribute value template) is required to be a lexical QName, then unless
otherwise specified it is a non-recoverable dynamic error if the defining
element has no namespace node whose name matches the prefix of the lexical
QName. This error may be signaled as a static error if the value of the
expression can be determined statically.
</p>

<p>
5.2 Unprefixed QNames in Expressions and Patterns
</p>

<p>
The attribute [xsl:]xpath-default-namespace (see 3.5 Standard Attributes) may
be used on an element in the stylesheet to define the namespace that will be
used for an unprefixed element name or type name within an XPath expression,
and in certain other contexts listed below.
</p>

<p>
The value of the attribute is the namespace URI to be used.
</p>

<p>
For any element in the stylesheet, this attribute has an effective value,
which is the value of the [xsl:]xpath-default-namespace on that element or on
the innermost containing element that specifies such an attribute, or the
zero-length string if no containing element specifies such an attribute.
</p>

<p>
For any element in the stylesheet, the effective value of this attribute
determines the value of the default namespace for element and type names in
the static context of any XPath expression contained in an attribute of that
element (including XPath expressions in attribute value templates). The effect
of this is specified in [XPath 2.0]; in summary, it determines the namespace
used for any unprefixed type name in the SequenceType production, and for any
element name appearing in a path expression or in the SequenceType production.
</p>

<p>
The effective value of this attribute similarly applies to any of the
following constructs appearing within its scope:
</p>

<ul class="org-ul">
<li>any unprefixed element name or type name used in a pattern
</li>

<li>any unprefixed element name used in the elements attribute of the 
xsl:strip-space or xsl:preserve-space instructions
</li>

<li>any unprefixed element name or type name used in the as attribute of an 
XSLT element
</li>

<li>any unprefixed type name used in the type attribute of an XSLT element
</li>

<li>any unprefixed type name used in the xsl:type attribute of a literal
result element.
</li>
</ul>

<p>
The [xsl:]xpath-default-namespace attribute must be in the XSLT namespace if
and only if its parent element is not in the XSLT namespace.
</p>

<p>
If the effective value of the attribute is a zero-length string, which will be
the case if it is explicitly set to a zero-length string or if it is not
specified at all, then an unprefixed element name or type name refers to a
name that is in no namespace. The default namespace of the parent element (see
Section 6.2 Element Nodes<sup>DM</sup>) is not used.
</p>

<p>
The attribute does not affect other names, for example function names,
variable names, or template names, or strings that are interpreted as lexical
QNames during stylesheet evaluation, such as the effective value of the name
attribute of xsl:element or the string supplied as the first argument to the 
key function.
</p>

<p>
5.3 Expressions
</p>

<p>
XSLT uses the expression language defined by XPath 2.0 [XPath 2.0].
Expressions are used in XSLT for a variety of purposes including:
</p>

<ul class="org-ul">
<li>selecting nodes for processing;
</li>

<li>specifying conditions for different ways of processing a node;
</li>

<li>generating text to be inserted in a result tree.
</li>
</ul>

<p>
[Definition: Within this specification, the term XPath expression, or simply 
expression, means a string that matches the production Expr^ XP defined in 
[XPath 2.0].]
</p>

<p>
An XPath expression may occur as the value of certain attributes on
XSLT-defined elements, and also within curly brackets in attribute value
templates.
</p>

<p>
Except where forwards-compatible behavior is enabled (see 3.9
Forwards-Compatible Processing), it is a static error if the value of such an
attribute, or the text between curly brackets in an attribute value template,
does not match the XPath production Expr^ XP, or if it fails to satisfy other
static constraints defined in the XPath specification, for example that all
variable references must refer to variables that are in scope. Error codes are
defined in [XPath 2.0].
</p>

<p>
The transformation fails with a non-recoverable dynamic error if any XPath 
expression is evaluated and raises a dynamic error. Error codes are defined in
[XPath 2.0].
</p>

<p>
The transformation fails with a type error if an XPath expression raises a
type error, or if the result of evaluating the XPath expression is evaluated
and raises a type error, or if the XPath processor signals a type error during
static analysis of an expression. Error codes are defined in [XPath 2.0].
</p>

<p>
[Definition: The context within a stylesheet where an XPath expression appears
may specify the required type of the expression. The required type indicates
the type of the value that the expression is expected to return.] If no
required type is specified, the expression may return any value: in effect,
the required type is then item()*.
</p>

<p>
[Definition: Except where otherwise indicated, the actual value of an 
expression is converted to the required type using the function conversion
rules. These are the rules defined in [XPath 2.0] for converting the supplied
argument of a function call to the required type of that argument, as defined
in the function signature. The relevant rules are those that apply when XPath
1.0 compatibility mode is set to false.]
</p>

<p>
This specification also invokes the XPath 2.0 function conversion rules to
convert the result of evaluating an XSLT sequence constructor to a required
type (for example, the sequence constructor enclosed in an xsl:variable, 
xsl:template, or xsl:function element).
</p>

<p>
Any dynamic error or type error that occurs when applying the function
conversion rules to convert a value to a required type results in the
transformation failing, in the same way as if the error had occurred while
evaluating an expression.
</p>

<p>
Note:
</p>

<p>
Note the distinction between the two kinds of error that may occur. Attempting
to convert an integer to a date is a type error, because such a conversion is
never possible. Type errors can be reported statically if they can be detected
statically, whether or not the construct in question is ever evaluated.
Attempting to convert the string 2003-02-29 to a date is a dynamic error
rather than a type error, because the problem is with this particular value,
not with its type. Dynamic errors are reported only if the instructions or
expressions that cause them are actually evaluated.
</p>

<p>
5.4 The Static and Dynamic Context
</p>

<p>
XPath defines the concept of an expression context<sup>XP</sup> which contains all the
information that can affect the result of evaluating an expression. The
expression context has two parts, the static context<sup>XP</sup>, and the dynamic
context<sup>XP</sup>. The components that make up the expression context are defined in
the XPath specification (see Section 2.1 Expression Context<sup>XP</sup>). This section
describes the way in which these components are initialized when an XPath
expression is contained within an XSLT stylesheet.
</p>

<p>
As well as providing values for the static and dynamic context components
defined in the XPath specification, XSLT defines additional context components
of its own. These context components are used by XSLT instructions (for
example, xsl:next-match and xsl:apply-imports), and also by the functions in
the extended function library described in this specification.
</p>

<p>
The following four sections describe:
</p>

<p>
5.4.1 Initializing the Static Context
5.4.2 Additional Static Context Components used by XSLT
5.4.3 Initializing the Dynamic Context
5.4.4 Additional Dynamic Context Components used by XSLT
</p>

<p>
5.4.1 Initializing the Static Context
</p>

<p>
The static context<sup>XP</sup> of an XPath expression appearing in an XSLT stylesheet
is initialized as follows. In these rules, the term containing element means
the element within the stylesheet that is the parent of the attribute whose
value contains the XPath expression in question, and the term enclosing
element means the containing element or any of its ancestors.
</p>

<ul class="org-ul">
<li>XPath 1.0 compatibility mode is set to true if and only if the containing
element occurs in part of the stylesheet where backwards compatible
behavior is enabled (see 3.8 Backwards-Compatible Processing).
</li>

<li>The statically known namespaces<sup>XP</sup> are the namespace declarations that are
in scope for the containing element.
</li>

<li>The default element/type namespace<sup>XP</sup> is the namespace defined by the
[xsl:]xpath-default-namespace attribute on the innermost enclosing element
that has such an attribute, as described in 5.2 Unprefixed QNames in
Expressions and Patterns. The value of this attribute is a namespace URI. 
If there is no [xsl:]xpath-default-namespace attribute on an enclosing
element, the default namespace for element names and type names is the
null namespace.
</li>

<li>The default function namespace<sup>XP</sup> is the standard function namespace,
defined in [Functions and Operators]. This means that it is not necessary
to declare this namespace in the stylesheet, nor is it necessary to use
the prefix fn (or any other prefix) in calls to the core functions.
</li>

<li>The in-scope schema definitions<sup>XP</sup> for the XPath expression are the same
as the in-scope schema components for the stylesheet, and are as specified
in 3.13 Built-in Types.
</li>

<li>The in-scope variables<sup>XP</sup> are defined by the variable binding elements
that are in scope for the containing element (see 9 Variables and
Parameters).
</li>

<li>The function signatures<sup>XP</sup> are the core functions defined in [Functions
and Operators], the constructor functions for all the atomic types in the 
in-scope schema definitions<sup>XP</sup>, the additional functions defined in this
specification, the stylesheet functions defined in the stylesheet, plus
any extension functions bound using implementation-defined mechanisms (see
18 Extensibility and Fallback).

<p>
Note:
</p>

<p>
It follows from the above that a conformant XSLT processor must implement
the entire library of core functions defined in [Functions and Operators].
</p>
</li>

<li>The statically known collations<sup>XP</sup> are implementation-defined. However,
the set of in-scope collations must always include the Unicode codepoint
collation, defined in Section 7.3 Equality and Comparison of Strings<sup>FO</sup>.
</li>

<li>The default collation<sup>XP</sup> is defined by the value of the [xsl:]
default-collation attribute on the innermost enclosing element that has
such an attribute. For details, see 3.6.1 The default-collation attribute.

<p>
[Definition: In this specification the term default collation means the
collation that is used by XPath operators such as eq and lt appearing in
XPath expressions within the stylesheet.]
</p>

<p>
This collation is also used by default when comparing strings in the
evaluation of the xsl:key and xsl:for-each-group elements. This may also
(but need not necessarily) be the same as the default collation used for 
xsl:sort elements within the stylesheet. Collations used by xsl:sort are
described in 13.1.3 Sorting Using Collations.
</p>
</li>

<li>The base URI<sup>XP</sup> is the base URI of the containing element. The concept of
the base URI of a node is defined in Section 5.2 base-uri Accessor<sup>DM</sup>
</li>
</ul>

<p>
5.4.2 Additional Static Context Components used by XSLT
</p>

<p>
Some of the components of the XPath static context are used also by XSLT
elements. For example, the xsl:sort element makes use of the collations
defined in the static context, and attributes such as type and as may
reference types defined in the in-scope schema components.
</p>

<p>
Many top-level declarations in a stylesheet, and attributes on the 
xsl:stylesheet element, affect the behavior of instructions within the
stylesheet. Each of these constructs is described in its appropriate place in
this specification.
</p>

<p>
A number of these constructs are of particular significance because they are
used by functions defined in XSLT, which are added to the library of functions
available for use in XPath expressions within the stylesheet. These are:
</p>

<ul class="org-ul">
<li>The set of named keys, used by the key function
</li>

<li>The set of named decimal formats, used by the format-number function
</li>

<li>The values of system properties, used by the system-property function
</li>

<li>The set of available instructions, used by the element-available function
</li>
</ul>

<p>
5.4.3 Initializing the Dynamic Context
</p>

<p>
For convenience, the dynamic context is described in two parts: the focus,
which represents the place in the source document that is currently being
processed, and a collection of additional context variables.
</p>

<p>
A number of functions specified in [Functions and Operators] are defined to be
stable^ FO, meaning that if they are called twice during the same execution
scope<sup>FO</sup>, with the same arguments, then they return the same results (see 
Section 1.7 Terminology<sup>FO</sup>). In XSLT, the execution of a stylesheet defines
the execution scope. This means, for example, that if the function 
current-dateTime<sup>FO</sup> is called repeatedly during a transformation, it produces
the same result each time. By implication, the components of the dynamic
context on which these functions depend are also stable for the duration of
the transformation. Specifically, the following components defined in Section
2.1.2 Dynamic Context<sup>XP</sup> must be stable: function implementations, current
dateTime, implicit timezone, available documents, available collections, and 
default collection. The values of global variables and stylesheet parameters
are also stable for the duration of a transformation. The focus is not stable;
the additional dynamic context components defined in 5.4.4 Additional Dynamic
Context Components used by XSLT are also not stable.
</p>

<p>
As specified in [Functions and Operators], implementations may provide user
options that relax the requirement for the doc^ FO and collection<sup>FO</sup> functions
(and therefore, by implication, the document function) to return stable
results. By default, however, the functions must be stable. The manner in
which such user options are provided, if at all, is implementation-defined.
</p>

<p>
XPath expressions contained in [xsl:]use-when attributes are not considered to
be evaluated "during the transformation" as defined above. For details see 
3.12 Conditional Element Inclusion.
</p>

<p>
5.4.3.1 Maintaining Position: the Focus
</p>

<p>
[Definition: When a sequence constructor is evaluated, the processor keeps
track of which items are being processed by means of a set of implicit
variables referred to collectively as the focus.] More specifically, the focus
consists of the following three values:
</p>

<ul class="org-ul">
<li>[Definition: The context item is the item currently being processed. An
item (see [Data Model]) is either an atomic value (such as an integer,
date, or string), or a node. The context item is initially set to the 
initial context node supplied when the transformation is invoked (see 2.3
Initiating a Transformation). It changes whenever instructions such as 
xsl:apply-templates and xsl:for-each are used to process a sequence of
items; each item in such a sequence becomes the context item while that
item is being processed.] The context item is returned by the XPath 
expression . (dot).
</li>

<li>[Definition: The context position is the position of the context item
within the sequence of items currently being processed. It changes
whenever the context item changes. When an instruction such as 
xsl:apply-templates or xsl:for-each is used to process a sequence of
items, the first item in the sequence is processed with a context position
of 1, the second item with a context position of 2, and so on.] The
context position is returned by the XPath expression position().
</li>

<li>[Definition: The context size is the number of items in the sequence of
items currently being processed. It changes whenever instructions such as 
xsl:apply-templates and xsl:for-each are used to process a sequence of
items; during the processing of each one of those items, the context size
is set to the count of the number of items in the sequence (or
equivalently, the position of the last item in the sequence).] The context
size is returned by the XPath expression last().
</li>
</ul>

<p>
[Definition: If the context item is a node (as distinct from an atomic value
such as an integer), then it is also referred to as the context node. The
context node is not an independent variable, it changes whenever the context
item changes. When the context item is an atomic value, there is no context
node.] The context node is returned by the XPath expression self::node(), and
it is used as the starting node for all relative path expressions.
</p>

<p>
Where the containing element of an XPath expression is an instruction or a 
literal result element, the initial context item, context position, and
context size for the XPath expression are the same as the context item, 
context position, and context size for the evaluation of the containing
instruction or literal result element.
</p>

<p>
In other cases (for example, where the containing element is xsl:sort, 
xsl:with-param, or xsl:key), the rules are given in the specification of the
containing element.
</p>

<p>
The current function can be used within any XPath expression to select the
item that was supplied as the context item to the XPath expression by the XSLT
processor. Unlike . (dot) this is unaffected by changes to the context item
that occur within the XPath expression. The current function is described in 
16.6.1 current.
</p>

<p>
On completion of an instruction that changes the focus (such as 
xsl:apply-templates or xsl:for-each), the focus reverts to its previous value.
</p>

<p>
When a stylesheet function is called, the focus within the body of the
function is initially undefined. The focus is also undefined on initial entry
to the stylesheet if no initial context node is supplied.
</p>

<p>
When the focus is undefined, evaluation of any expression that references the
context item, context position, or context size results in a non-recoverable
dynamic error [XPDY0002]
</p>

<p>
The description above gives an outline of the way the focus works. Detailed
rules for the effect of each instruction are given separately with the
description of that instruction. In the absence of specific rules, an
instruction uses the same focus as its parent instruction.
</p>

<p>
[Definition: A singleton focus based on a node N has the context item (and
therefore the context node) set to N, and the context position and context
size both set to 1 (one).]
</p>

<p>
5.4.3.2 Other components of the XPath Dynamic Context
</p>

<p>
The previous section explained how the focus for an XPath expression appearing
in an XSLT stylesheet is initialized. This section explains how the other
components of the dynamic context<sup>XP</sup> of an XPath expression are initialized.
</p>

<ul class="org-ul">
<li>The dynamic variables<sup>XP</sup> are the current values of the in-scope variable
binding elements.
</li>

<li>The current date and time represents an implementation-dependent point in
time during processing of the transformation; it does not change during
the course of the transformation.
</li>

<li>The implicit timezone<sup>XP</sup> is implementation-defined.
</li>

<li>The available documents<sup>XP</sup>, and the available collections<sup>XP</sup> are
determined as part of the process for initiating a transformation (see 2.3
Initiating a Transformation).

<p>
The available documents<sup>XP</sup> are defined as part of the XPath 2.0 dynamic
context to support the doc<sup>FO</sup> function, but this component is also
referenced by the similar XSLT document function: see 16.1 Multiple Source
Documents. This variable defines a mapping between URIs passed to the doc^
FO or document function and the document nodes that are returned.
</p>

<p>
Note:
</p>

<p>
Defining this as part of the evaluation context is a formal way of
specifying that the way in which URIs get turned into document nodes is
outside the control of the language specification, and depends entirely on
the run-time environment in which the transformation takes place.
</p>

<p>
The XSLT-defined document function allows the use of URI references
containing fragment identifiers. The interpretation of a fragment
identifier depends on the media type of the resource representation.
Therefore, the information supplied in available documents<sup>XP</sup> for XSLT
processing must provide not only a mapping from URIs to document nodes as
required by XPath, but also a mapping from URIs to media types.
</p>
</li>

<li>The default collection<sup>XP</sup> is implementation-defined. This allows options
such as setting the default collection to be an empty sequence, or to be
undefined.
</li>
</ul>

<p>
5.4.4 Additional Dynamic Context Components used by XSLT
</p>

<p>
In addition to the values that make up the focus, an XSLT processor maintains
a number of other dynamic context components that reflect aspects of the
evaluation context. These components are fully described in the sections of
the specification that maintain and use them. They are:
</p>

<ul class="org-ul">
<li>The current template rule, which is the template rule most recently
invoked by an xsl:apply-templates, xsl:apply-imports, or xsl:next-match
instruction: see 6.7 Overriding Template Rules;
</li>

<li>The current mode, which is the mode set by the most recent call of 
xsl:apply-templates (for a full definition see 6.5 Modes);
</li>

<li>The current group and current grouping key, which provide information
about the collection of items currently being processed by an 
xsl:for-each-group instruction: see 14.1 The Current Group and 14.2 The
Current Grouping Key;
</li>

<li>The current captured substrings: this is a sequence of strings, which is
maintained when a string is matched against a regular expression using the
xsl:analyze-string instruction, and which is accessible using the 
regex-group function: see 15.2 Captured Substrings.
</li>

<li>The output state: this is a flag whose two possible values are final
output state and temporary output state. This flag indicates whether
instructions are currently writing to a final result tree or to an
internal data structure. The initial setting is final output state, and it
is switched to temporary output state by instructions such as xsl:variable
. For more details, see 19.1 Creating Final Result Trees.
</li>
</ul>

<p>
The following non-normative table summarizes the initial state of each of the
components in the evaluation context, and the instructions which cause the
state of the component to change.
</p>

<!-- This HTML table template is generated by emacs 24.3.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;Component&nbsp;&nbsp;
    </td>
  </tr>
</table>

<p>
5.5 Patterns
</p>

<p>
A template rule identifies the nodes to which it applies by means of a
pattern. As well as being used in template rules, patterns are used for
numbering (see 12 Numbering), for grouping (see 14 Grouping), and for
declaring keys (see 16.3 Keys).
</p>

<p>
[Definition: A pattern specifies a set of conditions on a node. A node that
satisfies the conditions matches the pattern; a node that does not satisfy the
conditions does not match the pattern. The syntax for patterns is a subset of
the syntax for expressions.] As explained in detail below, a node matches a
pattern if the node can be selected by deriving an equivalent expression, and
evaluating this expression with respect to some possible context.
</p>

<p>
5.5.1 Examples of Patterns
</p>

<p>
Example: Patterns
</p>

<p>
Here are some examples of patterns:
</p>

<ul class="org-ul">
<li>para matches any para element.
</li>

<li>* matches any element.
</li>

<li>chapter|appendix matches any chapter element and any appendix element.
</li>

<li>olist/entry matches any entry element with an olist parent.
</li>

<li>appendix//para matches any para element with an appendix ancestor element.
</li>

<li>schema-element(us:address) matches any element that is annotated as an
instance of the type defined by the schema element declaration us:address,
and whose name is either us:address or the name of another element in its
substitution group.
</li>

<li>attribute(*, xs:date) matches any attribute annotated as being of type
xs:date.
</li>

<li>/ matches a document node.
</li>

<li>document-node() matches a document node.
</li>

<li>document-node(schema-element(my:invoice)) matches the document node of a
document whose document element is named my:invoice and matches the type
defined by the global element declaration my:invoice.
</li>

<li>text() matches any text node.
</li>

<li>node() matches any node other than an attribute node, namespace node, or
document node.
</li>

<li>id("W33") matches the element with unique ID W33.
</li>

<li>para<sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> matches any para element that is the first para child element of
its parent. It also matches a parentless para element.
</li>

<li>//para matches any para element that has a parent node.
</li>

<li>bullet[position() mod 2 = 0] matches any bullet element that is an
even-numbered bullet child of its parent.
</li>

<li>div[@class="appendix"]//p matches any p element with a div ancestor
element that has a class attribute with value appendix.
</li>

<li>@class matches any class attribute (not any element that has a class
attribute).
</li>

<li>@* matches any attribute node.
</li>
</ul>

<p>
5.5.2 Syntax of Patterns
</p>

<p>
[ERR XTSE0340] Where an attribute is defined to contain a pattern, it is a 
static error if the pattern does not match the production Pattern. Every
pattern is a legal XPath expression, but the converse is not true: 2+2 is an
example of a legal XPath expression that is not a pattern. The XPath
expressions that can be used as patterns are those that match the grammar for 
Pattern, given below.
</p>

<p>
Informally, a Pattern is a set of path expressions separated by |, where each
step in the path expression is constrained to be an AxisStep^ XP that uses
only the child or attribute axes. Patterns may also use the // operator. A 
Predicate^ XP within the PredicateList^ XP in a pattern can contain arbitrary
XPath expressions (enclosed between square brackets) in the same way as a 
predicate^ XP in a path expression.
</p>

<p>
Patterns may start with an id^ FO or key function call, provided that the
value to be matched is supplied as either a literal or a reference to a 
variable or parameter, and the key name (in the case of the key function) is
supplied as a string literal. These patterns will never match a node in a tree
whose root is not a document node.
</p>

<p>
If a pattern occurs in part of the stylesheet where backwards compatible
behavior is enabled (see 3.8 Backwards-Compatible Processing), then the
semantics of the pattern are defined on the basis that the equivalent XPath
expression is evaluated with XPath 1.0 compatibility mode set to true.
</p>

<p>
Patterns
</p>
</div>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> unsorted</h2>
<div class="outline-text-2" id="text-14">
<p>
sort sawfish quicksort swordfish syntax 
sort not
    (dont sort)
    (sort senses of not)
    (sort meanings of not by syntax)
</p>
</div>
<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1"><span class="section-number-3">14.1</span> develop a parser/sorter (for rewards)</h3>
<div class="outline-text-3" id="text-14-1">
<p>
for meanings of the term 'not'
according to  
(<b>grammatical-rules</b>) (<b>syntax</b>)
</p>
</div>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> gruff&#xa0;&#xa0;&#xa0;<span class="tag"><span class="gruff">gruff</span></span></h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1"><span class="section-number-3">15.1</span> The Programmatic Lisp API to Gruff</h3>
<div class="outline-text-3" id="text-15-1">
<p>
The symbols documented here are exported from the gruff package, which has the nickname "uf".
display-triples
</p>

<p>
Displays node pictures and link lines in a graph-node-pane for a set of triples, and then does a layout to arrange the nodes for readability.
</p>

<p>
(defun display-triples
  (triples &amp;key
           uncache-for-new-triple-store
           keep-old-nodes
           (layout-from-scratch (or uncache-for-new-triple-store
                                    (not keep-old-nodes)))
           node-upi-for-initial-position
           max-iterations
           select-window
           no-push-go-back-state
           no-regroup
           (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
triples should be a list of triples that exist in the currently open store. You can use whatever means you like to derive the list of triples to be displayed, such as one or more calls to get-triples-list.
</p>

<p>
uncache-for-new-triple-store should be true if you have just programmatically created or opened a store after displaying nodes and links from a previous store. If the store was created or opened using the standard browser's File menu, then this was done automatically.
</p>

<p>
If keep-old-nodes is true, then any nodes and links that are already on the node pane will be retained, with the specified triples being added to them. If nil, then all nodes and links are first removed from the node pane.
</p>

<p>
If layout-from-scratch is true, then a "full layout" will be done with all nodes initially at the center of the node pane, to remove any bias from the current node positions that may have resulted from multiple "incremental" layouts. If nil, then an incremental layout is done with any old nodes starting out at their current positions.
</p>

<p>
If node-upi-for-initial-position is true, then it normally should be a part ID (a UPI, future-part, or string in ntriples format) of one of the nodes that are already displayed on the node pane, and keep-old-nodes should be true. Then any nodes that are added to the display will initially be positioned where the node for that UPI is currently positioned, and then moved from there as the layout is done. This is useful when adding a set of nodes that are linked in the store with the specified node, to make the incremental layout that follows disrupt the existing layout less than it would otherwise.
</p>

<p>
max-iterations is the number of iterations at which the automatic incremental layout will stop if it has not reached a stable state by that time. To suppress the layout altogether, specify 0 (because nil will default to some positive number). Suppressing the layout may be useful if you are going to modify the set of nodes and links that are added before you care to nicely arrange them, such as if you plan to remove all leaf nodes after adding the triples by calling remove-orphans.
</p>

<p>
If select-window is true, then the top-level window of the node pane will be brought to the front and given the keyboard focus.
</p>

<p>
If no-push-go-back-state is true, then the current state will not be added to the node pane's undo stack before doing the new operation. Otherwise an undo state will be added, allowing the user to return to the current state from the new state that results from this operation. A state consists of a particular set of nodes and links and the positions of all of the nodes.
</p>

<p>
If no-regroup is true, then objects that have many links will not be divided into multiple nodes according to Visual Graph Options | Node and Link Spacing | Maximum Links Per Node Copy.
</p>

<p>
node-pane is the window onto which to add node pictures and link lines. It should be an instance of the graph-node-pane class. When unspecified, it will default to the node pane of the standard full Gruff browser window, which will be created automatically if it doesn't exist already. Otherwise it should a graph-node-pane instance that was created by calling the Common Graphics function make-window; see "Using the standard full browser or a plain graph layout pane".
</p>

<p>
Here's an example, which expects <b>my-node-pane</b> to exist from the example under "Using the standard full browser or a plain graph layout pane", and for a new store to have been created.
</p>

<p>
First let's create some resources and add some triples for them to the store. The triples here will form a logical "wheel" with one node that's connected to the other nodes that are themselves connected in a loop.
</p>

<p>
(defparameter <b>middle-thing</b> (triple-store:resource "MiddleThing")) 
</p>

<p>
(defparameter <b>things</b> (let* ((things nil))
                         (dotimes (j 9)
                           (push (triple-store:resource
                                  (format nil "Thing ~a" j))
                             things))
                         (nreverse things)))
</p>

<p>
(defparameter <b>points-to</b> (triple-store:resource "PointsTo")) 
</p>

<p>
(let* ((count 9)
       (triples nil))
  (dotimes (j count)
    (triple-store:add-triple <b>middle-thing</b> <b>points-to</b> (nth j <b>things</b>))
    (triple-store:add-triple (nth j <b>things</b>) <b>points-to</b>
                             (nth (mod (1+ j) count) <b>things</b>))))
</p>

<p>
And now (this could be any time later), let's display the triples as a visual graph. This displays all triples whose predicate is PointsTo, which happens to include all of the triples we just created.
</p>

<p>
(display-triples (triple-store:get-triples-list :p <b>points-to</b>)
</p>
<p>
:keep-old-nodes nil
</p>
<p>
:layout-from-scratch t
</p>
<p>
:node-pane <b>my-node-pane</b>
</p>
<p>
:select-window t)
</p>

<p>
display-upis
</p>

<p>
Displays node pictures on a node pane for a set of subject and object UPIs, and adds link lines between them for a given set of predicate UPIs.
</p>

<p>
(defun display-upis
  (upi-list &amp;key predicate-upis
                 uncache-for-new-triple-store
                 keep-old-nodes
                 (layout-from-scratch (or uncache-for-new-triple-store
                                          (not keep-old-nodes)))
                 node-upi-for-initial-position
                 max-iterations
                 select-window
                 no-push-go-back-state
                 no-regroup
                 (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
upi-list should be a list of subject and object part IDs of triples that exist in the currently open store. A node picture will be added to the node pane for each one. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "&lt;foo&gt;".)
</p>

<p>
predicate-upis should be a list of predicate part IDs of triples that exist in the open store, or else t or nil. t means all predicates for which there are triples in the store, while nil means all "current predicates", as set by calling set-current-predicates or using the "Global Options | Select Current Predicates" menu command in the standard browser.
</p>

<p>
Link lines will be added to the display to connect any of the new nodes with any new or already-displayed nodes that are linked by the specified predicates in the store. More specifically, a link line will be added to the node pane between two nodes whenever there are one or more triples in the currently open store where the subject or object of the triple is in the specified upi-list, the predicate of the triple is in the specified predicate-upis, and the other subject or object of the triple is either also in the upi-list or was already displayed on the node pane.
</p>

<p>
See display-triples for descriptions of the other arguments.
</p>

<p>
Here's an example that would display the wheel from the example for display-triples, except excluding the middle node.
</p>

<p>
(display-upis <b>things</b>
</p>
<p>
:predicate-upis (list <b>points-to</b>)
</p>
<p>
:keep-old-nodes nil
</p>
<p>
:layout-from-scratch t
</p>
<p>
:node-pane <b>my-node-pane</b>
</p>
<p>
:select-window t)
</p>

<p>
This would add the middle node to the existing nodes. The layout would probably be closer to a nice wheel-like shape if you change the :layout-from-scratch argument here to t.
</p>

<p>
(display-upis (list <b>middle-thing</b>)
</p>
<p>
:predicate-upis (list <b>points-to</b>)
</p>
<p>
:keep-old-nodes t
</p>
<p>
:layout-from-scratch nil
</p>
<p>
:node-pane <b>my-node-pane</b>
</p>
<p>
:select-window t)
</p>

<p>
display-upis-from-file
</p>

<p>
Displays node pictures on a node pane for a set of subject and object UPIs that are listed in a file, and adds link lines between them for a set of predicate UPIs that are listed in the same file. This is like display-upis except that it reads the UPIs from a file instead of accepting them as arguments.
</p>

<p>
(defun display-upis-from-file
  (path &amp;key keep-old-nodes
             select-window
             (layout-from-scratch (not keep-old-nodes))
             (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
path is the pathname or path namestring of a file that contains the URIs of the nodes and links to display. The file should contain a list of URIs for nodes (subjects and objects), with one URI per text line, followed by a blank line, followed by a list of predicate URIs. All of the URIs should name objects that are in the currently open store.
</p>

<p>
See display-triples for descriptions of the other arguments.
</p>

<p>
Here is a small example of the contents of a file that could be passed to this function, after opening the dbpedia store.
</p>

<p>
<a href="http://dbpedia.org/resource/Joanne_Woodward">http://dbpedia.org/resource/Joanne_Woodward</a> 
<a href="http://dbpedia.org/resource/Paul_Newman">http://dbpedia.org/resource/Paul_Newman</a> 
<a href="http://dbpedia.org/resource/The_Long,_Hot_Summer">http://dbpedia.org/resource/The_Long,_Hot_Summer</a> 
</p>

<p>
<a href="http://dbpedia.org/property/starring">http://dbpedia.org/property/starring</a> 
<a href="http://dbpedia.org/property/director">http://dbpedia.org/property/director</a> 
</p>

<p>
To display a set of triples from a file (rather than individual resources and predicates as with this function), you could use the usual AllegroGraph functions to create a new store and load triples into it, and then call the Gruff function display-store to display it.
find-and-display-paths
</p>

<p>
Displays nodes and links for all paths between two nodes that use certain predicates, up to a certain maximum path length. Returns the list of paths that were found.
</p>

<p>
(defun find-and-display-paths
    (node-upi1 node-upi2 predicate-upis
               &amp;key (finder-function 'triple-store:all-bidirectional-search-paths)
               (maximum-depth 4) warn-on-many-triples
               uncache-for-new-triple-store keep-old-nodes
               (layout-from-scratch (or uncache-for-new-triple-store
                                        (not keep-old-nodes)))
               (end-node-placement (and layout-from-scratch
</p>
<p>
                         :left-and-right))
node-upi-for-initial-position
max-iterations select-window no-push-go-back-state
(timeout 30)
(node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
node-upi1 and node-upi2 are the part IDs of the two resources and/or literals between which paths should be found. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "&lt;foo&gt;".)
</p>

<p>
predicate-upis should be a list of predicate part IDs. Only paths that use only predicates from this list will be found. If this argument is nil, it will default to the current predicates (see current-predicates). If it is t, then all predicates will be used.
</p>

<p>
finder-function is the particular AllegroGraph Social Network Analysis (SNA) function to call to find the paths. The default value is triple-store:all-bidirectional-search-paths, which will find only the shortest paths even when maximum-depth is large. This argument could be any path-finding function that takes the same arguments, such as triple-store:all-depth-first-search-paths or triple-store:all-breadth-first-search-paths.
</p>

<p>
maximum-depth is the length of the longest paths that are to be found.
</p>

<p>
end-node-placement works as with display-paths.
</p>

<p>
If warn-on-many-triples is true and the number of found paths is greater than the number-of-found-paths-for-warning option of the node pane, then a confirmation dialog is shown, and the nodes and links are added to the display only if the user confirms.
</p>

<p>
If the call to a path-finding function does not return in timeout seconds, then this function gives up and returns the symbol :timeout.
</p>

<p>
The other arguments are passed straight through to display-triples.
</p>

<p>
This function corresponds to the menu command Link | Display Paths Between Two Nodes (when keep-old-nodes is true) and to Link | Display Only Paths Between Two Nodes (when keep-old-nodes is nil).
</p>

<p>
This function calls display-paths to display the paths that were found. If you are calling AllegroGraph's path-finding functions such as all-bidirectional-search-paths yourself, then you could pass the result to display-paths instead of calling this function.
display-paths
</p>

<p>
Displays nodes and links for a set of paths that are specified as lists of nodes, for a particular set of predicates that link them.
</p>

<p>
(defun display-paths (paths predicate-upis
                            &amp;key warn-on-many-triples
                            uncache-for-new-triple-store keep-old-nodes
                            (layout-from-scratch (or uncache-for-new-triple-store
                                                     (not keep-old-nodes)))
                            (end-node-placement (and layout-from-scratch
</p>
<p>
                         :left-and-right))
node-upi-for-initial-position
max-iterations select-window no-push-go-back-state
(node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
paths is a list of lists of the part IDs of resources and/or literals, where each sublist should specify a sequence of nodes that are linked by the specified predicates. Typically this value would have been returned by one of AllegroGraph's social network path-finding functions such as all-depth-first-search-paths or all-bidirectional-search-paths. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "&lt;foo&gt;".)
</p>

<p>
predicate-upis should be a list of predicate part IDs. Links will be shown between the displayed nodes only for the predicates in this list. If this argument is nil, it will default to the current predicates (see current-predicates). If it is t, then all predicates will be used.
</p>

<p>
If warn-on-many-triples is true and the number of triples in all of the paths is greater than the number-of-found-path-links-for-warning option of the node pane, then a confirmation dialog is shown, and the nodes and links are added to the display only if the user confirms.
</p>

<p>
end-node-placement determines whether the two end nodes are pinned near the edges of the window during the automatic incremental layout that occurs. Pinning the end nodes near the window edges typically makes the paths between them clearer by stretching them out. :left-and-right will place the node-upi1 node near the left edge of the window and the node-upi2 node near the right edge. :top-and-bottom would place them near the top and bottom edges, while nil will let the two end nodes float freely as usual during the layout. The default is :left-and-right when layout-from-scratch is true, but nil when layout-from-scratch is false (to avoid disrupting the current layout).
</p>

<p>
The other arguments are passed straight through to display-triples.
</p>

<p>
This function is called by find-and-display-paths, which first finds the paths to display from nodes that lie at the ends of the paths.
display-linked-nodes
</p>

<p>
Adds nodes to the display that are linked in the store to a particular specified node by any of the current predicates, and adds these links to the display. A link is also added to the display between any newly-displayed node and any newly-displayed or already-displayed node to which it is linked by any current predicate.
</p>

<p>
(defun display-linked-nodes
  (from-node-upi &amp;key (keep-old-nodes t)
                      (levels-to-add 1)
                      (deselect-selected-node t)
                      (exclude-explicitly-excluded-nodes t)
                      (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
from-node-upi should be a part ID of a node that is already displayed on the node pane. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "&lt;foo&gt;".) Node pictures will be added to the node pane, and link-lines will connect them to this node, for any nodes in the store that are linked with this node by any of the current predicates. Call set-current-predicates beforehand to establish the current predicates.
</p>

<p>
If keep-old-nodes is true, then nodes and links that were already on the node-pane will not be removed. If nil, all nodes and links will be removed except for the node of the specified from-node-upi.
</p>

<p>
levels-to-add should be a positive integer indicating how many links from the specified from-node-upi should be traversed to find additional nodes to add. The default is 1 to add only nodes that are directly linked to the from-node-upi by the current predicates. A value of 2 would also add any nodes that are linked to those nodes by the current predicates. Note that a higher value is likely to add more nodes than can reasonably be layed out or viewed at one time.
</p>

<p>
If deselect-selected-node is true, then the currently selected node (which in this case will be the from-node-upi node) is deselected before the layout is done. Otherwise the from-node-upi node will be fixed in place during the layout.
</p>

<p>
If exclude-explicitly-excluded-nodes is true, then no nodes that have been explicitly excluded by the user will be added to the node pane. Otherwise they will be added if they meet the other requirements. A node is excluded by calling remove-node-of-upi with the exclude argument as true.
</p>

<p>
See display-triples for a description of the node-pane argument.
</p>

<p>
This function corresponds to the menu command Link | Display Linked Nodes for the Current Predicates, except that that command always acts on the node picture that has been selected by the user.
</p>

<p>
Here's an example that uses the test objects from the preceding examples. It first displays the middle node by itself and waits a couple of seconds. Then it makes our <b>points-to</b> predicate be a current predicate and adds any nodes that are linked with the middle node by any current predicates.
</p>

<p>
(progn 
</p>

<p>
;; Display the middle thing by itself.
(display-upis (list <b>middle-thing</b>)
</p>
<p>
:keep-old-nodes nil
</p>
<p>
:layout-from-scratch t
</p>
<p>
:node-pane <b>my-node-pane</b>
</p>
<p>
:select-window t)
</p>

<p>
;; Add nodes to the middle node that are linked to it by
;; any current predicates.
(sleep 2)
(set-current-predicates (list <b>points-to</b>) :node-pane <b>my-node-pane</b>)
(display-linked-nodes <b>middle-thing</b>
</p>
<p>
:node-pane <b>my-node-pane</b>)
</p>

<p>
;; For three of the nodes, add triples to connect them to
;; new resources, and then display any nodes that are linked
;; to the new ones by the current predicates.
(dotimes (node-num 3)
  (sleep 2)
  (dotimes (count 4)
    (triple-store:add-triple
     (nth node-num <b>things</b>) <b>points-to</b>
     (triple-store:resource (format nil "Thing ~a"
                              (+ 100 (* node-num 10) count)))))
  (uncache-for-modified-triple-store)
  (set-current-predicates (list <b>points-to</b>) :node-pane <b>my-node-pane</b>)
  (display-linked-nodes (nth node-num <b>things</b>)
</p>
<p>
:node-pane <b>my-node-pane</b>))
</p>

<p>
;; The layout is probably not as nice as it could be due to
;; doing multiple incremental layouts, so redo it from scratch.
(sleep 2)
(update-the-layout :layout-from-scratch t
</p>
<p>
:node-pane <b>my-node-pane</b>))
</p>

<p>
display-store
</p>

<p>
Displays node pictures and link lines in a graph-node-pane for some or all of the triples in the currently open store, and then does a layout to arrange the nodes for readability.
</p>

<p>
(defun display-store
  (&amp;key (limit 100)
        graph
        uncache-for-new-triple-store
        keep-old-nodes
        include-nodes-for-label-properties
        include-nodes-for-comment-properties
        (layout-from-scratch (or uncache-for-new-triple-store
                                 (not keep-old-nodes)))
        max-iterations
        select-window
        no-push-go-back-state
        no-regroup
        (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
limit is the maximum number of nodes to add to the display. When limit is less than the number of triples in the store, then the first arbitrary set of triples that are found will be used, even if they are already displayed on the node pane.
</p>

<p>
graph may be the UPI of one of the graphs of the store, to display only nodes that are in that particular graph.
</p>

<p>
Attempting to display all triples in a large store can easily overwhelm the ability of the software to do a layout in a reasonable amount of time. You can make the scrolling canvas larger to accomodate more nodes, though; see "Adjusting the size of the canvas for the layout".
</p>

<p>
If include-nodes-for-label-properties is nil, then nodes that are the object of triples whose predicates are rdfs:label will be excluded from the display. If true, they will be included like any other node. Typically it is not useful to include nodes for label properties because their values are printed on the nodes for which they are the labels.
</p>

<p>
If include-nodes-for-comment-properties is nil, then nodes that are the object triples whose predicates are rdfs:comment will be excluded from the display. If true, they will be included like any other node. Typically it is not necessary to include nodes for comment properties because the comment strings are displayed in tooltips when holding the mouse over nodes for which they are the comments.
</p>

<p>
See display-triples for descriptions of the other arguments.
</p>

<p>
This function corresponds to the menu command Display | Display Some Sample Triples.
remove-node-of-upi
</p>

<p>
Removes the node picture for a UPI from the display, along with any link lines that are connected to it.
</p>

<p>
(defun remove-node-of-upi
  (node-upi &amp;key exclude
                 (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
Removes a node picture that has been added to the display at some earlier time. Any link lines that are connected directly to the node picture are also removed (because otherwise they would be left pointing to nothing).
</p>

<p>
node-upi should be a part ID of a node that is currently displayed (though if it is not found a status-bar message will simply indicate that). (A part ID is either a UPI, a future-part, or a string in ntriples format such as "&lt;foo&gt;".)
</p>

<p>
If exclude is true, then the node will be marked as an indefinitely excluded node, and it will not be added back by functions or commands that add any nodes that are linked by the current predicates, or by display-store.
</p>

<p>
See display-triples for a description of the node-pane argument.
</p>

<p>
This function corresponds to the menu commands Remove | Remove Selected Node and Remove | Exclude Selected Node, except that those commands always act on the node that has been selected by the user.
</p>

<p>
Here's an example using the graph that was built in earlier examples.
</p>

<p>
(remove-node-of-upi <b>middle-thing</b>
</p>
<p>
:node-pane <b>my-node-pane</b>)
</p>

<p>
remove-orphans
</p>

<p>
Removes any orpan and/or leaf nodes from the display.
</p>

<p>
(defun remove-orphans
  (&amp;key leaves-too unhighlighted
        no-update no-warning
        (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
This function removes from the display any nodes that are not connected to other displayed nodes by link lines, and optionally also any nodes that are connected to only a single other displayed node.
</p>

<p>
If leaves-too is true, then leaf nodes (ones that are linked to exactly one other displayed node) are removed in addition to orphan nodes. If nil, then only orphan nodes (ones that are not linked to any other displayed nodes) are removed. Note that removing leaves may turn some remaining nodes into leaves, and so calling this function again may remove additional nodes.
</p>

<p>
If unhighlighted is true, then a completely different thing is done, to remove all nodes except for ones that are highligted.
</p>

<p>
If no-update is true, then no layout is done after removing the nodes. If nil, then an incremental layout is done.
</p>

<p>
If no-warning is true, then no warning is shown in the status bar if there were no nodes to remove, and otherwise a warning will be shown. It may be useful to suppress the warning to avoid covering an earlier more important status bar message.
</p>

<p>
See display-triples for a description of the node-pane argument.
</p>

<p>
This function corresponds to the menu commands Remove | Remove All Orphan Nodes, Remove | Remove All Leaf Nodes, and Remove | Remove All Unhighlighted Nodes.
remove-all-nodes
</p>

<p>
Removes all nodes and links from the display. This is useful for clearing the display to begin building a new one.
</p>

<p>
This function corresponds to the menu command Remove | Remove All Nodes.
current-predicates
</p>

<p>
Returns the current predicates as UPIs.
</p>

<p>
(defun current-predicates () 
</p>

<p>
Two values are returned, where the first is a list of UPIs of the predicates that will be used when a specified node is the subject of any triples that use those predicates, and the second being a list of UPIs of the predicates that are used when a specified node is the object of a triple.
set-current-predicates
</p>

<p>
Defines the set of predicates that are used by functions that use the current predicates.
</p>

<p>
(defun set-current-predicates
  (predicate-upis &amp;key (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
Some functions and menu commands act on a set of current predicates. This is a convenience feature that allows specifying a set of predicates that are of interest a single time, and then making multiple calls to add nodes that are linked by those predicates.
</p>

<p>
For example, if you call display-upis with the predicate-upis argument as nil, then it will add link lines to the display for any triples that link displayed nodes by these current predicates. And the function display-linked-nodes always uses the current predicates.
</p>

<p>
predicate-upis should be a list of predicate part IDs. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "&lt;foo&gt;".)
</p>

<p>
See the example for display-linked-nodes.
</p>

<p>
This function corresponds to the menu command Global Options | Select Current Predicates.
highlight-node-by-upi
</p>

<p>
Highlights or unhighlights a node that is on a node pane, by changing its background color.
</p>

<p>
(defun highlight-node-by-upi
  (node-upi &amp;key off (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
Highlighted nodes are drawn with a light red background to make it easier to spot particular nodes. This function is like the menu command Select | Toggle Highlighting of the Selected Node or Link, except that you can specify an arbitrary node.
</p>

<p>
node-upi should be a part ID of a node picture that is currently displayed on the node pane. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "&lt;foo&gt;".)
</p>

<p>
off should be nil to turn highlighting on for the node picture, or true to turn it off.
</p>

<p>
See display-triples for a description of the node-pane argument.
</p>

<p>
Alternately call remove-all-highlighting.
</p>

<p>
This function corresponds to the menu command Select | Toggle Highlighting of the Selected Node or Link.
remove-all-highlighting
</p>

<p>
Turns highlighting off for all node pictures that are currently displayed.
</p>

<p>
(defun remove-all-highlighting
  (&amp;key (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
See display-triples for a description of the node-pane argument.
</p>

<p>
This function corresponds to the menu command Select | Remove All Node and Link Highlighting.
update-the-layout
</p>

<p>
Arranges the nodes that are currently displayed to make the overall layout of nodes and links relatively readable.
</p>

<p>
(defun update-the-layout
    (&amp;key layout-from-scratch
          max-iterations
          fixed-node-upis
          deselect-selected-node
          compress-layout
          center-the-graph
          (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
fixed-node-upis may be a list of part IDs whose node pictures should remain at their current locations during the layout, forcing other nodes to arrange themselves around those fixed nodes. If nil, then no node pictures will be fixed in place. (A part ID is either a UPI, a future-part, or a string in ntriples format such as "&lt;foo&gt;".)
</p>

<p>
If deselect-selected-node is true, then the currently selected node (if any) is deselected before the layout is done. Otherwise the currently selected node will be fixed in place during the layout.
</p>

<p>
If compress-layout is true, then an additional step is done after the main layout that tends to bring the nodes closer together so that the entire graph takes up less space. If nil, this is not done. See the menu command Visual Graph Options | Layout Options | Compress After Full Layout.
</p>

<p>
If center-the-graph is true, then after the layout is done, the entire set of nodes is moved to the middle of the scrollable canvas, and the window is scrolled to the middle of the canvas. If nil, this is not done. See the menu command Visual Graph Options | Layout Options | Center After Full Layout.
</p>

<p>
See display-triples for descriptions of the other arguments.
</p>

<p>
This function corresponds to the menu commands Layout | Update Layout Incrementally and Layout | Redo Layout from Scratch.
center-the-graph
</p>

<p>
Centers the graph as a whole in the window.
</p>

<p>
(defun center-the-graph
  (&amp;key (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
This function first moves the whole set of displayed nodes and links as a group to the middle of the scrollable canvas of the node pane, and then scrolls the node pane to the middle of the canvas.
</p>

<p>
The two options Visual Graph Options | Layout Options | Center After Full Layout and Visual Graph Options | Layout Options | Center After Incremental Layout cause this to be done automatically at certain times, but note that the option for centering after an incremental layout will scroll the window to the middle only if it was nearly scrolled to the middle before the layout. This function will always do it.
</p>

<p>
See display-triples for a description of the node-pane argument.
</p>

<p>
This function corresponds to the menu command Layout | Center the Graph.
gruff-browser
</p>

<p>
Returns the standard full Gruff browser, complete with its menu bar of interactive commands and its alternate views. If the browser does not exist currently, it is created automatically.
</p>

<p>
(defun gruff-browser (&amp;key expose exterior http-server-port disable-menus) 
</p>

<p>
If expose is true, then the browser will be brought to the front and given the keyboard focus, whether or not the browser already exists. If nil, then it will come to the front only if it did not exist yet.
</p>

<p>
The exterior argument can be passed to specify the screen coordinates of the Gruff window, if it is being created. The value should be a Common Graphics "box" object that specifies the left, top, right, and bottom edges, as created by a call like (make-box 100 100 800 600).
</p>

<p>
The http-server-port argument may be an integer to tell Gruff to start up an HTTP server at that port, to allow controlling Gruff remotely with HTTP commands. See The HTTP Interface to Gruff.
</p>

<p>
If disable-menus is true, then no menu bar or pop-up menus will appear, and their keyboard shortcuts will be disabled as well. This may be useful for preventing the end user from controlling Gruff interactively if you want to exclusively control Gruff with HTTP commands.
</p>

<p>
The programmatic interface for graph layout can be used on the "graph view" node pane of the full browser, which is returned by this expression:
</p>

<p>
(graph-node-pane (gruff-browser)) 
</p>

<p>
Alternately you can make and use a raw instance of the graph-node-pane class. See "Using the standard full browser or a plain graph layout pane".
graph-node-pane
</p>

<p>
This symbol names both a class and a function.
</p>

<p>
An instance of the class is a Common Graphics window on which node pictures and link lines are placed. Various Gruff functions take a graph-node-pane as an argument. You can use either the one in the standard full browser, which is returned by (graph-node-pane (gruff-browser)), or use a custom graph-node-pane instance that you create by calling the Common Graphics function make-window.
</p>

<p>
See "Using the standard full browser or a plain graph layout pane".
</p>

<p>
This symbol also names a function, which returns the "graph view" node pane of the standard full Gruff browser.
</p>

<p>
(defmethod graph-node-pane ((window gruff-frame)) 
</p>

<p>
This simply returns the descendent window of the standard full Gruff browser that is used for drawing visual graphs of nodes and links in the graph view.
</p>

<p>
This child window is the default value for functions where a node-pane argument is needed, so you likely will not need to call this function yourself. Either you will be using the full Gruff browser and letting the node-pane arguments default, or you will be using your own instance of graph-node-pane and passing that node pane instead.
</p>

<p>
The argument to this function should be the Gruff browser window that's returned by gruff-browser.
save-layout
</p>

<p>
Saves the current state of a visual graph, which can be loaded any time later with load-layout.
</p>

<p>
(defmethod save-layout ((pane graph-node-pane) file) 
</p>

<p>
pane is the graph-node-pane that is displaying a visual graph.
</p>

<p>
file is the pathname or path namestring of the file into which to save the data.
</p>

<p>
This function corresponds to the menu command File | Save Layout State.
load-layout
</p>

<p>
(defmethod load-layout ((pane graph-node-pane) file) 
</p>

<p>
Loads a visual graph that was saved some time earlier with save-layout. The same store that was open when the save was done should be open when calling this function (or possibly another store that contains the same triples). Any triples in the saved state that are not found in the currently-open store will simply not be displayed.
</p>

<p>
True is returned if the load was successful, and otherwise nil is returned. A return value of nil may indicate that the file does not exist or that it is not really a gruff layout file.
</p>

<p>
pane is the graph-node-pane onto which to display the loaded visual graph.
</p>

<p>
file is the pathname or path namestring of the file from which to load the data.
</p>

<p>
This function corresponds to the menu command File | Load Layout State.
save-layout-as-pixmap
</p>

<p>
Creates a pixmap file containing an image of the currently-displayed visual graph. The pixmap will encompass all of the displayed nodes in the visual graph, even if they are scrolled out of view, adding a bit of margin around them all. On Windows a BMP file will be saved, while on Linux a PNG file will be saved.
</p>

<p>
(defun save-layout-as-pixmap (pane &amp;key path show-saved-pixmap) 
</p>

<p>
pane is the graph-node-pane that is displaying a visual graph.
</p>

<p>
path is the pathname or path namestring of the file into which to save the image. If nil or unsupplied, a dialog will ask for the path to which to save the image.
</p>

<p>
If show-saved-pixmap is true, then the saved pixmap will be displayed by another program. The other program will be either your default pixmap-viewing program or your preferred web browser, depending on the value of Global Options | Miscellaneous | Use Web Browser for All Documents.
</p>

<p>
This function corresponds to the menu command File | Save Layout As Pixmap.
uncache-for-modified-triple-store
</p>

<p>
Uncaches information as needed if the open store has been modified after displaying information from it in Gruff.
</p>

<p>
(defun uncache-for-modified-triple-store () 
</p>

<p>
If you have opened a triple-store and displayed some of its nodes and links in a visual graph, and then you have modified the store (such as by adding additional triples), then you should call this function before calling any further Gruff functions. Otherwise Gruff may use out-of-date information about the nodes and links that are in the store.
</p>

<p>
This function does not remove any of the displayed information in the Gruff interface, and so you do not need to start over building a visual graph, for example. But if any currently-displayed triples have been removed from the store, then this function will not be sufficient, and uncache-for-new-triple-store should be called instead.
uncache-for-new-triple-store
</p>

<p>
Clears everything as needed to begin displaying a different triple-store in Gruff.
</p>

<p>
(defun uncache-for-new-triple-store
  (&amp;key (node-pane (graph-node-pane (gruff-browser))))
</p>

<p>
Removes all nodes and links from the specified node pane, and clears information that has been cached about nodes and links in the current store. This is needed when creating or opening a different triple-store programmatically when the node pane is displaying objects from a previous store. This function is called automatically by the functions on the File menu of the standard browser, but otherwise needs to be called by an application that has created or opened a store in some other way after displaying information from another store.
</p>

<p>
If you have simply modified the store that's being browsed, without removing any of the currently-displayed triples, then you could instead call uncache-for-modified-triple-store to avoid clearing the currently-displayed information.
</p>

<p>
This function corresponds to the menu command File | Clear and Uncache Everything.
gruff-options-path
</p>

<p>
Returns the path of the file where your personal Gruff options are saved.
</p>

<p>
(defun gruff-options-path () 
</p>

<p>
If the standard Gruff browser window is used by calling gruff-browser rather than by creating a custom instance of the graph-node-pane class, then Gruff will save personal preferences from the various options menus of the standard browser. The options will be saved whenever the Global Options | Save All Options command is used, and also when the browser is exited. The saved options will be loaded when the standard browser is restarted.
</p>

<p>
The expression (gruff-options-path) returns the path of the file where the option values are saved. This file could be deleted to revert all default options, including ones that are not reverted by Global Options | Revert to Default Options.
<b>selected-node</b>
</p>

<p>
A global variable whose value is the UPI of the most recently selected node in the graph view, or else nil if no node has been selected yet.
</p>

<p>
This is intended as a handy way to get a programmatic handle on a resource or literal that appears in the interface. A debugging expression using this variable could be evaluated in a lisp listener of a development lisp, for example, after selecting the desired node in the graph view.
<b>selected-link</b>
</p>

<p>
A global variable whose value is the UPI of the most recently selected link in the graph view, or else nil if no node has been selected yet.
</p>

<p>
If the selected link represents multiple predicates, then one of those predicates is chosen arbitrarily and its UPI is used.
<b>suppressing-gruff-messages</b>
</p>

<p>
A global variable that determines whether messages will appear in any ancestor window of a graph-node-pane that has a status bar at the bottom of the window. The value is nil by default, and Gruff binds it to t now and then.
</p>

<p>
An application could bind this variable to a non-nil value while executing certain code where the status bar messages would be cumbersome. Or it could set the value permanently to a non-nil value to totally suppress status bar messages.
<b>gruff-version</b>
</p>

<p>
A global variable whose value is a string indicating the current version of Gruff. This value is shown in the Help | About dialog.
</p>
</div>
</div>

<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2"><span class="section-number-3">15.2</span> Lisp Functions for Modifying User Options Programmatically</h3>
<div class="outline-text-3" id="text-15-2">
<p>
The standard interactive Gruff browser has several menus for modifying a variety of user options interactively. There are also functions for reading and writing the option values programmatically. Each option is an accessor function of the graph-node-pane class.
</p>

<p>
For example, the menu option Visual Graph Options | Node and Link Spacing | Minimum Node-to-Node Spacing uses the accessor function min-node-to-node-spacing. Evaluating the form (min-node-to-node-spacing my-node-pane) will return the current value, while (setf (min-node-to-node-spacing my-node-pane) 10) would set the value to 10.
</p>

<p>
Here is a table of the various option menu commands and the accessor function that corresponds to each one. Refer to the documentation for each menu command for the meaning of the option.
</p>

<p>
View | Graph View Panes | Show Legend - show-legend (boolean)
View | Graph View Panes | Show Overview - show-overview (boolean)
Edit | Confirm Triple Deletion - confirm-triple-deletion (boolean)
Edit | Show Menus of Recent Namespaces - show-menus-of-recent-namespaces (boolean)
Edit | Percent-Decode Characters for Editing - percent-decode-characters-for-editing (boolean)
Edit | Percent-Encode Non-ASCII After Editing - percent-encode-non-ascii-after-editing (boolean)
Global Options | Status Bar Font - gruff-status-bar-font (font)
Global Options | Widget Font - gruff-widget-font (font)
Global Options | Node Label Predicates | Use Label Predicates for Node Labels - use-label-properties (boolean)
Global Options | Node Label Predicates | Label Predicate Language - label-property-language (string)
Global Options | Node Label Predicates | Custom Predicates for Node Labels - custom-predicates-for-labels-help (string)
Global Options | Node Label Predicates | Custom Predicates for Node Comments - custom-predicates-for-comments (string)
Global Options | Node Label Predicates | Custom Predicates for Node Pixmaps - custom-predicates-for-pixmaps (string)
Global Options | Derived Node and Link Labels | Exclude Namespaces from Labels - exclude-namespaces-from-labels (boolean)
Global Options | Derived Node and Link Labels | Add Spaces to Labels - add-spaces-to-labels (boolean)
Global Options | Derived Node and Link Labels | Collapse Contiguous Spaces in Labels - collapse-contiguous-spaces-in-labels (boolean)
Global Options | Derived Node and Link Labels | Capitalize First Word - capitalize-first-word (boolean)
Global Options | Derived Node and Link Labels | Convert Percent Encoding in Labels - convert-percent-hex-in-labels (boolean)
Global Options | Derived Node and Link Labels | Display subClassOf as "Superclass" | display-subclassof-as-superclass (boolean)
Global Options | Maximum Menu String Length | max-menu-item-string-length (integer)
Global Options | Show Full URIs in Pop-Up Menus | show-full-uris-in-pop-up-menus (boolean)
Global Options | Case-Sensitive Sorting for Menus | case-sensitive-sorting (boolean)
Global Options | Maximum Choices When Selecting a Subset | max-choices-when-selecting-a-subset (integer)
Global Options | General Triple-Fetching Limit - get-triples-list-limit (integer)
Global Options | Finding All Types Timeout - finding-all-types-timeout (integer)
Global Options | Finding All Predicates Timeout - finding-all-predicates-timeout (integer)
Global Options | SPARQL Endpoints | Query Results Limit - get-triples-list-limit-with-endpoints (integer)
Global Options | SPARQL Endpoints | Use Label Predicates for Node Labels - use-label-properties-with-endpoints (boolean)
Global Options | SPARQL Endpoints | Use Most Specific Type for Node Color - use-most-specific-type-for-node-color-with-endpoints (boolean)
Global Options | Communications | Use Session Ports - use-session-ports (boolean)
Global Options | Communications | HTTP Proxy for Microformat Extraction - gruff-http-proxy (list)
Global Options | Communications | Use any23.org for RDFa - use-any23-for-rdfa (boolean)
Global Options | Communications | Ignored RDFa Relationships - ignored-rdfa-relationships (list)
Global Options | Miscellaneous | Confirm Exit - confirm-exit (boolean)
Global Options | Miscellaneous | Reasoner Enables Restriction Reasoning - reasoner-enables-restriction-reasoning (boolean)
Global Options | Miscellaneous | External Format for Loading Triples - external-format-for-load-ntriples (symbol)
Global Options | Miscellaneous | Auto Font Switching on Text Entry - auto-font-switching-on-text-entry (boolean)
Global Options | Miscellaneous | Use Web Browser for All Documents - use-web-browser-for-all-documents (boolean)
Global Options | Miscellaneous | Document Base Folder - document-base-folder (string)
Query Options | Query String Font - query-string-font (font)
Query Options | Query Timeout - query-timeout (integer)
Query Options | Query Results Limit - query-results-limit (integer)
Query Options | Percent-Encode Non-ASCII in Queries - percent-encode-non-ascii-in-queries (boolean)
Query Options | Query Logging Enabled - query-logging-enabled (boolean)
Query Options | Query Logging File - query-logging-file (file)
Query Options | New Log File for Each Session - new-log-file-for-each-session (boolean)
Query Options | Query Text Report Show Full URIs - query-text-report-show-full-uris (boolean)
Query Options | Query Text Report One Line per Value - query-text-report-one-line-per-value (boolean)
Table Options | Table Property Name Font - table-property-name-font (font)
Table Options | Table Property Value Font - table-property-value-font (font)
Table Options | Show Full URIs in Tables - show-full-uris-in-tables (boolean)
Table Options | Show Multiple Property Values - show-multiple-property-values
Table Options | Show Multiple Text Lines - fit-row-height-to-text (boolean)
Table Options | Display Literals of All Languages - display-literals-of-all-languages-in-tables (boolean)
Table Options | Maximum Triples Per Predicate in Table - max-triples-per-predicate (integer)
Table Options | Maximum String Length in Table - max-string-length-in-table (integer)
Table Options | Table Color One - table-color-one (color)
Table Options | Table Color Two - table-color-two (color)
Table Options | Table Cell Vertical Padding - table-cell-vertical-padding (integer)
Outline Options | Outline Font - outline-node-font (font)
Outline Options | Show Full URIs in Outline - show-full-uris-in-outlines (boolean)
Outline Options | Create All Nodes as Blank Nodes | create-all-outline-nodes-as-blank-nodes (boolean)
Visual Graph Options | Node Labels | Node Label Font - node-font (font)
Visual Graph Options | Node Labels | Show Full URIs on Nodes - show-full-uris-on-nodes (boolean)
Visual Graph Options | Node Labels | Maximum Node Label Length - max-node-label-length (integer)
Visual Graph Options | Node Labels | Enforce Maximum Node Label Length - enforce-max-node-label-length (boolean)
Visual Graph Options | Node Labels | Absolute Maximum Node Label Length - absolute-max-node-label-length (integer)
Visual Graph Options | Link Labels | Draw Link Labels - draw-link-labels (boolean)
Visual Graph Options | Link Labels | Draw Graph Link Labels Horizontally - draw-link-labels-horizontally (boolean)
Visual Graph Options | Link Labels | Draw Query Link Labels Horizontally - draw-query-link-labels-horizontally (boolean)
Visual Graph Options | Link Labels | Use Line Color for Link Labels - use-line-color-for-link-labels (boolen)
Visual Graph Options | Link Labels | Link Label Color - link-label-color (color)
Visual Graph Options | Link Labels | Link Label Font - link-label-font (font)
Visual Graph Options | Link Labels | Draw Link Labels for Node Under Mouse (boolean)
Visual Graph Options | Link Labels | Link Label Box Color - link-label-box-color (color)
Visual Graph Options | Layout Options | Do Automatic Incremental Layouts - do-automatic-incremental-layouts (boolean)
Visual Graph Options | Layout Options | Animate Layouts - animate-layouts (boolean)
Visual Graph Options | Layout Options | Maximum Nodes for Animation - max-nodes-for-animated-layout (integer)
Visual Graph Options | Layout Options | Maximum Iterations for Full Layout - max-iterations-for-full-layout (integer)
Visual Graph Options | Layout Options | Maximum Iterations for Incremental Layout - max-iterations-for-incremental-layout (integer)
Visual Graph Options | Layout Options | Center After Full Layout - center-after-full-layout (boolean)
Visual Graph Options | Layout Options | Center After Incremental Layout - center-after-incremental-layout (boolean)
Visual Graph Options | Layout Options | Compress After Full Layout - compress-after-full-layout (boolean)
Visual Graph Options | Layout Options | Compress After Incremental Layout - compress-after-incremental-layout (boolean)
Visual Graph Options | Layout Options | Honor Layout Direction Constraints - honor-layout-direction-constraints (boolean)
Visual Graph Options | Layout Options | Specify Layout Direction for a Predicate - directional-predicates (alist)
Visual Graph Options | Layout Options | Clear Layout Direction for a Predicate - directional-predicates (alist)
Visual Graph Options | Layout Options | Canvas Resize Factor - canvas-resize-factor (real)
Visual Graph Options | Layout Options | Drag Scroll Zoom Factor - drag-scroll-zoom-factor (real)
Visual Graph Options | Spring Layout Options | Minimum Nodes for Spring Layout - min-nodes-for-spring-layout (integer)
Visual Graph Options | Spring Layout Options | Spacing Factor - spring-layout-spacing-factor (integer)
Visual Graph Options | Spring Layout Options | Velocity Divisor - spring-layout-velocity-divisor (integer)
Visual Graph Options | Spring Layout Options | Slowdown Exponent - spring-layout-slowdown-exponent (integer)
Visual Graph Options | Spring Layout Options | Keep Nodes on Canvas - spring-layout-keep-nodes-on-canvas (boolean)
Visual Graph Options | Constraint-Based Layout Options | Begin Full Layout at Random Positions | begin-with-nodes-at-random-positions (boolean)
Visual Graph Options | Inclusion Options | Remove Orphans on Node Removal - remove-orphans-on-node-removal (boolean)
Visual Graph Options | Inclusion Options | Number of Total Links for Warning - number-of-links-for-warning-2 (integer)
Visual Graph Options | Inclusion Options | Number of Total Links for Abort - number-of-links-for-abort-2 (integer)
Visual Graph Options | Inclusion Options | Number of Links from One Node for Warning - number-of-radial-links-for-warning-2 (integer)
Visual Graph Options | Inclusion Options | Show 1 Level of Nodes on Display Only Linked Nodes - levels-to-add-on-display-linked-nodes (integer)
Visual Graph Options | Inclusion Options | Show 2 Levels of Nodes on Display Only Linked Nodes - levels-to-add-on-display-linked-nodes (integer)
Visual Graph Options | Inclusion Options | Maximum Sample Triples to Display - max-triples-for-display-all-triples-2 (integer)
Visual Graph Options | Finding Paths Between Nodes | Maximum Path Length - max-path-length-for-add-paths (integer)
Visual Graph Options | Finding Paths Between Nodes | Find Only Shortest Paths - find-only-shortest-paths (boolean)
Visual Graph Options | Finding Paths Between Nodes | Path-Finding Timeout - path-finding-timeout (integer)
Visual Graph Options | Finding Paths Between Nodes | Number of Found Paths for Warning - number-of-found-paths-for-warning (integer)
Visual Graph Options | Finding Paths Between Nodes | Maximum Paths to Display - max-paths-to-display (integer)
Visual Graph Options | Finding Paths Between Nodes | Find Paths on Server - find-remote-paths-on-server (boolean)
Visual Graph Options | Finding Paths Between Nodes | Place Path End Nodes at Left and Right - path-end-node-placement (symbol)
Visual Graph Options | Finding Paths Between Nodes | Place Path End Nodes at Top and Bottom - path-end-node-placement (symbol)
Visual Graph Options | Finding Paths Between Nodes | Place Path End Nodes Anywhere - path-end-node-placement (symbol)
Visual Graph Options | Finding Paths Between Nodes | Path End Node Margin - path-end-node-margin (integer)
Visual Graph Options | Node and Link Spacing | Minimum Node-to-Node Spacing - min-node-to-node-spacing (integer)
Visual Graph Options | Node and Link Spacing | Minimum Link-to-Node Spacing - min-link-to-node-spacing (integer)
Visual Graph Options | Node and Link Spacing | Node Label Margin - label-margin (integer)
Visual Graph Options | Node and Link Spacing | Maximum Links Per Node Copy - max-links-per-node-copy (integer)
Visual Graph Options | Node and Link Spacing | Spacing Increment for Many Links - spacing-increment-for-many-links (integer)
Visual Graph Options | Node and Link Spacing | Add Spacing for Long Paths - add-spacing-for-long-paths (boolean)
Visual Graph Options | Node and Link Spacing | Long Path Spacing Increment - long-path-spacing-increment (integer)
Visual Graph Options | Node and Link Spacing | Long Path Maximum Spacing - long-path-max-spacing (integer)
Visual Graph Options | Node and Link Spacing | Limit Outward Stretching - limit-outward-stretching (boolean)
Visual Graph Options | Node and Link Spacing | Link Line Mousing Margin - link-line-mousing-margin (integer)
Visual Graph Options | Node and Link Flashing | Flash Legend Matches - flash-legend-matches (boolean)
Visual Graph Options | Node and Link Flashing | Flash End Nodes of Found Paths - flash-end-nodes-of-found-paths (boolean)
Visual Graph Options | Node and Link Flashing | Flash Newly Added Nodes - flash-newly-added-nodes (boolean)
Visual Graph Options | Node and Link Flashing | Flash Selected Search Matches - flash-selected-search-matches (booelan)
Visual Graph Options | Node and Link Flashing | Times to Flash - times-to-flash (integer or nil)
Visual Graph Options | Node and Link Flashing | Flashing Time Interval - flashing-interval (integer)
Visual Graph Options | Node and Link Flashing | Flashing Node Color Delta - flashing-node-color-difference (integer)
Visual Graph Options | Tooltips | Show Node Tooltips - show-node-tooltips (boolean)
Visual Graph Options | Tooltips | Show Link Tooltips - show-link-tooltips (boolean)
Visual Graph Options | Tooltips | Tooltip Font - node-and-link-tooltip-font (font)
Visual Graph Options | Tooltips | Tooltip Background Color - node-and-link-tooltip-background-color (color)
Visual Graph Options | Tooltips | Node Tooltips Delay - node-tooltip-delay (integer)
Visual Graph Options | Tooltips | Link Tooltips Delay - link-tooltip-delay (integer)
Visual Graph Options | Antialiasing | Antialias Lines - antialias-lines (boolen)
Visual Graph Options | Antialiasing | Antialias Text - antialias-text (boolen)
Visual Graph Options | Antialiasing | Suppress Antialiasing During Animation - suppress-antialiasing-during-animation (boolen)
Visual Graph Options | Arrowheads | Arrowhead Length - default-arrowhead-length (integer)
Visual Graph Options | Arrowheads | Arrowhead Width - default-arrowhead-width (integer)
Visual Graph Options | Color Gradients | Show Node Color Gradients - show-node-color-gradients (boolean)
Visual Graph Options | Color Gradients | Color Gradient Intensity - color-gradient-intensity (integer)
Visual Graph Options | Color Gradients | Suppress Color Gradients During Animation - suppress-color-gradients-during-animation (boolean)
Visual Graph Options | Color Nodes for Node Type - node-color-scheme (symbol)
Visual Graph Options | Color Nodes for Unseen Links - node-color-scheme (symbol)
Visual Graph Options | Node and Link Color for Types | Use Most Specific Type for Node Color - use-most-specific-type-for-node-color (boolean)
Visual Graph Options | Node and Link Color for Types | Specify Color for Selected Node's Type - node-colors-for-types (alist)
Visual Graph Options | Node and Link Color for Types | Remove Color Mapping for Selected Node's Type - node-colors-for-types (alist)
Visual Graph Options | Node and Link Color for Types | Specify Color for Selected Link's Predicate - line-styles-for-predicates (alist)
Visual Graph Options | Node and Link Color for Types | Specify Line Width for Selected Link's Predicate - line-styles-for-predicates (alist)
Visual Graph Options | Node and Link Color for Types | Specify Dashing for Selected Link's Predicate - line-styles-for-predicates (alist)
Visual Graph Options | Node and Link Color for Types | Suppress Link Link Styles - suppress-link-line-styles (boolean)
Visual Graph Options | Node Color for Unseen Links | Node Color for Unseen Current Links - node-color-for-unseen-current-links (color)
Visual Graph Options | Node Color for Unseen Links | Node Color for Unseen Non-Current Links - node-color-for-unseen-noncurrent-links (color)
Visual Graph Options | Node Color for Unseen Links | Node Color for No Unseen Links - node-color-for-no-unseen-links (color)
Visual Graph Options | Window Background | Graph View Background Color - color-for-window-background (color)
Visual Graph Options | Window Background | Legend Background Color - color-for-legend-background (color)
Visual Graph Options | Window Background | Background Pixmap - background-pixmap-source (file)
Visual Graph Options | Window Background | Show Background Pixmap (if any) - show-background-pixmap (boolean)
Visual Graph Options | Window Background | Stretch Background Pixmap - stretch-background-pixmap (boolean)
Visual Graph Options | Window Background | Graphical Query View Background Color - color-for-graphical-query-background (color)
Visual Graph Options | Node Border Color - node-border-color (color)
Help | Use Web Browser for Menu Help - use-web-browser-for-menu-help (boolean)
Help | Show Warnings in Dialogs - show-warnings-in-dialog (boolean)
Help | Show Quick Start on Startup - show-quick-start-on-startup (boolean)
</p>
</div>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> grammar: a set of production rules for strings</h2>
<div class="outline-text-2" id="text-16">
</div><div id="outline-container-sec-16-1" class="outline-3">
<h3 id="sec-16-1"><span class="section-number-3">16.1</span> formal grammar</h3>
<div class="outline-text-3" id="text-16-1">
<p>
Location: <a href="file:///home/xk05/.mozilla/firefox/8pk8p0lx.default/ScrapBook/data/20140128153927/index.html">file:///home/xk05/.mozilla/firefox/8pk8p0lx.default/ScrapBook/data/20140128153927/index.html</a>
</p>

<p>
Formal grammar
</p>

<p>
From Wikipedia, the free encyclopedia
Jump to: navigation, search
</p>

<p>
In formal language theory, a grammar (when the context is not given, often called
a formal grammar for clarity) is a set of production rules for strings in a formal
language. The rules describe how to form strings from the language's alphabet that
are valid according to the language's syntax. A grammar does not describe the 
meaning of the strings or what can be done with them in whatever contextonly
their form.
</p>

<p>
Formal language theory, the discipline which studies formal grammars and
languages, is a branch of applied mathematics. Its applications are found in 
theoretical computer science, theoretical linguistics, formal semantics, 
mathematical logic, and other areas.
</p>

<p>
A formal grammar is a set of rules for rewriting strings, along with a "start
symbol" from which rewriting starts. Therefore, a grammar is usually thought of as
a language generator. However, it can also sometimes be used as the basis for a "
recognizer"a function in computing that determines whether a given string belongs
to the language or is grammatically incorrect. To describe such recognizers,
formal language theory uses separate formalisms, known as automata theory. One of
the interesting results of automata theory is that it is not possible to design a
recognizer for certain formal languages.
</p>

<p>
Parsing is the process of recognizing an utterance (a string in natural languages)
by breaking it down to a set of symbols and analyzing each one against the grammar
of the language. Most languages have the meanings of their utterances structured
according to their syntaxa practice known as compositional semantics. As a
result, the first step to describing the meaning of an utterance in language is to
break it down part by part and look at its analyzed form (known as its parse tree
in computer science, and as its deep structure in generative grammar).
</p>
</div>

<div id="outline-container-sec-16-1-1" class="outline-4">
<h4 id="sec-16-1-1"><span class="section-number-4">16.1.1</span> Contents</h4>
<div class="outline-text-4" id="text-16-1-1">
<p>
[hide] 
</p>

<ul class="org-ul">
<li>1 Introductory example
</li>
<li>2 Formal definition
<ul class="org-ul">
<li>2.1 The syntax of grammars
</li>
<li>2.2 The semantics of grammars
</li>
<li>2.3 Example
</li>
</ul>
</li>
<li>3 The Chomsky hierarchy
<ul class="org-ul">
<li>3.1 Context-free grammars
</li>
<li>3.2 Regular grammars
</li>
<li>3.3 Other forms of generative grammars
</li>
<li>3.4 Recursive grammars
</li>
</ul>
</li>
<li>4 Analytic grammars
</li>
<li>5 See also
</li>
<li>6 References
</li>
<li>7 External links
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-16-1-2" class="outline-4">
<h4 id="sec-16-1-2"><span class="section-number-4">16.1.2</span> Introductory example[edit]</h4>
<div class="outline-text-4" id="text-16-1-2">
<p>
A grammar mainly consists of a set of rules for transforming strings. (If it only
consisted of these rules, it would be a semi-Thue system.) To generate a string in
the language, one begins with a string consisting of only a single start symbol.
The production rules are then applied in any order, until a string that contains
neither the start symbol nor designated nonterminal symbols is produced. A
production rule is applied to a string by replacing one occurrence of its
left-hand side in the string by its right-hand side (cf. the operation of the
theoretical Turing machine). The language formed by the grammar consists of all
distinct strings that can be generated in this manner. Any particular sequence of
production rules on the start symbol yields a distinct string in the language. If
there are multiple ways of generating the same single string, the grammar is said
to be ambiguous.
</p>

<p>
For example, assume the alphabet consists of a and b, the start symbol is S, and
we have the following production rules:
</p>

<ol class="org-ol">
<li>S \right
</li>
<li>S \right
</li>
</ol>

<p>
then we start with S, and can choose a rule to apply to it. If we choose rule 1,
we obtain the string aSb. If we then choose rule 1 again, we replace S with aSb
and obtain the string aaSbb. If we now choose rule 2, we replace S with ba and
obtain the string aababb, and are done. We can write this series of choices more
briefly, using symbols: S \Right. The language of the grammar is then the infinite
set \{a<sup>nbab</sup>, where a<sup>k</sup>      is a        repeated k        times (and n        in
particular represents the number of times production rule 1 has been applied).
</p>
</div>
</div>

<div id="outline-container-sec-16-1-3" class="outline-4">
<h4 id="sec-16-1-3"><span class="section-number-4">16.1.3</span> Formal definition[edit]</h4>
<div class="outline-text-4" id="text-16-1-3">
</div><ol class="org-ol"><li>The syntax of grammars[edit]<br  /><div class="outline-text-5" id="text-16-1-3-1">
<p>
In the classic formalization of generative grammars first proposed by Noam Chomsky
in the 1950s,<sup><sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup></sup><sup><sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup></sup> a grammar G consists of the following components:
</p>

<ul class="org-ul">
<li>A finite set N of nonterminal symbols, that is disjoint with the strings
formed from G.
</li>
<li>A finite set &Sigma;   of terminal symbols that is disjoint from N.
</li>
<li>A finite set P of production rules, each rule of the form

<p>
(&Sigma; 
</p>

<p>
where {*}      is the Kleene star operator and &cup;     denotes set union.
That is, each production rule maps from one string of symbols to another,
where the first string (the "head") contains an arbitrary number of symbols
provided at least one of them is a nonterminal. In the case that the second
string (the "body") consists solely of the empty string  i.e., that it
contains no symbols at all  it may be denoted with a special notation (often
&Lambda; , e or &epsilon;) in order to avoid confusion.
</p>
</li>

<li>A distinguished symbol S &isin; N  that is the start symbol.
</li>
</ul>

<p>
A grammar is formally defined as the tuple (N, \Sig. Such a formal grammar is
often called a rewriting system or a phrase structure grammar in the literature.<sup>[</sup>
3]<sup><sup><a id="fnr.4.100" name="fnr.4.100" class="footref" href="#fn.4">4</a></sup></sup>
</p>
</div>
</li>

<li>The semantics of grammars[edit]<br  /><div class="outline-text-5" id="text-16-1-3-2">
<p>
The operation of a grammar can be defined in terms of relations on strings:
</p>

<ul class="org-ul">
<li>Given a grammar G = (N, , the binary relation \Rightar (pronounced as "G
derives in one step") on strings in (&Sigma;  is defined by:
</li>
</ul>

<p>
x \Right
</p>

<ul class="org-ul">
<li>the relation {\Righta (pronounced as G derives in zero or more steps) is
defined as the reflexive transitive closure of \Rightar
</li>
<li>a sentential form is a member of (&Sigma;  that can be derived in a finite
number of steps from the start symbol S       ; that is, a sentential form is
a member of \{ w &isin;. A sentential form that contains no nonterminal symbols
(i.e. is a member of &Sigma;<sup>*</sup>) is called a sentence.<sup><sup><a id="fnr.7.100" name="fnr.7.100" class="footref" href="#fn.7">7</a></sup></sup>
</li>
<li>the language of G       , denoted as \boldsym, is defined as all those
sentences that can be derived in a finite number of steps from the start
symbol S       ; that is, the set \{ w &isin;.
</li>
</ul>

<p>
Note that the grammar G = (N,  is effectively the semi-Thue system (N &cup; ,
rewriting strings in exactly the same way; the only difference is in that we
distinguish specific nonterminal symbols which must be rewritten in rewrite rules,
and are only interested in rewritings from the designated start symbol S        to
strings without nonterminal symbols.
</p>
</div>
</li>

<li>Example[edit]<br  /><div class="outline-text-5" id="text-16-1-3-3">
<p>
For these examples, formal languages are specified using set-builder notation.
</p>

<p>
Consider the grammar G        where N = \lef, &Sigma; =, S        is the start
symbol, and P        consists of the following production rules:
</p>

<ol class="org-ol">
<li>S \right
</li>
<li>S \right
</li>
<li>Ba \righ
</li>
<li>Bb \righ
</li>
</ol>

<p>
This grammar defines the language L(G) = \ where a<sup>n</sup>    denotes a string of n
consecutive a       's. Thus, the language is the set of strings that consist of 1
or more a       's, followed by the same number of b       's, followed by the
same number of c       's.
</p>

<p>
Some examples of the derivation of strings in L(G)     are:
</p>

<ul class="org-ul">
<li>\boldsym
</li>
<li>\boldsym
</li>
<li>\boldsym \Righta

<p>
(Note on notation: P \Right reads "String P generates string Q by means of
production i", and the generated part is each time indicated in bold type.)
</p>
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-16-1-4" class="outline-4">
<h4 id="sec-16-1-4"><span class="section-number-4">16.1.4</span> The Chomsky hierarchy[edit]</h4>
<div class="outline-text-4" id="text-16-1-4">
<p>
Main article: Chomsky hierarchy
</p>

<p>
When Noam Chomsky first formalized generative grammars in 1956,<sup><sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup></sup> he classified
them into types now known as the Chomsky hierarchy. The difference between these
types is that they have increasingly strict production rules and can express fewer
formal languages. Two important types are context-free grammars (Type 2) and 
regular grammars (Type 3). The languages that can be described with such a grammar
are called context-free languages and regular languages, respectively. Although
much less powerful than unrestricted grammars (Type 0), which can in fact express
any language that can be accepted by a Turing machine, these two restricted types
of grammars are most often used because parsers for them can be efficiently
implemented.<sup><sup><a id="fnr.8.100" name="fnr.8.100" class="footref" href="#fn.8">8</a></sup></sup> For example, all regular languages can be recognized by a finite
state machine, and for useful subsets of context-free grammars there are
well-known algorithms to generate efficient LL parsers and LR parsers to recognize
the corresponding languages those grammars generate.
</p>
</div>

<ol class="org-ol"><li>Context-free grammars[edit]<br  /><div class="outline-text-5" id="text-16-1-4-1">
<p>
A context-free grammar is a grammar in which the left-hand side of each production
rule consists of only a single nonterminal symbol. This restriction is
non-trivial; not all languages can be generated by context-free grammars. Those
that can are called context-free languages.
</p>

<p>
The language L(G) = \ defined above is not a context-free language, and this can
be strictly proven using the pumping lemma for context-free languages, but for
example the language \left \{ (at least 1 a        followed by the same number of
b       's) is context-free, as it can be defined by the grammar G<sub>2</sub>      with
N=\left , &Sigma;=\, S        the start symbol, and the following production rules:
</p>

<ol class="org-ol">
<li>S \right
</li>
<li>S \right
</li>
</ol>

<p>
A context-free language can be recognized in O(n<sup>3</sup>)   time (see Big O notation) by
an algorithm such as Earley's algorithm. That is, for every context-free language,
a machine can be built that takes a string as input and determines in O(n<sup>3</sup>)  
time whether the string is a member of the language, where n        is the length
of the string.<sup><sup><a id="fnr.9.100" name="fnr.9.100" class="footref" href="#fn.9">9</a></sup></sup> Deterministic context-free languages is a subset of
context-free languages that can be recognized in linear time.<sup><sup><a id="fnr.10.100" name="fnr.10.100" class="footref" href="#fn.10">10</a></sup></sup> There exist
various algorithms that target either this set of languages or some subset of it.
</p>
</div>
</li>

<li>Regular grammars[edit]<br  /><div class="outline-text-5" id="text-16-1-4-2">
<p>
In regular grammars, the left hand side is again only a single nonterminal symbol,
but now the right-hand side is also restricted. The right side may be the empty
string, or a single terminal symbol, or a single terminal symbol followed by a
nonterminal symbol, but nothing else. (Sometimes a broader definition is used: one
can allow longer strings of terminals or single nonterminals without anything
else, making languages easier to denote while still defining the same class of
languages.)
</p>

<p>
The language \left \{ defined above is not regular, but the language \left \{ (at
least 1 a        followed by at least 1 b       , where the numbers may be
different) is, as it can be defined by the grammar G<sub>3</sub>      with N=\left ,
&Sigma;=\, S        the start symbol, and the following production rules:
</p>

<ol class="org-ol">
<li>S \right
</li>
<li>A \right
</li>
<li>A \right
</li>
<li>B \right
</li>
<li>B \right
</li>
</ol>

<p>
All languages generated by a regular grammar can be recognized in linear time by a
finite state machine. Although, in practice, regular grammars are commonly
expressed using regular expressions, some forms of regular expression used in
practice do not strictly generate the regular languages and do not show linear
recognitional performance due to those deviations.
</p>
</div>
</li>

<li>Other forms of generative grammars[edit]<br  /><div class="outline-text-5" id="text-16-1-4-3">
<p>
Many extensions and variations on Chomsky's original hierarchy of formal grammars
have been developed, both by linguists and by computer scientists, usually either
in order to increase their expressive power or in order to make them easier to
analyze or parse. Some forms of grammars developed include:
</p>
</div>
</li>

<li>Tree-adjoining grammars<br  /><div class="outline-text-5" id="text-16-1-4-4">
<p>
increase the expressiveness of conventional generative grammars by
allowing rewrite rules to operate on parse trees instead of just
strings.<sup><sup><a id="fnr.12" name="fnr.12" class="footref" href="#fn.12">12</a></sup></sup>
</p>
</div>
</li>
<li>Affix grammars<sup><sup><a id="fnr.5.100" name="fnr.5.100" class="footref" href="#fn.5">5</a></sup></sup> and attribute grammars<sup><sup><a id="fnr.13" name="fnr.13" class="footref" href="#fn.13">13</a></sup></sup><sup><sup><a id="fnr.14" name="fnr.14" class="footref" href="#fn.14">14</a></sup></sup><br  /><div class="outline-text-5" id="text-16-1-4-5">
<p>
allow rewrite rules to be augmented with semantic attributes and
operations, useful both for increasing grammar expressiveness and
for constructing practical language translation tools.
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-16-1-5" class="outline-4">
<h4 id="sec-16-1-5"><span class="section-number-4">16.1.5</span> Recursive grammars[edit]</h4>
<div class="outline-text-4" id="text-16-1-5">
<p>
Not to be confused with Recursive language.
</p>

<div class="org-src-container">

<pre class="src src-n3"><span style="color: #98fb98;">:</span><span style="color: #7fffd4;">recursive-grammar</span> <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">disjointWith</span> <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">recursive-language</span> .
</pre>
</div>

<p>
A recursive grammar is a grammar which contains production rules that are 
recursive. For example, a grammar for a context-free language is left-recursive if
there exists a non-terminal symbol A that can be put through the production rules
to produce a string with A as the leftmost symbol.<sup><sup><a id="fnr.15" name="fnr.15" class="footref" href="#fn.15">15</a></sup></sup> All types of grammars in
the Chomsky hierarchy can be recursive.
</p>
</div>
</div>

<div id="outline-container-sec-16-1-6" class="outline-4">
<h4 id="sec-16-1-6"><span class="section-number-4">16.1.6</span> Analytic grammars[edit]</h4>
<div class="outline-text-4" id="text-16-1-6">
<p>
Though there is a tremendous body of literature on parsing algorithms, most of
these algorithms assume that the language to be parsed is initially described by
means of a generative formal grammar, and that the goal is to transform this
generative grammar into a working parser. Strictly speaking, a generative grammar
does not in any way correspond to the algorithm used to parse a language, and
various algorithms have different restrictions on the form of production rules
that are considered well-formed.
</p>

<p>
An alternative approach is to formalize the language in terms of an analytic
grammar in the first place, which more directly corresponds to the structure and
semantics of a parser for the language. Examples of analytic grammar formalisms
include the following:
</p>

<ul class="org-ul">
<li>The Language Machine directly implements unrestricted analytic grammars.
Substitution rules are used to transform an input to produce outputs and
behaviour. The system can also produce the lm-diagram which shows what happens
when the rules of an unrestricted analytic grammar are being applied.
</li>
<li>Top-down parsing language (TDPL): a highly minimalist analytic grammar
formalism developed in the early 1970s to study the behavior of top-down
parsers.<sup><sup><a id="fnr.16" name="fnr.16" class="footref" href="#fn.16">16</a></sup></sup>
</li>
<li>Link grammars: a form of analytic grammar designed for linguistics, which
derives syntactic structure by examining the positional relationships between
pairs of words.<sup><sup><a id="fnr.17" name="fnr.17" class="footref" href="#fn.17">17</a></sup></sup><sup><sup><a id="fnr.6.100" name="fnr.6.100" class="footref" href="#fn.6">6</a></sup></sup>
</li>
<li>Parsing expression grammars (PEGs): a more recent generalization of TDPL
designed around the practical expressiveness needs of programming language and
compiler writers.<sup><sup><a id="fnr.18" name="fnr.18" class="footref" href="#fn.18">18</a></sup></sup>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-n3"><span style="color: #98fb98;">:</span><span style="color: #7fffd4;">formal-grammar</span> <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">seeAlso</span> <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Abstract-syntax-tree</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Adaptive-grammar</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Ambiguous-grammar</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Backus&#8211;Naur-form</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Categorial-grammar</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Concrete-syntax-tree</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Extended-Backus&#8211;Naur-form</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Augmented-Backus-Naur-form</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Grammar-framework</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">L-system</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Lojban</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Post-canonical-system</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Shape-grammar</span> ,
  <span style="color: #98fb98;">:</span><span style="color: #7fffd4;">Well-formed-formula</span> .
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-16-1-7" class="outline-4">
<h4 id="sec-16-1-7"><span class="section-number-4">16.1.7</span> References[edit]</h4>
<div class="outline-text-4" id="text-16-1-7">
<ol class="org-ol">
<li>^ Jump up to: ^a ^b Chomsky, Noam (1956). "Three Models for the Description of
Language". IRE Transactions on Information Theory 2 (2): 113123. <a href="10.1109/">10.1109/</a>
TIT.1956.1056813. 
</li>
<li>Jump up ^ Chomsky, Noam (1957). Syntactic Structures. The Hague: Mouton. 
</li>
<li>Jump up ^ Ginsburg, Seymour (1975). Algebraic and automata theoretic
properties of formal languages. North-Holland. pp. 89. ISBN 0-7204-2506-9. 
</li>
<li>Jump up ^ Harrison, Michael A. (1978). Introduction to Formal Language Theory.
Reading, Mass.: Addison-Wesley Publishing Company. p. 13. ISBN 0-201-02955-3. 
</li>
<li>Jump up ^ Sentential Forms, Context-Free Grammars, David Matuszek
</li>
<li>Jump up ^ Grune, Dick &amp; Jacobs, Ceriel H., Parsing Techniques  A Practical
Guide, Ellis Horwood, England, 1990.
</li>
<li>Jump up ^ Earley, Jay, "An Efficient Context-Free Parsing Algorithm," 
Communications of the ACM, Vol. 13 No. 2, pp. 94-102, February 1970.
</li>
<li>Jump up ^ Knuth, D. E. (July 1965). "On the translation of languages from left
to right". Information and Control 8 (6): 607639. <a href="10.1016/S0019-9958(65)">10.1016/S0019-9958(65)</a>
90426-2. Retrieved 29 May 2011.  edit
</li>
<li>Jump up ^ Joshi, Aravind K., et al., "Tree Adjunct Grammars," Journal of
Computer Systems Science, Vol. 10 No. 1, pp. 136-163, 1975.
</li>
<li>Jump up ^ Koster , Cornelis H. A., "Affix Grammars," in ALGOL 68
Implementation, North Holland Publishing Company, Amsterdam, p. 95-109, 1971.
</li>
<li>Jump up ^ Knuth, Donald E., "Semantics of Context-Free Languages," 
Mathematical Systems Theory, Vol. 2 No. 2, pp. 127-145, 1968.
</li>
<li>Jump up ^ Knuth, Donald E., "Semantics of Context-Free Languages
(correction)," Mathematical Systems Theory, Vol. 5 No. 1, pp 95-96, 1971.
</li>
<li>Jump up ^ Notes on Formal Language Theory and Parsing, James Power, Department
of Computer Science National University of Ireland, Maynooth Maynooth, Co.
Kildare, Ireland.JPR02
</li>
<li>Jump up ^ Birman, Alexander, The TMG Recognition Schema, Doctoral thesis,
Princeton University, Dept. of Electrical Engineering, February 1970.
</li>
<li>Jump up ^ Sleator, Daniel D. &amp; Temperly, Davy, "Parsing English with a Link
Grammar," Technical Report CMU-CS-91-196, Carnegie Mellon University Computer
Science, 1991.
</li>
<li>Jump up ^ Sleator, Daniel D. &amp; Temperly, Davy, "Parsing English with a Link
Grammar," Third International Workshop on Parsing Technologies, 1993. (Revised
version of above report.)
</li>
<li>Jump up ^ Ford, Bryan, Packrat Parsing: a Practical Linear-Time Algorithm with
Backtracking, Masters thesis, Massachusetts Institute of Technology, Sept.
<ol class="org-ol">
<li></li>
</ol>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-16-2" class="outline-3">
<h3 id="sec-16-2"><span class="section-number-3">16.2</span> Automata theory: formal languages and formal grammars</h3>
<div class="outline-text-3" id="text-16-2">
</div><div id="outline-container-sec-16-2-1" class="outline-4">
<h4 id="sec-16-2-1"><span class="section-number-4">16.2.1</span> Chomsky hierarchy table</h4>
<div class="outline-text-4" id="text-16-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">Chomsky</td>
<td class="left">Grammars</td>
<td class="left">Languages</td>
<td class="left">Minimal automaton</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">* Unrestricted</td>
<td class="left">* Recursively</td>
<td class="left">* Turing machine</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">* (no common name)</td>
<td class="left">enumerable</td>
<td class="left">* Decider</td>
</tr>

<tr>
<td class="left">* Type-0</td>
<td class="left">* Context-sensitive</td>
<td class="left">* Decidable</td>
<td class="left">* Linear-bounded</td>
</tr>

<tr>
<td class="left">* </td>
<td class="left">* Indexed</td>
<td class="left">* Context-sensitive</td>
<td class="left">* Nested stack</td>
</tr>

<tr>
<td class="left">* Type-1</td>
<td class="left">* Linear context-free</td>
<td class="left">* Indexed</td>
<td class="left">* Thread automaton</td>
</tr>

<tr>
<td class="left">* </td>
<td class="left">rewriting systems</td>
<td class="left">* Mildly</td>
<td class="left">* Embedded pushdown</td>
</tr>

<tr>
<td class="left">* </td>
<td class="left">etc.</td>
<td class="left">context-sensitive</td>
<td class="left">* Nondeterministic</td>
</tr>

<tr>
<td class="left">* </td>
<td class="left">* Tree-adjoining etc.</td>
<td class="left">* Tree-adjoining</td>
<td class="left">pushdown</td>
</tr>

<tr>
<td class="left">* Type-2</td>
<td class="left">* Context-free</td>
<td class="left">* Context-free</td>
<td class="left">* Deterministic</td>
</tr>

<tr>
<td class="left">* </td>
<td class="left">* Deterministic</td>
<td class="left">* Deterministic</td>
<td class="left">pushdown</td>
</tr>

<tr>
<td class="left">* </td>
<td class="left">context-free</td>
<td class="left">context-free</td>
<td class="left">* Visibly pushdown</td>
</tr>

<tr>
<td class="left">* Type-3</td>
<td class="left">* Visibly pushdown</td>
<td class="left">* Visibly pushdown</td>
<td class="left">* Finite</td>
</tr>

<tr>
<td class="left">* </td>
<td class="left">* Regular</td>
<td class="left">* Regular</td>
<td class="left">* Counter-free (with</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">* </td>
<td class="left">* Star-free</td>
<td class="left">aperiodic finite monoid)</td>
</tr>
</tbody>
</table>

<p>
Each category of languages is a proper subset of the category directly above it.   
Any automaton and any grammar in each category has an equivalent automaton or      
grammar in the category directly above it.                                         
</p>

<p>
Retrieved from "
<a href="http://en.wikipedia.org/w/index.php?title=Formal_grammar&oldid=581347229">http://en.wikipedia.org/w/index.php?title=Formal_grammar&oldid=581347229</a>"
</p>
</div>
</div>
</div>

<div id="outline-container-sec-16-3" class="outline-3">
<h3 id="sec-16-3"><span class="section-number-3">16.3</span> Wikipedia Stuff</h3>
<div class="outline-text-3" id="text-16-3">
</div><div id="outline-container-sec-16-3-1" class="outline-4">
<h4 id="sec-16-3-1"><span class="section-number-4">16.3.1</span> Categories:</h4>
<div class="outline-text-4" id="text-16-3-1">
<ul class="org-ul">
<li>Formal languages
</li>
<li>Grammar
</li>
<li>Linguistics
</li>
<li>Mathematical logic
</li>
<li>Syntax
</li>
<li>Automata theory
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-3-2" class="outline-4">
<h4 id="sec-16-3-2"><span class="section-number-4">16.3.2</span> Navigation menu</h4>
</div>
<div id="outline-container-sec-16-3-3" class="outline-4">
<h4 id="sec-16-3-3"><span class="section-number-4">16.3.3</span> Personal tools</h4>
<div class="outline-text-4" id="text-16-3-3">
<ul class="org-ul">
<li>Create account
</li>
<li>Log in
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-16-3-4" class="outline-4">
<h4 id="sec-16-3-4"><span class="section-number-4">16.3.4</span> Namespaces</h4>
<div class="outline-text-4" id="text-16-3-4">
<ul class="org-ul">
<li>Article
</li>
<li>Talk
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-3-5" class="outline-4">
<h4 id="sec-16-3-5"><span class="section-number-4">16.3.5</span> Variants</h4>
</div>
<div id="outline-container-sec-16-3-6" class="outline-4">
<h4 id="sec-16-3-6"><span class="section-number-4">16.3.6</span> Views</h4>
<div class="outline-text-4" id="text-16-3-6">
<ul class="org-ul">
<li>Read
</li>
<li>Edit
</li>
<li>View history
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-16-3-7" class="outline-4">
<h4 id="sec-16-3-7"><span class="section-number-4">16.3.7</span> Actions</h4>
</div>
<div id="outline-container-sec-16-3-8" class="outline-4">
<h4 id="sec-16-3-8"><span class="section-number-4">16.3.8</span> Search</h4>
<div class="outline-text-4" id="text-16-3-8">
<p>
[                    ] S 
</p>
</div>
</div>

<div id="outline-container-sec-16-3-9" class="outline-4">
<h4 id="sec-16-3-9"><span class="section-number-4">16.3.9</span> Navigation</h4>
<div class="outline-text-4" id="text-16-3-9">
<ul class="org-ul">
<li>Main page
</li>
<li>Contents
</li>
<li>Featured content
</li>
<li>Current events
</li>
<li>Random article
</li>
<li>Donate to Wikipedia
</li>
<li>Wikimedia Shop
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-16-3-10" class="outline-4">
<h4 id="sec-16-3-10"><span class="section-number-4">16.3.10</span> Interaction</h4>
<div class="outline-text-4" id="text-16-3-10">
<ul class="org-ul">
<li>Help
</li>
<li>About Wikipedia
</li>
<li>Community portal
</li>
<li>Recent changes
</li>
<li>Contact page
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-16-3-11" class="outline-4">
<h4 id="sec-16-3-11"><span class="section-number-4">16.3.11</span> Tools</h4>
<div class="outline-text-4" id="text-16-3-11">
<ul class="org-ul">
<li>What links here
</li>
<li>Related changes
</li>
<li>Upload file
</li>
<li>Special pages
</li>
<li>Permanent link
</li>
<li>Page information
</li>
<li>Data item
</li>
<li>Cite this page
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-16-3-12" class="outline-4">
<h4 id="sec-16-3-12"><span class="section-number-4">16.3.12</span> Print/export</h4>
<div class="outline-text-4" id="text-16-3-12">
<ul class="org-ul">
<li>Create a book
</li>
<li>Download as PDF
</li>
<li>Printable version
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-16-3-13" class="outline-4">
<h4 id="sec-16-3-13"><span class="section-number-4">16.3.13</span> Languages</h4>
<div class="outline-text-4" id="text-16-3-13">
<ul class="org-ul">
<li>Bosanski
</li>
<li>Catal
</li>
<li>etina
</li>
<li>Deutsch
</li>
<li>Eesti
</li>
<li>
</li>
<li>Espaol
</li>
<li>Esperanto
</li>
<li>
</li>
<li>Franais
</li>
<li>Galego
</li>
<li>
</li>
<li>Hrvatski
</li>
<li>Italiano
</li>
<li>Magyar
</li>
<li>Nederlands
</li>
<li>
</li>
<li>Norsk bokml
</li>
<li>Polski
</li>
<li>Portugus
</li>
<li>
</li>
<li>Slovenina
</li>
<li> / srpski
</li>
<li>Srpskohrvatski / 
</li>
<li>Suomi
</li>
<li>Svenska
</li>
<li>
</li>
<li>
</li>
<li>Edit links
</li>

<li>This page was last modified on 12 November 2013 at 16:05.
</li>
<li>Text is available under the Creative Commons Attribution-ShareAlike License;
additional terms may apply. By using this site, you agree to the Terms of Use
and Privacy Policy.
Wikipedia is a registered trademark of the Wikimedia Foundation, Inc., a
non-profit organization.
</li>

<li>Privacy policy
</li>
<li>About Wikipedia
</li>
<li>Disclaimers
</li>
<li>Contact Wikipedia
</li>
<li>Developers
</li>
<li>Mobile view
</li>

<li>Wikimed
</li>
<li>Powered
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> ebnf2ps</h2>
<div class="outline-text-2" id="text-17">
<p>
`ebnf'        ebnf2ps recognizes the syntax described in ebnf2ps
             documentation.
             The following variables <b>ONLY</b> have effect with this
             setting:
             `ebnf-terminal-regexp', `ebnf-case-fold-search',
             `ebnf-lex-comment-char' and `ebnf-lex-eop-char'.
</p>

<p>
`abnf'        ebnf2ps recognizes the syntax described in the URL:
             `<a href="http://www.ietf.org/rfc/rfc2234.txt">http://www.ietf.org/rfc/rfc2234.txt</a>'
             ("Augmented BNF for Syntax Specifications: ABNF").
</p>

<p>
`iso-ebnf'        ebnf2ps recognizes the syntax described in the URL:
             `<a href="http://www.cl.cam.ac.uk/~mgk25/iso-ebnf.html">http://www.cl.cam.ac.uk/~mgk25/iso-ebnf.html</a>'
             ("International Standard of the ISO EBNF Notation").
             The following variables <b>ONLY</b> have effect with this
             setting:
             `ebnf-iso-alternative-p' and `ebnf-iso-normalize-p'.
</p>

<p>
`yacc'        ebnf2ps recognizes the Yacc/Bison syntax.
             The following variable <b>ONLY</b> has effect with this
             setting:
             `ebnf-yac-ignore-error-recovery'.
</p>

<p>
`ebnfx'        ebnf2ps recognizes the syntax described in the URL:
             `<a href="http://www.w3.org/TR/2004/REC-xml-20040204/#sec-notation">http://www.w3.org/TR/2004/REC-xml-20040204/#sec-notation</a>'
             ("Extensible Markup Language (XML) 1.0 (Third Edition)")
</p>

<p>
`dtd'        ebnf2ps recognizes the syntax described in the URL:
             `<a href="http://www.w3.org/TR/2004/REC-xml-20040204/">http://www.w3.org/TR/2004/REC-xml-20040204/</a>'
             ("Extensible Markup Language (XML) 1.0 (Third Edition)")
</p>

<p>
Any other value is treated as `ebnf'.
</p>
</div>
</div>

<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> xml spec 1.0</h2>
<div class="outline-text-2" id="text-18">
<p>
W3C
Extensible Markup Language (XML) 1.0 (Fifth Edition)
W3C Recommendation 26 November 2008
</p>

<p>
This version:
    <a href="http://www.w3.org/TR/2008/REC-xml-20081126/">http://www.w3.org/TR/2008/REC-xml-20081126/</a> 
Latest version:
    <a href="http://www.w3.org/TR/xml/">http://www.w3.org/TR/xml/</a> 
Previous versions:
    <a href="http://www.w3.org/TR/2008/PER-xml-20080205/">http://www.w3.org/TR/2008/PER-xml-20080205/</a>
    <a href="http://www.w3.org/TR/2006/REC-xml-20060816/">http://www.w3.org/TR/2006/REC-xml-20060816/</a> 
Editors:
    Tim Bray, Textuality and Netscape &lt;tbray@textuality.com&gt;
    Jean Paoli, Microsoft &lt;jeanpa@microsoft.com&gt;
    C. M. Sperberg-McQueen, W3C &lt;cmsmcq@w3.org&gt;
    Eve Maler, Sun Microsystems, Inc. &lt;eve.maler@east.sun.com&gt;
    Franois Yergeau
</p>

<p>
Please refer to the errata for this document, which may include some normative corrections.
</p>

<p>
The previous errata for this document, are also available.
</p>

<p>
See also translations.
</p>

<p>
This document is also available in these non-normative formats: XML and XHTML with color-coded revision indicators.
</p>

<p>
Copyright  2008 W3C (MIT, ERCIM, Keio), All Rights Reserved. W3C liability, trademark and document use rules apply.
Abstract
</p>

<p>
The Extensible Markup Language (XML) is a subset of SGML that is completely described in this document. Its goal is to enable generic SGML to be served, received, and processed on the Web in the way that is now possible with HTML. XML has been designed for ease of implementation and for interoperability with both SGML and HTML.
Status of this Document
</p>

<p>
This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at <a href="http://www.w3.org/TR/">http://www.w3.org/TR/</a>.
</p>

<p>
This document specifies a syntax created by subsetting an existing, widely used international text processing standard (Standard Generalized Markup Language, ISO 8879:1986(E) as amended and corrected) for use on the World Wide Web. It is a product of the XML Core Working Group as part of the XML Activity. The English version of this specification is the only normative version. However, for translations of this document, see <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml">http://www.w3.org/2003/03/Translations/byTechnology?technology=xml</a>.
</p>

<p>
This document is a W3C Recommendation. This fifth edition is not a new version of XML. As a convenience to readers, it incorporates the changes dictated by the accumulated errata (available at <a href="http://www.w3.org/XML/xml-V10-4e-errata">http://www.w3.org/XML/xml-V10-4e-errata</a>) to the Fourth Edition of XML 1.0, dated 16 August 2006. In particular, erratum [E09] relaxes the restrictions on element and attribute names, thereby providing in XML 1.0 the major end user benefit currently achievable only by using XML 1.1. As a consequence, many possible documents which were not well-formed according to previous editions of this specification are now well-formed, and previously invalid documents using the newly-allowed name characters in, for example, ID attributes, are now valid.
</p>

<p>
This edition supersedes the previous W3C Recommendation of 16 August 2006.
</p>

<p>
Please report errors in this document to the public xml-editor@w3.org mail list; public archives are available. For the convenience of readers, an XHTML version with color-coded revision indicators is also provided; this version highlights each change due to an erratum published in the errata list for the previous edition, together with a link to the particular erratum in that list. Most of the errata in the list provide a rationale for the change. The errata list for this fifth edition is available at <a href="http://www.w3.org/XML/xml-V10-5e-errata">http://www.w3.org/XML/xml-V10-5e-errata</a>.
</p>

<p>
An implementation report is available at <a href="http://www.w3.org/XML/2008/01/xml10-5e-implementation.html">http://www.w3.org/XML/2008/01/xml10-5e-implementation.html</a>. A Test Suite is maintained to help assessing conformance to this specification.
</p>

<p>
This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.
</p>

<p>
W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.
Table of Contents
</p>

<p>
1 Introduction
    1.1 Origin and Goals
    1.2 Terminology
2 Documents
    2.1 Well-Formed XML Documents
    2.2 Characters
    2.3 Common Syntactic Constructs
    2.4 Character Data and Markup
    2.5 Comments
    2.6 Processing Instructions
    2.7 CDATA Sections
    2.8 Prolog and Document Type Declaration
    2.9 Standalone Document Declaration
    2.10 White Space Handling
    2.11 End-of-Line Handling
    2.12 Language Identification
3 Logical Structures
    3.1 Start-Tags, End-Tags, and Empty-Element Tags
    3.2 Element Type Declarations
        3.2.1 Element Content
        3.2.2 Mixed Content
    3.3 Attribute-List Declarations
        3.3.1 Attribute Types
        3.3.2 Attribute Defaults
        3.3.3 Attribute-Value Normalization
    3.4 Conditional Sections
4 Physical Structures
    4.1 Character and Entity References
    4.2 Entity Declarations
        4.2.1 Internal Entities
        4.2.2 External Entities
    4.3 Parsed Entities
        4.3.1 The Text Declaration
        4.3.2 Well-Formed Parsed Entities
        4.3.3 Character Encoding in Entities
    4.4 XML Processor Treatment of Entities and References
        4.4.1 Not Recognized
        4.4.2 Included
        4.4.3 Included If Validating
        4.4.4 Forbidden
        4.4.5 Included in Literal
        4.4.6 Notify
        4.4.7 Bypassed
        4.4.8 Included as PE
        4.4.9 Error
    4.5 Construction of Entity Replacement Text
    4.6 Predefined Entities
    4.7 Notation Declarations
    4.8 Document Entity
5 Conformance
    5.1 Validating and Non-Validating Processors
    5.2 Using XML Processors
6 Notation
Appendices
</p>

<p>
A References
    A.1 Normative References
    A.2 Other References
B Character Classes
C XML and SGML (Non-Normative)
D Expansion of Entity and Character References (Non-Normative)
E Deterministic Content Models (Non-Normative)
F Autodetection of Character Encodings (Non-Normative)
    F.1 Detection Without External Encoding Information
    F.2 Priorities in the Presence of External Encoding Information
G W3C XML Working Group (Non-Normative)
H W3C XML Core Working Group (Non-Normative)
I Production Notes (Non-Normative)
J Suggestions for XML Names (Non-Normative)
1 Introduction
</p>

<p>
Extensible Markup Language, abbreviated XML, describes a class of data objects called XML documents and partially describes the behavior of computer programs which process them. XML is an application profile or restricted form of SGML, the Standard Generalized Markup Language [ISO 8879]. By construction, XML documents are conforming SGML documents.
</p>

<p>
XML documents are made up of storage units called entities, which contain either parsed or unparsed data. Parsed data is made up of characters, some of which form character data, and some of which form markup. Markup encodes a description of the document's storage layout and logical structure. XML provides a mechanism to impose constraints on the storage layout and logical structure.
</p>

<p>
[Definition: A software module called an XML processor is used to read XML documents and provide access to their content and structure.] [Definition: It is assumed that an XML processor is doing its work on behalf of another module, called the application.] This specification describes the required behavior of an XML processor in terms of how it must read XML data and the information it must provide to the application.
1.1 Origin and Goals
</p>

<p>
XML was developed by an XML Working Group (originally known as the SGML Editorial Review Board) formed under the auspices of the World Wide Web Consortium (W3C) in 1996. It was chaired by Jon Bosak of Sun Microsystems with the active participation of an XML Special Interest Group (previously known as the SGML Working Group) also organized by the W3C. The membership of the XML Working Group is given in an appendix. Dan Connolly served as the Working Group's contact with the W3C.
</p>

<p>
The design goals for XML are:
</p>

<p>
XML shall be straightforwardly usable over the Internet.
</p>

<p>
XML shall support a wide variety of applications.
</p>

<p>
XML shall be compatible with SGML.
</p>

<p>
It shall be easy to write programs which process XML documents.
</p>

<p>
The number of optional features in XML is to be kept to the absolute minimum, ideally zero.
</p>

<p>
XML documents should be human-legible and reasonably clear.
</p>

<p>
The XML design should be prepared quickly.
</p>

<p>
The design of XML shall be formal and concise.
</p>

<p>
XML documents shall be easy to create.
</p>

<p>
Terseness in XML markup is of minimal importance.
</p>

<p>
This specification, together with associated standards (Unicode [Unicode] and ISO/IEC 10646 [ISO/IEC 10646] for characters, Internet BCP 47 [IETF BCP 47] and the Language Subtag Registry [IANA-LANGCODES] for language identification tags), provides all the information necessary to understand XML Version 1.0 and construct computer programs to process it.
</p>

<p>
This version of the XML specification may be distributed freely, as long as all text and legal notices remain intact.
1.2 Terminology
</p>

<p>
The terminology used to describe XML documents is defined in the body of this specification. The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when EMPHASIZED, are to be interpreted as described in [IETF RFC 2119]. In addition, the terms defined in the following list are used in building those definitions and in describing the actions of an XML processor:
</p>

<p>
error
</p>

<p>
    [Definition: A violation of the rules of this specification; results are undefined. Unless otherwise specified, failure to observe a prescription of this specification indicated by one of the keywords MUST, REQUIRED, MUST NOT, SHALL and SHALL NOT is an error. Conforming software MAY detect and report an error and MAY recover from it.] 
fatal error
</p>

<p>
    [Definition: An error which a conforming XML processor MUST detect and report to the application. After encountering a fatal error, the processor MAY continue processing the data to search for further errors and MAY report such errors to the application. In order to support correction of errors, the processor MAY make unprocessed data from the document (with intermingled character data and markup) available to the application. Once a fatal error is detected, however, the processor MUST NOT continue normal processing (i.e., it MUST NOT continue to pass character data and information about the document's logical structure to the application in the normal way).] 
at user option
</p>

<p>
    [Definition: Conforming software MAY or MUST (depending on the modal verb in the sentence) behave as described; if it does, it MUST provide users a means to enable or disable the behavior described.] 
validity constraint
</p>

<p>
    [Definition: A rule which applies to all valid XML documents. Violations of validity constraints are errors; they MUST, at user option, be reported by validating XML processors.] 
well-formedness constraint
</p>

<p>
    [Definition: A rule which applies to all well-formed XML documents. Violations of well-formedness constraints are fatal errors.] 
match
</p>

<p>
    [Definition: (Of strings or names:) Two strings or names being compared are identical. Characters with multiple possible representations in ISO/IEC 10646 (e.g. characters with both precomposed and base+diacritic forms) match only if they have the same representation in both strings. No case folding is performed. (Of strings and rules in the grammar:) A string matches a grammatical production if it belongs to the language generated by that production. (Of content and content models:) An element matches its declaration when it conforms in the fashion described in the constraint [VC: Element Valid].] 
for compatibility
</p>

<p>
    [Definition: Marks a sentence describing a feature of XML included solely to ensure that XML remains compatible with SGML.] 
for interoperability
</p>

<p>
[Definition: Marks a sentence describing a non-binding recommendation included to increase the chances that XML documents can be processed by the existing installed base of SGML processors which predate the WebSGML Adaptations Annex to ISO 8879.] 
</p>

<p>
2 Documents
</p>

<p>
[Definition: A data object is an XML document if it is well-formed, as defined in this specification. In addition, the XML document is valid if it meets certain further constraints.]
</p>

<p>
Each XML document has both a logical and a physical structure. Physically, the document is composed of units called entities. An entity may refer to other entities to cause their inclusion in the document. A document begins in a "root" or document entity. Logically, the document is composed of declarations, elements, comments, character references, and processing instructions, all of which are indicated in the document by explicit markup. The logical and physical structures MUST nest properly, as described in 4.3.2 Well-Formed Parsed Entities.
2.1 Well-Formed XML Documents
</p>

<p>
[Definition: A textual object is a well-formed XML document if:]
</p>

<p>
Taken as a whole, it matches the production labeled document.
</p>

<p>
It meets all the well-formedness constraints given in this specification.
</p>

<p>
Each of the parsed entities which is referenced directly or indirectly within the document is well-formed.
</p>

<p>
Document
</p>
<p>
x y z
</p>



<p>
#x20 #x20 x y z
</p>

<p>
a="&amp;d;&amp;d;A&amp;a;&amp;#x20;&amp;a;B&amp;da;"
</p>



<p>
A #x20 B
</p>



<p>
#x20 #x20 A #x20 #x20 #x20 B #x20 #x20
</p>

<p>
a=
"&amp;#xd;&amp;#xd;A&amp;#xa;&amp;#xa;B&amp;#xd;&amp;#xa;"
</p>



<p>
#xD #xD A #xA #xA B #xD #xA
</p>



<p>
#xD #xD A #xA #xA B #xD #xA
</p>

<p>
Note that the last example is invalid (but well-formed) if a is declared to be of type NMTOKENS.
3.4 Conditional Sections
</p>

<p>
[Definition: Conditional sections are portions of the document type declaration external subset or of external parameter entities which are included in, or excluded from, the logical structure of the DTD based on the keyword which governs them.]
Conditional Section
</p>
</div>
</div>

<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> aptitude search parser - installed</h2>
<div class="outline-text-2" id="text-19">
<p>
i A libxrd-parser-perl              - parse XRD and host-meta files into RDF::Tr
i A libhtml-html5-parser-perl       - parse HTML reliably 
i A librdf-rdfa-parser-perl         - flexible RDFa parser       
i A libxml-parser-perl              - Perl module for parsing XML files  
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
document           ::=           prolog element Misc*
</p>

<p class="footpara">
Matching the document production implies that:
</p>

<p class="footpara">
It contains one or more elements.
</p>

<p class="footpara">
[Definition: There is exactly one element, called the root, or document element, no part of which appears in the content of any other element.] For all other elements, if the start-tag is in the content of another element, the end-tag is in the content of the same element. More simply stated, the elements, delimited by start- and end-tags, nest properly within each other.
</p>

<p class="footpara">
[Definition: As a consequence of this, for each non-root element C in the document, there is one other element P in the document such that C is in the content of P, but is not in the content of any other element that is in the content of P. P is referred to as the parent of C, and C as a child of P.]
2.2 Characters
</p>

<p class="footpara">
[Definition: A parsed entity contains text, a sequence of characters, which may represent markup or character data.] [Definition: A character is an atomic unit of text as specified by ISO/IEC 10646:2000 [ISO/IEC 10646]. Legal characters are tab, carriage return, line feed, and the legal characters of Unicode and ISO/IEC 10646. The versions of these standards cited in A.1 Normative References were current at the time this document was prepared. New characters may be added to these standards by amendments or new editions. Consequently, XML processors MUST accept any character in the range specified for Char. ]
Character Range
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
Char           ::=           #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]        <i>* any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. *</i>
</p>

<p class="footpara">
The mechanism for encoding character code points into bit patterns may vary from entity to entity. All XML processors MUST accept the UTF-8 and UTF-16 encodings of Unicode [Unicode]; the mechanisms for signaling which of the two is in use, or for bringing other encodings into play, are discussed later, in 4.3.3 Character Encoding in Entities.
</p>

<p class="footpara">
Note:
</p>

<p class="footpara">
Document authors are encouraged to avoid "compatibility characters", as defined in section 2.3 of [Unicode]. The characters defined in the following ranges are also discouraged. They are either control characters or permanently undefined Unicode characters:
</p>

<p class="footpara">
[#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDEF],
[#x1FFFE-#x1FFFF], [#x2FFFE-#x2FFFF], [#x3FFFE-#x3FFFF],
[#x4FFFE-#x4FFFF], [#x5FFFE-#x5FFFF], [#x6FFFE-#x6FFFF],
[#x7FFFE-#x7FFFF], [#x8FFFE-#x8FFFF], [#x9FFFE-#x9FFFF],
[#xAFFFE-#xAFFFF], [#xBFFFE-#xBFFFF], [#xCFFFE-#xCFFFF],
[#xDFFFE-#xDFFFF], [#xEFFFE-#xEFFFF], [#xFFFFE-#xFFFFF],
[#x10FFFE-#x10FFFF].
</p>

<p class="footpara">
2.3 Common Syntactic Constructs
</p>

<p class="footpara">
This section defines some symbols used widely in the grammar.
</p>

<p class="footpara">
S (white space) consists of one or more space (#x20) characters, carriage returns, line feeds, or tabs.
White Space
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
S           ::=           (#x20 | #x9 | #xD | #xA)+
</p>

<p class="footpara">
Note:
</p>

<p class="footpara">
The presence of #xD in the above production is maintained purely for backward compatibility with the First Edition. As explained in 2.11 End-of-Line Handling, all #xD characters literally present in an XML document are either removed or replaced by #xA characters before any other processing is done. The only way to get a #xD character to match this production is to use a character reference in an entity value literal.
</p>

<p class="footpara">
An Nmtoken (name token) is any mixture of name characters.
</p>

<p class="footpara">
[Definition: A Name is an Nmtoken with a restricted set of initial characters.] Disallowed initial characters for Names include digits, diacritics, the full stop and the hyphen.
</p>

<p class="footpara">
Names beginning with the string "xml", or with any string which would match (('X'|'x') ('M'|'m') ('L'|'l')), are reserved for standardization in this or future versions of this specification.
</p>

<p class="footpara">
Note:
</p>

<p class="footpara">
The Namespaces in XML Recommendation [XML Names] assigns a meaning to names containing colon characters. Therefore, authors should not use the colon in XML names except for namespace purposes, but XML processors must accept the colon as a name character.
</p>

<p class="footpara">
The first character of a Name MUST be a NameStartChar, and any other characters MUST be NameChars; this mechanism is used to prevent names from beginning with European (ASCII) digits or with basic combining characters. Almost all characters are permitted in names, except those which either are or reasonably could be used as delimiters. The intention is to be inclusive rather than exclusive, so that writing systems not yet encoded in Unicode can be used in XML names. See J Suggestions for XML Names for suggestions on the creation of names.
</p>

<p class="footpara">
Document authors are encouraged to use names which are meaningful words or combinations of words in natural languages, and to avoid symbolic or white space characters in names. Note that COLON, HYPHEN-MINUS, FULL STOP (period), LOW LINE (underscore), and MIDDLE DOT are explicitly permitted.
</p>

<p class="footpara">
The ASCII symbols and punctuation marks, along with a fairly large group of Unicode symbol characters, are excluded from names because they are more useful as delimiters in contexts where XML names are used outside XML documents; providing this group gives those contexts hard guarantees about what cannot be part of an XML name. The character #x037E, GREEK QUESTION MARK, is excluded because when normalized it becomes a semicolon, which could change the meaning of entity references.
Names and Tokens
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
NameStartChar           ::=           ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
[4a]           NameChar           ::=           NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
</p></div>

<div class="footdef"><sup><a id="fn.5" name="fn.5" class="footnum" href="#fnr.5">5</a></sup> <p class="footpara">
AttValue           ::=           '"' ([^&lt;&amp;"] | Reference)* '"'
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">"'" ([^&lt;&amp;']</td>
<td class="left">Reference)* "'"</td>
</tr>
</tbody>
</table></div>

<div class="footdef"><sup><a id="fn.6" name="fn.6" class="footnum" href="#fnr.6">6</a></sup> <p class="footpara">
PI           ::=           '&lt;?' PITarget (S (Char* - (Char* '?&gt;' Char*)))? '?&gt;'
</p></div>

<div class="footdef"><sup><a id="fn.7" name="fn.7" class="footnum" href="#fnr.7">7</a></sup> <p class="footpara">
Name           ::=           NameStartChar (NameChar)*
</p></div>

<div class="footdef"><sup><a id="fn.8" name="fn.8" class="footnum" href="#fnr.8">8</a></sup> <p class="footpara">
Names           ::=           Name (#x20 Name)*
</p></div>

<div class="footdef"><sup><a id="fn.9" name="fn.9" class="footnum" href="#fnr.9">9</a></sup> <p class="footpara">
Nmtoken           ::=           (NameChar)+
</p></div>

<div class="footdef"><sup><a id="fn.10" name="fn.10" class="footnum" href="#fnr.10">10</a></sup> <p class="footpara">
Nmtokens           ::=           Nmtoken (#x20 Nmtoken)*
</p>

<p class="footpara">
Note:
</p>

<p class="footpara">
The Names and Nmtokens productions are used to define the validity of tokenized attribute values after normalization (see 3.3.1 Attribute Types).
</p>

<p class="footpara">
Literal data is any quoted string not containing the quotation mark used as a delimiter for that string. Literals are used for specifying the content of internal entities (EntityValue), the values of attributes (AttValue), and external identifiers (SystemLiteral). Note that a SystemLiteral can be parsed without scanning for markup.
Literals
</p></div>

<div class="footdef"><sup><a id="fn.11" name="fn.11" class="footnum" href="#fnr.11">11</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.12" name="fn.12" class="footnum" href="#fnr.12">12</a></sup> <p class="footpara">
EntityValue           ::=           '"' ([^%&amp;"] | PEReference | Reference)* '"'
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">"'" ([^%&amp;']</td>
<td class="left">PEReference</td>
<td class="left">Reference)* "'"</td>
</tr>
</tbody>
</table></div>

<div class="footdef"><sup><a id="fn.13" name="fn.13" class="footnum" href="#fnr.13">13</a></sup> <p class="footpara">
SystemLiteral           ::=           ('"' [^"]* '"') | ("'" [<sup>']</sup>* "'")
</p></div>

<div class="footdef"><sup><a id="fn.14" name="fn.14" class="footnum" href="#fnr.14">14</a></sup> <p class="footpara">
PubidLiteral           ::=           '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
</p></div>

<div class="footdef"><sup><a id="fn.15" name="fn.15" class="footnum" href="#fnr.15">15</a></sup> <p class="footpara">
PubidChar           ::=           #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
</p>

<p class="footpara">
Note:
</p>

<p class="footpara">
Although the EntityValue production allows the definition of a general entity consisting of a single explicit &lt; in the literal (e.g., &lt;!ENTITY mylt "&lt;"&gt;), it is strongly advised to avoid this practice since any reference to that entity will cause a well-formedness error.
2.4 Character Data and Markup
</p>

<p class="footpara">
Text consists of intermingled character data and markup. [Definition: Markup takes the form of start-tags, end-tags, empty-element tags, entity references, character references, comments, CDATA section delimiters, document type declarations, processing instructions, XML declarations, text declarations, and any white space that is at the top level of the document entity (that is, outside the document element and not inside any other markup).]
</p>

<p class="footpara">
[Definition: All text that is not markup constitutes the character data of the document.]
</p>

<p class="footpara">
The ampersand character (&amp;) and the left angle bracket (&lt;) MUST NOT appear in their literal form, except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section. If they are needed elsewhere, they MUST be escaped using either numeric character references or the strings " &amp;amp; " and " &amp;lt; " respectively. The right angle bracket (&gt;) may be represented using the string " &amp;gt; ", and MUST, for compatibility, be escaped using either " &amp;gt; " or a character reference when it appears in the string " ]]&gt; " in content, when that string is not marking the end of a CDATA section.
</p>

<p class="footpara">
In the content of elements, character data is any string of characters which does not contain the start-delimiter of any markup and does not include the CDATA-section-close delimiter, " ]]&gt; ". In a CDATA section, character data is any string of characters not including the CDATA-section-close delimiter, " ]]&gt; ".
</p>

<p class="footpara">
To allow attribute values to contain both single and double quotes, the apostrophe or single-quote character (') may be represented as " &amp;apos; ", and the double-quote character (") as " &amp;quot; ".
Character Data
</p></div>

<div class="footdef"><sup><a id="fn.16" name="fn.16" class="footnum" href="#fnr.16">16</a></sup> <p class="footpara">
CharData           ::=           [^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]*)
2.5 Comments
</p>

<p class="footpara">
[Definition: Comments may appear anywhere in a document outside other markup; in addition, they may appear within the document type declaration at places allowed by the grammar. They are not part of the document's character data; an XML processor MAY, but need not, make it possible for an application to retrieve the text of comments. For compatibility, the string " &#x2013; " (double-hyphen) MUST NOT occur within comments.] Parameter entity references MUST NOT be recognized within comments.
Comments
</p></div>

<div class="footdef"><sup><a id="fn.17" name="fn.17" class="footnum" href="#fnr.17">17</a></sup> <p class="footpara">
Comment           ::=           '&lt;!&#x2013;' ((Char - '-') | ('-' (Char - '-')))* '&#x2013;&gt;'
</p>

<p class="footpara">
An example of a comment:
</p>

<p class="footpara">
&lt;!&#x2013; declarations for &lt;head&gt; &amp; &lt;body&gt; &#x2013;&gt;
</p>

<p class="footpara">
Note that the grammar does not allow a comment ending in &#x2014;&gt;. The following example is not well-formed.
</p>

<p class="footpara">
&lt;!&#x2013; B+, B, or B&#x2014;&gt;
</p>

<p class="footpara">
2.6 Processing Instructions
</p>

<p class="footpara">
[Definition: Processing instructions (PIs) allow documents to contain instructions for applications.]
Processing Instructions
</p></div>

<div class="footdef"><sup><a id="fn.18" name="fn.18" class="footnum" href="#fnr.18">18</a></sup> <p class="footpara">
PITarget           ::=           Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
</p>

<p class="footpara">
PIs are not part of the document's character data, but MUST be passed through to the application. The PI begins with a target (PITarget) used to identify the application to which the instruction is directed. The target names " XML ", " xml ", and so on are reserved for standardization in this or future versions of this specification. The XML Notation mechanism may be used for formal declaration of PI targets. Parameter entity references MUST NOT be recognized within processing instructions.
2.7 CDATA Sections
</p>

<p class="footpara">
[Definition: CDATA sections may occur anywhere character data may occur; they are used to escape blocks of text containing characters which would otherwise be recognized as markup. CDATA sections begin with the string " &lt;![CDATA[ " and end with the string " ]]&gt; ":]
CDATA Sections
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Donald Lindsay</p>
<p class="date">Created: 2014-05-25 Sun 17:02</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.6)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

* startup 

#+startup:  overview hideblocks

** drawers 

#+drawer:   hidden state properties owl2-rdfs org-n3 n3

** tags 

#+tags:     { @file @buffer @window @frame } 
#+tags:     { @doc @src @lob } 
#+tags:     { @import @export @org-n3 }
#+tags:     org elisp n3 owl2 rdfs prolog lisp shell axiom
#+tags:     { proof theorem def desc example } grammar

** header-args 

#+property: header-args         :export results
#+property: header-args:org-n3  :session *org-n3*

** properties 
   :properties:
   :see-also org-property-allowed-value-functions
   :end:

*** TODO do i want a #+property: list of all owl2 and rdfs? 
    
**** or elisp via org-global-properties

     "List of property/value pairs that can be inherited by any entry.
     This list will be combined with the constant
     `org-global-properties-fixed'.  The entries in this list are cons
     cells where the car is a property name and cdr is a string with the
     value."
 
**** org-global-properties format

   '(("org-n3-triple-part" . "subject predicate object"))

   it might make sense to make a separate file for holding the list
   since it might be somewhat long and can be imported.

   a related question is if i want to define all the owl2 and rdfs as
   tags.

   this may be where drawers will be appropriate as they are easily
   handled, are custom definable, and have good code support.

   also, the syntax of drawers is similar to n3 syntax, making the
   production of n3 strings easier, if, for instance, i want to do
   string replacement and filtering functions, or want to do things
   with agenda and column views

#+BEGIN_EXAMPLE owl2-rdfs property drawer
  :owl2-rdfs:
  :doc-string "owl2 and rdfs markup element drawer"
  :type drawer
  :end:
#+END_EXAMPLE

#+property: org-n3_all          org-n3-rdfs-type

#+property: org-n3+             org-n3-predicate
#+property: org-n3-predicate    rdfs-type

**** or elisp via org-file-properties
   
     "You can set buffer-local values for the same purpose in the variable
     `org-file-properties' this by adding lines like
   
     #+PROPERTY: NAME VALUE"


** calls 
  
   "#+call [<inside header arguments>] (<arguments>) <end header arguments>"

#+call: org-n3-imenu-add-to-menubar
#+call: org-n3-button-panel
#+call: org-n3-ac-predictive
#+CALL: factorial(n=5)
#+CALL: factorial[:session special](n=5)
#+CALL: org-n3-todo-keywords (<arguments>)


* functions 
** Periodic Functions 
   Captured [2014-06-18 Wed 08:14]
   {Periodic function} (Math.), a function whose values recur at
   fixed intervals as the variable uniformly increases. The
   trigonomertic functions, as sin(x), tan(x), etc., are
   periodic functions. Exponential functions are also
   periodic, having an imaginary period, and the elliptic
   functions have not only a real but an imaginary period,
   and are hence called doubly periodic.
** org-n3-org-ac 
#+name: org-n3-org-ac
#+BEGIN_SRC emacs-lisp
  (defun org-n3-ac-predictive ()
    "Enable org-ac and predictive mode. Warning: resource intensive."
    (interactive)
    (progn
      (predictive-mode)             
      (org-ac/setup-current-buffer))
    )
#+END_SRC

** org-n3-todo 
#+name:     org-n3-todo-keywords
#+headers:  :var data1=1
#+begin_src emacs-lisp          :var data2=2
(progn 
;; buttonize
(org-babel-execute-src-block)

(setq org-todo-keywords
       '((sequence "TODO" "|" "DONE")
         (sequence "REPORT" "BUG" "KNOWNCAUSE" "|" "FIXED")
         (sequence "|" "CANCELED")))

(message "data1:%S, data2:%S" data1 data2))
#+end_src
#+results:
: data1:1, data2:2

#+name: named-block
#+header: :var data=2
#+begin_src emacs-lisp
(message "data:%S" data)
#+end_src
#+results: named-block
: data:2

** org-n3-button-panel 
   :properties:
   :doc-string  "A panel window with a set of custom buttons for common tasks."
   :import      buffer-buttons.el
   :end:

   Buffer buttons placed at the bottom or top of this file. So that
   they can be used in a two window frame, when the buttons are ready,
   code the frame window geometry setup. See buffer-buttons.el for more.

   Another feature is inline buttons for source blocks. Buttons
   provide quick access to executions and editing functions. Source
   blocks, like repls, with buttons.

*** org-n3-button-definitions
#+name: org-n3-button-definitions
#+BEGIN_SRC emacs-lisp
  ; eval-last-sexp
  (define-buffer-button (elisp-eval b
                                    :label "<- Eval"
                                    :prefix ";;")
    (save-excursion
      (goto-char (button-start b))
      (eval-last-sexp nil)))
  ; org-edit-src-code
  (define-buffer-button (elisp-eval b
                                    :label "Edit Src"
                                    :prefix ";;")
    (save-excursion
      (goto-char (button-start b))
      (org-edit-src-code nil)))
  ; org-execute-source-block
  (define-buffer-button (elisp-eval b
                                    :label "Exec Src"
                                    :prefix ";;")
    (save-excursion
      (goto-char (button-start b))
      (org-execute-source-block nil)))
#+end_src

***  define the buttons in source blocks

** org-n3-yas 
#+name: yasnippet-functions
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
                      (lambda ()
                        (org-set-local 'yas/trigger-key [tab])
                        (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))
  


 (add-hook 'org-mode-hook
                      (lambda ()
                        (make-variable-buffer-local 'yas/trigger-key)
                        (setq yas/trigger-key [tab])
                        (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
                        (define-key yas/keymap [tab]
                      'yas/next-field)))

(defun yas/org-very-safe-expand ()
              (let ((yas/fallback-behavior 'return-nil))
              (yas/expand)))

#+END_SRC
** org-n3-imenu
** org-n3-predictive-mode
** org-n3-lob-ingest 
 :properties:
 :org-n3-lob-file ~/src/lisp/org-n3/org-n3-library-of-babel.org
 :end:

#+name: org-n3-lob-ingest
#+BEGIN_SRC emacs-lisp
; (org-babel-lob-ingest)

#+END_SRC


* tasks 
** dfa-dg.org
This file has mainly become about deterministic finite automata and
directed graphs. This is progress because my targets have been source
blocks and n3. #+begin_src might read as #+deterministic-finite-automata
and n3 might read as directed-graph. My current interest is developing
this code along those lines and with a focus on producing code that i
can load into gruff, which at this point means turtle and hence, n3.

** determine the significance of (:how) (:what) and (seq (:how :much))
** TODO do i want a #+property: list of all owl2 and rdfs? 

#+property: org-n3_all          org-n3-rdfs-type
#+property: org-n3+             org-n3-predicate
#+property: org-n3-predicate    rdfs-type

*** drawers
#+drawer:   hidden state

** TODO edit for org-n3-lob-file
*** utilities							      :shell:
**** raptor							 :rdf:parser:
***** TODO define functions to run rapper
****** this is a start
#+NAME: raptor
#+BEGIN_SRC sh :var filename=(buffer-file-name) :exports both
       rapper -i turtle -o ntriples $filename
#+END_SRC
***** man raptor
****** Raptor RDF Syntax Library - Raptor RDF parser utility	 :rdf:raptor:
******* NAME
       	rapper − Raptor RDF parsing and serializing utility

******* SYNOPSIS
       	rapper [OPTIONS] INPUT-URI [INPUT-BASE-URI]

******* EXAMPLE
       	rapper -o ntriples http://planetrdf.com/guide/rss.rdf
       	rapper -i rss-tag-soup -o rss-1.0 pile-of-rss.xml
	     http://example.org/base/ 
       	rapper --count http://example.org/index.rdf

******* DESCRIPTION
       	The rapper utility allows parsing of RDF content by the
       	Raptor RDF parser toolkit emitting the results as RDF
       	triples in a choice of syntaxes. The INPUT-URI can be a
       	file name, ’-’ for standard input or if Raptor is built
       	with a WWW retrieval library, a general URI. The optional
       	INPUT-BASE-URI is used as the document parser base URI if
       	present otherwise defaults to the INPUT-URI. A value of
       	’-’ means no base URI.

******* OPTIONS
       	rapper uses the usual GNU command line syntax, with long
       	options starting with two dashes (’-’) if supported by
       	the getopt_long function. Otherwise the short options are
       	only available.

       	−h, −−help

       	Show a summary of the options.

       	−i, −−input FORMAT

       	Set the input FORMAT to one of ’rdfxml’ (RDF/XML,
       	default), ’ntriples’ (N-Triples, see below), ’turtle’
       	(Turtle, see below) or ’rss-tag-soup’ (RSS Tag Soup). The
       	RSS Tag Soup parser can turn the many XML RSS formats and
       	Atom 0.3 into RDF triples.

       	The list of parsers depends on how libraptor(3) was
       	built. The list of supported parsers is given in the help
       	summary given by −h.

       	−I, −−input-uri URI

       	Set the input/parser base URI or use value ’-’ for no
       	base. The default is the INPUT-URI argument value.

       	−o, −−output FORMAT

       	Set the output FORMAT to ’ntriples’ (N-Triples, default),
       	’rdfxml’ (RDF/XML), ’rdfxml-abbrev’ (RDF/XML with
       	abbreviations) or ’rss-1.0’ (RSS 1.0, also an RDF/XML
       	syntax).

       	The list of serializers depends on how libraptor(3) was
       	built. The list of supported serializers is given in the
       	help summary given by −h.

       	−O, −−output-uri URI

       	Set the output/serializer base URI or use value ’-’ for
       	no base. The default is the input base uri, either set by
       	the argument INPUT-BASE-URI or via options −I,
       	−−input-uri URI

       	−c, −−count

       	Only count the triples and produce no other output.

       	−e, −−ignore-errors

       	Ignore errors, do not emit the messages and try to
       	continue parsing.

       	−f, −−feature FEATURE[=VALUE]

       	Set a parser or serializer feature FEATURE to a value, or
       	to 1 if VALUE is omitted, Use −f help to get lists of
       	valid parser and serializer features.

       	If the form −f ’xmlns:prefix="uri"’ is used, the prefix
       	and namespace uri given will be set for serializing. The
       	syntax matches XML in that either or both of prefix or
       	uri can be omitted.

       	−g, −−guess

       	Guess the parser to use from the source-URI rather than
       	use the −i FORMAT.

       	−q, −−quiet

       	No extra information messages.

       	−r, −−replace-newlines

       	Replace newlines in multi-line literals with spaces.

       	−−show-graphs

       	Print graph names (URIs) as they are seen in the input. This only has
       	a meaning for parsers that support graph names such as the TRiG
       	parser.

       	−−show-namespaces

       	Print namespaces as they are seen in the input.

       	−t, −−trace

       	Print URIs retrieved during parsing. Especially useful
       	for monitoring what the guess and GRDDL parsers are
       	doing.

       	−w, −−ignore-warnings

       	Ignore warnings, do not emit the messages.

       	−v, −−version

       	Print the raptor version and exit.  

******* EXAMPLES

       	rapper -q -i ntriples -o rdfxml 
       	-f ’xmlns:rss="http://purl.org/rss/1.0/"’ 
       	-f ’xmlns:ex="http://example.org/"’ 
       	   tests/test.nt

       	rapper -q -o rdfxml 
       	-f ’xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"’ 
       	   tests/rdf-schema.rdf 
       	   ’http://www.w3.org/2000/01/rdf-schema#’

******* Examples
     rapper -q -i ntriples -o rdfxml 
	    -f ’xmlns:rss="http://purl.org/rss/1.0/"’
	    -f ’xmlns:ex="http://example.org/"’ tests/test.nt

     rapper -q -o rdfxml 
	    -f ’xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"’ tests/rdf-schema.rdf 
	       ’http://www.w3.org/2000/01/rdf-schema#’

#+begin_src elisp
(defun rapper)
(interactive)
(shell-command rapper)
(insert results at point)
(append-results-to-buffer-or-file)
#+end_src
**** ebnf2ps							   :meta:rdf:
       	 `ebnf'	ebnf2ps recognizes the syntax described in ebnf2ps
   		   documentation.
   		   The following variables *ONLY* have effect with this
   		   setting:
   		   `ebnf-terminal-regexp', `ebnf-case-fold-search',
   		   `ebnf-lex-comment-char' and `ebnf-lex-eop-char'.
      
       	 `abnf'	ebnf2ps recognizes the syntax described in the URL:
   		   `http://www.ietf.org/rfc/rfc2234.txt'
   		   ("Augmented BNF for Syntax Specifications: ABNF").
      
       	 `iso-ebnf'	ebnf2ps recognizes the syntax described in the URL:
   		   `http://www.cl.cam.ac.uk/~mgk25/iso-ebnf.html'
   		   ("International Standard of the ISO EBNF Notation").
   		   The following variables *ONLY* have effect with this
   		   setting:
   		   `ebnf-iso-alternative-p' and `ebnf-iso-normalize-p'.
      
       	 `yacc'	ebnf2ps recognizes the Yacc/Bison syntax.
   		   The following variable *ONLY* has effect with this
   		   setting:
   		   `ebnf-yac-ignore-error-recovery'.
      
       	 `ebnfx'	ebnf2ps recognizes the syntax described in the URL:
   		   `http://www.w3.org/TR/2004/REC-xml-20040204/#sec-notation'
   		   ("Extensible Markup Language (XML) 1.0 (Third Edition)")
      
       	 `dtd'	ebnf2ps recognizes the syntax described in the URL:
   		   `http://www.w3.org/TR/2004/REC-xml-20040204/'
   		   ("Extensible Markup Language (XML) 1.0 (Third Edition)")
      
      Any other value is treated as `ebnf'.
**** bnf2xml							:ebnf:parser:
#+begin_src elisp
(defun bnf2xml)
(interactive)
(on-region (shell-command bnf2xml))
(insert results at point)
(append-results-to-buffer-or-file)
#+end_src
***** BNF parser:
	recursively does lookups from L to R
	that stops (returns) if terminals are found.
	for each LHS item
	1) search for each RHS, or failing that, ...
	2) try to match it (a terminal) against input
	If all LHS items on a line finally get matched to terminals: done.

LHS : RHS
<a> : <b>
<b> : <c> <b>
<b> : <d> <b>
<d> : <e>

	Any RHS with no LHS in a bnf table is terminal.
	c and d are terminal (no c and d on LHS)
	d isn't ever found so e is questionable

What that does is group how terminals are matched, and so one can,
with a full bnf file, have a language specified (ie, C) is one use.


===============================
this was the initial design
before functions were 
#+begin_src language

#+end_src
hardly writen yet
===============================


	this implementation was mostly written in early to early '90s when you
	couldn't hardly find / download such things (before XML, mid-90's)
	development was halted by 1) college  2) health emergencies 3) money
	too bad.  not that xml isn't nice.

	This parser byte compiles (makes op codes) of the BNF table.
	It's a multi-line table.  NOTE: input string is seen as flat
	there's no "lines of input of file" - none

					// ---- BnfSym ----
	WHAT IS last ?  		// LogLHS uses it to tell FindRHS "fake logical match
					// ignore / don't do any action (record, pop, any)
	word4symbol, symbol4word	// dictionary lookup / uncrack op code table
	SVec3 ssBNFv3 ; 		// BNF text file v3{string, line, word in line}
	DVec1<long, uint> slRHSv1 ;	// RHS symbols for a line (after byte compiles bnf table)
	SVec2 ssTRMv2 ; 		// list of terminal strings (last symbol+1 = termbase, 
					// ssTRMv2[symb-termbase]=terminal string)
					// (for indexing each input char to bnf terminal char table)
	DVec2<long, uint> slLHSv2 ; 	// LHS symbols for a line
					// ---- Parse ----
        // all four pushed after each successful search
	// and _found (ones pushed in search) is remarked depending on ret_val
        DVec1<long, uint> lresv1_found ; // T/F per group
        DVec1<long, uint> lresv1_found_item ; // T/F  per item
	DVec1<long, uint> lresv1_rec_lvl ; // how deep
					// so print can know if repeat push due to recursive search
					// no of the other pushes can be used to show repeasts
					// possible to not push if not necessary?  but using logic for when
					// to push removes what happened (if you did want to trace failed
	// matches) and could get complicated
        DVec1<long, uint> lresv1_line ;  // current atline of
        DVec1<long, uint> lresv1_n ;     // n of line[n] == symb if any
        DVec1<long, uint> lresv1_symb ;  // symbol if any

		// these support a "quick find" only of top of search
		// and report is only input and line # really
	DVec1<long, uint> slResV1 ;	// Results vec, pushed, List of symbols for input.
	DVec1<long, uint> slSymbLineV1 ; // list of lines numbers matched, pushed
	DVec1<long, uint> slSymbV1 ;	// Index for ea. symbol in ssTRMv2 for input.
					// A convenience since option based.
					// list made just before exit by listing slResV1

	SVec2 ssStrV2 ;			// List of matched words in input from BNF file
					// (no caps for common, etc).
					// list made just before exit by listing slResV1
					// ---- Program codes for matches ----
	DVec1<long, uint> slMapedTrmV1 ; // prog id for terminal strings
					// ss, "str / str" table
					// sl, "str / long" (string / number)
					// (has nothing to do with parsing)


    ret_val  is 0 False no !retval, 1 true yes ret_val
            (unsigned int) -1 is a special yes check for in one place


	"this is a FIRST LEVEL parse; this rule file can (in turn)
	 define more complicated rule files which can then in
	 turn be used to parse more complicated files"

		Sat Jul  2 21:50:26 EDT 2011

	HOW?? (took me an hour to remmeber)
		* each parsed input can be a new bnf line
		  (instead of getting input from FileArr, recycled)
		* after being parsed it needs end up being
		  the form this parser reads (basic bnf)
	INTERNALS
		* FileArr(filename)->BnfSym(file)->BnfParse(txt)->FindRHS(txt, syms)
			c++ Parse:BnfParse:BnfSym:FileArr
		* BnfSym has no specification of what terminals are
		  any RHS with no LHS is mapped as 'terminal'
		* the built in terminators {=,<,>,\t,:,|, ,',"} seem limiting
		  on a 1st parse but if bnf is recyled they are the target format
		  (are muted, bnf terminators used to read final input).
		* but what IS limiting is built-in operators (&,|,=,~)
		  These reduce size of final RHS LHS table provide search rules.
		  A 2nd level bnf can combine ot act like new ones.
			  * I'm unsure if that has the same cost.
	WHAT IS VARIABLE 'last' ?
		LogLHS uses it to tell FindRHS "fake logical match - ignore"
		LogLHS -> MatchLHS -> FindRHS (which must know it's fake)

orig. bnf features
	& is implied always by bnf form and
		<ab> : <a> <b>
	bnf parser can list recursive matches (a recursive searcher)
		<white> : <whitechar> <white>

3 enhacements, meant to be strong yet still basic

	1) | logical search operator - for tech. reasons

	2) ==  is for simpler callers to limit matching to a dictionary
	   (otherwise a simple caller couldn't read report: too comlicated)
	   (also a bnf shortcut: "find these [terminal] or quit")
		with <repl> and <sys> (see features)

	3) 3 REPORT : 
		a) simple reflection of input matched
		b) a quick report showing top line, symbols, and words
		   matched (highest line fully matched)
		   NOTE: based on report a, not report c
		c) extended report dump of all non-failed searches
		   trace what you need

	FindRHS can be invoke to begin at whatever line for which symb.

todo, if ever: search enhancements

	ex. to specify groups <being> <end> that "fail one skip the rest of group"
	search enhancements, operators, anything to reduce table, extend searching,
	or reduce needless searching smartly / by standards

	support for OPS was added later and (I hope) is completely
	separable from the basic code (don't use them in bnf
	and the more complex yet separate code is never used)

*/
/*
	TODOS
		* simple reflexion requires more though to print
			<w> : <wc> <w> 
			<w> : w <wc> <w> /w /w
			-->	W " " W " " /W /W
			<a> <a> <b> is inf rec
		* the fact that ie, 9 30 W 9 30 W repeated pushes
			likely means something (ie, logLHS last 0)
			maybe never needs to push or pop
				though easily skipped

	// Sat Oct 13 17:05:58 EDT 2012

	// printing results better...

	two basic ways:

		 1)  some complicated way that pushes only "wanted info"
		*2)  push all that didn't fail, extra data, and you can
		    trace into what you want l8tr

    done
*/


===============================
this was the initial design
before functions were 
hardly writen yet
===============================

/*
Report generation for parser:
	Lvec2 ComTab () const ;
	Svec2 ComStr () const ;
ex. "look at room"
ComTab:
	3			10		9		4			8
	3			200		300		400			500
ComSym:
	<com>		<verb>	<prep>	<article>	<noun>
	command		look	at		the			room
*/

// ------------------------------------------------------------------------
/*
Contents of Symbol table:

	- The recursive algorithm only needs unique symbols
	in place of long form, thus:
		char *strtok( char *string1, const char *string2 );
	can be (is) used to identify tokens to symbolize.

	- Symbols have to express whether their token is terminal (T/F &mask).

	- The table must contain references to use to match tokens
	(note that most terminals are not characters).
*/
// ------------------------------------------------------------------------
/*

**	Note that the below ignores the difficulty in actually providing the 
correct solution when substitution, identity, and other such features exist.
	Symbols for partial matches musted be pushed as found and poped
if a full statement can't be matched.  Some statements will not need to be
matched.  Complete information on all previous operations would be 
hard to maintain and hard to analyze.
	The sol. is notated somewhat in the source code.  A parameter is used
to keep track of whether the current frame is a frame which will cause all
of the input to be matched.  Frames which aren't responsible in this manner
do not cause the solutions stack to be poped.

1. find a matching RHS element (noting first is on line 0)
1. STARTS on same line as LHS
1.1R if exits
	2 determin lhs elements
	2.1 if <>== found, do 2.2 else 3.1
	2.2 * matches aggregates to pre-defined terminals
		1. feed <> to rhs MUST return 1 (or return char *)
			if ( !(FindRHS(match, atline)) ) // note: we don't want atline changed now...
		2. match <> to terminal and return result
		3. lhs should be listed to rhs
		3.1 if () found: () here groups logics
			- start from inner most () (& recurse ?)
		3.2 first | found
			- feed left and right to this function return |
		* this is where to add other logicals
		3.3 feed remaining to rhs, return with && logic
			a. if T return T
			b. if symlst () (the set?) F, match terminal(s)
				1. match downward only
				2. match () RHS
				3. ' ','\t','\r','\n' are term separators, ret T?
				4. if F and ! end line, keep checking
1.2E if not exits LHS item was terminal, ret T
*/
// ------------------------------------------------------------------------


// ------------------------------------------------------------------------
/*
	Notes in source specify a difference from the process below.
	The aim of the notes is to define avail. syntax
*/
/*
1. find a matching RHS element (noting first is on line 0)
1. STARTS on same line as LHS
1.1R if exits
	2 determin lhs elements
	2.1 if <>== found, do 2.2 else 3.1
	2.2 * matches aggregates to pre-defined terminals
		1. feed <> to rhs MUST return 1 (or return char *)
			if ( !(FindRHS(match, atline)) ) // note: we don't want atline changed now...
		2. match <> to terminal and return result
		3. lhs should be listed to rhs
		3.1 if () found: () here groups logics
		() never found in first level parse - see PROC: list symbols
		3.2 an | found
			- feed left and right to this function return |
		* this is where to add other logicals
		3.3 feed remaining to rhs, return with && logic
			a. if T return T
			b. if symlst () (the set?) F, match terminal(s)
				1. match downward only
				2. match () RHS
				3. r','\n' are term separators, ret T?
				4. if F and ! end line, keep checking
1.2E if not exits LHS item was terminal, ret T

  PROC: list symbols:
	- use start, end idecies
	- =
		(if symb exits after =)
		AndLhs(st, end(OP=)) || AndLhs(OP=+1, end)
	- |
		do
		find end
		AndLhs(st, end(OP|))
		st = OP+1 end = st
		until finished
		| return logic
	- ~ not
		same as | except !(...) in symbol table 
		is in form ~...~ 
	- &
		do
		AndLhs(st) to findrhs
		++st 
		until st==end
		& return logic
*/
// ------------------------------------------------------------------------
/*
Table Build Format:
	note that: 6|>5rhs and 8t>5rhs; 
				1|2= allows term determination: (!RHS>lhs)
start	guess		guess			finish
rlll	1 2|143		1 26143			3 4165		
rlllll	2 23|342	2 236342		4 451564
rllll	3 4=s|s+s	3 47868??		5 6218
rltt	4 tttt		4 9??			6 9
rttt	5 t		5 (10)			7 (10...)

NOTE: 8,9,>10 are terminal that are stored for matching
PROCESS: rhs and lhs are stored seperately
	rhs is a 1 to ... count
	lhs is the same - but terminals must have a symbol
		differing from bnf identifiers - so they have a 
		number higher than any of those...
	termbase is the lowest non bnf identifier in table
	termstr[lhs[i]-termbase] is a terminal to match

Q: sym for ea. term in rhs or one for ea. rhs ?
A: 1 uniq. for ea. + lookup allows efficient storage...
	   --> AND easy lookup

OOPS: or (|) begins at 1 - 0 will be the unassigned constant

ANTIQUITY:
	- no assignment for operators; they are assumed first (1,2,...)
	- this is a FIRST LEVEL parse; this rule file can (in turn)
    define more complicated rule files which can then in
	turn be used to parse more complicated files
*/	
// ------------------------------------------------------------------------



***** bnf2xml
FEATURES:
	fully reflexive (don't need *, automatic)
	OR, AND, == (bnf bnf a maybe, see below)

	REPLACE / DO something hack , 2 ways to match
		form   <a> : <repl> "" ""
		repl <a_r> : <foo> "" ""
			if <a> take parallel <a_r>
			replaces in output: REPORT c (not report a or b)
			does not change input
		form   <a> : <subst> "" ""
		repl <a_s> : <foo> "" ""
			if <a> take parallel <a_r>
			replace input during search
			restars search on that line and continues
			downward (do not start at line 0)
			replaces in all REPORT a,b,c
		form   <a> : <sys> "" ""
		repl <a_S> : <foo> "" ""
			if <a> system(<a_r>)
		NOTES:
		* lines must be one after the other, _r is
		  actuall <a_foo> (use positionally)
		* #define SYS_FOO_PRINTONLY is default
		* Note input subst remains once done, so
		  plan ahead not to depend on whether the
		  line where <a> is found wholey matches)
TODOS
	this looks easiest, or getop if must
		cat opts bnf1 bnf2 | parse

	input is one line only (can't parse input file)

	cannot yet use input to use 1st bnf to read in a 2nd bnf
		which would then read input
		point being to allow varied bnf syntax support

	output is not very useable yet but mostly complete

	WARNING: having read Ale I guaruntee the naming is confusing
	and not good enough.  see parse.discussion about many parsers /
	analyzers
**** rdf2rdf							 :rdf:parser:
#+begin_src elisp
(defun rdf2rdf)
(interactive)
(shell-command bnf2xml)
(insert results at point)
(append-results-to-buffer-or-file)
#+end_src
**** rdf.sh (perl)						   :rdf:perl:
#+begin_src elisp
(defun rdf.sh)
(interactive)
(shell-command rdf.sh)
(insert results at point)
(append-results-to-buffer-or-file)
#+end_src
#+begin_src turtle
<http://sebastian.tramp.name/Projects/rdf.sh> a :Project;
    <http://purl.org/dc/terms/updated> "2013-05-05T17:52:26Z"^^xsd:dateTime;
         :description "A multi-tool shell script for doing Semantic Web jobs on the command line.";
         :developer <http://sebastian.tramp.name>;
         :download-page <https://github.com/seebi/rdf.sh/archives/master>;
         :homepage <https://github.com/seebi/rdf.sh/>;
         :programming-language "Shell";
         :name "rdf.sh".
#+end_src
**** pellet.sh
     file:///home/xk05/apps/pellet-2.3.1


*** exclusive-or
#+name: exclusive-or
#+begin_src emacs-lisp
       (defun org-xor (a b)
          "Exclusive or."
          (if a (not b) b))
#+end_src

*** XPath							     :rdf:fn:

    [Definition: XPath operates on the abstract, logical structure of an
    XML document, rather than its surface syntax. This logical
    structure, known as the data model, is defined in [XQuery 1.0 and
    XPath 2.0 Data Model (Second Edition)].]

    XPath is designed to be embedded in a host language such as [XSL
    Transformations (XSLT) Version 2.0 (Second Edition)] or [XQuery 1.0:
    An XML Query Language (Second Edition)]. XPath has a natural subset
    that can be used for matching (testing whether or not a node matches
    a pattern); this use of XPath is described in [XSL Transformations
    (XSLT) Version 2.0 (Second Edition)].

    XQuery Version 1.0 is an extension of XPath Version 2.0. Any
    expression that is syntactically valid and executes successfully in
    both XPath 2.0 and XQuery 1.0 will return the same result in both
    languages. Since these languages are so closely related, their
    grammars and language descriptions are generated from a common
    source to ensure consistency, and the editors of these
    specifications work together closely.

**** IRI is an extention of URI.					:rdf:
  URI is still used in documentation for backward compatibility
  with the larger corpus of specifications.

[Definition: Within this specification, the term
URI refers to a Universal Resource Identifier as
defined in [RFC3986] and extended in [RFC3987]
with the new name IRI.] The term URI has been
retained in preference to IRI to avoid introducing
new names for concepts such as "Base URI" that are
defined or referenced across the whole family of
XML specifications.



[Definition: Statically known documents. This is a
mapping from strings onto types. The string
represents the absolute URI of a resource that is
potentially available using the fn:doc
function. The type is the static type of a call to
fn:doc with the given URI as its literal
argument. ] If the argument to fn:doc is a string
literal that is not present in statically known
documents, then the static type of fn:doc is
document-node()?.

Note:

The purpose of the statically known documents is
to provide static type information, not to
determine which documents are available. A URI
need not be found in the statically known
documents to be accessed using fn:doc.

**** xmlpatterns -- A tool for running XQuery queries.			:rdf:

     -                          When appearing, any following options are not 
			       	interpreted as switches.
     -help                      Displays this help.
     -initial-template <string> The name of the initial template to call as a 
			       	Clark Name.
     -is-uri                    If specified, all filenames on the command line 
			       	are interpreted as URIs instead of a local
			       	filenames.
     -no-format                 By default output is formatted for readability. 
			       	When specified, strict serialization is
			       	performed.
     -output <local file>       A local file to which the output should be 
			       	written. The file is overwritten, or if not
			       	exist, created. If absent, stdout is used.
     -param <name=value>        Binds an external variable. The value is 
			       	directly available using the variable
			       	reference: $name.
     -version                   Displays version information.
     focus <string>             The document to use as focus. Mandatory in case 
			       	a stylesheet is used. This option is also
			       	affected by the is-uris option.
     query/stylesheet <string>  A local filename pointing to the query to run. 
			       	If the name ends with .xsl it's assumed to be
			       	an XSL-T stylesheet. If it ends with .xq, it's
			       	assumed to be an XQuery query. (In other cases
			       	it's also assumed to be an XQuery query, but
			       	that interpretation may change in a future
			       	release of Qt.)

**** XPath is defined 
     in terms of the data model and the expression context.
**** XPath defines						  :rdf:debug:
     two phases of processing called the static
     analysis phase and the dynamic evaluation phase
***** thus
      (((data-model) (expression-context)) 
      (xpath) 
      ((static-analysis-phase) (dynamic-evalution-phase)))
**** rdf							  :rdf:debug:
**** owl							    :rdf:owl:
***** owl2 in triples						    :rdf:owl:
****** DONE load these triples into the ts triple-store
****** Annotations

       "... the OWL 2 RDF-Based Semantics includes many semantic
       conditions that can in a sense be regarded as being
       "axiomatic", and thus can be considered a replacement for
       the missing axiomatic triples."
       [[file:///usr/share/doc/w3-recs/html/www.w3.org/TR/2009/REC-owl2-rdf-based-semantics-20091027/index.html#Appendix:_Axiomatic_Triples_.28Informative.29]]

****** owl2 in turtle

owl:AllDifferent rdf:type rdfs:Class .

owl:AllDifferent rdfs:subClassOf rdfs:Resource .

owl:AllDisjointClasses rdf:type rdfs:Class .

owl:AllDisjointClasses rdfs:subClassOf rdfs:Resource .

owl:AllDisjointProperties rdf:type rdfs:Class .

owl:AllDisjointProperties rdfs:subClassOf rdfs:Resource .

owl:Annotation rdf:type rdfs:Class .

owl:Annotation rdfs:subClassOf rdfs:Resource .

owl:AnnotationProperty rdf:type rdfs:Class .

owl:AnnotationProperty rdfs:subClassOf rdf:Property .

owl:AsymmetricProperty rdf:type rdfs:Class .

owl:AsymmetricProperty rdfs:subClassOf owl:ObjectProperty .

owl:Axiom rdf:type rdfs:Class .

owl:Axiom rdfs:subClassOf rdfs:Resource .

owl:Class rdf:type rdfs:Class .

owl:Class rdfs:subClassOf rdfs:Class .

owl:DataRange rdf:type rdfs:Class .

owl:DataRange rdfs:subClassOf rdfs:Datatype .

owl:DatatypeProperty rdf:type rdfs:Class .

owl:DatatypeProperty rdfs:subClassOf rdf:Property .

owl:DeprecatedClass rdf:type rdfs:Class .

owl:DeprecatedClass rdfs:subClassOf rdfs:Class .

owl:DeprecatedProperty rdf:type rdfs:Class .

owl:DeprecatedProperty rdfs:subClassOf rdf:Property .

owl:FunctionalProperty rdf:type rdfs:Class .

owl:FunctionalProperty rdfs:subClassOf rdf:Property .

owl:InverseFunctionalProperty rdf:type rdfs:Class .

owl:InverseFunctionalProperty rdfs:subClassOf owl:ObjectProperty .

owl:IrreflexiveProperty rdf:type rdfs:Class .

owl:IrreflexiveProperty rdfs:subClassOf owl:ObjectProperty .

owl:NamedIndividual rdf:type rdfs:Class .

owl:NamedIndividual rdfs:subClassOf owl:Thing .

owl:NegativePropertyAssertion rdf:type rdfs:Class .

owl:NegativePropertyAssertion rdfs:subClassOf rdfs:Resource .

owl:Nothing rdf:type owl:Class .

owl:Nothing rdfs:subClassOf owl:Thing .

owl:ObjectProperty rdf:type rdfs:Class .

owl:ObjectProperty rdfs:subClassOf rdf:Property .

owl:Ontology rdf:type rdfs:Class .

owl:Ontology rdfs:subClassOf rdfs:Resource .

owl:OntologyProperty rdf:type rdfs:Class .

owl:OntologyProperty rdfs:subClassOf rdf:Property .

owl:ReflexiveProperty rdf:type rdfs:Class .

owl:ReflexiveProperty rdfs:subClassOf owl:ObjectProperty .

owl:Restriction rdf:type rdfs:Class .

owl:Restriction rdfs:subClassOf owl:Class .

owl:SymmetricProperty rdf:type rdfs:Class .

owl:SymmetricProperty rdfs:subClassOf owl:ObjectProperty .

owl:Thing rdf:type owl:Class .

owl:TransitiveProperty rdf:type rdfs:Class .

owl:TransitiveProperty rdfs:subClassOf owl:ObjectProperty .

******* Axiomatic Triples for the Properties

owl:allValuesFrom rdf:type rdf:Property .

owl:allValuesFrom rdfs:domain owl:Restriction .

owl:allValuesFrom rdfs:range rdfs:Class .

owl:annotatedProperty rdf:type rdf:Property .

owl:annotatedProperty rdfs:domain rdfs:Resource .

owl:annotatedProperty rdfs:range rdfs:Resource .

owl:annotatedSource rdf:type rdf:Property .

owl:annotatedSource rdfs:domain rdfs:Resource .

owl:annotatedSource rdfs:range rdfs:Resource .

owl:annotatedTarget rdf:type rdf:Property .

owl:annotatedTarget rdfs:domain rdfs:Resource .

owl:annotatedTarget rdfs:range rdfs:Resource .

owl:assertionProperty rdf:type rdf:Property .

owl:assertionProperty rdfs:domain owl:NegativePropertyAssertion .

owl:assertionProperty rdfs:range rdf:Property .

owl:backwardCompatibleWith rdf:type owl:AnnotationProperty .

owl:backwardCompatibleWith rdf:type owl:OntologyProperty .

owl:backwardCompatibleWith rdfs:domain owl:Ontology .

owl:backwardCompatibleWith rdfs:range owl:Ontology .

owl:bottomDataProperty rdf:type owl:DatatypeProperty .

owl:bottomDataProperty rdfs:domain owl:Thing .

owl:bottomDataProperty rdfs:range rdfs:Literal .

owl:bottomObjectProperty rdf:type owl:ObjectProperty .

owl:bottomObjectProperty rdfs:domain owl:Thing .

owl:bottomObjectProperty rdfs:range owl:Thing .

owl:cardinality rdf:type rdf:Property .

owl:cardinality rdfs:domain owl:Restriction .

owl:cardinality rdfs:range xsd:nonNegativeInteger .

owl:complementOf rdf:type rdf:Property .

owl:complementOf rdfs:domain owl:Class .

owl:complementOf rdfs:range owl:Class .

owl:datatypeComplementOf rdf:type rdf:Property .

owl:datatypeComplementOf rdfs:domain rdfs:Datatype .

owl:datatypeComplementOf rdfs:range rdfs:Datatype .

owl:deprecated rdf:type owl:AnnotationProperty .

owl:deprecated rdfs:domain rdfs:Resource .

owl:deprecated rdfs:range rdfs:Resource .

owl:differentFrom rdf:type rdf:Property .

owl:differentFrom rdfs:domain owl:Thing .

owl:differentFrom rdfs:range owl:Thing .

owl:disjointUnionOf rdf:type rdf:Property .

owl:disjointUnionOf rdfs:domain owl:Class .

owl:disjointUnionOf rdfs:range rdf:List .

owl:disjointWith rdf:type rdf:Property .

owl:disjointWith rdfs:domain owl:Class .

owl:disjointWith rdfs:range owl:Class .

owl:distinctMembers rdf:type rdf:Property .

owl:distinctMembers rdfs:domain owl:AllDifferent .

owl:distinctMembers rdfs:range rdf:List .

owl:equivalentClass rdf:type rdf:Property .

owl:equivalentClass rdfs:domain rdfs:Class .

owl:equivalentClass rdfs:range rdfs:Class .

owl:equivalentProperty rdf:type rdf:Property .

owl:equivalentProperty rdfs:domain rdf:Property .

owl:equivalentProperty rdfs:range rdf:Property .

owl:hasKey rdf:type rdf:Property .

owl:hasKey rdfs:domain owl:Class .

owl:hasKey rdfs:range rdf:List .

owl:hasSelf rdf:type rdf:Property .

owl:hasSelf rdfs:domain owl:Restriction .

owl:hasSelf rdfs:range rdfs:Resource .

owl:hasValue rdf:type rdf:Property .

owl:hasValue rdfs:domain owl:Restriction .

owl:hasValue rdfs:range rdfs:Resource .

owl:imports rdf:type owl:OntologyProperty .

owl:imports rdfs:domain owl:Ontology .

owl:imports rdfs:range owl:Ontology .

owl:incompatibleWith rdf:type owl:AnnotationProperty .

owl:incompatibleWith rdf:type owl:OntologyProperty .

owl:incompatibleWith rdfs:domain owl:Ontology .

owl:incompatibleWith rdfs:range owl:Ontology .

owl:intersectionOf rdf:type rdf:Property .

owl:intersectionOf rdfs:domain rdfs:Class .

owl:intersectionOf rdfs:range rdf:List .

owl:inverseOf rdf:type rdf:Property .

owl:inverseOf rdfs:domain owl:ObjectProperty .

owl:inverseOf rdfs:range owl:ObjectProperty .

owl:maxCardinality rdf:type rdf:Property .

owl:maxCardinality rdfs:domain owl:Restriction .

owl:maxCardinality rdfs:range xsd:nonNegativeInteger .

owl:maxQualifiedCardinality rdf:type rdf:Property .

owl:maxQualifiedCardinality rdfs:domain owl:Restriction .

owl:maxQualifiedCardinality rdfs:range xsd:nonNegativeInteger .

owl:members rdf:type rdf:Property .

owl:members rdfs:domain rdfs:Resource .

owl:members rdfs:range rdf:List .

owl:minCardinality rdf:type rdf:Property .

owl:minCardinality rdfs:domain owl:Restriction .

owl:minCardinality rdfs:range xsd:nonNegativeInteger .

owl:minQualifiedCardinality rdf:type rdf:Property .

owl:minQualifiedCardinality rdfs:domain owl:Restriction .

owl:minQualifiedCardinality rdfs:range xsd:nonNegativeInteger .

owl:onClass rdf:type rdf:Property .

owl:onClass rdfs:domain owl:Restriction .

owl:onClass rdfs:range owl:Class .

owl:onDataRange rdf:type rdf:Property .

owl:onDataRange rdfs:domain owl:Restriction .

owl:onDataRange rdfs:range rdfs:Datatype .

owl:onDatatype rdf:type rdf:Property .

owl:onDatatype rdfs:domain rdfs:Datatype .

owl:onDatatype rdfs:range rdfs:Datatype .

owl:oneOf rdf:type rdf:Property .

owl:oneOf rdfs:domain rdfs:Class .

owl:oneOf rdfs:range rdf:List .

owl:onProperty rdf:type rdf:Property .

owl:onProperty rdfs:domain owl:Restriction .

owl:onProperty rdfs:range rdf:Property .

owl:onProperties rdf:type rdf:Property .

owl:onProperties rdfs:domain owl:Restriction .

owl:onProperties rdfs:range rdf:List .

owl:priorVersion rdf:type owl:AnnotationProperty .

owl:priorVersion rdf:type owl:OntologyProperty .

owl:priorVersion rdfs:domain owl:Ontology .

owl:priorVersion rdfs:range owl:Ontology .

owl:propertyChainAxiom rdf:type rdf:Property .

owl:propertyChainAxiom rdfs:domain owl:ObjectProperty .

owl:propertyChainAxiom rdfs:range rdf:List .

owl:propertyDisjointWith rdf:type rdf:Property .

owl:propertyDisjointWith rdfs:domain rdf:Property .

owl:propertyDisjointWith rdfs:range rdf:Property .

owl:qualifiedCardinality rdf:type rdf:Property .

owl:qualifiedCardinality rdfs:domain owl:Restriction .

owl:qualifiedCardinality rdfs:range xsd:nonNegativeInteger .

owl:sameAs rdf:type rdf:Property .

owl:sameAs rdfs:domain owl:Thing .

owl:sameAs rdfs:range owl:Thing .

owl:someValuesFrom rdf:type rdf:Property .

owl:someValuesFrom rdfs:domain owl:Restriction .

owl:someValuesFrom rdfs:range rdfs:Class .

owl:sourceIndividual rdf:type rdf:Property .

owl:sourceIndividual rdfs:domain owl:NegativePropertyAssertion .

owl:sourceIndividual rdfs:range owl:Thing .

owl:targetIndividual rdf:type rdf:Property .

owl:targetIndividual rdfs:domain owl:NegativePropertyAssertion .

owl:targetIndividual rdfs:range owl:Thing .

owl:targetValue rdf:type rdf:Property .

owl:targetValue rdfs:domain owl:NegativePropertyAssertion .

owl:targetValue rdfs:range rdfs:Literal .

owl:topDataProperty rdf:type owl:DatatypeProperty .

owl:topDataProperty rdfs:domain owl:Thing .

owl:topDataProperty rdfs:range rdfs:Literal .

owl:topObjectProperty rdf:type rdf:ObjectProperty .

owl:topObjectProperty rdfs:domain owl:Thing .

owl:topObjectProperty rdfs:range owl:Thing .

owl:unionOf rdf:type rdf:Property .

owl:unionOf rdfs:domain rdfs:Class .

owl:unionOf rdfs:range rdf:List .

owl:versionInfo rdf:type owl:AnnotationProperty .

owl:versionInfo rdfs:domain rdfs:Resource .

owl:versionInfo rdfs:range rdfs:Resource .

owl:versionIRI rdf:type owl:OntologyProperty .

owl:versionIRI rdfs:domain owl:Ontology .

owl:versionIRI rdfs:range owl:Ontology .

owl:withRestrictions rdf:type rdf:Property .

owl:withRestrictions rdfs:domain rdfs:Datatype .

owl:withRestrictions rdfs:range rdf:List .
	
******* Axiomatic Triples for the Datatypes

xsd:anyURI rdf:type rdfs:Datatype .

xsd:anyURI rdfs:subClassOf rdfs:Literal .

xsd:base64Binary rdf:type rdfs:Datatype .

xsd:base64Binary rdfs:subClassOf rdfs:Literal .

xsd:boolean rdf:type rdfs:Datatype .

xsd:boolean rdfs:subClassOf rdfs:Literal .

xsd:byte rdf:type rdfs:Datatype .

xsd:byte rdfs:subClassOf rdfs:Literal .

xsd:dateTime rdf:type rdfs:Datatype .

xsd:dateTime rdfs:subClassOf rdfs:Literal .

xsd:dateTimeStamp rdf:type rdfs:Datatype .

xsd:dateTimeStamp rdfs:subClassOf rdfs:Literal .

xsd:decimal rdf:type rdfs:Datatype .

xsd:decimal rdfs:subClassOf rdfs:Literal .

xsd:double rdf:type rdfs:Datatype .

xsd:double rdfs:subClassOf rdfs:Literal .

xsd:float rdf:type rdfs:Datatype .

xsd:float rdfs:subClassOf rdfs:Literal .

xsd:hexBinary rdf:type rdfs:Datatype .

xsd:hexBinary rdfs:subClassOf rdfs:Literal .

xsd:int rdf:type rdfs:Datatype .

xsd:int rdfs:subClassOf rdfs:Literal .

xsd:integer rdf:type rdfs:Datatype .

xsd:integer rdfs:subClassOf rdfs:Literal .

xsd:language rdf:type rdfs:Datatype .

xsd:language rdfs:subClassOf rdfs:Literal .

xsd:long rdf:type rdfs:Datatype .

xsd:long rdfs:subClassOf rdfs:Literal .

xsd:Name rdf:type rdfs:Datatype .

xsd:Name rdfs:subClassOf rdfs:Literal .

xsd:NCName rdf:type rdfs:Datatype .

xsd:NCName rdfs:subClassOf rdfs:Literal .

xsd:negativeInteger rdf:type rdfs:Datatype .

xsd:negativeInteger rdfs:subClassOf rdfs:Literal .

xsd:NMTOKEN rdf:type rdfs:Datatype .

xsd:NMTOKEN rdfs:subClassOf rdfs:Literal .

xsd:nonNegativeInteger rdf:type rdfs:Datatype .

xsd:nonNegativeInteger rdfs:subClassOf rdfs:Literal .

xsd:nonPositiveInteger rdf:type rdfs:Datatype .

xsd:nonPositiveInteger rdfs:subClassOf rdfs:Literal .

xsd:normalizedString rdf:type rdfs:Datatype .

xsd:normalizedString rdfs:subClassOf rdfs:Literal .

rdf:PlainLiteral rdf:type rdfs:Datatype .

rdf:PlainLiteral rdfs:subClassOf rdfs:Literal .

xsd:positiveInteger rdf:type rdfs:Datatype .

xsd:positiveInteger rdfs:subClassOf rdfs:Literal .

owl:rational rdf:type rdfs:Datatype .

owl:rational rdfs:subClassOf rdfs:Literal .

owl:real rdf:type rdfs:Datatype .

owl:real rdfs:subClassOf rdfs:Literal .

xsd:short rdf:type rdfs:Datatype .

xsd:short rdfs:subClassOf rdfs:Literal .

xsd:string rdf:type rdfs:Datatype .

xsd:string rdfs:subClassOf rdfs:Literal .

xsd:token rdf:type rdfs:Datatype .

xsd:token rdfs:subClassOf rdfs:Literal .

xsd:unsignedByte rdf:type rdfs:Datatype .

xsd:unsignedByte rdfs:subClassOf rdfs:Literal .

xsd:unsignedInt rdf:type rdfs:Datatype .

xsd:unsignedInt rdfs:subClassOf rdfs:Literal .

xsd:unsignedLong rdf:type rdfs:Datatype .

xsd:unsignedLong rdfs:subClassOf rdfs:Literal .

xsd:unsignedShort rdf:type rdfs:Datatype .

xsd:unsignedShort rdfs:subClassOf rdfs:Literal .

rdf:XMLLiteral rdf:type rdfs:Datatype .

rdf:XMLLiteral rdfs:subClassOf rdfs:Literal .
	
******* Axiomatic Triples for the Facets

<rdf:langRange> <rdf:type> <owl:DatatypeProperty> .

<rdf:langRange> <rdfs:domain> <rdfs:Resource> .

<rdf:langRange> <rdfs:range> <rdfs:Literal> .

<xsd:length> <rdf:type> <owl:DatatypeProperty> .

<xsd:length> <rdfs:domain> <rdfs:Resource> .

<xsd:length> <rdfs:range> <rdfs:Literal> .

<xsd:maxExclusive> <rdf:type> <owl:DatatypeProperty> .

<xsd:maxExclusive> <rdfs:domain> <rdfs:Resource> .

<xsd:maxExclusive> <rdfs:range> <rdfs:Literal> .

<xsd:maxInclusive> <rdf:type> <owl:DatatypeProperty> .

<xsd:maxInclusive> <rdfs:domain> <rdfs:Resource> .

<xsd:maxInclusive> <rdfs:range> <rdfs:Literal> .

<xsd:maxLength> <rdf:type> <owl:DatatypeProperty> .

<xsd:maxLength> <rdfs:domain> <rdfs:Resource> .

<xsd:maxLength> <rdfs:range> <rdfs:Literal> .

<xsd:minExclusive> <rdf:type> <owl:DatatypeProperty> .

<xsd:minExclusive> <rdfs:domain> <rdfs:Resource> .

<xsd:minExclusive> <rdfs:range> <rdfs:Literal> .

<xsd:minInclusive> <rdf:type> <owl:DatatypeProperty> .

<xsd:minInclusive> <rdfs:domain> <rdfs:Resource> .

<xsd:minInclusive> <rdfs:range> <rdfs:Literal> .

<xsd:minLength> <rdf:type> <owl:DatatypeProperty> .

xsd:minLength rdfs:domain rdfs:Resource .

xsd:minLength rdfs:range rdfs:Literal .

xsd:pattern rdf:type owl:DatatypeProperty .

xsd:pattern rdfs:domain rdfs:Resource .

xsd:pattern rdfs:range rdfs:Literal .
	
******* Additional Axiomatic Triples for Classes and Properties

<rdfs:Class> <rdfs:subClassOf> <owl:Class> .

<rdfs:comment> <rdf:type> <owl:AnnotationProperty> .

<rdfs:comment> <rdfs:domain> <rdfs:Resource> .

<rdfs:comment> <rdfs:range> <rdfs:Literal> .

<rdfs:Datatype> <rdfs:subClassOf> <owl:DataRange> .

<rdfs:isDefinedBy> <rdf:type> <owl:AnnotationProperty> .

<rdfs:isDefinedBy> <rdfs:domain> <rdfs:Resource> .

<rdfs:isDefinedBy> <rdfs:range> <rdfs:Resource> .

<rdfs:label> <rdf:type> <owl:AnnotationProperty> .

<rdfs:label> <rdfs:domain> <rdfs:Resource> .

<rdfs:label> <rdfs:range> <rdfs:Literal> .

<rdfs:Literal> <rdf:type> <rdfs:Datatype> .

<rdf:Property> <rdfs:subClassOf> <owl:ObjectProperty> .

<rdfs:Resource> <rdfs:subClassOf> <owl:Thing> .

<rdfs:seeAlso> <rdf:type> <owl:AnnotationProperty> .

<rdfs:seeAlso> <rdfs:domain> <rdfs:Resource> .

<rdfs:seeAlso> <rdfs:range> <rdfs:Resource> .
***** misc owl2								:rdf:
      ICEXT(I(ex:c1)) ⊆ ICEXT(I(ex:c2)) ∪ ICEXT(I(ex:c3)) . 
***** owl2 basic gloss

      owl:AllDifferent 

      owl:AllDisjointClasses 

      owl:AllDisjointProperties 

      owl:allValuesFrom 

      owl:annotatedProperty 

      owl:annotatedSource 

      owl:annotatedTarget 

      owl:Annotation 

      owl:AnnotationProperty 

      owl:assertionProperty 

      owl:AsymmetricProperty 

      owl:Axiom 

      owl:backwardCompatibleWith 

      owl:bottomDataProperty 

      owl:bottomObjectProperty 

      owl:cardinality 

      owl:Class 

      owl:complementOf 

      owl:DataRange 

      owl:datatypeComplementOf 

      owl:DatatypeProperty 

      owl:deprecated 

      owl:DeprecatedClass 

      owl:DeprecatedProperty 

      owl:differentFrom 

      owl:disjointUnionOf 

      owl:disjointWith 

      owl:distinctMembers 

      owl:equivalentClass 

      owl:equivalentProperty 

      owl:FunctionalProperty 

      owl:hasKey 

      owl:hasSelf 

      owl:hasValue 

      owl:imports 

      owl:incompatibleWith 

      owl:intersectionOf 

      owl:InverseFunctionalProperty 

      owl:inverseOf 

      owl:IrreflexiveProperty 

      owl:maxCardinality 

      owl:maxQualifiedCardinality 

      owl:members 

      owl:minCardinality 

      owl:minQualifiedCardinality 

      owl:NamedIndividual 

      owl:NegativePropertyAssertion 

      owl:Nothing 

      owl:ObjectProperty 

      owl:onClass 

      owl:onDataRange 

      owl:onDatatype 

      owl:oneOf 

      owl:onProperty 

      owl:onProperties 

      owl:Ontology 

      owl:OntologyProperty 

      owl:priorVersion 

      owl:propertyChainAxiom 

      owl:propertyDisjointWith 

      owl:qualifiedCardinality 

      owl:ReflexiveProperty 

      owl:Restriction 

      owl:sameAs 

      owl:someValuesFrom 

      owl:sourceIndividual 

      owl:SymmetricProperty 

      owl:targetIndividual 

      owl:targetValue 

      owl:Thing 

      owl:topDataProperty 

      owl:topObjectProperty 

      owl:TransitiveProperty 

      owl:unionOf 

      owl:versionInfo 

      owl:versionIRI 

      owl:withRestrictions 

***** About owl2 and axiomatic triples

_:x rdf:type owl:Class.

_:x owl:intersectionOf ( C1 … Cn ). 

_:x rdf:type owl:Class.

_:x owl:unionOf ( C1 … Cn ). 

_:x rdf:type owl:Class.

_:x owl:complementOf C. 

_:x rdf:type owl:Class.

_:x owl:oneOf ( a1 … an ). 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:allValuesFrom C .

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:someValuesFrom C .

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:hasValue a. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:hasSelf "true"^^xsd:boolean. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:cardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:qualifiedCardinality n.

_:x owl:onClass C. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:maxCardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:maxQualifiedCardinality n.

_:x owl:onClass C. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:minCardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty P.

_:x owl:minQualifiedCardinality n.

_:x owl:onClass C. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:allValuesFrom D. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:someValuesFrom D. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:hasValue v. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:cardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:qualifiedCardinality n.

_:x owl:onDataRange D. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:maxCardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:maxQualifiedCardinality n.

_:x owl:onDataRange D. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:minCardinality n. 

_:x rdf:type owl:Restriction.

_:x owl:onProperty R.

_:x owl:minQualifiedCardinality n.

_:x owl:onDataRange D. 

_:x rdf:type rdfs:Datatype.

_:x owl:datatypeComplementOf D. 

_:x rdf:type rdfs:Datatype.

_:x owl:intersectionOf (D1…Dn). 

_:x rdf:type rdfs:Datatype.

_:x owl:unionOf (D1…Dn). 

_:x rdf:type rdfs:Datatype.

_:x owl:oneOf ( v1 … vn ). 

_:x rdf:type rdfs:Datatype.

_:x owl:onDatatype DN.

_:x owl:withRestrictions (_:x1 ... _:xn).

_:xj fj vj.      j=1…n 

C1 rdfs:subClassOf C2. 

Cj owl:equivalentClass Cj+1. j=1…n-1 

C1 owl:disjointWith C2. 

_:x rdf:type owl:AllDisjointClasses.

_:x owl:members ( C1 … Cn ). 

P1 rdfs:subPropertyOf P2. 

P owl:propertyChainAxiom (P1 … Pn). 

P rdfs:domain C. 

P rdfs:range C. 

Pj owl:equivalentProperty Pj+1. j=1…n-1 

P1 owl:propertyDisjointWith P2. 

_:x rdf:type owl:AllDisjointProperties.

_:x owl:members ( P1 … Pn ). 

CN owl:disjointUnionOf ( C1 … Cn ).

P1 owl:inverseOf P2. 

P rdf:type owl:FunctionalProperty. 

P rdf:type owl:InverseFunctionalProperty. 

P rdf:type owl:ReflexiveProperty. 

P rdf:type owl:IrreflexiveProperty. 

P rdf:type owl:SymmetricProperty. 

P rdf:type owl:AsymmetricProperty. 

P rdf:type owl:TransitiveProperty. 

DN owl:equivalentClass D. 

aj owl:sameAs aj+1. j=1…n-1 

a1 owl:differentFrom a2. 

_:x rdf:type owl:AllDifferent.

_:x owl:members (a1 … an). 

a rdf:type C. 

a1 PN a2. 

a R v. 

_:x rdf:type owl:NegativePropertyAssertion.

_:x owl:sourceIndividual a1.

_:x owl:assertionProperty P.

_:x owl:targetIndividual a2. 

_:x rdf:type owl:NegativePropertyAssertion.

_:x owl:sourceIndividual a.

_:x owl:assertionProperty R.

_:x owl:targetValue v. 

C owl:hasKey (P1 … Pm R1 … Rn).

m+n>0 

CN rdf:type owl:Class. 

DN rdf:type rdfs:Datatype. 

PN rdf:type owl:ObjectProperty. 

R rdf:type owl:DatatypeProperty. 

A rdf:type owl:AnnotationProperty. 

aN rdf:type owl:NamedIndividual. 

@prefix p U. 

rdf:type rdf:type rdf:Property .

rdf:type rdfs:domain rdfs:Resource .

rdf:type rdfs:range rdfs:Class .

rdfs:Datatype rdfs:subClassOf rdfs:Class .

rdfs:isDefinedBy rdfs:subPropertyOf rdfs:seeAlso .

I(rdf:type) ∈ ICEXT(I(rdf:Property)) ,

IEXT(I(rdf:type)) ⊆ ICEXT(I(rdfs:Resource)) × ICEXT(I(rdfs:Class)) ,

ICEXT(I(rdfs:Datatype)) ⊆ ICEXT(I(rdfs:Class)) ,

IEXT(I(rdfs:isDefinedBy)) ⊆ IEXT(I(rdfs:seeAlso)) . 

I(owl:FunctionalProperty) ∈ IC 

owl:FunctionalProperty rdf:type rdfs:Class .

ICEXT(I(owl:FunctionalProperty)) ⊆ IP 

owl:FunctionalProperty rdfs:subClassOf rdf:Property .

E rdf:type rdfs:Datatype .

E rdfs:subClassOf rdfs:Literal .

I(owl:disjointWith) ∈ IP 

owl:disjointWith rdf:type rdf:Property .

IEXT(I(owl:disjointWith)) ⊆ IC × IC 

owl:disjointWith rdfs:domain owl:Class .

owl:disjointWith rdfs:range owl:Class .

E rdf:type owl:DatatypeProperty .

E rdfs:domain rdfs:Resource .

E rdfs:range rdfs:Literal .
**** prolog							     :prolog:
***** Allegro Prolog					  :prolog:lisp:gruff:
******* Release 0.98b

Release 0.98b of Allegro Prolog continues a sequence of minor bugfix releases
from 0.98, but 0.98 and its accompanying documentation have significant
changes and enhancements from earlier releases.

The prolog module can be loaded with 
#+begin_lisp
(require :prolog) .
(use-package :prolog)
prolog:==
 options
(shadowing-import '(prolog:==))(use-package :prolog)
#+end_lisp


Symbols are exported from the prolog package. If you intend to use
Prolog interactively you will probably find it convenient to execute
(use-package :prolog) also.

It happens that both the prolog and cg packages export a symbol named ==
which will signal a package conflict if there is an attempt to use both
packages. This will happen, for instance, if you try to use the prolog
package in the cg-user package without first shadowing one or the other
symbol. Usually you want == to refer to prolog:==. You will get that if you
load the prolog module and evaluate (shadowing-import '(prolog:==)) and then
(use-package :prolog).

****** User Documentation

This document is not intended as an introduction to programming in Prolog. It
assumes some programming knowledge of both Prolog and Common Lisp.

Allegro Prolog is an implementation of Prolog in Common Lisp. It is based on
the implementation developed by Peter Norvig in Paradigms of Artificial
Intelligence Programming. The code has been further optimized and useful
extensions provided, making an industrial-strength Prolog programming
environment with a flexible calling interface in both directions between
Common Lisp and Prolog.

Prolog functors are translated to compiled Common Lisp functions. A single
Lisp function combines all rules for each distinct functor/arity. Special
treatment is given for facts, that is, rules with no variables in the head
and no clauses in the body. The Lisp function automatically captures these as
data instead of code. This allows reasonably large collections of data to be
specified as regular Prolog rules. Larger, highly-scalable data sets can be
implemented by extensions outlined below.

Allegro Prolog does not intend to be an ISO-compliant Prolog, nor does it
implement the entire Prolog language. Its purpose is to provide Prolog logic
programming as an integrated extension to Common Lisp for use in Lisp
programs, not as a separate language. Many standard Prolog arithmetic,
predicate operators, and I/O operators are not implemented, as they are a
subset of the standard Common Lisp operators available using lisp/2. There is
also no support for operator syntax (e.g. infix notation), as input notation
is subsumed by sexpr syntax. These choices may be reconsidered in the future
if there is reason to if there is motivation to make Allegro Prolog a
self-standing Prolog implementation. What is provided is the basic Prolog
engine for logic programming.

Prolog source files may be loaded either compiled or interpreted, as Prolog
functors are automatically compiled upon first use. But since Allegro Prolog
programs will typically contain both Lisp and Prolog code intermixed, it is
generally a good idea to compile the files so that the Lisp code is compiled.

All public symbols are exported from the prolog package. The definitions
mostly follow Norvig. Lisp S-expression syntax is used rather than Edinburgh
syntax, although support for Edinburgh input may be provided in the future.
Prolog variables are Lisp symbols that have names that begin with the `?'
character. The anonymous variable is the symbol `?' (that is, `prolog:?').
Some symbols exported from the prolog package are eq to symbols exported from
the common-lisp package, but there is never any ambiguity between use of a
Prolog name and a Lisp name. There is no implementation of the Prolog module
system. Programmers should be aware that there is a danger of collision with
inherited symbols. For example, the symbol cl:list is not defined by Prolog
but would typically be inherited from the common-lisp package by an
application package. An attempt to make a Lisp function definition on cl:list
would be prevented by package locking, but definition as a Prolog functor is
not protected. If multiple application packages attempt to make such
definitions, they would collide on the inherited symbol.

Allegro Prolog has no known dependencies on 8-bit vs. 16-bit character images
or on ANSI vs. Modern mode images.

***** Built-in Prolog Functors

The following Prolog functors are predefined in Allegro Prolog and generally
implement the standard Prolog functionality. The set of defined functors may
be extended in the future. A few functors in this implementation accept
varying arity and are indicated with a *, as in or/*.
***** allegro-prolog functors

       =/2   ==/2   abolish/2   and/*   append/3   arg/3   assert/1   asserta/1
       assertz/1   atom/1   atomic/1   bagof/3   call/1   consult/1   
       copy-term/2   erase/1   fail/0   first/1   functor/3   ground/1   if/2   
       if/3   is/2   last/1   leash/1   length/1   listing/1   member/2   
       memberp/2 (member without backtracking)   not/1   number/1   or/*   princ
       /1   read/1   recorda/1   recordz/1   recorded/2   repeat/0   rest/1   
       retract/1   rev/2   setof/3   true/0   var/1   write/1  
      
***** ! is the Prolog cut. 
      It may written as an atom ! as well as the 1-element list (!). The
      Prolog atom predicate is equivalent to Lisp's symbolp. The Prolog
      atomic predicate is equivalent to Lisp's atom, true for any object
      that is not a cons.

***** The Prolog Top Level

Allegro Prolog does not provide a top level listener loop other than the
regular lisp listener. Prolog computation may be invoked programmatically
from Lisp using the prolog macro described below, or interactively by
executing the ?- macro. Here is a simple example interactive session using ?-
.

cl-user(2): (require :prolog)
nil
cl-user(3): (use-package :prolog)
t
cl-user(4): (?- (append ?x ?y (1 2 3)))
?x = ()
?y = (1 2 3) <ENTER>
?x = (1)
?y = (2 3) <ENTER>
?x = (1 2)
?y = (3) <ENTER>
?x = (1 2 3)
?y = () <ENTER>
No.
cl-user(5): 
***** the ?- macro
The ?- macro operates similarly to the top-level loop in interactive Prologs.
A ?- expression takes zero or more subforms which are clauses and tries to
solve them. When a solution is found, it prints the values of all variables
in the expression then reads a character from *standard-input*. (If there are
no variables it prints "Yes."). If the character is either newline (usually 
enter on a keyboard) or semicolon, Prolog backtracks and attempts to find
another solution. If the character is a period, Prolog prints "No." and
returns.

***** Defined Lisp Operators

         Lisp Operator                                                                                                                                                                                                                                                                                                                                Description                                                                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
<- clause*                      Assert a fact or rule. A macro.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                As above, but first retracts all rules for the functor with the same arity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                This is similar to the action taken for <- the first time a functor/arity is                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
                                seen within a consult, but <-- is especially useful interactively. By                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                retracting previous clauses it allows predicates to be changed and files to                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
<-- clause*                     be loaded more than once. A useful convention (in a file that might be loaded                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                rather than consulted) is to use <-- in the first rule for a particular                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                function/arity. An example of typical usage would be:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                  (<-- (member ?item (?item . ?)))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                  (<-  (member ?item (? . ?rest)) (member ?item ?rest))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
?- clause*                      Interactively try to prove the concatenation of clauses, printing unified                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                variables and then backtracking after each success. A macro.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                This function calls cl:load on its filename or pathname argument, with the                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                additional functionality that the first time <- is executed for a given                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
consult &rest filename*         predicate/arity, that predicate/arity is cleared before the new definition is                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                established. consult/1 is also available as a prolog functor, accepting a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                single filename or a list of filenames.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                A macro analogous to Lisp trace which causes printing at each of the four                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                ports to the functor: call, exit, redo, and fail. This predicate is often                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                called trace in other Prologs, but that name clashes with the standard                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                cl:trace macro.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                Leash output is printed to *trace-output*.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                If leash is called with no arguments it returns a list of the                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                currently-leashed functor/aritys currently being leashed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                When a functor/arity is leashed (or unleashed) it is automatically recompiled                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                without (or with) tail-call optimization to make leash output conform to                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                Prolog WAM model even for tail-recursive functors. The programmer does not                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                normally need to be concerned with this.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                Some built in functors such as if, not, or, and and are normally rewritten by                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                inline macro transformers so will usually not appear in leash output if                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                leashed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                Here is an example of leash. rev-member is like member but returns results                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                starting from the tail of the list:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
leash {functor arity}*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                cl-user(2): (require :prolog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                cl-user(3): (use-package :prolog)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                cl-user(4): (<-- (rev-member ?item (? . ?rest)) (rev-member ?item ?rest)) rev-member cl-user(5): (<- (rev-member ?item (?item . ?))) rev-member cl-user(6): (leash rev-member 2) t cl-user(7): (?- (rev-member ?animal (dog cat fish))) [1] Entering rev-member/2 {Unbound 1000fe7cb1} (dog cat fish) [2] Entering rev-member/2 {Unbound 1000fe7cb1} (cat fish) [3] Entering rev-member/2 {Unbound 1000fe7cb1} (fish) [4] Entering rev-member/2 {Unbound 1000fe7cb1} () [4] Failed rev-member/2 [3] Succeeded rev-member/2 fish (fish) [2] Succeeded rev-member/2 fish (cat fish) [1] Succeeded rev-member/2 fish (dog cat fish) ?animal="fish" <ENTER>
                                [1] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                 [2] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                  [3] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
                                  [3] Failed rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                 [2] Succeeded rev-member/2 cat (cat fish)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                [1] Succeeded rev-member/2 cat (dog cat fish)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                ?animal = cat <ENTER>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                [1] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                 [2] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                 [2] Failed rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                [1] Succeeded rev-member/2 dog (dog cat fish)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                ?animal = dog <ENTER>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                [1] Backtracking into rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                [1] Failed rev-member/2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                No.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                cl-user(8):                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
leash-1 functor arity           Functional version of the above.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
unleash {functor arity}*        Analogous to Lisp untrace. If called with no arguments, every                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                currently-leashed functor/arity is unleashed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
unleash-1 functor arity         Functional version of the above                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                If variable this is an integer, the debugger will be entered if leash output                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
*leash-limit*                   exceeds the specified depth. This is intended as a convenience when debugging                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                deep recursion. Initially nil.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                Leash output indents one space for each level of leashed functor. If leashing                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
*prolog-leash-indent-wrap*      is deeply recursive this indentation may make the leash output unreadable, so                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                the indentation is taken modulo the value of this variable. It must be a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                nonnegative integer, but may be set large. Initially 20.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                This may be called after new rules are asserted before making Prolog queries.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
prolog-compile-symbols functor* Called with no arguments, it compiles all functors needing (re)compilation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                Otherwise, a functor/arity will be compiled automatically the first time it                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                is called.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

Whether a rule is established by <- or assert/2, a Lisp form inside a prolog
rule executed by the lisp/2 and similar functors may not refer to the Lisp
lexical environment outside the rule definition. This restriction is
necessary because the code for the Prolog functor is not compiled until
later, after all functor/arity clauses have been combined to form its
function body.

***** The Programming Interface between Prolog and Common Lisp

In addition to the interactive query and assertion macros (e.g. ?-> and <-)
there are several operators to call in either direction between Prolog code
and Lisp code.

****** Prolog Functor                                Description                              
                                                                                       
                Execute a Lisp form from Prolog. The Lisp form is compiled (at the same
                time the Prolog predicate is compiled) and may refer to variables in   
                the surrounding dynamic Lisp environment. Lexical references cannot go 
                beyond the rule boundary. Prolog variables may be referenced, but only 
lisp arg form   in evaluated positions (i.e. not inside constants). Prolog variables   
                are dereferenced as necessary into non-dynamic-extent copies. The      
                clause fails and no Lisp code is executed if any Prolog variables in   
                the form are unbound. The result of executing the Lisp form second     
                argument is unified with the first argument.                           
                                                                                       
lisp form       As above, but the Lisp form is executed for side effect only. Any value
                returned by the form is ignored.                                       
                                                                                       
                As above, but unbound Prolog variables do not cause the clause to fail.
                If the Prolog variables referenced within the Lisp form are guaranteed 
                to be bound, this functor is more efficient than the                   
lisp* arg form  otherwise-equivalent lisp functor because it does not need to set up   
lisp* form      code to handle the unbound-variable failure case. It is often the case 
                in numeric calculation that the variables are certain to be bound. In  
                such situations it is faster to execute (lisp* ?x (1+ ?x)) than (lisp ?
                x (1+ ?x)).                                                            
                                                                                       
                A convenience functor similar to lisp but runs as a predicate and fails
                if execution of the form returns nil. The familiar Prolog numeric      
lispp form      predicates can be obtained this way:                                   
                                                                                       
                  (lispp (>= ?x 5))                                                    
                                                                                       
                As above, except that unbound Prolog variables do not cause the rule to
lispp* form     fail. lispp* is more efficient than lispp if all referenced Prolog     
                variables are bound.                                                   
                                                                                       
lisp! arg form                                                                         
lisp! form      Similar to the above functors, with the provision that any             
lisp*! arg form dynamic-extent data bound to Prolog variables in the form are consed in
lisp*! form     the heap before being passed to Lisp. See the section below on Prolog  
lispp! form     and Dynamic Extent.                                                    
lispp*! form                                                                           
                                                                                       
                This is an exact equivalent for the 2-argument lisp functor above. is  
                is the traditional name for this functor. The lisp and is in this      
                implementation are slightly more powerful than the Prolog is since they
                are capable of unifying (even destructuring) an arbitrary returned     
                value returned by the Lisp form, while the Prolog functor is intended  
is arg form     only for numerical calculations.                                       
                                                                                       
                  cl-user: (?- (is (?div ?rem) (multiple-value-list (truncate 11 3)))) 
                  ?div = 3                                                             
                  ?rem = 2                                                             
                  No.                                                                  

****** Lisp Operator                           Description                          
                                                                             
               Lisp code running inside a call to one of the the Prolog lisp 
fail           functors can call this Lisp function to cause the clause to   
               fail immediately.                                             
                                                                             
               A Lisp macro that invokes Prolog programmatically to solve the
               conjunction of the clauses. The surrounding Lisp environment  
               (lexical as well as dynamic) can be accessed using the lisp   
               functor. This example refers to the likes data in an example  
               in a later section of this document:                          
                                                                             
                 (defun human-friends-of (person)                            
                   (let ((friends nil))                                      
                     (prolog (lisp ?person person)                           
                             (likes ?person ?x)                              
                             (human ?x)                                      
                             (lisp (pushnew ?x friends)))                    
prolog clause*       friends))                                               
                                                                             
               The expansion of the prolog macro wraps a block named prolog  
               around the body so Lisp forms inside the body can easily      
               return a value:                                               
                                                                             
                 (defun human-friend-of (person)                             
                   (prolog (lisp ?person person)                             
                           (likes ?person ?x)                                
                           (human ?x)                                        
                           (lisp (return-from prolog ?x))))                  
                                                                             
               Unless there is some nonlocal exit, execution of the prolog   
               macro silently finds all solutions to the clauses.            

***** Prolog and Dynamic Extent

Computation in Prolog works by attempting to satisfy a clause and, if
successful, calling a continuation function. If that continuation fails
control may return to any previous choice point, undoing any intervening
unifications, and trying a different solution choice. Prolog unification data
and continuation functions always have dynamic extent. The implementation
exploits this by allocating Prolog variables themselves, cons structure
created by unification, and continuation closure functions on the stack, that
is, with dynamic extent. This allows Prolog code to operate with essentially
zero consing and with a resulting improvement in speed.

There are, however, certain functors that typically cons data with indefinite
extent. Solutions collected by the bagof/3 and setof/3 functors are
automatically heap consed, as are any rules stored by the assert, asserta,
assertz, recorda, and recordz functors.

The family of lisp functors are special cases. When a call to the lisp
functor is performed, the values of any Prolog variables referenced in the
Lisp form are communicated efficiently to the Lisp code using symbol macros.
But those variables may contain nested unification with other Prolog
variables, and the structure created by unification may have been consed with
dynamic extent. This is not normally a concern since the Lisp code is of
course running within the dynamic extent of the surrounding Prolog code, but
it would become an issue if the Lisp code stored the data somewhere with
indefinite extent.

Dynamic extent is only a concern for cons structures. Numeric data is
generally not stack consed.

Some examples will make this clear. Consider the following code:
#+begin_src lisp
(defun ancestors-of (person)
  (let ((ancestors nil))
    (prolog (lisp ?person person)
            (ancestor ?x person)
            (lisp (push ?x ancestors)))
    ancestors))
#+end_src
If the data returned by the ancestor predicate are atoms (e.g. symbols) there
is no problem since they cannot be stack consed. Similarly, there is no
problem with numbers and numeric calculation since the implementation
generally does not stack cons numbers. But suppose Prolog data passed to Lisp
code was created by unification:
#+begin_src lisp
(defun grandfather-pairs ()
  (let ((pairs nil))
    (prolog (grandfather ?gramp ?child)
            (lisp (push (?gramp ?child) pairs)))
    pairs))
#+end_src
... are atoms, but it would not work if the objects being passed back were conses
created by Prolog unification. But structure created by Prolog unification
has only dynamic extent -- that is, it may be consed on the stack.
Stack-consed data must be copied to the heap if it is passed outward to Lisp
or otherwise preserved outside the dynamic contour where it is created. As an
example see the function zebra-benchmark in the zebra example file.

A top-level list created by bagof and setof are automatically given
indefinite extent, as is any substructure created by unification and
collected on these lists. Therefore the programmer should not have to worry
about dynamic extent when using these predicates.

***** Tail Call Elimination

The ISO standard for Prolog apparently does not require tail-call
elimination. However, most implementations provide it to some degree. It is
certainly a valuable feature. Allegro Prolog functors usually do not perform
tail-call elimination. The Prolog compiler tries to stack cons Prolog
variables, data structure, and continuations. Stack allocation of these data
enhances performance, but stack-consed data generally prohibits tail-call
elimination.

Since tail-call elimination can be important for particular functors in
certain styles of coding, a crude control over stack consing has been
implemented at the level of an individual functor/arity. This facility is
experimental and is likely to change in future releases.

The first clause of any rule may be a cl:declare which makes declarations
about the functor. Declarations may appear in any rule for a given functor/
arity -- declarations in later rules (according to the ordering maintained by
assert and friends) override earlier declarations.

The only declarations currently supported are :tail-calls and :no-tail-calls.
The latter is the default.

  (<-- (my-member ?item (?item . ?)) (declare :tail-calls)) (<- (my-member ?item (? . ?rest)) (my-member ?item ?rest))

The (declare :tail-calls) could have been included in either or both of the
two rules.

The built in member/2 and length/2 functors are written in a way that
consumes neither Prolog nor Lisp stack, but if they had not, the version of
my-member shown above implements heap-consing by the functor and allows tail
recursion on the Lisp stack. The functor still requires Prolog stack for the
unifications performed on the ?rest Prolog variable, but this is small (one
word per unified variable) compared to the consumption of Lisp stack that
recursion would require.

Tail call elimination is subject to the normal constraints imposed by the
Lisp compiler. These are platform dependent.The presence in a functor/arity
of calls to the lisp, lispp or lisp! functors will sometimes prevent tail
call elimination. Where possible, use lisp*, lispp* and lisp*! instead.

***** The Prolog Stack

******          Lisp Name                             Description                   
                                                                             
                             Prolog maintains a stack of unifications as it  
                             tries to satisfy clauses recursively. This stack
                             is separate from the regular Lisp execution     
                             stack. The initial stack length is determined by
                             the implementation, but the stack will double in
                             length when the current length is exceeded. This
                             Lisp condition is signalled with cerror when    
                             automatic doubling will exceed the limit        
prolog-stack-overflow        contained in the variable *prolog-stack-limit*. 
                             Continuing (e.g. with the standard Lisp continue
                             function) will continue Prolog computation with 
                             the stack length doubled.                       
                                                                             
                             The only superclass of this condition is        
                             cl:condition itself. In particular, it is not a 
                             subclass of error so extraneous error handlers  
                             don't try to handle it.                         
                                                                             
prolog-stack-overflow-length This reader on the above condition returns the  
                             current stack length.                           
                                                                             
                             A special variable containing a positive integer
*prolog-stack-limit*         that specifies the size above which a           
                             prolog-stack-overflow-length will be signalled. 
                             The initial value is 4096.                      

***** I/O Functors

The set of built-in Prolog I/O functors is intentionally limited because most
input and output would naturally be done by Lisp code. A few functors are
provided for convenience.

******                Lisp Name                             Description             
                                                                             
                                        The value argument is unified with a 
                                        single datum read from               
                                        *standard-input*. This is just a     
                                        simple wrapper for the Lisp read     
                                        function. The input syntax is Lisp   
                                        syntax, not Edinburgh.               
read value [stream [stream [stream] ] ]                                      
                                        The functors read/2, read/3, and read
                                        /4 are also defined, providing the   
                                        stream, eof-error, and eof-value     
                                        optional arguments to read. If       
                                        supplied, the values of these        
                                        arguments must be grounded.          
                                                                             
                                        The value argument is written to     
                                        *standard-output*. This is just a    
                                        simple wrapper for the Lisp write    
                                        function. The output syntax is Lisp  
write value [stream]                    syntax, not Edinburgh.               
                                                                             
                                        The functor write/2 is also defined, 
                                        providing the stream, write. If      
                                        supplied, the value must be grounded.
                                                                             
princ value [stream]                    Like write but uses the Lisp princ   
                                        function.                            
                                                                             
nl [stream]                             A wrapper for the Lisp terpri        
                                        function.                            

****** Unification with standard-objects.

*******            Prolog Functor                                    Description                       
                                                                                               
                                      This Prolog functor unifies the value of a slot of a     
                                      standard instance. The instance and slot-name arguments  
                                      must be bound, otherwise the predicate silently fails.   
                                      The slot-value argument is unified against the content of
                                      the slot. A Lisp error is signalled if the slot does not 
                                      exist or is not bound. The implementation is:            
slot= inst slot-name slot-value                                                                
                                        (<-- (slot= ?instance ?slot-name ?slot-value)          
                                             (lisp ?slot-value                                 
                                                   (slot-value ?instance ?slot-name)))         
                                                                                               
                                      When it is only necessary to read a slot, this functor is
                                      faster than the two that follow.                         
                                                                                               
slot=* inst slot-name slot-value      Like lisp* except that this functor fails silently if the
                                      slot does not exist or is unbound.                       
                                                                                               
                                      As above, this Prolog functor unifies the value of a slot
                                      in a standard instance. However, if the slot is unbound  
                                      it is bound dynamically as if by letf to the value of    
                                      slot-value, and the clause succeeds. (If slot-value is   
                                      unbound or contains any unbound Prolog variables, the    
                                      clause fails.) The slot is again made unbound when       
                                      execution returns out of the continuation (by            
                                      backtracking, or by Lisp nonlocal exit). While the slot  
                                      is bound it is visible to other threads. Example:        
                                                                                               
                                        cl-user(38): (defparameter *inst* (make-instance 'foo))
slot-value inst slot-name slot-value    *inst*                                                 
                                        cl-user(39): (?- (lisp ?i *inst*)                      
                                                         (slot-value ?i a ?sv))                
                                        No.                                                    
                                        cl-user(40): (?- (lisp ?i *inst*)                      
                                                         (slot-value ?i a 123)                 
                                                         (slot-value ?i a ?sv))                
                                        ?i = #<foo>                                            
                                        ?sv = 123                                              
                                        No.                                                    
                                        cl-user(41): (?- (lisp ?i *inst*)                      
                                                         (slot-value ?i a ?sv))                
                                        No.                                                    
                                                                                               
                                      As above, except that if the slot is set it is not made  
                                      unbound when execution backtracks. The side effect of    
                                      setting the slot persists. Example:                      
                                                                                               
                                        cl-user(42): (defparameter *inst* (make-instance 'foo))
                                        *inst*                                                 
                                        cl-user(43): (?- (lisp ?i *inst*)                      
                                                         (slot-value! ?i a ?sv))               
                                        No.                                                    
slot-value! inst slot-name slot-value   cl-user(44): (?- (lisp ?i *inst*)                      
                                                         (slot-value! ?i a 123)                
                                                         (slot-value! ?i a ?sv))               
                                        ?i = #<foo>                                            
                                        ?sv = 123                                              
                                        No.                                                    
                                        cl-user(45): (?- (lisp ?i *inst*)                      
                                                         (slot-value! ?i a ?sv))               
                                        ?i = #<foo>                                            
                                        ?sv = 123                                              
                                        No.                                                    

***** The Prolog `Database' and Generators.

In its simplest model, Prolog needs only to remember rules. (A fact is simply
a rule with no trailing clauses and no variables in its head.) All rules for
a particular functor/arity are remembered in the order they were asserted and
the Prolog implementation somehow references these when that functor/arity is
invoked. Under this simple model, there is no firm distinction between that
portion of a system which the programmer considers program, that part which
he considers internal data and tables, and (sometimes) that part which he
would consider external data.

But the scaling requirements and operating characteristics of Prolog data
sets vary over enormous ranges. Many standard functors have only one or two
rules:

  (<-- (first ?x (?x . ?)))

  (<-- (member ?item (?item . ?)))
  (<-  (member ?item (? . ?rest)) (member ?item ?rest))

Functors like these are naturally represented as compiled code, or may even
be inlined. Rules which are conceptually implemented by compiled program code
are managed by the Prolog assert/abolish mechanism.

Now consider a different example (from Norvig) where a functor is defined
partly by algorithm (nontrivial rules) and partly by data (facts):

  (<-- (likes Kim Robin))
  (<-  (likes Sandy Lee))
  (<-  (likes Sandy Kim))
  (<-  (likes Robin cats))
  (<-  (likes Sandy ?x) (likes ?x cats))
  (<-  (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
  (<-  (likes ?x ?x))

The likes/2 predicate has seven rules, four of which are facts. Despite the
combination of programmatic rules and facts, this combined data is still
small enough to be represented directly by the code implementing the functor/
arity predicate. (This is true especially for Allegro Prolog since compiled
functors capture facts as constant data, rather that expanding them into
volumous Lisp code.) However, this representation would become unwieldy if
the number of individuals represented in the data were a few orders of
magnitude larger, and especially if more of the individuals had idiosyncratic
affinities. The factual data would better be represented in tabular form,
usually called recorded databases in Prolog. These are managed by functors
such as recorda. Prolog stores recorded facts in an equal-key hashtable.

Note that details of the following functors differ in some ways from those of
other Prolog implementations, and the API may change in the future. The
predicates assert/1, asserta/1, assertz/1 and abolish/2 pertain to the
compiled predicate database. The predicates recorda/2, recordz/2, retract/1,
and retractall/1 pertain to the hashtable database of facts. The hashtable
database is not automatically referenced by compiled functors; it is
consulted only by the recorded/2 predicate.

***** AllegroCache Object Database 
There is a separate interface to the AllegroCache object database described 
below.

******    Prolog Functor                           Description                      
                                                                             
                      Asserts a single rule into the database. The new rule  
                      is placed after all existing rules for that functor/   
                      arity.                                                 
                                                                             
                      Note that assert/1 takes a single list of clauses,     
assertz rule          therefore one would write                              
                                                                             
                      ... (assert ((likes ?name Lisp))) ...                  
                                                                             
                      and not                                                
                                                                             
                      ... (assert (likes ?name Lisp)) ...                    
                                                                             
assert rule           Same as assertz.                                       
                                                                             
asserta rule          Like assertz except the new rule is placed before all  
                      existing rules..                                       
                                                                             
abolish functor arity All rules for the functor/arity are removed.           

A typical Prolog application will reason over sets of data. In small
programming examples, the data is simply included as `facts' that are part of
the program source itself. Reading facts from an external source and
asserting them into the program is not much different. While a clever Prolog
implementation can optimize collections of facts, this approach cannot scale
indefinitely. First, it requires the facts be captured as data belonging to
the function. Second, efficient reasoning over large data sets requires
knowledge about how the data will be accessed. Often this is really an
indexing problem, and the application programmer must guide the system by
describing (or implementing) how the data is indexed. It is no coincidence
that this concern is similar to database implementation.

A Prolog functor/arity is compiled automatically the first time it is called.
Any assert or retract to that functor/arity automatically invalidates the
compiled function such that it will be recompiled the next time it is called.
While the Allegro compiler is reasonably fast, performance may be poor if
dynamic fact/rule management is performed using assert and retract with high
bandwidth, interspersed with calls to the functor/arity. In such applications
it would be better to use the recorded interface or some other custom fact
maintenance code, perhaps using generator.

******  Prolog Functor                           Description                        
                                                                             
                  Asserts a single new rule into the recorded database, keyed
                  on the key which is the head of the rule. Only the functor 
recordz rule      and arity are considered in matching the key. The new rule 
                  is placed after all existing rules for that key. See the   
                  example below under generator.                             
                                                                             
recorda rule      Same as recordz except that the new rule is placed before  
                  all current rules for key.                                 
                                                                             
                  Finds the list of rules matching key in the recorded       
recorded key rule database and unifies rule successively to each rule. Only  
                  the functor and arity are considered in matching the key.  
                                                                             
retract key       All rules for the key are removed from the recorded        
                  database. Succeeds only if something is deleted.           

A common idiom for solving the data set issue is to construct a Lisp closure
that iteratively generates the data items to be returned. The following
functors support this use.

******         Prolog Functor                                           Description                                 
                                                                                                             
                                The generator argument should be a Lisp closure that returns an item each    
                                time it is called. When there are no more items, it should return nil. This  
                                protocol cannot be used with generators that may return nil; see generator*  
                                below. The item argument is unified with the returned item.                  
                                                                                                             
                                Example:                                                                     
                                                                                                             
                                  ;; This asserts facts into the record database all the package             
                                  ;; inheritances in the running Lisp.                                       
                                  cl-user(40): (?- (lisp ?gen (let ((packages (list-all-packages)))          
                                                                (lambda () (pop packages))))                 
                                                   (generator ?package ?gen)                                 
                                                   (lisp ?used-list (package-use-list ?package))             
generator item generator                           (member ?used ?used-list)                                 
                                                   (recordz (use ?package ?used))                            
                                                   (fail))                                                   
                                  No.                                                                        
                                  ;; This queries which packages are used by the current package.            
                                  cl-user(41): (?- (lisp ?package *package*)                                 
                                                   (recorded (use ?package ?) (? ? ?used)))                  
                                  ?package = #<The common-lisp-user package>                                 
                                  ?t = #<The prolog package>                                                 
                                  ?package = #<The common-lisp-user package>                                 
                                  ?t = #<The common-lisp package>                                            
                                  ?package = #<The common-lisp-user package>                                 
                                  ?t = #<The excl package>                                                   
                                  No.                                                                        
                                                                                                             
                                Similar to generator but suitable when generated items may include nil. The  
generator* item generator       generator should return two values: the item, and a boolean indicating that  
                                an item was returned. When there are no more items the second value should be
                                nil.                                                                         
                                                                                                             
                                This is a convenience shortcut for typical use of the generator functor. The 
                                second argument is a lisp form that returns the generator closure. The values
                                it generates are unified against the first argument. The example above could 
                                be written more conveniently this way:                                       
                                                                                                             
generating item lisp-generator    cl-user(40): (?- (generating ?package (let ((packages (list-all-packages)))
                                                                          (lambda () (pop packages))))       
                                                   (lisp ?used-list (package-use-list ?package))             
                                                   (member ?used ?used-list)                                 
                                                   (recordz (use ?package ?used))                            
                                                   (fail))                                                   
                                  No.                                                                        
                                                                                                             
generating* item lisp-generator As above for generator*.                                                     
***** prolog lattice
A Prolog program that walks a lattice of linked objects is naturally
implemented using the lisp operator to follow links using standard Lisp
accessors.

  (<-- (class-subclass-gen ?gen ?class)
       (lisp ?gen
             (let ((class-stack (list
                                 (if (symbolp ?class)
                                     (find-class ?class)
                                   ?class))))
               (lambda ()
                 (let ((class (pop class-stack)))
                   (when class
                     (loop for subclass in (clos:class-direct-subclasses class)
                            do (push subclass class-stack))
                     class))))))

  (<-- (has-initarg-p ?class ?slot-name ?initarg)
       (lisp t (typep ?class 'standard-class))
       (lisp ?dslotds (clos:class-direct-slots ?class))
       (member ?dslotd ?dslotds)
       (lisp ?initargs (clos:slot-definition-initargs ?dslotd))
       (member ?initarg ?initargs)
       (lisp ?slot-name (clos:slot-definition-name ?dslotd)))

  (<-- (class-initarg ?root-class ?class ?slot-name ?initarg)
       (class-subclass-gen ?gen ?root-class)
       (generator ?class ?gen)
       (has-initarg-p ?class ?slot-name ?initarg))

  ;; This query will unify to each standard-class and slot that has a
  ;; :documentation initialization argument.
  ;;   (?- (class-initarg t ?class ?slot :documentation))

But querying large collections of relational data may require the programmer
to inform the system how the data should be stored and indexed. Allegro
Prolog has under development some general mechanisms for indexing data sets,
or else an application programmer may implement his own custom mechanisms.
For example, the application programmer might back end the Prolog program
with a full relational or object database. These possibilities are under
active exploration as extensions.

***** The Interface to AllegroCache
****** SeeAlso AllegroGraph, Gruff
Prolog code can reason directly over data stored in an AllegroCache database.
The interface is contained in the pcache module which can be loaded with
(require :pcache). The module is currently distributed as part of the
AllegroCache distribution.

The interface consists of the single prolog:db functor. This functor has
variable arity.

******                Prolog Functor                          Description           
                                                                             
                                             The db functor should only be   
                                             executed in a dynamic (Lisp)    
                                             environment in which the        
                                             *allegrocache* variable is bound
                                             to an open AllegroCache         
                                             database. The class argument    
                                             must be grounded and have the   
                                             value of a persistent-metaclasss
                                             class or the name of such a     
                                             class. ?instance is a variable  
                                             that will be unified with a     
                                             succession of instances of that 
                                             class. If there are no          
                                             additional arguments, the clause
                                             succeeds once for each instance 
                                             of that class in the database.  
                                                                             
                                             If there are additional         
db class ?instance { slot-name slot-value }* arguments, they are pairs of    
                                             slot-names and slot-values. Each
                                             slot-name must be grounded and  
                                             be a symbol naming a slot. If   
                                             ungrounded, the functor silently
                                             fails. The value of that slot is
                                             unified against the slot-value  
                                             which may be grounded or not.   
                                                                             
                                             If the first slot is indexed and
                                             the first value is fully        
                                             grounded, retrieval uses        
                                             AllegroCache's indexing and is  
                                             fast. Otherwise retrieval may   
                                             need to iterate over all        
                                             instances of the class.         
                                             Improvements in this simple     
                                             indexing strategy may be        
                                             explored in future releases.    

This is an example of a Roman numeral database that can do arithmetic by
database lookup. The objects in the database store Roman numeral and English
representations. The example retrieves the integer and English representation
of numbers that are half the value of perfect squares that are multiples of
100.

(defclass roman ()
  ((int     :accessor int     :index :any-unique :initarg :int)
   (roman   :accessor roman   :index :any-unique :initarg :roman)
   (english :accessor english :index :any-unique :initarg :english)
   (0mod100 :accessor 0mod100 :index :any        :initarg :0mod100)
   (square  :accessor square  :initarg :square))
  (:metaclass db.allegrocache:persistent-class))

(defun test-populate ()
  (with-file-database ("roman.db" :if-exists :supersede :if-does-not-exist :create)
    (loop for i from 1 to 500
        do (make-instance 'roman
             :int i
             :roman   (intern (format nil "~@r" i) (load-time-value (find-package :keyword)))
             :english (mapcar (lambda (string)
                                (intern string
                                        (load-time-value (find-package :keyword))))
                              (split-re "[ -]" (format nil "~r" i)))
             :0mod100 (zerop (mod i 100))
             :square (* i i)))))

(defmacro with-file-database ((name
                               &key (if-exists nil if-exists-p)
                                    (if-does-not-exist nil if-does-not-exist-p)
                                    read-only)
                              &body body)
  `(let ((db.allegrocache:*allegrocache* nil))
     (unwind-protect
         (multiple-value-prog1
             (progn
               (db.allegrocache:open-file-database
                ,name
                ,@(and if-exists-p
                       `(:if-exists ,if-exists))
                ,@(and if-does-not-exist-p
                       `(:if-does-not-exist ,if-does-not-exist)))
               ,@body)
           (unless ,read-only
             (db.allegrocache:commit)))
       (when db.allegrocache:*allegrocache*
         (db.allegrocache:close-database db.allegrocache:*allegrocache*)))))

cl-user(15): (test-populate)
nil
cl-user(16): (with-file-database ("roman.db")
               (?- (bagof (?half ?english)
                          (and
                           (db roman ?r 0mod100 t int ?int english ?english square ?square)
                           (lisp ?half (truncate ?int 2))
                           (db roman ?r2 int ?half english ?english-half))
                          ?bag)))
?r = 
?english = 
?square = 
?int = 
?r2 = 
?half = 
?english-half = 
?bag = ((100 (two hundred)) (150 (three hundred)) (200 (four hundred)) (250 (five hundred))
        (50 (one hundred)))
No.

***** Known Issues.

Allegro Prolog is a new product and rough edges can be expected while
experience is gained supporting large programs. More attention is needed on
smooth integration into the Allegro program development and debugging
environment. These are some other known issues:

The interface to and capabilities of leash deserve extension better to
support debugging. A mechanism such as the Allegro CL :inside trace option
would be especially useful, as would the ability to select individually which
of a functor's four WAM ports to leash. In some cases immediately recursive
invocation of a functor will not be intercepted by leash. (The issue is
essentially the same as tracing lisp self calls.)

It might be worthwhile to make public the Prolog compiler-macro interface if
it allows better optimization of user code. However, the API and conventions
for a compiler macro are complex and need review and some convenience macros
before the machinery can be exported.

A more powerful solution to the tail-jump elimination problem is pending.

Performance could be improved in some kinds of programs by a capability to
control indexing of rule terms. This is available as the index/1 in some
Prolog implementations.

Definition of Prolog functors should be integrated into the Allegro CL source
file recording machinery. This would provide warnings about multiple
definitions, particularly in definitions on inherited symbols.

An etags extension for <- and <-- would be helpful.

Franz Inc is interested in bugs and the experience of programmers using 
Allegro Prolog. Contact support@franz.com.

***** Example: the zebra problem

Here is the Lisp code and the Prolog code for the zebra problem, a well known
example of a puzzle with a set of facts about the attributes of people who
live in adjacent houses. First here is the Lisp code:
#+begin_src lisp

;;;========== zebra.cl

;;;; -*- Mode: common-lisp; Syntax: Common-Lisp -*-

(in-package :user)
(eval-when (compile load eval)
  (use-package :prolog))

(eval-when (compile) (setf excl:*load-xref-info* nil))

(<-- (nextto ?x ?y ?list) (iright ?x ?y ?list))
(<-  (nextto ?x ?y ?list) (iright ?y ?x ?list))
(<-- (iright ?left ?right (?left ?right . ?rest)))
(<-  (iright ?left ?right (?x . ?rest))
     (iright ?left ?right ?rest))

(<-- (zebra ?h ?w ?z)
     ;; Each house is of the form:
     ;; (house nationality pet cigarette drink house-color)
     (= ?h ((house norwegian ? ? ? ?)   ;1,10
            ?
            (house ? ? ? milk ?) ? ?))  ; 9
     (member (house englishman ? ? ? red) ?h) ; 2
     (member (house spaniard dog ? ? ?) ?h) ; 3
     (member (house ? ? ? coffee green) ?h) ; 4
     (member (house ukrainian ? ? tea ?) ?h) ; 5
     (iright (house ? ? ? ? ivory)      ; 6
             (house ? ? ? ? green) ?h)
     (member (house ? snails winston ? ?) ?h) ; 7
     (member (house ? ? kools ? yellow) ?h) ; 8
     (nextto (house ? ? chesterfield ? ?) ;11
             (house ? fox ? ? ?) ?h)
     (nextto (house ? ? kools ? ?)      ;12
             (house ? horse ? ? ?) ?h)
     (member (house ? ? luckystrike oj ?) ?h) ;13
     (member (house japanese ? parliaments ? ?) ?h) ;14
     (nextto (house norwegian ? ? ? ?)  ;15
             (house ? ? ? ? blue) ?h)
     (member (house ?w ? ? water ?) ?h) ;Q1
     (member (house ?z zebra ? ? ?) ?h) ;Q2
     )

;; This runs the query:

(?- (zebra ?houses ?water-drinker ?zebra-owner))

;; These are benchmarking and profiling functions.  
;; It is believed that solving zebra a
;; single time requires 12825 inferences.

(defun zebra-benchmark (&optional (n 1000))
  (declare (optimize (speed 3) (safety 0)))
  (let (rt0 rt1)
    (time (loop initially (setf rt0 (get-internal-run-time))
              repeat n do (prolog (zebra ?houses ?water-drinker ?zebra-owner)
                                  !     ; Stop once answer is found.  
                                        ; This appears to be
                                        ; what other implementations do, 
                                        ; e.g. time/1 in
                                        ; SWI Prolog.
                                  )
              finally (setf rt1 (get-internal-run-time))))
    (let (zebra-owner water-drinker houses)
      (prolog (zebra ?houses ?water-drinker ?zebra-owner)
              ;; Nearly any cons structure created by Prolog 
              ;; unification will be consed with
              ;; dynamic extent.  It isn't safe to return such 
              ;; structure outside the contour
              ;; that created it.  Prolog doesn't need to worry, 
              ;; since unification always
              ;; has dynamic extent, but arbitrary Lisp 
              ;; code needs to be careful.  The first
              ;; two values this function will return are 
              ;; symbols, but the third is a cons
              ;; tree created by Prolog unification.  In order 
              ;; to return it, the tree needs
              ;; to be copied with indefinite extent.
              (lisp (setf zebra-owner ?zebra-owner
                          water-drinker ?water-drinker
                          houses (copy-tree ?houses)))
              !)
      (values (/ (* n 12825) (/ (- rt1 rt0) 1000.0)) ; real time 
                                                     ; is milliseconds
              zebra-owner water-drinker houses))))

;;;  zebra.cl end
#+end_src

Here is Prolog code:

#+begin_src prolog

========== zebra.pl

#+end_src

****** /* -*- Mode: prolog -*-
      *
****** This file for benchmarking against SWI Prolog.
 */

#+begin_src prolog

#+end_src
****** nextto(X, Y, List) :- iright(X, Y, List).
****** nextto(X, Y, List) :- iright(Y, X, List).
****** iright(Left, Right, [Left, Right | _]).
****** iright(Left, Right, [_ | Rest]) :- iright(Left, Right, Rest).
****** zebra(H, W, Z) :-
       	 H = [house(norwegian, _, _, _, _), _, house(_, _, _, milk, _), _, _],
       	  member(house(englishman, _, _, _, red), H),
       	  member(house(spaniard, dog, _, _, _), H),

******      member(house(_, _, _, coffee, green), H),
******      member(house(ukrainian, _,  _, tea, _), H),
******      iright(house(_, _, _, _, ivory), house(_, _, _, _, green), H),
******      member(house(_, snails, winston, _, _), H),
******      member(house(_, _, kools, _, yellow), H),
******      nextto(house(_, _, chesterfield, _, _), house(_, fox, _, _, _), H),
******      nextto(house(_, _, kools, _, _), house(_, horse, _, _, _), H),
******      member(house(_, _, luckystrike, oj, _), H),
******      member(house(japanese, _, parliaments, _, _), H),
******      nextto(house(norwegian, _, _, _, _), house(_, _, _, _, blue), H),
******      member(house(W, _, _, water, _), H),
******      member(house(Z, zebra, _, _, _), H).
****** /* This runs the query a single time:
      * 
      * ?- zebra(Houses, WaterDrinker, ZebraOwner).
      */

****** zebra1(Houses, WaterDrinker, ZebraOwner) :-
             zebra(Houses, WaterDrinker, ZebraOwner), !.

****** benchmark1 :-
             flag(benchmark,_,0),
             repeat,
             zebra1(Houses, WaterDrinker, ZebraOwner),
             flag(benchmark,N,N+1),

******         N = 1000,
             !.

****** benchmark :- time(benchmark1).
****** ========== end
#+begin_src emacs-lisp :tangle yes
(shell-command "bnf2xml")
#+end_src
***** Prolog vs. Lisp
European AI researchers favored Prolog while Americans favored Lisp,
reportedly causing many nationalistic debates on the merits of the
languages
***** Pure Prolog
Pure Prolog was soon extended, however, to include negation as
failure, in which negative conditions of the form not(Bi) are shown by
trying and failing to solve the corresponding positive conditions Bi.
***** Buran Spacecraft
the software for the Buran spacecraft was written in the Prolog
programming language.
***** SWI-Prolog and Ciao, support
      server-side web programming with support for web protocols, HTML and
      XML. There are also extensions to support semantic web formats
      such as RDF and OWL. 

****** Prolog has also been suggested as a client-side language.

^ Jan Wielemaker and Michiel Hildebrand and Jacco van Ossenbruggen (2007), "Using {Prolog} as the fundament for applications on the semantic web", in S.Heymans, A. Polleres, E. Ruckhaus, D. Pearse, and G. Gupta, Proceedings of the 2nd Workshop on Applications of Logic Programming and to the web, Semantic Web and Semantic Web Services, CEUR Workshop Proceedings (Porto, Portugal: CEUR-WS.org) 287: 84–98
^ Processing OWL2 Ontologies using Thea: An Application of Logic
Programming. Vangelis Vassiliadis, Jan Wielemaker and Chris
Mungall. Proceedings of the 5th International Workshop on OWL:
Experiences and Directions (OWLED 2009), Chantilly, VA, United States,
October 23–24, 2009

OW Prolog has been created in order to answer Prolog's lack of
graphics and interface.

JPL is a bi-directional Java Prolog bridge which ships with SWI-Prolog
by default, allowing Java and Prolog to call each other
(recursively). It is known to have good concurrency support and is
under active development.

GNU Prolog for Java is an implementation of ISO Prolog as a Java
library (gnu.prolog)

Jekejeke Prolog API provides tightly coupled concurrent call-in and
call-out facilities between Prolog and Java or Android, with the
marked possibility to create individual knowledge base objects. It can
be used to embed the ISO Prolog interpreter in standalones, applets,
servlets, APKs, etc..

***** prolog and reflection
Prolog is a homoiconic language and provides many facilities for
reflection

solve(true, 1) :- !.
solve((A, B), C) :-
    !, solve(A, C1), solve(B, C2), minimum(C1, C2, C).
solve(A, 1) :-
    builtin(A), !, A.
solve(A, C) :-
    clause_cf(A, B, C1), solve(B, C2), C is C1 * C2.

builtin(A is B).
builtin(read(X)).
% etc.

and clauses represented as clause_cf(Head, Body, Certainty). Given
those, it can be called as solve(Goal, Certainty) to execute Goal and
obtain a measure of certainty about the result.
***** Prolog's single data type is the term. 
      Terms are either atoms, numbers, variables or compound terms.

      An atom is a general-purpose name with no inherent meaning. Examples
      of atoms include x, blue, 'Taco', and 'some atom'.  Numbers can be
      floats or integers.  Variables are denoted by a string consisting of
      letters, numbers and underscore characters, and beginning with an
      upper-case letter or underscore. Variables closely resemble
      variables in logic in that they are placeholders for arbitrary
      terms.  A compound term is composed of an atom called a "functor"
      and a number of "arguments", which are again terms. Compound terms
      are ordinarily written as a functor followed by a comma-separated
      list of argument terms, which is contained in parentheses. The
      number of arguments is called the term's arity. An atom can be
      regarded as a compound term with arity zero. Examples of compound
      terms are truck_year('Mazda', 1986) and
      'Person_Friends'(zelda,[tom,jim]).

****** Special cases of compound terms:
       A List is an ordered collection of terms. It is denoted by square
       	brackets with the terms separated by commas or in the case of the
       	empty list, []. For example [1,2,3] or [red,green,blue].  Strings:
       	A sequence of characters surrounded by quotes is equivalent to a
       	list of (numeric) character codes, generally in the local
       	character encoding, or Unicode if the system supports Unicode. For
       	example, "to be, or not to be".

****** Rules and facts

Prolog programs describe relations, defined by means of clauses. Pure
Prolog is restricted to Horn clauses. There are two types of clauses:
facts and rules. A rule is of the form

****** Head :- Body.

and is read as "Head is true if Body is true". A rule's body consists
of calls to predicates, which are called the rule's goals. The
built-in predicate ,/2 (meaning a 2-arity operator with name ,)
denotes conjunction of goals, and ;/2 denotes
disjunction. Conjunctions and disjunctions can only appear in the
body, not in the head of a rule.

****** Clauses with empty bodies are called facts. An example of a fact is:

cat(tom).

which is equivalent to the rule:

cat(tom) :- true.

****** The built-in predicate true/0 is always true.

Given the above fact, one can ask:

is tom a cat?

 ?- cat(tom).
 Yes

what things are cats?

 ?- cat(X).
 X = tom

****** Clauses with bodies are called rules. 
An example of a rule is:

animal(X) :- cat(X).

If we add that rule and ask what things are animals?

 ?- animal(X).
 X = tom
****** Relational nature of many built-in-predicates
Due to the relational nature of many built-in predicates, they can
typically be used in several directions. For example, length/2 can be
used to determine the length of a list (length(List, L), given a list
List) as well as to generate a list skeleton of a given length
(length(X, 5)), and also to generate both list skeletons and their
lengths together (length(X, L)). Similarly, append/3 can be used both
to append two lists (append(ListA, ListB, X) given lists ListA and
ListB) as well as to split a given list into parts (append(X, Y,
List), given a list List). For this reason, a comparatively small set
of library predicates suffices for many Prolog programs.
****** General purpose language
As a general purpose language, Prolog also provides various built-in
predicates to perform routine activities like input/output, using
graphics and otherwise communicating with the operating system. These
predicates are not given a relational meaning and are only useful for
the side-effects they exhibit on the system. For example, the
predicate write/1 displays a term on the screen.
***** Prolog program execution
Execution of a Prolog program is initiated by the user's posting of a
single goal, called the query. Logically, the Prolog engine tries to
find a resolution refutation of the negated query. The resolution
method used by Prolog is called SLD resolution. If the negated query
can be refuted, it follows that the query, with the appropriate
variable bindings in place, is a logical consequence of the
program. In that case, all generated variable bindings are reported to
the user, and the query is said to have succeeded. Operationally,
Prolog's execution strategy can be thought of as a generalization of
function calls in other languages, one difference being that multiple
clause heads can match a given call. In that case, the system creates
a choice-point, unifies the goal with the clause head of the first
alternative, and continues with the goals of that first
alternative. If any goal fails in the course of executing the program,
all variable bindings that were made since the most recent
choice-point was created are undone, and execution continues with the
next alternative of that choice-point. This execution strategy is
called chronological backtracking. For example:

mother_child(trude, sally).
 
father_child(tom, sally).
father_child(tom, erica).
father_child(mike, tom).
 
sibling(X, Y)      :- parent_child(Z, X), parent_child(Z, Y).
 
parent_child(X, Y) :- father_child(X, Y).
parent_child(X, Y) :- mother_child(X, Y).

This results in the following query being evaluated as true:

 ?- sibling(sally, erica).
 Yes

This is obtained as follows: Initially, the only matching clause-head for the query sibling(sally, erica) is the first one, so proving the query is equivalent to proving the body of that clause with the appropriate variable bindings in place, i.e., the conjunction (parent_child(Z,sally), parent_child(Z,erica)). The next goal to be proved is the leftmost one of this conjunction, i.e., parent_child(Z, sally). Two clause heads match this goal. The system creates a choice-point and tries the first alternative, whose body is father_child(Z, sally). This goal can be proved using the fact father_child(tom, sally), so the binding Z = tom is generated, and the next goal to be proved is the second part of the above conjunction: parent_child(tom, erica). Again, this can be proved by the corresponding fact. Since all goals could be proved, the query succeeds. Since the query contained no variables, no bindings are reported to the user. A query with variables, like:

?- father_child(Father, Child).

enumerates all valid answers on backtracking.

Notice that with the code as stated above, the query ?- sibling(sally,
sally). also succeeds. One would insert additional goals to describe
the relevant restrictions, if desired.
****** non-monotonic reasoning
The built-in Prolog predicate \+/1 provides negation as failure, which
allows for non-monotonic reasoning
****** In Prolog, loading code is referred to as consulting

Hello world

An example of a query:

?- write('Hello world!'), nl.
Hello world!
true.
 
?-

****** Any computation can be expressed 
       declaratively as a sequence of state transitions.
***** design pattern
A design pattern is a general reusable solution to a commonly
occurring problem in software design. 

In Prolog, design patterns go under various names: skeletons and
techniques, cliches, program schemata, and logic description schemata.

An alternative to design patterns is higher order programming.

****** higher order predicate
A higher-order predicate is a predicate that takes one or more other
predicates as arguments

call/1, call/2, call/3, findall/3, setof/3, and bagof/3

higher-order predicates like maplist/2, which applies an arbitrary
predicate to each member of a given list, and sublist/3, which filters
elements that satisfy a given predicate, also allowing for currying
****** conversions from temporal representation
to convert solutions from temporal representation (answer substitutions
on backtracking) to spatial representation (terms), Prolog has various
all-solutions predicates that collect all answer substitutions of a
given query in a list. This can be used for list comprehension. 
******* example
For example, perfect numbers equal the sum of their proper divisors:

 perfect(N) :-
     between(1, inf, N), U is N // 2,
     findall(D, (between(1,U,D), N mod D =:= 0), Ds),
     sumlist(Ds, N).

This can be used to enumerate perfect numbers, and also to check
whether a number is perfect.
****** maplist
As another example, the predicate maplist applies a predicate P to all
corresponding positions in a pair of lists:

maplist(_P, [], []).
maplist(P, [X1|X1s], [X2|X2s]) :-
   call(P, X1, X2),
   maplist(P, X1s, X2s).

When P is a function in the sense that for all X, P(X,Y) unifies Y
with a single unique value, maplist(P, Xs, Ys) is equivalent to
applying the map function in functional programming as Ys = map(P,
Xs).

Higher-order programming style in Prolog was pioneered in HiLog and
λProlog.
***** subset of first-order predicate logic
Pure Prolog is based on a subset of first-order predicate logic, Horn
clauses, which is Turing-complete. Turing completeness of Prolog can
be shown by using it to simulate a Turing machine:

turing(Tape0, Tape) :-
    perform(q0, [], Ls, Tape0, Rs),
    reverse(Ls, Ls1),
    append(Ls1, Rs, Tape).
 
perform(qf, Ls, Ls, Rs, Rs) :- !.
perform(Q0, Ls0, Ls, Rs0, Rs) :-
    symbol(Rs0, Sym, RsRest),
    once(rule(Q0, Sym, Q1, NewSym, Action)),
    action(Action, Ls0, Ls1, [NewSym|RsRest], Rs1),
    perform(Q1, Ls1, Ls, Rs1, Rs).
 
symbol([], b, []).
symbol([Sym|Rs], Sym, Rs).
 
action(left, Ls0, Ls, Rs0, Rs) :- left(Ls0, Ls, Rs0, Rs).
action(stay, Ls, Ls, Rs, Rs).
action(right, Ls0, [Sym|Ls0], [Sym|Rs], Rs).
 
left([], [], Rs0, [b|Rs0]).
left([L|Ls], Ls, Rs, [L|Rs]).

A simple example Turing machine is specified by the facts:

rule(q0, 1, q0, 1, right).
rule(q0, b, qf, 1, stay).

This machine performs incrementation by one of a number in unary
encoding: It loops over any number of "1" cells and appends an
additional "1" at the end. Example query and result:

?- turing([1,1,1], Ts).
Ts = [1, 1, 1, 1] ;

This illustrates how any computation can be expressed declaratively as
a sequence of state transitions, implemented in Prolog as a relation
between successive states of interest.

For efficiency, Prolog code is typically compiled to abstract machine
code, often influenced by the register-based Warren Abstract Machine
(WAM) instruction set.

Prolog systems typically implement a well-known optimization method
called tail call optimization (TCO) for deterministic predicates
exhibiting tail recursion or, more generally, tail calls: A clause's
stack frame is discarded before performing a call in a tail
position. Therefore, deterministic tail-recursive predicates are
executed with constant stack space, like loops in other languages.

***** term indexing
Finding clauses that are unifiable with a term in a query is linear in
the number of clauses. Term indexing uses a data structure that
enables sublinear-time lookups. Indexing only affects program
performance, it does not affect semantics.
****** research, education and pragma 
Although Prolog is widely used in research and education, Prolog and
other logic programming languages have not had a significant impact on
the computer industry in general. Most applications are small by
industrial standards, with few exceeding 100,000 lines of
code. Programming in the large is considered to be complicated
because not all Prolog compilers support modules, and there are
compatibility problems between the module systems of the major Prolog
compilers. Portability of Prolog code across implementations has
also been a problem, but developments since 2007 have meant: "the
portability within the family of Edinburgh/Quintus derived Prolog
implementations is good enough to allow for maintaining portable
real-world applications."
****** prolog performance
Software developed in Prolog has been criticised for having a high
performance penalty compared to conventional programming
languages. However, advances in implementation methods have reduced
the penalties to as little as 25%-50% for some applications.
****** prolog is not purely declarative
Prolog is not purely declarative: because of constructs like the cut
operator, a procedural reading of a Prolog program is needed to
understand it. The order of clauses in a Prolog program is
significant. Other logic programming languages, such as Datalog, are
truly declarative but restrict the language.

The syntax of Prolog does not specify which arguments of a predicate
are inputs and which are outputs. However, this information is
significant and it is recommended that it be included in the comments
Modes provide valuable information when reasoning about Prolog
programs and can also be used to accelerate execution
Prolog systems that provide a graphics library are SWI-prolog,
Visual-prolog, LPA Prolog for Windows and B-Prolog.

***** Using Prolog with AllegroGraph 3.3 (and gruff)	       :prolog:gruff:
****** IRI 
file:///archive/xk05/Downloads/agraph-fse-3.3/doc/prolog-tutorial.html   
****** index
Using Prolog with AllegroGraph 3.3

  * AllegroGraph
      + Introduction
      + Upgrade Guide
      + Recent Changes
      + HTTP/Sesame Protocol
      + Server Installation
  * Java
      + Java Tutorial
      + Learning Center (local)
      + Learning Center (franz.com)
      + Javadocs
      + Jena
  * Python
      + Python client
      + Python Tutorial
      + Python API
  * Lisp
      + Lisp Installation
      + AllegroGraph Tutorial
      + Client
      + hasValue Reasoning Tutorial
      + Freetext indexing tutorial
      + Federation tutorial
      + Temporal tutorial
      + Geospatial tutorial
      + RDFS++ Reasoning Tutorial
      + Reference Guide
      + AllegroGraph and Prolog
  * SPARQL
      + SPARQL Tutorial
      + SPARQL Reference
      + SPARQL Client
      + SPARQL Server
      + SPARQL Geospatial Extension
      + SPARQL Construct
      + Twinql Releases Notes
  * Other
      + FAQ
      + LUBM Benchmarks
      + Performance Tuning
      + Suggested Reading
      + Community Resources
      + Copyrights
  * Franz, Inc.
  * Download

***** Introduction

We would urge you to first do this tutorial and then study the Allegro Prolog
documentation if necessary. This is a basic tutorial on how to use Prolog with
AllegroGraph 3.3. It should be enough to get you going but if you have any
questions please write to us and we will help you. In this example we will focus
mainly on how to use the following constructs:

  * select
  * q-
  * q
  * <--
  * <-
  * ??
  * !

When consulting the Reference Guide, one should understand the conventions for
documenting Prolog functors. A Prolog functor clause looks like a regular Lisp
function call, the symbol naming the functor being the first element of the list
and the remaining elements being arguments. But arguments to a Prolog functor call
can either be supplied as input to the functor, or unsupplied so that the clause
might return that argument as a result by unifying some data to it, or may be a
tree of nodes containing both ground data an Prolog variables. The common example
is the functor append which has three arguments and succeeds for any solution
there the third argument is the same as the first two arguments appended. The
remarkable thing about Prolog semantics is that append is a declarative relation
that succeeds regardless which arguments are supplied as inputs and which are
supplied as outputs. <ret> indicates where the user would type a return to ask
Prolog to find the next result.

    > (?- (append (1 2) (3) ?z))  
    ?z = (1 2 3)  
    <ret>  
    No.  
    > (?- (append (1 2) ?y (1 2 3)))  
    ?y = (3)  
    <ret>  
    No.  
    > (?- (append ?x ?y (1 2 3)))  
    ?x = ()  
    ?y = (1 2 3)  
    <ret>  
    ?x = (1)  
    ?y = (2 3)  
    <ret>  
    ?x = (1 2)  
    ?y = (3)  
    <ret>  
    ?x = (1 2 3)  
    ?y = ()  
    <ret>  
    No.  
    > (?- (append ? (1 ?next . ?) (1 2 1 3 4 1 5 1)))  
    ?next = 2  
    <ret>  
    ?next = 3  
    <ret>  
    ?next = 5  
    <ret>  
    No. 

The last example successively unifies to each element in the list immediately
preceded by a 1. It shows the power of unification against partially ground tree
structure.

Now we return to the the notational convention: A functor argument that is an
input to the functor and which must be supplied is marked in the documentaiton
with a +. A functor argument that is returned by the functor and which must not be
supplied is marked with a -. An argument that can be either is marked with ±.
(Prolog documentation generally used ? for this, but in Lisp-bnased Prologs that
character is used as the first character of a symbol that is a Prolog variable,
overloading using it to indicate and input-output argument would be very
confusing.) Within this convention append would be notated as (append &plusmn;left
&plusmn;right &plusmn;result). But a functor like part= which simply checks
whether two parts are the same UPI and which requires two actual which requires
two actual furure-part or UPI arguments, would be documented (part= +upi1 +upi2)`.

The rest of this tutorial will be based on a tiny genealogy database of the
Kennedy family.

Please open the file kennedy.ntriples that came with this distribution in a text
editor or with TopBraidComposer and study the contents of the file. Notice that
people in this file have a type, sometimes multiple children, multiple spouses,
multiple professions, and go to multiple colleges or universities.

This tutorial uses Lisp as the base language but there is also a Java example with
the same content.

***** First let us get AllegroGraph ready to use:

> (require :agraph)  
;; .... output deleted.  
 
> (in-package :triple-store-user)  
#<The db.agraph.user package>  
 
> (enable-!-reader)  
#<Function read-!>  
t  
 
> (register-namespace "ex" "http://www.franz.com/simple#"  
   :errorp nil)  
"http://www.franz.com/simple#" 

Now we can create a triple-store and load it with data. The function 
create-triple-store creates a new triple-store and opens it. If you use the
triple-store name "temp/test", then AllegroGraph will create a new directory named
temp in your current directory (use the top-level command :pwd if you want to see
what this is). It will then make another directory named test as a sub-directory
of temp. All of this triple-store's data will be placed in this new directory temp
/test:

> (defun fill-kennedy-db ()   
    (create-triple-store "temp/test"  
                         :if-exists :supersede)  
    (time  
     (load-ntriples #p"sys:agraph;tutorial-files;kennedy.ntriples"))  
    (index-all-triples))  
fill-kennedy-db  
> (fill-kennedy-db)  
;; .... output deleted. 

***** So let us first look at person1 in this database:

> (print-triples  
   (get-triples-list :s !ex:person1))  
<http://www.franz.com/simple#person1> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.franz.com/simple#person> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#first-name> <http://www.franz.com/simple#Joseph> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#middle-initial> <http://www.franz.com/simple#Patrick> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#last-name> <http://www.franz.com/simple#Kennedy> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#birth-year> <http://www.franz.com/simple#1888> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#death-year> <http://www.franz.com/simple#1969> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#sex> <http://www.franz.com/simple#male> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#spouse> <http://www.franz.com/simple#person2> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#suffix> <http://www.franz.com/simple#none> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person9> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person13> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person17> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person4> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person6> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person15> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person11> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person3> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#has-child> <http://www.franz.com/simple#person7> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#profession> <http://www.franz.com/simple#producer> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#profession> <http://www.franz.com/simple#banker> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#profession> <http://www.franz.com/simple#ambassador> .  
<http://www.franz.com/simple#person1> <http://www.franz.com/simple#alma-mater> <http://www.franz.com/simple#Harvard> . 

Now we are ready to try the select statement in combination with the Prolog q
functor. Let us try to find all the children of person1. Just type the following
in the listener. Afterward, I'll explain.

***** select
> (select (?x)  
   (q- !ex:person1 !ex:has-child ?x))  
(("http://www.franz.com/simple#person9")  
 ("http://www.franz.com/simple#person13")  
 ("http://www.franz.com/simple#person17")  
 ("http://www.franz.com/simple#person4")  
 ("http://www.franz.com/simple#person6")  
 ("http://www.franz.com/simple#person15")  
 ("http://www.franz.com/simple#person11")  
 ("http://www.franz.com/simple#person3")  
 ("http://www.franz.com/simple#person7")) 

select is a wrapper used around one or more Prolog statements. The first element
after select is template for the format and variables that you want to bind and
return. So in this example above we want to bind the variable ?x. The rest of the
elements tell Prolog what we want to bind ?x to.

This select statement has only one clause, namely (q- !ex:person1 !ex:has-child ?
x)`

If you have studied how get-triples works you probably can guess what happens
here. q- is a Prolog functor that is our link to the data in the triple-store. It
calls get-triples and unifies the ?x with the objects of all triples with subject
!ex:person1 and predicate !ex:has-child.

So let us make it a little bit more complex. Let us find all the children of the
children of person1. Here is how you do it:

> (select (?y)  
   (q- !ex:person1 !ex:has-child ?x)  
   (q- ?x !ex:has-child ?y))  
(("http://www.franz.com/simple#person33")  
 ("http://www.franz.com/simple#person26")  
 ("http://www.franz.com/simple#person28")  
 ("http://www.franz.com/simple#person31")  
 ("http://www.franz.com/simple#person25")  
 ("http://www.franz.com/simple#person62")  
 ("http://www.franz.com/simple#person56")  
 ("http://www.franz.com/simple#person42")  
 ("http://www.franz.com/simple#person47")  
 ("http://www.franz.com/simple#person51") ...) 

Although Prolog is a declarative language, a procedural reading of this query
works better for most people. So the previous query can be read as

    Find all triples that start with !ex:person1 !ex:has-child. For each match set
    ?x to the object of that triple; then for each triple that starts with ?x !
    ex:has-child find the ?y
   
The following example should now be easy to understand. Here we are trying to find
all the spouses of the grand-children of ?z. Notice that we ignore the ?x and ?y
in the query. The select will only return the ?z

> (select (?z)  
   (q- !ex:person1 !ex:has-child ?x)  
   (q- ?x !ex:has-child ?y)  
   (q- ?y !ex:spouse ?z))  
(("http://www.franz.com/simple#person34")  
 ("http://www.franz.com/simple#person27")  
 ("http://www.franz.com/simple#person30")  
 ("http://www.franz.com/simple#person32")  
 ("http://www.franz.com/simple#person63")  
 ("http://www.franz.com/simple#person57")  
 ("http://www.franz.com/simple#person43")  
 ("http://www.franz.com/simple#person49")  
 ("http://www.franz.com/simple#person48")  
 ("http://www.franz.com/simple#person52") ...) 

Now if you wanted to you could get the other variables back. Here is the same
query but now you also want to see the grand-child.

> (select (?y ?z)  
    (q- !ex:person1 !ex:has-child ?x)  
    (q- ?x !ex:has-child ?y)  
    (q- ?y !ex:spouse ?z))  
(("http://www.franz.com/simple#person33" "http://www.franz.com/simple#person34")  
 ("http://www.franz.com/simple#person26" "http://www.franz.com/simple#person27")  
 ("http://www.franz.com/simple#person28" "http://www.franz.com/simple#person30")  
 ("http://www.franz.com/simple#person31" "http://www.franz.com/simple#person32")  
 ("http://www.franz.com/simple#person62" "http://www.franz.com/simple#person63")  
 ("http://www.franz.com/simple#person56" "http://www.franz.com/simple#person57")  
 ("http://www.franz.com/simple#person42" "http://www.franz.com/simple#person43")  
 ("http://www.franz.com/simple#person47" "http://www.franz.com/simple#person49")  
 ("http://www.franz.com/simple#person47" "http://www.franz.com/simple#person48")  
 ("http://www.franz.com/simple#person51" "http://www.franz.com/simple#person52") ...) 

***** prolog functors
So now we understand the select and the q statement. We are halfway there. Let us
now define some Prolog functors.

The following defines a functor that says: ?x is a male if in the triple store I
can find an ?x that has the !ex:sex !ex:male.

> (<-- (male ?x)  
    (q- ?x !ex:sex !ex:male))  
male 

Let us try it out by finding all the sons of person1.

> (select (?x)  
    (q- !ex:person1 !ex:has-child ?x)  
    (male ?x)) ;;; Note how we use NO q here!  
(("http://www.franz.com/simple#person13")  
 ("http://www.franz.com/simple#person17")  
 ("http://www.franz.com/simple#person4")  
 ("http://www.franz.com/simple#person3")) 

Now this is not too exciting, and it is equivalent to the following:

(select (?x)  
 (q- !ex:person1 !ex:has-child ?x)  
 (q- ?x !ex:sex !ex:male)) 

So let us make it more complex:

> (<-- (female ?x)  
    (q- ?x !ex:sex !ex:female))  
female  
> (<-- (father ?x ?y)  
    (male ?x)  
    (q- ?x !ex:has-child ?y))  
father  
> (<-- (mother ?x ?y)  
    (female ?x)  
    (q- ?x !ex:has-child ?y))  
mother 

The female, father, mother relations are all simple to understand. The following
adds the idea of multiple rules (or functors). Notice how we define the parent
relationship with two rules, where the first rule uses <-- and the second rule
uses <-. The reason is that <-- means: wipe out all the previous rules that I had
about parent and start anew whereas <- means, add to the existing rules for
parent.

The following should be read as:

  * ?x is the parent of ?y if ?x is the father of ?y or
  * ?x is the parent of ?y if ?x is the mother of ?y.

        (<-- (parent ?x ?y)
       
    (father ?x ?y))  
    parent 
    
        (<- (parent ?x ?y)
   
    (mother ?x ?y))  
    parent 
    
So let us try it out by finding the grand children of person1

> (select (?y)  
    (parent !ex:person1 ?x)  
    (parent ?x ?y))  
(("http://www.franz.com/simple#person33")  
 ("http://www.franz.com/simple#person26")  
 ("http://www.franz.com/simple#person28")  
 ("http://www.franz.com/simple#person31")  
 ("http://www.franz.com/simple#person25")  
 ("http://www.franz.com/simple#person62")  
 ("http://www.franz.com/simple#person56")  
 ("http://www.franz.com/simple#person42")  
 ("http://www.franz.com/simple#person47")  
 ("http://www.franz.com/simple#person51") ...) 

We could have done the same thing by defining a grandparent functor. See the next
definition.

> (<-- (grandparent ?x ?y)  
    (parent ?x ?z)  
    (parent ?z ?y))  
grandparent  
> (<-- (grandchild ?x ?y)  
    (grandparent ?y ?x))  
grandchild 

And here it gets really interesting because we now go for the first time to a
recursive functor.

> (<-- (ancestor ?x ?y)  
    (parent ?x ?y))  
ancestor  
> (<-  (ancestor ?x ?y)      
    (parent ?x ?z)  
    (ancestor ?z ?y))                
ancestor 

Read the previous two expressions as

  * ?x is the ancestor of ?y if
      + ?x is the parent of ?y or
      + ?x is the parent of some person ?z and ?z is the ancestor of ?y

A descendant is of course the reverse of ancestor

> (<-- (descendant ?x ?y)  
    (ancestor ?y ?x))  
descendant 

So if we want to find all the male descendants of person1 then here is how to do
it.

> (select (?x)  
    (descendant ?x !ex:person1)  
    (male ?x))  
(("http://www.franz.com/simple#person13")  
 ("http://www.franz.com/simple#person17")  
 ("http://www.franz.com/simple#person4")  
 ("http://www.franz.com/simple#person3")  
 ("http://www.franz.com/simple#person33")  
 ("http://www.franz.com/simple#person28")  
 ("http://www.franz.com/simple#person31")  
 ("http://www.franz.com/simple#person25")  
 ("http://www.franz.com/simple#person62")  
 ("http://www.franz.com/simple#person47") ...) 

***** some puzzles to work out
And then here are some puzzles that you can work out for yourself.. Note the use
of not and part= in these statements. 'not' can contain any expression. part= will
compare its two arguments as UPIs; It will not unify.

> (<-- (aunt ?x ?y)  
    (father ?z ?x)  
    (female ?x)  
    (father ?z ?w)  
    (not (part= ?x ?w))  
    (parent ?w ?y))  
aunt  
> (<-- (uncle ?x ?y)  
    (father ?z ?x)  
    (male ?x)  
    (father ?z ?w)  
    (not (part= ?x ?w))  
    (parent ?w ?y))  
uncle 

And the final query: find all the children of person1 that are uncles

> (select (?x ?y)  
    (parent !ex:person1 ?x)  
    (uncle ?x ?y))  
(("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person33")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person26")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person28")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person31")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person25")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person62")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person56")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person42")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person47")  
 ("http://www.franz.com/simple#person13"  
  "http://www.franz.com/simple#person51")  
 ...)  
> 

***** another convenient shorthand
There is another convenient shorthand to know in Allegro Prolog. It is often
necessary to use small bits of Lisp code inside a series of prolog clauses. A
typical example is here, where it is necessary inside a sequence of prolog clauses
to retrieve a value from the surrounding Lisp environment. Here we define a Lisp
function that returns the first and last name of every person born in the argument
year.

    > (defun born-in-year (year)  
        (select0 (?first-name ?last-name)  
          (lisp ?year (literal (princ-to-string year)))  
          (q- ?person !ex:birth-year ?year)  
          (q- ?person !ex:first-name ?first-name)  
          (q- ?person !ex:last-name ?last-name)))  
    born-in-year  
    > (born-in-year 1915)  
    (({Joseph} {Kennedy}) ({Robert} {Shriver}))  
    t 

The year argument may be a string or an integer, but we need to convert it to a
string since that's the way birth years are stored in this particular database.
Then the argument needs to be interned as a literal. But the important point is
that we need to get the value of year from the surrounding Lisp environments and
bind it to a Prolog variable (here named ?year) so it can be passed to q-.

This necessary transfer of data into the Prolog environment clutters the code and
makes it harder to read. The ?? syntax marker can eliminate much of this:

    > (defun born-in-year (year)  
        (select0 (?first-name ?last-name)  
          (q- ?person !ex:birth-year (?? (literal (princ-to-string year))))  
          (q- ?person !ex:first-name ?first-name)  
          (q- ?person !ex:last-name ?last-name))) 

This is nothing more than a syntactic shorthand of the previous example and
operates just like it. It eliminates the need for the Prolog variable to be
visible. The body of ?? has syntax like Lisp progn and substitutes the value
computed by the progn body into the Prolog clause.

There is a problem with the syntax for the Prolog cut and AllegroGraph's
future-part syntax. Prolog uses the exclamation point ! to denote the cut
operation. When executed, a cut clears all previous backtracking points within the
current predicate. For example,

     > (<-- (parent ?x)  
            (parent ?x ?)  
            !) 

defines a predicate that tests whether the argument person a parent, but if so
succeeds only once. The ! is traditional Prolog notation, but AllegroGraph uses
the ! character as a reader macro to create a future part, so the above definition
will signal a read error when the AllegroGraph readtable is in effect (see the !
-reader macro section).

The simplest way to resolve this is to preface the Prolog ! with a backslash in
any code that might be read with the AllegroGraph readtable in effect. The
backslash suppresses any reader macro for the following character. This adds
minimal clutter to the source code, and is completely harmless even when the
AllegroGraph readtable is not in effect.

     > (<-- (is-a-parent ?x)  
            (parent ?x ?)  
            \!) 

Be aware that sometimes names with syntax parent/2 will appear in Prolog
documentation and in the debugger. The portion of the name is the predicate name
-- also called a functor and the same as the Lisp symbol naming the predicate. The
non-negative integer after the slash is the arity, which is the number of
arguments to the predicate. Two predicates with the same functor but different
arity are completely unrelated to one another. In the example above the predicate 
parent/1 has no relation to the parent/2 predicate defined earlier in this
document and which it calls.

****** logo-franz   
Copyright (c) 2005 - 2010 Franz, Incorporated

Last updated 17 February 2010 at 14:09
**** sparql							 :sparql:rdf:
***** DONE tracker-sparql					 :sparql:rdf:
****** DONE tracker-sparql -q "SELECT ?cl WHERE { ?cl a rdfs:Class }"
Results:
  http://www.w3.org/2001/XMLSchema#string
  http://www.w3.org/2001/XMLSchema#boolean
  http://www.w3.org/2001/XMLSchema#integer
  http://www.w3.org/2001/XMLSchema#double
  http://www.w3.org/2001/XMLSchema#date
  http://www.w3.org/2001/XMLSchema#dateTime
  http://www.w3.org/2000/01/rdf-schema#Resource
  http://www.w3.org/2000/01/rdf-schema#Class
  http://www.w3.org/1999/02/22-rdf-syntax-ns#Property
  http://www.w3.org/2000/01/rdf-schema#Literal
  http://www.tracker-project.org/ontologies/tracker#Namespace
  http://www.tracker-project.org/ontologies/tracker#Ontology
  http://www.semanticdesktop.org/ontologies/2007/08/15/nrl#InverseFunctionalProperty
  http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataObject
  http://www.semanticdesktop.org/ontologies/2007/01/19/nie#DataSource
  http://www.semanticdesktop.org/ontologies/2007/01/19/nie#InformationElement
  http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Tag
  http://www.semanticdesktop.org/ontologies/2007/08/15/nao#Property
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Role
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Affiliation
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Contact
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactGroup
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactList
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactMedium
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#EmailAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMAccount
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#OrganizationContact
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PersonContact
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PostalAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ModemNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#MessagingNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PagerNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#Gender
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VoicePhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#VideoTelephoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IsdnNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ParcelDeliveryAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#FaxNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CarPhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#ContactListDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PcsNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#InternationalDeliveryAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#BbsNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#CellPhoneNumber
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#DomesticDeliveryAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#PresenceStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#IMCapability
  http://www.semanticdesktop.org/ontologies/2007/03/22/nco#AuthorizationStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Document
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Software
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Media
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Visual
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Image
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RasterImage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DataContainer
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemotePortAddress
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaFileListEntry
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#VectorImage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Audio
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#CompressionType
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Icon
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#TextDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PlainTextDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HtmlDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#OperatingSystem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaList
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Executable
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Folder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Font
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Filesystem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareService
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareItem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Presentation
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RemoteDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#PaginatedTextDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Video
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Spreadsheet
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Trash
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FileHash
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SourceCode
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Application
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#EmbeddedFileDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Attachment
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#ArchiveItem
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Archive
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MindMap
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#MediaStream
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#BookmarkFolder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#FilesystemImage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HardDiskPartition
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Cursor
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Bookmark
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#DeletedResource
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Website
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#WebHistory
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Note
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareCategory
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#SoftwareApplication
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Orientation
  http://www.tracker-project.org/ontologies/poi#ObjectOfInterest
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#Equipment
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#HelpDocument
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterest
  http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#RegionOfInterestContent
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MimePart
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Multipart
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Message
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Email
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Attachment
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailAccount
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailboxDataObject
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MessageHeader
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#IMMessage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Conversation
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#CommunicationChannel
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PermanentChannel
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#TransientChannel
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#Call
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#VOIPCall
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MailFolder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#SMSMessage
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#PhoneMessageFolder
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#DeliveryStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#ReportReadStatus
  http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#MMSMessage
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#UnionParentClass
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifier
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttachmentEncoding
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#EventStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceFrequency
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attachment
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AccessClassification
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarDataObject
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#JournalStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceIdentifierRange
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeOrOrganizer
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AlarmAction
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RecurrenceRule
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TodoStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimeTransparency
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalTimeEntity
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarScale
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#AttendeeRole
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#BydayRulePart
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Weekday
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Trigger
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyType
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#CalendarUserType
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#ParticipationStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#RequestStatus
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalDateTime
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TimezoneObservance
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Organizer
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Attendee
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#NcalPeriod
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Calendar
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#FreebusyPeriod
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#TriggerRelation
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Alarm
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Event
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Todo
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Freebusy
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Journal
  http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#Timezone
  http://www.tracker-project.org/temp/scal#Calendar
  http://www.tracker-project.org/temp/scal#CalendarItem
  http://www.tracker-project.org/temp/scal#TransparencyValues
  http://www.tracker-project.org/temp/scal#Attendee
  http://www.tracker-project.org/temp/scal#AttendanceStatus
  http://www.tracker-project.org/temp/scal#AttendeeRole
  http://www.tracker-project.org/temp/scal#RSVPValues
  http://www.tracker-project.org/temp/scal#CalendarUserType
  http://www.tracker-project.org/temp/scal#Event
  http://www.tracker-project.org/temp/scal#Todo
  http://www.tracker-project.org/temp/scal#Journal
  http://www.tracker-project.org/temp/scal#EventStatus
  http://www.tracker-project.org/temp/scal#TodoStatus
  http://www.tracker-project.org/temp/scal#JournalStatus
  http://www.tracker-project.org/temp/scal#CalendarAlarm
  http://www.tracker-project.org/temp/scal#TimePoint
  http://www.tracker-project.org/temp/scal#AccessLevel
  http://www.tracker-project.org/temp/scal#RecurrenceRule
  http://www.semanticdesktop.org/ontologies/2007/05/10/nid3#ID3Audio
  http://www.tracker-project.org/temp/nmm#MusicPiece
  http://www.tracker-project.org/temp/nmm#MusicAlbum
  http://www.tracker-project.org/temp/nmm#MusicAlbumDisc
  http://www.tracker-project.org/temp/nmm#SynchronizedText
  http://www.tracker-project.org/temp/nmm#Video
  http://www.tracker-project.org/temp/nmm#Artist
  http://www.tracker-project.org/temp/nmm#Playlist
  http://www.tracker-project.org/temp/nmm#ImageList
  http://www.tracker-project.org/temp/nmm#Photo
  http://www.tracker-project.org/temp/nmm#Flash
  http://www.tracker-project.org/temp/nmm#MeteringMode
  http://www.tracker-project.org/temp/nmm#WhiteBalance
  http://www.tracker-project.org/temp/nmm#RadioStation
  http://www.tracker-project.org/temp/nmm#DigitalRadio
  http://www.tracker-project.org/temp/nmm#AnalogRadio
  http://www.tracker-project.org/temp/nmm#RadioModulation
  http://www.tracker-project.org/temp/mto#TransferElement
  http://www.tracker-project.org/temp/mto#Transfer
  http://www.tracker-project.org/temp/mto#UploadTransfer
  http://www.tracker-project.org/temp/mto#DownloadTransfer
  http://www.tracker-project.org/temp/mto#SyncTransfer
  http://www.tracker-project.org/temp/mto#State
  http://www.tracker-project.org/temp/mto#TransferMethod
  http://www.tracker-project.org/temp/mlo#GeoLocation
  http://www.tracker-project.org/temp/mlo#GeoPoint
  http://www.tracker-project.org/temp/mlo#GeoSphere
  http://www.tracker-project.org/temp/mlo#GeoBoundingBox
  http://www.tracker-project.org/temp/mlo#LocationBoundingBox
  http://www.tracker-project.org/temp/mlo#Route
  http://www.tracker-project.org/temp/mlo#LandmarkCategory
  http://www.tracker-project.org/temp/mlo#Landmark
  http://www.tracker-project.org/temp/mlo#PointOfInterest
  http://www.tracker-project.org/temp/mfo#FeedElement
  http://www.tracker-project.org/temp/mfo#FeedChannel
  http://www.tracker-project.org/temp/mfo#FeedMessage
  http://www.tracker-project.org/temp/mfo#Enclosure
  http://www.tracker-project.org/temp/mfo#FeedSettings
  http://www.tracker-project.org/temp/mfo#Action
  http://www.tracker-project.org/temp/mfo#FeedType
  http://www.tracker-project.org/temp/mtp#ScanType
  http://www.tracker-project.org/ontologies/tracker#Volume
  http://www.tracker-project.org/temp/slo#LandmarkCategory
  http://www.tracker-project.org/temp/slo#Landmark
  http://www.tracker-project.org/temp/slo#GeoLocation
  http://www.tracker-project.org/temp/slo#Route
  http://www.tracker-project.org/ontologies/osinfo#Installer

****** DONE tracker-sparql -q "SELECT ?prefix ?ns WHERE {
   >                     ?ns a tracker:Namespace ;
   >                     tracker:prefix ?prefix
   >                 }"
Results:
  xsd, http://www.w3.org/2001/XMLSchema#
  rdf, http://www.w3.org/1999/02/22-rdf-syntax-ns#
  rdfs, http://www.w3.org/2000/01/rdf-schema#
  tracker, http://www.tracker-project.org/ontologies/tracker#
  nrl, http://www.semanticdesktop.org/ontologies/2007/08/15/nrl#
  dc, http://purl.org/dc/elements/1.1/
  nie, http://www.semanticdesktop.org/ontologies/2007/01/19/nie#
  nao, http://www.semanticdesktop.org/ontologies/2007/08/15/nao#
  nco, http://www.semanticdesktop.org/ontologies/2007/03/22/nco#
  nfo, http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#
  poi, http://www.tracker-project.org/ontologies/poi#
  nmo, http://www.semanticdesktop.org/ontologies/2007/03/22/nmo#
  ncal, http://www.semanticdesktop.org/ontologies/2007/04/02/ncal#
  scal, http://www.tracker-project.org/temp/scal#
  nid3, http://www.semanticdesktop.org/ontologies/2007/05/10/nid3#
  nmm, http://www.tracker-project.org/temp/nmm#
  mto, http://www.tracker-project.org/temp/mto#
  mlo, http://www.tracker-project.org/temp/mlo#
  mfo, http://www.tracker-project.org/temp/mfo#
  mtp, http://www.tracker-project.org/temp/mtp#
  fts, http://www.tracker-project.org/ontologies/fts#
  slo, http://www.tracker-project.org/temp/slo#
  osinfo, http://www.tracker-project.org/ontologies/osinfo#

***** CONSTRUCT
    "The CONSTRUCT query form returns a single RDF graph
    specified by a graph template. The result is an RDF graph
    formed by taking each query solution in the solution
    sequence, substituting for the variables in the graph
    template, and combining the triples into a single RDF
    graph by set union."
#+begin_src sparql
CONSTRUCT {
    where xk:role ("?chapel" "?leader")
    owl:Exclusion "?anti-chapel"
    , owl:Related "?chancel"
    , owl:Members ("?altar" "?choir")
    }
#+end_src
*** elisp							      :elisp:
**** (if TRUE-OR-FALSE-TEST ACTION-TO-CARRY-OUT-IF-TEST-IS-TRUE)

#+BEGIN_SRC emacs-lisp
(if (> 5 4)                             ; if-part
    (message "5 is greater than 4!"))   ; then-part
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun type-of-animal (characteristic)
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger."
       (if (equal characteristic 'fierce)
           (message "It's a tiger!")))

(type-of-animal 'fierce)

(type-of-animal 'zebra)

#+END_SRC

#+BEGIN_EXAMPLE
(defun NAME-OF-FUNCTION (ARGUMENT-LIST)
       "DOCUMENTATION..."
       BODY...)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
(defun type-of-animal (characteristic)
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger."
       BODY: THE `if' EXPRESSION)
#+END_EXAMPLE

**** (let VARLIST BODY)

#+begin_example
(let ((VARIABLE VALUE)
           (VARIABLE VALUE)
           ...)
       BODY...)
#+end_example

#+begin_src emacs-lisp
(let ((zebra 'stripes)
      (tiger 'fierce))
  (message "One kind of animal has %s and another is %s."
           zebra tiger))
#+end_src

**** TODO problems with macros					      :debug:
***** repeated expansion (how many times is the macro expanded?)
Captured [2014-06-06 Fri 18:47]
  13.5.5 How Many Times is the Macro Expanded?
  --------------------------------------------
  
  Occasionally problems result from the fact that a macro call is
  expanded each time it is evaluated in an interpreted function, but is
  expanded only once (during compilation) for a compiled function.  If the
  macro definition has side effects, they will work differently depending
  on how many times the macro is expanded.
  
     Therefore, you should avoid side effects in computation of the macro
  expansion, unless you really know what you are doing.
  
     One special kind of side effect can't be avoided: constructing Lisp
  objects.  Almost all macro expansions include constructed lists; that is
  the whole point of most macros.  This is usually safe; there is just one
  case where you must be careful: when the object you construct is part
  of a quoted constant in the macro expansion.
  
     If the macro is expanded just once, in compilation, then the object
  is constructed just once, during compilation.  But in interpreted
  execution, the macro is expanded each time the macro call runs, and this
  means a new object is constructed each time.
  
     In most clean Lisp code, this difference won't matter.  It can matter
  only if you perform side-effects on the objects constructed by the macro
  definition.  Thus, to avoid trouble, *avoid side effects on objects
  constructed by macro definitions*.  Here is an example of how such side
  effects can get you into trouble:
  
       (defmacro empty-object ()
         (list 'quote (cons nil nil)))
  
       (defun initialize (condition)
         (let ((object (empty-object)))
           (if condition
               (setcar object condition))
           object))
  
  If `initialize' is interpreted, a new list `(nil)' is constructed each
  time `initialize' is called.  Thus, no side effect survives between
  calls.  If `initialize' is compiled, then the macro `empty-object' is
  expanded during compilation, producing a single "constant" `(nil)' that
  is reused and altered each time `initialize' is called.
****** think of 'empty-object' as a funny kind of constant  
     One way to avoid pathological cases like this is to think of
  `empty-object' as a funny kind of constant, not as a memory allocation
  construct.  You wouldn't use `setcar' on a constant such as `'(nil)',
  so naturally you won't use it on `(empty-object)' either.
  
  [[info:elisp#Repeated%20Expansion][info:elisp#Repeated Expansion]]

empty-object is not a memory allocation construct

***** evaluating macro arguments in expansion
Captured [2014-06-06 Fri 18:46]
  13.5.4 Evaluating Macro Arguments in Expansion
  ----------------------------------------------
  
  Another problem can happen if the macro definition itself evaluates any
  of the macro argument expressions, such as by calling `eval' (*note
  Eval::).  If the argument is supposed to refer to the user's variables,
  you may have trouble if the user happens to use a variable with the
  same name as one of the macro arguments.  Inside the macro body, the
  macro argument binding is the most local binding of this variable, so
  any references inside the form being evaluated do refer to it.  Here is
  an example:
  
       (defmacro foo (a)
         (list 'setq (eval a) t))
       (setq x 'b)
       (foo x) ==> (setq b t)
            => t                  ; and `b' has been set.
       ;; but
       (setq a 'c)
       (foo a) ==> (setq a t)
            => t                  ; but this set `a', not `c'.
  
     It makes a difference whether the user's variable is named `a' or
  `x', because `a' conflicts with the macro argument variable `a'.
  
     Another problem with calling `eval' in a macro definition is that it
  probably won't do what you intend in a compiled program.  The byte
  compiler runs macro definitions while compiling the program, when the
  program's own computations (which you might have wished to access with
  `eval') don't occur and its local variable bindings don't exist.
****** don't evaluate an argument expression while computing the macro expansion  
       To avoid these problems, *don't evaluate an argument expression
    while computing the macro expansion*.  Instead, substitute the
    expression into the macro expansion, so that its value will be computed
    as part of executing the expansion.  This is how the other examples in
    this chapter work.
    
    [[info:elisp#Eval%20During%20Expansion][info:elisp#Eval During Expansion]]

***** local variables in macro expansions
Captured [2014-06-06 Fri 18:45]
  13.5.3 Local Variables in Macro Expansions
  ------------------------------------------
  
  In the previous section, the definition of `for' was fixed as follows
  to make the expansion evaluate the macro arguments the proper number of
  times:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple for loop: (for i from 1 to 10 do (print i))."
         `(let ((,var ,init)
                (max ,final))
            (while (<= ,var max)
              ,@body
              (inc ,var))))
  
  The new definition of `for' has a new problem: it introduces a local
  variable named `max' which the user does not expect.  This causes
  trouble in examples such as the following:
  
       (let ((max 0))
         (for x from 0 to 10 do
           (let ((this (frob x)))
             (if (< max this)
                 (setq max this)))))
  
  The references to `max' inside the body of the `for', which are
  supposed to refer to the user's binding of `max', really access the
  binding made by `for'.
  
     The way to correct this is to use an uninterned symbol instead of
  `max' (*note Creating Symbols::).  The uninterned symbol can be bound
  and referred to just like any other symbol, but since it is created by
  `for', we know that it cannot already appear in the user's program.
  Since it is not interned, there is no way the user can put it into the
  program later.  It will never appear anywhere except where put by
  `for'.  Here is a definition of `for' that works this way:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple for loop: (for i from 1 to 10 do (print i))."
         (let ((tempvar (make-symbol "max")))
           `(let ((,var ,init)
                  (,tempvar ,final))
              (while (<= ,var ,tempvar)
                ,@body
                (inc ,var)))))
  
  This creates an uninterned symbol named `max' and puts it in the
  expansion instead of the usual interned symbol `max' that appears in
  expressions ordinarily.
  
  [[info:elisp#Surprising%20Local%20Vars][info:elisp#Surprising Local Vars]]

***** evaluating macro arguments repeatedly
Captured [2014-06-06 Fri 18:44]
  File: elisp.info,  Node: Argument Evaluation,  Next: Surprising Local Vars,  Prev: Wrong Time,  Up: Problems with Macros
  
  13.5.2 Evaluating Macro Arguments Repeatedly
  --------------------------------------------
  
  When defining a macro you must pay attention to the number of times the
  arguments will be evaluated when the expansion is executed.  The
  following macro (used to facilitate iteration) illustrates the problem.
  This macro allows us to write a "for" loop construct.
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple \"for\" loop.
       For example, (for i from 1 to 10 do (print i))."
         (list 'let (list (list var init))
               (cons 'while
                     (cons (list '<= var final)
                           (append body (list (list 'inc var)))))))
  
       (for i from 1 to 3 do
          (setq square (* i i))
          (princ (format "\n%d %d" i square)))
       ==>
       (let ((i 1))
         (while (<= i 3)
           (setq square (* i i))
           (princ (format "\n%d %d" i square))
           (inc i)))
  
            -|1       1
            -|2       4
            -|3       9
       => nil
  
  The arguments `from', `to', and `do' in this macro are "syntactic
  sugar"; they are entirely ignored.  The idea is that you will write
  noise words (such as `from', `to', and `do') in those positions in the
  macro call.
  
     Here's an equivalent definition simplified through use of backquote:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple \"for\" loop.
       For example, (for i from 1 to 10 do (print i))."
         `(let ((,var ,init))
            (while (<= ,var ,final)
              ,@body
              (inc ,var))))
  
     Both forms of this definition (with backquote and without) suffer
  from the defect that FINAL is evaluated on every iteration.  If FINAL
  is a constant, this is not a problem.  If it is a more complex form,
  say `(long-complex-calculation x)', this can slow down the execution
  significantly.  If FINAL has side effects, executing it more than once
  is probably incorrect.
  
     A well-designed macro definition takes steps to avoid this problem by
  producing an expansion that evaluates the argument expressions exactly
  once unless repeated evaluation is part of the intended purpose of the
  macro.  Here is a correct expansion for the `for' macro:
  
       (let ((i 1)
             (max 3))
         (while (<= i max)
           (setq square (* i i))
           (princ (format "%d      %d" i square))
           (inc i)))
  
     Here is a macro definition that creates this expansion:
  
       (defmacro for (var from init to final do &rest body)
         "Execute a simple for loop: (for i from 1 to 10 do (print i))."
         `(let ((,var ,init)
                (max ,final))
            (while (<= ,var max)
              ,@body
              (inc ,var))))
  
     Unfortunately, this fix introduces another problem, described in the
  following section.
  
  [[info:elisp#Argument%20Evaluation][info:elisp#Argument Evaluation]]

***** wrong time
Captured [2014-06-06 Fri 18:43]
  13.5.1 Wrong Time
  -----------------
  
  The most common problem in writing macros is doing some of the real
  work prematurely--while expanding the macro, rather than in the
  expansion itself.  For instance, one real package had this macro
  definition:
  
       (defmacro my-set-buffer-multibyte (arg)
         (if (fboundp 'set-buffer-multibyte)
             (set-buffer-multibyte arg)))
  
     With this erroneous macro definition, the program worked fine when
  interpreted but failed when compiled.  This macro definition called
  `set-buffer-multibyte' during compilation, which was wrong, and then
  did nothing when the compiled package was run.  The definition that the
  programmer really wanted was this:
  
       (defmacro my-set-buffer-multibyte (arg)
         (if (fboundp 'set-buffer-multibyte)
             `(set-buffer-multibyte ,arg)))
  
  This macro expands, if appropriate, into a call to
  `set-buffer-multibyte' that will be executed when the compiled program
  is actually run.
  [[info:elisp#Wrong%20Time][info:elisp#Wrong Time]]

**** kill ring concepts
Captured [2014-06-06 Fri 14:00]
  32.8.1 Kill Ring Concepts
  -------------------------
  
  The kill ring records killed text as strings in a list, most recent
  first.  A short kill ring, for example, might look like this:
  
       ("some text" "a different piece of text" "even older text")
  
  When the list reaches `kill-ring-max' entries in length, adding a new
  entry automatically deletes the last entry.
  
     When kill commands are interwoven with other commands, each kill
  command makes a new entry in the kill ring.  Multiple kill commands in
  succession build up a single kill ring entry, which would be yanked as a
  unit; the second and subsequent consecutive kill commands add text to
  the entry made by the first one.
  
     For yanking, one entry in the kill ring is designated the "front" of
  the ring.  Some yank commands "rotate" the ring by designating a
  [[info:elisp#Kill%20Ring%20Concepts][info:elisp#Kill Ring Concepts]]

**** (setq list (cons newelt list))
**** use of a special variable as a formal argument in a function 
     is discouraged.
**** resist the temptation to use error handling to transfer control
 Resist the temptation to use error handling to transfer control from
one part of the program to another; use `catch' and `throw' instead.
*Note Catch and Throw::.
**** TODO function definitions
     It is helpful to think of the five parts of a function definition
     as being organized in a template, with slots for each part:

       (defun FUNCTION-NAME (ARGUMENTS...)
       	 "OPTIONAL-DOCUMENTATION..."
       	 (interactive ARGUMENT-PASSING-INFO)     ; optional
       	 BODY...)

***** the 5 parts
      function-name
      arguments
      optional-documentation
      argument-passing-info
      body

**** TODO errors						:elisp:debug:
***** 10.5.3.4 Error Symbols and Condition Names
Captured [2014-06-01 Sun 22:33]
  File: elisp.info,  Node: Error Symbols,  Prev: Handling Errors,  Up: Errors
  
  10.5.3.4 Error Symbols and Condition Names
  ..........................................
  
  When you signal an error, you specify an "error symbol" to specify the
  kind of error you have in mind.  Each error has one and only one error
  symbol to categorize it.  This is the finest classification of errors
  defined by the Emacs Lisp language.
  
     These narrow classifications are grouped into a hierarchy of wider
  classes called "error conditions", identified by "condition names".
  The narrowest such classes belong to the error symbols themselves: each
  error symbol is also a condition name.  There are also condition names
  for more extensive classes, up to the condition name `error' which
  takes in all kinds of errors (but not `quit').  Thus, each error has
  one or more condition names: `error', the error symbol if that is
  distinct from `error', and perhaps some intermediate classifications.
  
     In order for a symbol to be an error symbol, it must have an
  `error-conditions' property which gives a list of condition names.
  This list defines the conditions that this kind of error belongs to.
  (The error symbol itself, and the symbol `error', should always be
  members of this list.)  Thus, the hierarchy of condition names is
  defined by the `error-conditions' properties of the error symbols.
  Because quitting is not considered an error, the value of the
  `error-conditions' property of `quit' is just `(quit)'.
  
     In addition to the `error-conditions' list, the error symbol should
  have an `error-message' property whose value is a string to be printed
  when that error is signaled but not handled.  If the error symbol has
  no `error-message' property or if the `error-message' property exists,
  but is not a string, the error message `peculiar error' is used.  *Note
  Definition of signal::.
  
     Here is how we define a new error symbol, `new-error':
  
       (put 'new-error
            'error-conditions
            '(error my-own-errors new-error))
       => (error my-own-errors new-error)
       (put 'new-error 'error-message "A new error")
       => "A new error"
  
  This error has three condition names: `new-error', the narrowest
  classification; `my-own-errors', which we imagine is a wider
  classification; and `error', which is the widest of all.
  
     The error string should start with a capital letter but it should
  not end with a period.  This is for consistency with the rest of Emacs.
  
     Naturally, Emacs will never signal `new-error' on its own; only an
  explicit call to `signal' (*note Definition of signal::) in your code
  can do this:
  
       (signal 'new-error '(x y))
            error--> A new error: x, y
  
     This error can be handled through any of the three condition names.
  This example handles `new-error' and any other errors in the class
  `my-own-errors':
  
       (condition-case foo
           (bar nil t)
         (my-own-errors nil))
  
     The significant way that errors are classified is by their condition
  names--the names used to match errors with handlers.  An error symbol
  serves only as a convenient way to specify the intended error message
  and list of condition names.  It would be cumbersome to give `signal' a
  list of condition names rather than one error symbol.
  
     By contrast, using only error symbols without condition names would
  seriously decrease the power of `condition-case'.  Condition names make
  it possible to categorize errors at various levels of generality when
  you write an error handler.  Using error symbols alone would eliminate
  all but the narrowest level of classification.
  
     *Note Standard Errors::, for a list of the main error symbols and
  their conditions.
  
  [[info:elisp#Error%20Symbols][info:elisp#Error Symbols]]

**** Completion::M-TAB knows what you need

     Emacs would not be Emacs without completion, and Org mode uses it
     whenever it makes sense.  If you prefer an iswitchb- or ido-like
     interface for some of the completion prompts, you can specify your
     preference by setting at most one of the variables
     `org-completion-use-iswitchb' `org-completion-use-ido'.

     Org supports in-buffer completion.  This type of completion does not
     make use of the minibuffer.  You simply type a few letters into the
     buffer and use the key to complete text right there.

     `M-<TAB>'
     Complete word at point
          * At the beginning of a headline, complete TODO keywords.

          * After `\', complete TeX symbols supported by the exporter.

          * After `*', complete headlines in the current buffer so that
            they can be used in search links 
	    like `[[*find this headline]]'.

          * After `:' in a headline, complete tags.  The list of tags is
            taken from the variable `org-tag-alist' (possibly set through
            the `#+TAGS' in-buffer option, *note Setting tags::), or it
            is created dynamically from all tags used in the current
            buffer.

          * After `:' and not in a headline, complete property keys.  The
            list of keys is constructed dynamically from all keys used in
            the current buffer.

          * After `[', complete link abbreviations 
	    (*note Link abbreviations::).

          * After `#+', complete the special keywords like `TYP_TODO' or
            `OPTIONS' which set file-specific options for Org mode.  When
            the option keyword is already complete, pressing `M-<TAB>'
            again will insert example settings for this keyword.

          * In the line after `#+STARTUP: ', complete startup keywords,
            i.e., valid keys for this line.

          * Elsewhere, complete dictionary words using Ispell.

**** *we discourage redefinition of primitive functions*

*** third-party content security issues				    :defense:

    Captured [2014-05-30 Fri 14:54]
    Title: Complexity as the Enemy of Security
    Date: Tue, 27 May 2014 10:27:12 PDT
    Feed: Krebs on Security
    Link: http://krebsonsecurity.co[...]as-the-enemy-of-security/
   
    Late last month, hackers allied with the Syrian Electronic Army
    (SEA) compromised the Web site for the RSA Conference, the world's
    largest computer security gathering. The attack, while unremarkable
    in many ways, illustrates the continued success of phishing attacks
    that spoof top executives within targeted organizations. It's also
    a textbook example of how third-party content providers can be
    leveraged to break into high-profile Web sites.

*** perl							  :rdf:shell:
**** command line (emacs -batch)  
    #!/usr/bin/perl

       # define the Emacs command to run
       $cmd = "emacs -batch -l ~/.emacs -eval '(org-batch-agenda-csv \"t\")'";

       # run it and capture the output
       $agenda = qx{$cmd 2>/dev/null};

       # loop over all lines
       foreach $line (split(/\n/,$agenda)) {
       	 # get the individual values
       	 ($category,$head,$type,$todo,$tags,$date,$time,$extra,
          $priority_l,$priority_n) = split(/,/,$line);
       	 # process and print
       	 print "[ ] $head\n";
       }

*** negative-assertion						  :rdf:debug:
    (non) is sometimes failure, sometimes not failure
**** a test for three cases
***** :non a :failure
***** :non a :success
***** :non a :no-result
*** average post size
Captured [2014-05-30 Fri 11:12]
  Title: Irreal: Calculating My Average Post Size
  Date: Thu, 29 May 2014 02:36:00 PDT
  Feed: Planet Emacsen
  Link: http://irreal.org/blog/?p=2719
  
  Most of my posts are pretty short: maybe 250 words or so. The other
  day, I began to wonder how long the average post is so I wrote a few
  lines of Elisp code and just executed it in the scratch buffer. 
  
  Here’s the code: 
  
  (let ((posts 0) (words 0))
    (mapc (lambda(p)
            (with-temp-buffer
              (insert-file-contents p)
              (goto-char 1)
              (setq words (+ words (how-many "\\w+")))
              (setq posts (1+ posts))))
          (directory-files "~/org/blog" t ".*\\.org"))
    (format "Total words: %s, Average per Post: %s" words (/ words posts)))
  
  As you can see there’s nothing special in it. The only points worthy
  of note are the use of with-temp-buffer and =insert-file-contents
  instead of find-file, a trick I learned from Xah Lee, and the use of
  directory-files, which is a nice way of getting a list of files
  satisfying some regex. 
  
  When I run the code I get 
  
  Total words: 362460, Average per Post: 303
  
  so my posts are a bit longer than I thought. It’s also interesting
  that in the 3 years I’ve been posting to Irreal, I’ve written about
  360,000 words or 120,000 words a year. That’s about a novel’s worth of
  words a year. Now if I could only write a novel.

*** cl-org-parser ebnf-ish

#+BEGIN_EXAMPLE
org                    := ( :org org-header org-section org-entry* )
org-header             := ( :header org-option* )
org-entry              := ( :entry org-headline org-section org-entry* )
org-headline           := ( :stars <integer> org-entry-title org-headline-tag* [ org-entry-tags ] )
org-entry-title        := :title <string>
org-headline-tag       := :commented t
                        | :quoted t
                        | :todo <keyword>
                        | :priority <string>
org-entry-tags         := :tags ( <string>* )
org-section            := ( :section org-section-component* )
org-section-component  := org-element
                        | org-greater-element
                        | org-affiliated-keyword
org-element            := <string>
org-greater-element    := org-greater-block
                        | org-dynamic-block
                        | org-drawer
org-greater-block      := ( :block         <string> [ :parameters <string> ] :contents org-section )
org-dynamic-block      := ( :dynamic-block <string> [ :parameters <string> ] :contents org-section )
org-drawer             := org-basic-drawer
                        | org-property-drawer
org-basic-drawer       := ( :basic-drawer    <string> :contents org-section )
org-property-drawer    := ( :property-drawer <string> :contents ( org-property* ) )
org-property           := ( :property <string> :value <string> )
org-affiliated-keyword := org-keyword
                        | org-attribute
org-keyword            := ( :keyword   <string> [ :optional <string> ] :value <string> )
org-attribute          := ( :attribute <string> [ :optional <string> ] :value <string> )
#+END_EXAMPLE

**** features

    mark element(s)
    
    convert elements from org to turtle

    invoke rapper to produce ntriples buffer

    mark parser errors

    comment out or delete parser messages in parser output buffer

    save parser buffer to .nt file

    another way is to do the 'parsing' entirely in elisp, this might
    be better, actually, maybe even easier

    org-elements has a couple of variables and functions that
    basically have done alot or most of the work, what needs to be
    done is to read the parse tree and output the result of the read
    in ntriples. it may be easier to simply output in ntriples than
    going for an intermediate step of using turtle.

    there are a couple different things to consider. first, how
    sophisticated to i need the outputted file to be? it will be
    better to start with simple output, like property lists and
    rdfs:type declarations to begin with than to try and capture all
    of the owl and rdf elements at once

    an interesting consequence is that its probably that i wont have
    all the rdfs and owl compliant predicates ready for direct
    translation to begin with. this may mean an ongoing process where
    rdfs and owl ready translations are elicited as i go.

    for instance, say i have a headline with two subheadlines, each
    with a body of text and a property list. the subheadlines might be
    properties and the text bodies of the subheadlines might be
    properties of properties. this doesnt seem to jibe very well with
    the way org-elements is currently designed because the
    subheadlines have property lists already under the :properties:
    symbols. this might not be an issue, however, if i treat the text
    as just another property. however, this might not be such a good
    idea because the point of conversion to .nt is to capture (subject
    predicate object) relationships.

    property drawers with rdfs and owl compliant property values will
    be helpful in creating the correct ntriples for an element and can
    be made a part of the .org file.

    preparing the .org file

    basically there will be two types of predicate sources to work
    with:
    first, this predicate sources that derive from the structure of
    org-elements. these are the predicates that derive from the way an
    org document is structured and do not depend on user designated
    property lists
    second, are user designated property lists introduced
    with :properties:

    there will be alot of stuff that's in the org-element parse tree
    that i really am not going to want in the .nt file, that
    represents stuff for org internals and emacs specific use that im
    not going to want cluttering things up. therefor my default
    strategy is going to be basically picking out some specific things
    that i want to capture to triples and ignoring the rest

    a way to do start doing this is with a simple interactive function
    that does one thing, creates a triple from a headline element,
    consing onto each element the appropriate URI information.

    where a turtle or n3 stage might be useful here, and why i might
    want to resort to an external parser, is the readability of the
    output of my 'triplize' function while im working. if i do it with
    eval and print then its going to output a ntriple that will most
    likely run right off the end of the screen and making it less
    readable.

    as a stage, will it be a big deal if im producing turtle notation
    that i can process with raptor, or some other parser/printer?
    surely not, although i eventually want to be producing ntriples
    for gruff, or at least until i can get a 64bit laptop so i can run
    later versions of gruff that can read more file formats.

    ergo, i can create some source blocks

    first, i want to eval and print the org-elements parse tree

#+BEGIN_SRC emacs-lisp :results output
(require 'ox)


#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp :results output
(let ((oem (org-element-map))
        (oem 'org-element-map)
;    (print (format "%s %f" "OEM: " (eval org-element-map)))
    (print (format "%s %d" "OEM: " (eval org-element-map) nil)
    (print "End of org-element-map"))
#+end_src

#+name:
: 
: "Dog:  1.414214"
: 
: "Cat:  7"
: 
: "Fish."

***** introduce org-babel to =xml= and =n3=

#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

**** library-of-stuff
***** custom query of user before evaluating code block
   :PROPERTIES:
   :DATE:     2012-02-08
   :END:
#+begin_src sh :eval (if (y-or-n-p "Run operation X?") "yes" "no")
  echo "Going ahead with operation X!"
#+end_src
***** call line which dumps out its own header argument info
   :PROPERTIES:
   :DATE:     2012-02-05
   :END:
This call line passes its in-buffer location to a code block.  Notice
that the call to =(point)= in the call line is saved into a header
argument named =:my-point= and is then retrieved by the variable
initialization.  This indirection is required because of /when/ and
/where/ the elisp forms in header arguments are evaluated, a simpler
call line like =#+call: show:((point))= would not work because the
form =(point)= would not be evaluated in the correct place.

#+call: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info)))) :special-header "foo"

The special header argument =:special-header= may be seen in the
output below.  The =results= variable is due to the way that call
lines are evaluated.  During evaluation a call line is converted into
a trivial elisp code block of the form
: #+begin_src emacs-lisp :var results=called-function()
:   results
: #+end_src
which is evaluated in place.

#+RESULTS: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info))))
| (:var results ((:var nil)) ((:colname-names)) ((:rowname-names)) ((:result-params replace)) ((:result-type . value)) ((:comments . )) ((:shebang . )) ((:cache . no)) ((:padline . )) ((:noweb . yes)) ((:tangle . no)) ((:exports . code)) ((:results . replace)) ((:padnewline . yes)) ((:hlines . no)) ((:session . none))) |
| (:colname-names)                                                                                                                                                                                                                                                                                                               |
| (:rowname-names)                                                                                                                                                                                                                                                                                                               |
| (:result-params replace)                                                                                                                                                                                                                                                                                                       |
| (:result-type . value)                                                                                                                                                                                                                                                                                                         |
| (:comments . )                                                                                                                                                                                                                                                                                                                 |
| (:shebang . )                                                                                                                                                                                                                                                                                                                  |
| (:cache . no)                                                                                                                                                                                                                                                                                                                  |
| (:padline . )                                                                                                                                                                                                                                                                                                                  |
| (:noweb . yes)                                                                                                                                                                                                                                                                                                                 |
| (:tangle . no)                                                                                                                                                                                                                                                                                                                 |
| (:exports . code)                                                                                                                                                                                                                                                                                                              |
| (:results . replace)                                                                                                                                                                                                                                                                                                           |
| (:special-header . foo)                                                                                                                                                                                                                                                                                                        |
| (:padnewline . yes)                                                                                                                                                                                                                                                                                                            |
| (:hlines . no)                                                                                                                                                                                                                                                                                                                 |
| (:session . none)                                                                                                                                                                                                                                                                                                              |

This code block visits the location of the call line, and calculates
the info using the same mechanisms used by =org-babel-lob-execute=.
#+name: show
#+begin_src emacs-lisp :var call-line-location=0
  (let ((call-info (save-excursion
                     (goto-char call-line-location)
                     (org-babel-lob-get-info))))
    (mapcar #'list
            (org-babel-process-params
             (org-babel-merge-params
              org-babel-default-header-args
              (org-babel-params-from-properties)
              (org-babel-parse-header-arguments
               (org-babel-clean-text-properties
                (concat ":var results="
                        (mapconcat #'identity (butlast call-info) " "))))))))
#+end_src
***** noweb insertion edge cases
   :PROPERTIES:
   :DATE:     2012-01-24
   :END:
The =cat= line below is dangerously close to a noweb reference.  The
space after test.org keeps it from being interpreted as a noweb
reference.

#+begin_src sh :tangle test.out :noweb yes
  <<task1>>
  <<b>>
  cat <<test.org >> test.out2
#+end_src

#+begin_src sh :noweb-ref task1
 echo "hello world"
#+end_src

#+BEGIN_SRC sh :noweb-ref b
 echo "b"
#+END_SRC

***** issues with call lines result insertion
   :PROPERTIES:
   :session:  *R-babel*
   :DATE:     2012-01-24
   :END:
#+NAME: foo-for-R
#+HEADER: :var a="a1.png"
#+BEGIN_SRC R :results output silent
  cat("in foo-for-R block\n")
  cat.a <- function() { cat(a,"\n",sep="") }
  cat.a()
#+END_SRC

#+NAME: bar-for-R
#+begin_src R :results output raw replace :exports none
 cat.a()
#+end_src

Because there are three instances of the =bar-for-R()= call line, all
of their results are inserted into the same place in the file,
specifically the location of the =#+Results: bar-for-R()= line.  This
can be very confusing if you are expected each =bar-for-R()= line to
generate it's own results.

Should have all a1 stuff
#+call: foo-for-R(a="a1.png")
#+call: bar-for-R()

Should have all a2 stuff
#+call: foo-for-R(a="a2.png")
#+call: bar-for-R()

Should have all a3 stuff
#+call: foo-for-R(a="a3.png")
#+call: bar-for-R()

The solution demonstrated below is to add a nothing header argument to
each bar-for-R to make it unique.  Notice that the three =foo= lines
below don't include results, as their results are inserted at the
identical foo lines above.

Should have all a1 stuff
#+call: foo-for-R(a="a1.png")
#+call: bar-for-R[id=1]()

Should have all a2 stuff
#+call: foo-for-R(a="a2.png")
#+call: bar-for-R[id=2]()

Should have all a3 stuff
#+call: foo-for-R(a="a3.png")
#+call: bar-for-R[id=3]()

***** name src_emacs-lisp{org-current-export-file}
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
Fanciness with running code in header arguments.

One block to tangle.
#+BEGIN_SRC emacs-lisp :tangle yes
  (message "I am tangled")
#+END_SRC

One block to export.
#+BEGIN_SRC emacs-lisp :exports results :var foo=(org-babel-tangle)
  (message "I just tangled %S during export" foo)
#+END_SRC

***** inhibit some call line evaluation on export
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
A buffer in which we want =foo= to be run when called interactively
from /any/ call line, but to only be run by a single call line on
export.  Ensure this works by executing this buffer to html while
tracking =foo-called.times= with =tail -f /tmp/foo-called.times=.

#+NAME: foo
#+BEGIN_SRC sh :var id="foo"
  echo "called by $id at $(date +%s.%N)" |tee -a /tmp/foo-called.times
#+END_SRC

This will *not* be run on export.
#+call: foo[:eval no-export]("bar")

This *will* be run on export.
#+call: foo("baz")

***** code block export template
   :PROPERTIES:
   :DATE:     2012-01-14
   :END:

The =org-babel-exp-code-template= (see below for its documentation)
variable may be customized to control which information from code
blocks is exported.

- Example code block
  #+Name: foo
  #+BEGIN_SRC sh :bar baz
    echo qux
  #+END_SRC

- Evaluate this block to export (shows the export of the name).
  #+Name: do-export-name
  #+BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "\n=%name=:\n#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"))
      (org-export-as-html nil))
  #+END_SRC

- Evaluate this block to export (shows the export of header arguments).
  #+Name: do-export-header-arguments
  #+BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "Header arguments for =%name=.
    | header  | value    |
    |---------+----------|
    | bar     | %bar     |
    | results | %results |\n#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"))
      (org-export-as-html nil))
  #+END_SRC

: ,----[org-babel-exp-code-template]
: | org-babel-exp-code-template is a variable defined in `ob-exp.el'.
: | Its value is "#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"
: | 
: | Documentation:
: | Template used to export the body of code blocks.
: | This template may be customized to include additional information
: | such as the code block name, or the values of particular header
: | arguments.  The template is filled out using `org-fill-template',
: | and the following %keys may be used.
: | 
: |  lang ------ the language of the code block
: |  name ------ the name of the code block
: |  body ------ the body of the code block
: |  flags ----- the flags passed to the code block
: | 
: | In addition to the keys mentioned above, every header argument
: | defined for the code block may be used as a key and will be
: | replaced with its value.
: | 
: | You can customize this variable.
: `----

***** simple R session
   :PROPERTIES:
   :DATE:     2011-09-21
   :END:
#+begin_src R :session R
  paste("Yep!")
#+end_src

#+name:
: Yep!

***** should this throw an error for no variable definition
   :PROPERTIES:
   :DATE:     2011-09-15
   :END:
Evaluating this block should raise an error that there are
uninitialized variables.

#+name: add-column-in-table(table="", column="", something, type="", else, nullability)
#+begin_src sql
-- add column `$column' (if column does not exist yet)
IF NOT EXISTS (SELECT *
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '$table'
               AND COLUMN_NAME = '$column')
BEGIN
    ALTER TABLE $table
    ADD $column $type $nullability
END
#+end_src

***** header arguments on call lines
   :PROPERTIES:
   :DATE:     2011-09-11
   :END:
#+name: simple-example
#+begin_src emacs-lisp
  "the result"
#+end_src

#+call: simple-example()

#+name: simple-example()
: the result

#+call: simple-example() :results raw

#+name: simple-example()
the result

***** removing result with a silent header argument
   :PROPERTIES:
   :DATE:     2011-09-07
   :END:
evaluating the following code block will remove the related result.

#+begin_src sh :results silent
  date +%Y-%m-%d
#+end_src

#+name:
: 2011-09-07

***** silent results in org but not in export
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
The results of the following code block will not be inserted during
interactive evaluation but will during export.

#+begin_src sh :results (if org-current-export-file "replace" "silent") :exports both
  echo  "I want to see this in HTML/PDF, but not in Org"
#+end_src

***** leading commas in code blocks
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
#+begin_src r :exports code
  a <- c(1
         , 2
         , 3)
#+end_src

#+begin_src org :exports code
  ,this one will have commas removed
  ,#+begin_src R
  ,  a <- c(1
  ,         , 2
  ,         , 3)
  ,#+end_src
#+end_src

***** returning file type to inline call line
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec
hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam
nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis
natoque penatibus et magnis dis parturient montes, nascetur ridiculus
mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non
turpis. call_nothing_to_something()[:results file] [[file:something.txt]]
Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan
nisl.

#+name: nothing_to_something
#+begin_src sh :file something.txt
  echo nothing
#+end_src

***** demarcation of indented blocks
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Demarcating a block with the point part-way in a line should indent
the remainder of the line in the second block.
    #+begin_src sh
      echo 1
      echo 2
      echo 3
      echo 4
    #+end_src

becomes

    #+begin_src sh :results silent :session something
      echo 1
      echo 2
      echo
    #+end_src
    
    #+begin_src sh :results silent :session something
           3
      echo 4
    #+end_src

***** simple indexing
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
#+name: list-o-numbers
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src sh :var column=list-o-numbers[,0]
  echo $column
#+end_src

#+name:
: 1 4 7

***** simple gnuplot plotting of Org-mode tables
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
#+tblname: gnuplot-testing
| x |  y |
|---+----|
| 1 |  2 |
| 2 |  4 |
| 3 |  6 |
| 4 |  8 |
| 5 | 10 |
| 6 | 12 |
| 7 | 14 |
| 8 | 16 |

#+begin_src gnuplot :var data=gnuplot-testing :file output.eps
set term postscript
set title "test"
set auto x
set style data histogram
set style fill solid border -1
set boxwidth 0.9
plot data using 2:xtic(1)
#+end_src

***** simple short R block
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
#+BEGIN_SRC R
c(1,23,54,5)
#+END_SRC

#+name:
|  1 |
| 23 |
| 54 |
|  5 |

***** convert results to all string
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
#+name: hetero-table
#+begin_src emacs-lisp
  '((1 2 3 4)
    ("a" "b" "c" "d"))
#+end_src

#+name: all-to-string
#+begin_src emacs-lisp :var tbl='()
  (defun all-to-string (tbl)
    (if (listp tbl)
        (mapcar #'all-to-string tbl)
      (if (stringp tbl)
          tbl
        (format "%s" tbl))))
  (all-to-string tbl)
#+end_src

#+begin_src emacs-lisp :var tbl=hetero-table
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
#+end_src

#+name:
| nil | nil | nil | nil |
| t   | t   | t   | t   |

#+begin_src emacs-lisp :var tbl=all-to-string(hetero-table)
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
#+end_src

#+name:
| t | t | t | t |
| t | t | t | t |

***** two blocks and a table
   :PROPERTIES:
   :DATE:     2011-08-28
   :END:

#+name: stuff
#+begin_src sh
  echo 1
  echo 2
  echo 3
#+end_src

#+name: last-of-stuff
#+begin_src sh :var input=stuff
  echo "$input" |tail -1
#+end_src

| one |
| two |
| 3   |
#+TBLFM: @3$1='(sbe last-of-stuff)

***** inheriting the file property
   :PROPERTIES:
   :FILE: something.png
   :DATE:     2011-08-23
   :END:

#+begin_src ditaa
   +-----------------------------+
   |                             |
   |    +-----+                  |
   |    |     |   +---------+    |
   |    |     |   |         |    |
   |    +-----+   |         |    |
   |              |         |    |
   |   file       |         |    |
   | inheritance  +---------+    |
   |                             |
   +-----------------------------+
#+end_src

#+name:
[[file:something.png]]

***** a table with tags
   :PROPERTIES:
   :DATE:     2011-08-23
   :END:

#+TBLNAME: sandbox           :noexport:
| 1 |         2 | 3 |
| 4 | org-babel | 6 |

#+begin_src emacs-lisp :var table=sandbox
  (message "%S" table)
#+end_src

#+name:
: ((1 2 3) (4 "org-babel" 6))

***** shell script output not in table
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
#+begin_src sh :results scalar
  echo 1
  echo 2
  echo 3
#+end_src

#+name:
: 1
: 2
: 3

***** inline code block and downstream src blocks
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
something src_sh{echo eric}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
#+begin_src sh
  echo schulte
#+end_src
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE

***** with R
    :PROPERTIES:
    :DATE:     2011-08-21
    :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
blah blah src_R[:results output]{cat(rnorm(2))}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
#+begin_src R :eval never :exports none
  1+2
  a <- b + c
  xyz
#+end_src
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD

***** updating a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+name: this-is-another-table
| 0 | 0 | 0 |
| 0 | 0 | 0 |
| 0 | 0 | 0 |

#+name: this-is-another-table
#+begin_src emacs-lisp :var table=this-is-another-table
  (setf (nth 1 table) '(2 2 2))
  table
#+end_src

***** space around exported code blocks
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
try evaluating the following blocks, then removing their results with
M-x `org-babel-remove-result'

Verbiage to begin the paragraph
#+begin_src sh
  echo eric
#+end_src
and verbiage to end the same paragraph.

#+begin_src sh
  echo 1
  echo 2
#+end_src

and verbiage to end the same paragraph.

***** simple ditaa block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+begin_src ditaa :file work-flow.png
    +-------+             +--------+
    |       |             |        |
    | Org   |------------>| Tex    |
    |       |             |        |
    +-------+             +--------+
#+end_src

#+name:
[[file:work-flow.png]]

***** ruby code block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+begin_src ruby
  1+2
#+end_src

#+name:
: 3

***** replacing a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+name: this-is-the-table
| 1 | 4 | 7 |
| 2 | 5 | 8 |
| 3 | 6 | 9 |

#+name: this-is-the-table
#+begin_src emacs-lisp :var table=this-is-the-table
  (mapcar (lambda (row) (mapcar (lambda (cell) (* cell 2)) row)) table)
#+end_src

***** tangle before evaluating a code block
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:

#+begin_src sh :var TANGLED=(org-babel-tangle) :tangle no
  wc $TANGLED
#+end_src

#+name:
: 2  2 11 it.sh

#+begin_src sh :tangle it.sh
  echo TEST
#+end_src

***** bug with undefined function copy-seq
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:
#+begin_src R :session :exports both
  1:10
#+end_src

***** plot results with org-plot
   :PROPERTIES:
   :DATE:     2011-08-02
   :END:
#+name: disk-usage
#+begin_src sh :exports both
  df
#+end_src

#+PLOT: title:"Disk Usage" ind:6 deps:(5) type:2d with:histograms set:"yrange [0:100]"
#+name: disk-usage
| Filesystem | 1K-blocks |     Used | Available | Use% | Mounted   | on |
| /dev/sda6  |  28835836 |  8447712 |  18923344 |  31% | /         |    |
| none       |   2997072 |      676 |   2996396 |   1% | /dev      |    |
| none       |   3006056 |        0 |   3006056 |   0% | /dev/shm  |    |
| none       |   3006056 |       96 |   3005960 |   1% | /var/run  |    |
| none       |   3006056 |        0 |   3006056 |   0% | /var/lock |    |
| /dev/sda7  | 144176824 | 72225604 |  64627420 |  53% | /home     |    |

***** premature truncation of emacs-lisp results
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

#+begin_src emacs-lisp
  '(nil nil nil nil)
#+end_src

#+name:
: (nil nil nil nil)

***** non-defined code blocks can still tangle
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

#+begin_src text :tangle somewhere.txt
  This will still tangle out to a file, and it opens in text mode, which
  may be nice.  
#+end_src

***** expand noweb refs
   :PROPERTIES:
   :DATE:     2011-07-25
   :END:
#+name: def-something
#+begin_src sh
  SOMETHING=nothing
#+end_src

#+begin_src sh
  <<def-something>>
  echo $SOMETHING
#+end_src

***** returning file names -- interpreted as lists
   :PROPERTIES:
   :DATE:     2011-07-21
   :END:
#+begin_src sh :results scalar
  echo "[[file:./cv.cls]]"
#+end_src

#+name:
: [[file:./cv.cls]]

#+begin_src sh :results raw scalar
  echo "[[file:./cv.cls]]"
#+end_src

#+name:
[[file:./cv.cls]]

***** java code block
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
#+begin_src java :classname myfirstjavaprog
  class myfirstjavaprog
  {  
      public static void main(String args[])
      {
          System.out.println("Hello World!");
      }
  }
#+end_src

#+name:
: Hello World!

***** including noweb refs w/o last newline
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
#+begin_src sh :noweb yes
  <<my-name>> |\
  <<capitalize-name>>
#+end_src

#+name: my-name
#+begin_src sh
  echo "eric schulte"
#+end_src

#+name: capitalize-name
#+begin_src sh
  sed 's/^e/E/;s/ s/ S/'
#+end_src

***** exporting a ditaa example
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:

#+begin_src ditaa :file blue.png :cmdline -r
/---------------\
|    test       |
|        {cBLU} |
\---------------/
#+end_src

#+name:
[[file:blue.png]]

***** simple sbe example
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

|   1 |
|   2 |
|   3 |
|   4 |
|   5 |
|   6 |
| 3.5 |
#+TBLFM: @7$1='(sbe mean (lst @1..@6))

#+name: mean
#+begin_src emacs-lisp :var lst=()
  (let ((num (car lst)) (nums (cdr lst)))
    (/ (float (+ num (apply #'+ nums))) (1+ (length nums))))
#+end_src

***** eval never
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

#+begin_src emacs-lisp :eval (if org-export-current-backend "never" "yes") :exports results
  (message "launch missles")
#+end_src

#+name:
: launch missles

***** indexing into a list variable
   :PROPERTIES:
   :DATE:     2011-07-06
   :END:

#+begin_src emacs-lisp :var lst='(0 1 2)
  (first lst)
#+end_src

#+name:
: 0

or as a noweb reference

#+name: external-list
- 0
- 1
- 2

#+begin_src sh :noweb yes
  echo <<external-list()[0]>>
#+end_src

#+name:
: 0

***** data alias for resname
   :PROPERTIES:
   :DATE:     2011-07-05
   :END:
#+name: blah
: blahcontent

#+begin_src emacs-lisp :var it=blah
  it
#+end_src

#+name:
: blahcontent

***** find a resource by global id
   :PROPERTIES:
   :DATE:     2011-07-01
   :END:

#+begin_src emacs-lisp :var it=990f3218-6fce-44fb-bd0c-5f6076c0dadc
  it
#+end_src

#+name:
: 
: here it is

****** I'm the resource
    :PROPERTIES:
    :ID:       990f3218-6fce-44fb-bd0c-5f6076c0dadc
    :DATE:     2011-07-01
    :END:

here it is

***** define a block with a name for noweb expansion
   :PROPERTIES:
   :tangle:   yes
   :noweb:    yes
   :DATE:     2011-07-01
   :END:

#+name: simple(something="something")
#+begin_src emacs-lisp
  something
#+end_src

another block including the first block
#+begin_src emacs-lisp
  <<simple(something="something else")>>
#+end_src

***** longtable label and attr lines on code block results
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:

#+name: faz
#+begin_src emacs-lisp :exports results
  '((foo foo)
    (bar baz))
#+end_src

#+LABEL: Foo
#+name: faz
| foo | foo |
| bar | baz |

***** another test
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:
#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

Here is a call_square(it=4), stuck in the middle of some prose.

Here is another 25^2=call_square(it=25).

***** un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

#+call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

#+name: minus
#+begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
#+end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

***** un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

#+call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

#+name: minus
#+begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
#+end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

***** multiple variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

Should work call_concat(1, 2, 3) =123= in order.

#+name: concat
#+begin_src emacs-lisp :var a=0 :var b=0 :var c=0
  (format "%S%S%S" a b c)
#+end_src

Should be positive call_lob-minus(4, 3) =1= by order.

***** inline call line
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: double
#+begin_src emacs-lisp :var it=0
  (* 2 it)
#+end_src

This is the number src_sh[:var it=double(it=1)]{echo $it} in the middle

The following exports as a normal call line
#+call: double(it=1)

Now here is an inline call call_double(it=1) stuck in the middle of
some prose.

This one should not be exported =call_double(it=2)= because it is
quoted.

Finally this next one should export, even though it starts a line
call_double(it=3) because sometimes inline blocks fold with a
paragraph.

And, a call with raw results call_double(4)[:results raw] should not
have quoted results.

***** text and graphics from R
   :PROPERTIES:
   :DATE:     2011-06-24
   :END:

#+begin_src R :results output :session
print(seq(1,10))
#+end_src

#+begin_src R :file example.png :results graphics :session
plot(seq(1,10))
#+end_src

#+name:
[[file:example.png]]

***** large code in inline blocks
   :PROPERTIES:
   :DATE:     2011-06-22
   :END:

#+name: big-block
#+begin_src emacs-lisp :exports none
  "something complex"
#+end_src

Here is some text with src_emacs-lisp[:var it=big-block]{it} in the middle.

***** clojure =:results scalar=
   :PROPERTIES:
   :DATE:     2011-06-21
   :END:
#+begin_src clojure :results scalar
  '(1 2 3)
#+end_src

***** expand variable during tangling
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2011-06-20
   :END:

#+begin_src sh :var VER=(vc-working-revision (buffer-file-name))
  echo $VER
#+end_src

***** scalar emacs lisp results
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
#+begin_src emacs-lisp :results scalar
  '(1 2 3)
#+end_src

#+name:
: (1 2 3)

***** python session
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
#+begin_src python :results output :session mypy 
x = 1
for i in range(1,5):
  x = x + i
  print x

print "I throw an error"
#+end_src

#+name:
: 
: ... ... ... 2
: 4
: 7
: 11
: I throw an error

#+begin_src python :results output :session
  print y
#+end_src

#+name:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: NameError: name 'y' is not defined

***** named code block export
   :PROPERTIES:
   :DATE:     2011-06-13
   :END:
This has a name which is not exported.

#+name: rand(n)
#+begin_src R
  runif(n)
#+end_src

***** tangle test
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
#+begin_src R :tangle test.R :shebang #!/bin/cat :padline no
This is
a test
#+end_src

***** ruby with xmpfilter
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
#+begin_src ruby :results xmp code
  2 + 2 # =>
  3.times{ puts :hello }
#+end_src

#+name:
#+BEGIN_SRC ruby
2 + 2 # => 4
3.times{ puts :hello }
# >> hello
# >> hello
# >> hello
#+END_SRC

***** continued code blocks
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2011-06-10
   :END:
#+name: foo
#+begin_src emacs-lisp
  (message "foo:%S" 1)
#+end_src

#+begin_src emacs-lisp
  (message "un-named")
#+end_src

#+name: bar
#+begin_src emacs-lisp
  (message "bar:%S" 1)
#+end_src

#+name: foo
#+begin_src emacs-lisp
  (message "foo:%S" 2)
#+end_src

#+name: bar
#+begin_src emacs-lisp
  (message "bar:%S" 2)
#+end_src

#+begin_src emacs-lisp :tangle no :results silent
  (with-temp-buffer
    (insert-file-contents "scraps.el")
    (eval-buffer))
#+end_src

***** simple shell
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src sh
  sleep 10 && ls
#+end_src

#+name:
| _config.yml     |
| data            |
| development.org |
| elsevier        |
| index.org       |
| paper           |
| publish.org     |
| scraps          |
| scraps.html     |
| scraps.org      |
| scraps.tex      |

#+begin_src ruby :session eric
  puts [1..4]
#+end_src

#+name:
: nil

***** quick testing new session code
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src sh :session test :results output
  echo foo
#+end_src

#+name:
: foo

#+begin_src ruby :results output :session simple
  puts "foo"
#+end_src

#+name:
: foo

***** =:file= and python
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src python :file /tmp/test.png
  return 1
#+end_src

#+name:
[[file:/tmp/test.png]]

***** testing new data names
   :PROPERTIES:
   :DATE:     2011-06-02
   :END:

#+name: simple-123
: 123

#+begin_src emacs-lisp :var simple=simple-123 :exports both
  (* simple 2)
#+end_src

results

data

my data is results

#+name:
: 246

***** default directory examples in lisp
   :PROPERTIES:
   :DATE:     2011-06-01
   :END:

#+begin_src lisp
  *default-pathname-defaults*
#+end_src

#+begin_src sh
  pwd
#+end_src

#+begin_src lisp :dir
  *default-pathname-defaults*
#+end_src

#+name:
: #P""

***** lisp body with multiple forms
   :PROPERTIES:
   :DATE:     2011-05-31
   :END:

#+begin_src lisp :results value
  (format t "~&eric")
  (+ 1 2)
#+end_src

#+name:
: 3

***** passing values through to STDIN of shell code blocks
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:
#+name: square-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+name: first-col
#+begin_src sh :stdin square-table
  awk '{print $1}'
#+end_src

#+begin_src sh :stdin first-col
  sed 's/4/middle/g'
#+end_src

#+name:
|      1 |
| middle |
|      7 |

***** awk example
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:

#+name: simple-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src awk :stdin simple-table
  {print $1}
#+end_src

#+name:
| 1 |
| 4 |
| 7 |

***** don't match end_src inside of a block
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:

#+name: the_issue
#+begin_src sh :results output
  echo '#+end_src'
#+end_src

#+name: the_issue
: #+end_src block

***** append tables
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:
#+name: table-names
- first-table
- second-table
- third-table

#+name: first-table
| a | 1 |
| b | 2 |

#+name: second-table
| c | 3 |
| d | 4 |

#+name: third-table
| e | 5 |
| f | 6 |

#+begin_src emacs-lisp :var table-names=table-names
  (mapcar #'org-babel-ref-resolve table-names)
#+end_src

#+name:
| (a 1) | (b 2) |
| (c 3) | (d 4) |
| (e 5) | (f 6) |

***** ocaml
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

#+begin_src ocaml
  [3;2;3] @ [3;2;3;4;5];;
#+end_src

#+name:
| 3 | 2 | 3 | 3 | 2 | 3 | 4 | 5 |

***** new names for results
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

#+name: simple
: 1

#+begin_src emacs-lisp :var data=simple
  data
#+end_src

#+name:
: 1

changing the variable used to label data
#+begin_src emacs-lisp :results silent
  (setq org-babel-result-fmt
        "^[ \t]*#\\+\\(TBLNAME\\|RESNAME\\|RESULTS\\|DATA\\):[ \t]*%s[ \t]*$")
#+end_src

#+name: not-so-simple
: 2

#+begin_src emacs-lisp :var data=not-so-simple
  data
#+end_src

#+name:
: 2

***** simple latex verbatim wrap example
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
#+begin_src emacs-lisp :results silent
  (setq org-export-latex-verbatim-wrap
        '("{\\scriptsize\n\\begin{verbatim}\n" . "\\end{verbatim}\n}\n"))
#+end_src

#+begin_src sh
  echo eric schulte
  echo another
#+end_src

***** inserting complicated results
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
#+begin_src emacs-lisp :results scalar
  ((lambda (result) (condition-case nil (read result) (error result)))
   "(:return
   (:ok \"{:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y*sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}\")
   13)")
#+end_src

#+name:
| :return | (:ok {:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y*sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}) | 13 |

***** automatic org-mode formatting
   :PROPERTIES:
   :DATE:     2011-04-27
   :END:

#+name: raw-results
#+begin_src sh :results output tabular
  echo "| 1 |"
  echo "| 2 |"
#+end_src

#+begin_src emacs-lisp :var in=raw-results
  (stringp in)
#+end_src

#+name:
: t

***** units in R plot
   :PROPERTIES:
   :DATE:     2011-04-21
   :END:
#+begin_src R  :results graphics :file test.png :width 8 :height 8 :res 200 :units cm
  x <- -10:10
  y <- x^2
  plot(x, y, type="l", col="red", lty=1)
#+end_src

#+name:
[[file:test.png]]

***** simple Oz example
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
#+begin_src oz :results output
  {Browse 'Hello'}
#+end_src

***** Ocaml appending blocks
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
block

#+begin_src ocaml
  [|1;2;3|];;
#+end_src

#+name:
| 1 | 2 | 3 |

***** complex numbers in tables and python, reference in table formula
   :PROPERTIES:
   :DATE:     2011-04-13
   :END:

#+name: parameter-variation(data=0)
#+begin_src python :result values
  return 'text'
#+end_src

|---------------------------------------|
| "(0.0331901438056,0.000535222885197)" |
| "(0.0333434157791,0.000537930174356)" |
| "(0.0345727512157,0.000559346040457)" |
| "(0.0353146483908,0.000571501584524)" |
| "(0.0355522909393,0.000574387067408)" |
| "(0.0356575682336,0.000574851263615)" |
| "(0.0357806926897,0.000575051685084)" |
|---------------------------------------|
| text                                  |
#+TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

| '(1 2 3 4) |
|------------|
|          4 |
#+TBLFM: @2$1='(sbe quote (it @1$1))

| (1 2 3 4) |
|-----------|
| #ERROR    |
#+TBLFM: @2$1='(sbe quote (it @1$1))

***** using vectors to represent complex number is lisp
    :PROPERTIES:
    :DATE:     2011-04-15
    :END:
| [1 2]            |
|------------------|
| real:1 complex:2 |
#+TBLFM: @2$1='(sbe real (it @1$1))

#+name: real(it='())
#+begin_src emacs-lisp
  (format "real:%d complex:%d" (aref it 0) (aref it 1))
#+end_src

***** reference the table in a table formula
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
#+name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
|-------------------------------------|
|                                   4 |
#+TBLFM: @2$1='(sbe quote (it "complex-data"))

***** externally referencing the table
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
#+name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |
#+TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

#+begin_src python :var data=complex-data
  return data
#+end_src

#+name:
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |

***** emacs-lisp printing with output to string
   :PROPERTIES:
   :DATE:     2011-04-10
   :END:

#+begin_src emacs-lisp :results output
  (let ((dog (sqrt 2))
        (cat 7))
    (print (format "%s %f" "Dog: " (eval dog)))
    (print (format "%s %d" "Cat: " (eval cat)) nil)
    (print "Fish."))
#+end_src

#+name:
: 
: "Dog:  1.414214"
: 
: "Cat:  7"
: 
: "Fish."


#+begin_src emacs-lisp
  (let ((dog (sqrt 2))
        (cat 7))
    `((dog ,dog)
      (cat ,cat)
      (fish)))
#+end_src

#+name:
| dog  | 1.4142135623730951 |
| cat  |                  7 |
| fish |                    |

***** headers in R tables during export
   :PROPERTIES:
   :DATE:     2011-04-04
   :END:
#+TBLNAME: Chuah07
| condition | Mean.offer |
|-----------+------------|
| 1.MMM     |      48.49 |
| 2.MMU     |      42.59 |
| 3.MUM     |      44.87 |
| 4.UMU     |      46.43 |
| 5.UUM     |      44.15 |
| 6.UUU     |      43.80 |
| MAL       |      46.28 |
| UK        |       44.1 |
| All       |      45.29 |

#+headers: :var data=Chuah07
#+begin_src R :results output :exports both :cache yes
  str(data)
#+end_src

#+name[135a7f73839b69d118780ca29a64c3840601f7b9]:
: 'data.frame': 9 obs. of  2 variables:
:  $ condition : chr  "1.MMM" "2.MMU" "3.MUM" "4.UMU" ... 
:  $ Mean.offer: num  48.5 42.6 44.9 46.4 44.1 ... eric

***** session associated with R block
   :PROPERTIES:
   :DATE:     2011-04-02
   :END:
#+begin_src R :session *chris*
  x <- 1
  y <- 2
  y-x
#+end_src

#+name:
: 1

***** vc-log
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

A version control log of this file.  The =vc-log= code block lives in
the library of babel.
#+call: vc-log() :exports results

***** tangling out vc information
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

#+headers: :var STATE=(vc-state (or (buffer-file-name) org-current-export-file))
#+headers: :var REV=(vc-working-revision (or (buffer-file-name) org-current-export-file))
#+begin_src sh :tangle yes
  rm -rf ./R
  rm -f ./spreadSim.sub
  REVISION=$REV.$STATE
  tar -xf nsa.$REVISION.tar.gz
  $HOME/R/R/R-2.12.0/bin/Rscript --vanilla -e
"source('./R/generateLatinHypercubeScenarios.R'); doIt()"
  for SCENARIO in ./R/scenarios/*.R; do
    export SCENARIO=${SCENARIO#./R/scenarios/}
    qsub nsa.sub
  done
#+end_src

***** grabbing the current buffer during export
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
Eric

#+begin_src emacs-lisp :var buf=(buffer-file-name (current-buffer)) :exports both
  (message "buffer %S!" buf)
#+end_src

#+begin_src sh :exports results :results output
  git log -1
#+end_src

***** detangling example
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :shebang:  #!/bin/sh
   :ID:       7a22cf71-6be3-4fca-a700-4c8be8237303
   :DATE:     2011-04-01
   :END:

#+name: sh-for-tangling
#+begin_src sh
  echo "this is the `sh-for-tangling' code block"
  num=`expr 1 + 1`
  echo "the value of num is $num"
#+end_src

#+begin_src sh
  echo "this is an unnamed code block"
#+end_src

***** CL example
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
#+begin_src lisp
  (defun range (n &optional m)
    "Return the numbers in range."
    (loop for num from (if m n 0) to (if m m (- n 1)) collect num))
  
  (mapcar #'list (mapcar #'1+ (range 10)))
#+end_src

#+name:
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

***** colnames with call lines
   :PROPERTIES:
   :DATE:     2011-03-29
   :END:
#+TBLNAME: data
| x | parameter | value |
|---+-----------+-------|
| 0 | heat      |    30 |
| 1 | heat      |    30 |

#+name: func5
#+begin_src R :var name=data :var a="one" :colnames yes
  names(name)
#+end_src

#+name: func5
| x         |
|-----------|
| x         |
| parameter |
| value     |

#+call: func5(name=data, a="two") :colnames yes

#+name: func5(name=data, a="two")
| x         |
|-----------|
| x         |
| parameter |
| value     |

***** caching on export
   :PROPERTIES:
   :DATE:     2011-03-23
   :END:
#+name: testcache
#+begin_src R :cache yes :exports results
  dat <-  matrix(runif(12), 3, 4)
  print(dat)
#+end_src

#+name[e7b83e61596da84f85c5a24e61569576c802f9a2]: testcache
| 0.590091332094744 | 0.101750465808436 | 0.487125408137217 |  0.92315583024174 |
| 0.483292032498866 | 0.427640072302893 | 0.974636133294553 | 0.995571716455743 |
|  0.60190233332105 | 0.122638279106468 | 0.437959408387542 | 0.015639441087842 |

***** macros during tangling
   :PROPERTIES:
   :ID:       d2ff9d6f-b413-4072-91a9-3ae8aa32032c
   :DATE:     2011-03-14
   :END:

First, add macro expansion to the new `org-babel-tangle-body-hook'.

#+begin_src emacs-lisp :results silent
  (add-hook 'org-babel-tangle-body-hook
            (lambda () (org-export-preprocess-apply-macros)))
#+end_src

Then define the macro.  Note: you may need to export the buffer before
tangling so that the macro definition is noticed and processed by
Org-mode.

#+MACRO: CONFIG_PARAM01 45

Then on both export and tangling the macro in the following code block
will be replaced.

#+begin_src sh :tangle yes
  echo org-mode set CONFIG_PARAMETER to: {{{CONFIG_PARAM01}}}
#+end_src

***** conflicting header arguments
   :PROPERTIES:
   :DATE:     2011-03-14
   :END:

code block
#+name: conflict-block
#+begin_src sh :exports results :results silent
  echo eric
#+end_src

call line
#+call: conflict-block() :exports results

#+name: conflict-block()
: eric

***** looks like a pipe in a table
   :PROPERTIES:
   :DATE:     2011-03-07
   :END:
#+name: clean
#+begin_src emacs-lisp :var in=""
  (flet ((clean (in)
                (if (listp in)
                    (mapcar #'clean in)
                  (if (stringp in)
                      (replace-regexp-in-string "¦" "|" in)
                    in))))
    (clean in))
#+end_src

#+name: regexps
| first  | (a¦b) |
| second | (1¦2) |

#+begin_src perl :var a=clean(in=regexps)[0,1] :var b=clean(in=regexps)[1,1]
  $a; $b;
#+end_src

#+name:
: (1|2)

***** eval results as a list
   :PROPERTIES:
   :DATE:     2011-03-06
   :END:
#+begin_src python :results value
  return "(mapcar (lambda (el) (+ 1 el)) '(1 2))"
#+end_src

#+name:
| 2 | 3 |

#+begin_src python :results value
  return "[1, 2]"
#+end_src

#+name:
| 1 | 2 |

#+begin_src python :results value
  return [1, 2]
#+end_src

#+name:
| 1 | 2 |

#+begin_src python :results value
  return "%r" % "[1 2]"
#+end_src

#+name:
: [1 2]

***** simple mysql
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
#+begin_src sql :engine mysql
  show tables;
#+end_src

***** export of inline R code
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
Here I test inline code evaluation in R.

#+begin_src R :session *R*
x <- 100
#+end_src

#+name:
: 100

Now I want to export the value of x, which should be
src_R[:session *R*]{x} .

Did the number 100 show up at the end of the previous sentence on export?

***** results org raw wrap
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
#+begin_src sh :results output org :exports none
  cat <<EOF
  - first
  - second
  EOF
#+end_src

#+name:
#+BEGIN_ORG
- first
- second
#+END_ORG

****** Version 1
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version only prints the org code for the table, but does not interprets it.
#+begin_src R :exports both :results output raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

****** Version 2
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version prints the table including the graph as expected, but
:results is used twice as a header argument.
#+begin_src R :results output :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

****** Version 3
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
Finally this version does only export the R code
#+begin_src R :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

***** leading/trailing spaces
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
#+name: spaces-wrapped-string
- " pass through with space "

#+begin_src emacs-lisp :var res=spaces-wrapped-string[0]
  res
#+end_src

#+name:
:  pass through with space 

***** reference to a commented out subtree
      :PROPERTIES:
      :DATE:     2011-02-28
      :END:
****** COMMENT I don't export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
#+name: hidden-parameters
| 1 |
| 2 |
| 3 |
| 4 |

****** I do export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
#+begin_src emacs-lisp :var params=hidden-parameters :exports both
  params
#+end_src

***** literal reference in a table with sbe
   :PROPERTIES:
   :DATE:     2011-02-28
   :END:

| "eric schulte" | 12 |
#+TBLFM: @1$2='(sbe length (in $1))

#+name: length
#+begin_src emacs-lisp :var in="foo"
  (length in)
#+end_src

***** strip hline before processing a variables indices
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+name: table-w-hline
| 1 | a |
|---+---|
| 2 | b |
| 3 | c |
| 4 | d |

#+begin_src emacs-lisp :var table=table-w-hline[1,1] :hlines no
  table
#+end_src

#+name:
: hline

#+tblname: perl-table-w-hline
| colA | colB |
|------+------|
| a1   | b1   |
| a2   | b2   |

#+headers: :var b=perl-table-w-hline[2..,1]
#+headers: :var a=perl-table-w-hline[2..,0]
#+begin_src perl :tangle yes
  $a; $b;
#+end_src 

***** passing elisp-looking variables to code blocks
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+begin_src perl :var it="(+ 1 1)" :results output
  printf "passed in %s", $it
#+end_src

#+name:
: passed in (+ 1 1)

#+name: elisp-looking-table
| 1 | (+ 1 1) |
| 2 | (a b c) |
| 3 | (+ 3 3) |

#+begin_src perl :var data=elisp-looking-table[1,1]
  $data
#+end_src

#+name:
: (a b c)

#+begin_src emacs-lisp :var data=elisp-looking-table[1,1]
  data
#+end_src

#+name:
: (a b c)

***** pass a vector to calc
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:

#+begin_src calc :var y=[1 2 3]
  y
#+end_src

#+name:
: [1 2 3]

#+begin_src calc :var y=[1 2 3]
  3 y
#+end_src

#+name:
: [3, 6, 9]

#+begin_src emacs-lisp :var data=[1 2 3]
  (elt data 1)
#+end_src

#+name:
: 2

#+begin_src calc
  1 * 8
#+end_src

#+name:
: 8

***** new block regexp tests
      :PROPERTIES:
      :DATE:     2011-02-27
      :END:
****** Block 1 (Exports OK)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 1
#+END_SRC

****** Block 2 (Exports OK - double blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out


#+END_SRC

****** Block 3 (Fails - single blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out

#+END_SRC

****** Block 4 (Gets consumed by previous Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 4
#+END_SRC

****** Block 5 (Fails - no lines in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
#+END_SRC

****** Block 6 (Gets consumed by previous Block
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 6
#+END_SRC

***** exporting cache and noweb
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+name: test_sleep
#+begin_src R :session :exports code
  Sys.sleep(time=5)
  1:10
#+end_src

#+name: test_sleep
#+begin_src R :session :exports results :noweb yes :cache yes
  <<test_sleep>>
#+end_src

#+name[e2c9e6c2f84563b590a765502057d92463e50182]: test_sleep
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

***** don't interpret tuples as elisp code
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+begin_src python :results value
  return (1,2)
#+end_src

#+name:
: (1, 2)

***** source block names in current buffer
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src emacs-lisp :results list
 (org-babel-src-block-names)
#+end_src

***** simple python block
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src python :return foo
  foo = 8
  foo += 1
#+end_src

#+name:
: 9

***** sh return a list of elements with spaces
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src sh :results list
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
#+end_src

#+name:
- ("eric" "schulte")
- ("dan" "davison")
- ("seb" "vauban")

#+begin_src sh :results scalar
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
#+end_src

#+name:
: eric schulte
: dan davison
: seb vauban

***** calc variables inside of parenthesis
   :PROPERTIES:
   :DATE:     2011-02-22
   :END:
#+BEGIN_SRC calc :var testvar=9000
testvar - 200
#+END_SRC

#+name:
: 8800

#+BEGIN_SRC calc :var testvar=9000
(testvar - 200) 800
#+END_SRC

#+name:
: 7040000

***** new lists
      :PROPERTIES:
      :DATE:     2011-02-21
      :END:
****** results embedded inside of a list
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
1. this has results
   #+name: something-in-a-list
   : foo
2. and this doesn't work
   #+begin_src emacs-lisp :var data=something-in-a-list
     data
   #+end_src

   #+name:
   : foo

****** reading and writing
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
#+name: simple-list
- 1
- two
- 3
- four


#+name: simple-list
#+begin_src emacs-lisp :var lst=simple-list :results list
  (reverse lst)
#+end_src

***** catch the file name during export
   :PROPERTIES:
   :DATE:     2011-02-21
   :END:

#+begin_src emacs-lisp :var file-name=(buffer-file-name) :exports both
  file-name
#+end_src

***** mentions of file names in file contents
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
directory to search
#+name: graph-dir
: graph-dir

list all files in dir
#+name: graph-files
#+begin_src sh :results vector :var dir=graph-dir
  find $dir -type f -exec basename {} \;
#+end_src

#+name: graph-files
| other |
| dan   |
| eric  |
| seb   |

association of files with mentions
#+name: graph-associations
#+begin_src sh :var dir=graph-dir :var files=graph-files
  for i in $files; do
      for j in `grep -l -r $i $dir`;do
          echo $i, `basename $j`
      done
  done
#+end_src

#+name: graph-associations
| other | eric |
| other | seb  |
| dan   | eric |
| eric  | seb  |
| seb   | dan  |

graphing with dot
#+name: to-dot
#+begin_src sh :var associations=graph-associations :results scalar
  echo "$associations"|awk '{print $1, "->", $2}'
#+end_src

#+name: to-dot
: other -> eric
: other -> seb
: dan -> eric
: eric -> seb
: seb -> dan

#+begin_src dot :var data=to-dot :file files.png
  digraph G{
    $data
  }
#+end_src

#+name:
[[file:files.png]]

***** export of inline code blocks which are silent
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
#+begin_src emacs-lisp :results silent
  (setf org-babel-default-inline-header-args
        '((:session . "none")
          (:results . (if (boundp 'org-current-export-file) "replace" "silent"))
          (:exports . "results")))
#+end_src

Here is an inline code block src_sh{echo 8} <- there

***** inline code block
   :PROPERTIES:
   :DATE:     2011-02-18
   :END:

here is an inline block src_R{1+1}

***** SQL --- example reading org-mode table into sql
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
#+tblname: example-table-for-sql
| a |  b |
|---+----|
| 1 | 10 |
| 2 | 11 |
| 3 | 12 |
| 4 | 13 |
| 5 | 14 |
| 6 | 15 |

#+headers: :var table=example-table-for-sql
#+begin_src sql :engine mysql
load data infile "$table" into mytable;
#+end_src

***** recutils
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
#+begin_src sh :file book.rec
  cat <<EOF > book.rec
  # -*- mode: rec -*-
  %rec: Book
  %mandatory: Title
  %type: Location enum loaned home unknown
  %doc:
  + A book in my personal collection.
  
  Title: GNU Emacs Manual
  Author: Richard M. Stallman
  Publisher: FSF
  Location: home
  
  Title: The Colour of Magic
  Author: Terry Pratchett
  Location: loaned
  
  Title: Mio Cid
  Author: Anonymous
  Location: home
  
  Title: chapters.gnu.org administration guide
  Author: Nacho Gonzalez
  Author: Jose E. Marchesi
  Location: unknown
  
  Title: Yeelong User Manual
  Location: home
  
  # End of books.rec
  EOF
#+end_src

#+name:
[[file:book.rec]]

#+begin_src rec :data book.rec :fields Title,Author
  Location = 'loaned'
#+end_src

#+name:
| Title               | Author          |
| The Colour of Magic | Terry Pratchett |

#+begin_src rec :data book.rec :fields Title,Author
  
#+end_src

#+name:
| Title                                 | Author              | Author_2         |
| GNU Emacs Manual                      | Richard M. Stallman |                  |
| The Colour of Magic                   | Terry Pratchett     |                  |
| Mio Cid                               | Anonymous           |                  |
| chapters.gnu.org administration guide | Nacho Gonzalez      | Jose E. Marchesi |
| Yeelong User Manual                   |                     |                  |

***** passing keywords inside header arguments
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:

#+begin_src emacs-lisp :var lst='(:no-expand :other)
  lst
#+end_src

#+name:
| :no-expand | other |

***** two vars in a properties block -- not possible
   :PROPERTIES:
   :var:      test1=7
   :var:      test2=8
   :DATE:     2011-02-10
   :END:

#+begin_src emacs-lisp
  (message "test1=%S test2=%S" test1 test2)
#+end_src

results in Error
: let: Symbol's value as variable is void: test2

****** an alternative
    :PROPERTIES:
    :var:      tests=all-tests
    :DATE:     2011-02-10
    :END:

#+tblname: all-tests
- 7
- 8

#+begin_src emacs-lisp :var eric=89
  (message "test1=%S test2=%S" (first tests) (second tests))
#+end_src

#+name:
: test1=7 test2=8

****** another alternative
    :PROPERTIES:
    :var:      vars=variables
    :DATE:     2011-06-21
    :END:

#+tblname: variables
| var1 | 1 |
| var2 | 2 |

#+begin_src python
  print vars[0][1]
  print vars[1][1]
#+end_src

***** how to set no-expand in properties
   :PROPERTIES:
   :no-expand: yes
   :DATE:     2011-02-10
   :END:

#+begin_src emacs-lisp :var something="other thing" :tangle no-expand.el
  :test
#+end_src

tangles to

***** non-inlined inline code block
   :PROPERTIES:
   :DATE:     2011-01-27
   :END:
The Date is src_sh[:results replace]{date} at the time of =this= export.

src_sh[:results replace]{ls}

***** simple calc example
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
#+begin_src calc 
2*3
#+end_src

#+name:
: 6

***** results replace not always working
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
#+begin_src sh :results output org replace :exports code
  for i in `seq 4`;do
      echo "- place $i in the list"
  done
#+end_src

#+name:
#+BEGIN_ORG
- place 1 in the list
- place 2 in the list
- place 3 in the list
- place 4 in the list
#+END_ORG

inline block src_emacs-lisp[:exports code :results replace]{(+ 1 1 1)} here is was

***** inserting wrappers eats following characters
      :PROPERTIES:
      :DATE:     2011-01-20
      :END:
****** Test
       :PROPERTIES:
       :DATE:     2011-01-20
       :END:
     
     #+begin_src emacs-lisp :results latex
       "\\begin{equation}\\frac{1}{2}\n\\end{equation}"
     #+end_src

     #+name:
     #+BEGIN_LaTeX
     \begin{equation}\frac{1}{2}
     \end{equation}
     #+END_LaTeX
     
****** Watch me die :-(
       :PROPERTIES:
       :DATE:     2011-01-20
       :END:

***** creating a directory when needed for tangling
   :PROPERTIES:
   :DATE:     2011-01-19
   :END:
#+begin_src clojure :tangle (prog1 "src/foo.clj" (make-directory "src" "."))
  (ns something)
#+end_src

a helper function for the above
#+begin_src emacs-lisp
  (defun mkdir-p (file &optional dir)
    "Create any parent directories of FILE if missing and return FILE."
    (make-directory (file-name-directory file) (or dir ".")) file)
#+end_src

allows the following
#+begin_src clojure :tangle (mkdir-p "src/foo.clj")
  (ns something)
#+end_src

There is now a new header argument controlling this behavior
#+begin_src emacs-lisp :mkdirp yes :tangle novel/nested/directories/finally.clj
  (message "contents")
#+end_src

***** passing arguments to the shell
   :PROPERTIES:
   :DATE:     2011-01-18
   :END:
#+name: something
: eric
:   schulte
:     yes
: more

#+name: something-list
| 1 |
| 2 |
| 3 |

#+begin_src sh :var data=something-list
  echo "$data"|wc -l
#+end_src

#+name:
: 3

#+begin_src emacs-lisp :results silent
  (setq org-babel-sh-var-quote-fmt "`cat <<'BABEL_TABLE'\n%s\nBABEL_TABLE\n`")
#+end_src

***** wrap noweb references in comments
   :PROPERTIES:
   :DATE:     2011-01-16
   :END:
#+name: wrappable
#+begin_src emacs-lisp
  (setq x (+ 4 x))
#+end_src

#+begin_src emacs-lisp :comments noweb :noweb yes :tangle yes
  (let ((x 1))
    (message "x=%s" x)
    <<wrappable>>
    (message "x=%s" x))
#+end_src

***** replace inline code block
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
This is src_emacs-lisp{(+ 1 2 3)} an inline block.

#+begin_src emacs-lisp
  (defun replace-inline-block ()
    (interactive)
    (if (save-excursion (re-search-backward "[ \f\t\n\r\v]" nil t)
                        (looking-at org-babel-inline-src-block-regexp))
        (replace-match
         ((lambda (el) (if (stringp el) el (format "%S" el)))
          (org-babel-execute-src-block)) nil nil nil 1)
      (error "not inside of an inline source block.")))
#+end_src

***** noweb then variables
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
#+name: replaced-first
#+begin_src latex
  \begin{itemize}
  \item first
  \item data
  \item third
  \end{itemize}
#+end_src

#+begin_src latex :var data="second" :noweb yes
  \section{ordinals}
  \label{sec:ordinals}
  <<replaced-first>>
#+end_src

***** empty strings as arguments
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:

#+begin_src emacs-lisp :results output :var foo=""
  (concat foo "bar")
#+end_src

#+name:
: bar

***** call lines
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:
#+name: doubler
#+begin_src emacs-lisp :var n=2
  (* n 2)
#+end_src

#+call: doubler(n=3)

#+name: doubler(n=3)
: 6

#+call: doubler[:var n=3]()

#+name: doubler[:var n=3]()
: 6

***** language name abbreviations
   :PROPERTIES:
   :DATE:     2011-01-07
   :END:

#+begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("clj" . clojure))
#+end_src

#+begin_src clj
  (map (partial + 1) (range 20))
#+end_src

***** eval query
   :PROPERTIES:
   :DATE:     2010-12-21
   :END:
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate
        (lambda (lang body) (not (equal "ditaa" lang))))
#+end_src

#+name:
| lambda | (lang body) | (not (equal ditaa lang)) |

#+begin_src emacs-lisp :eval query
  (message "eval'd")
#+end_src

#+name:
: eval'd

#+begin_src ditaa
  ---
#+end_src

***** new file handling
   :PROPERTIES:
   :DATE:     2010-12-20
   :END:

#+begin_src sh :sep , :file dirlisting
  ls -l
#+end_src

#+name:
[[file:dirlisting]]

#+begin_src ruby :file ruby-out
  [[1, 2, 3, 4],
   [2, 4, 6, 8]]
#+end_src

#+name:
[[file:ruby-out]]

#+begin_src emacs-lisp :results file :results append
  (let ((today (replace-regexp-in-string "[ \t]" "-" (current-time-string))))
    (with-temp-file today
      (insert (message "I'm feeling %s"
                       (nth (random 3) (list "good" "bad" "just fine")))))
    today)
#+end_src

#+name:
[[file:Mon-Dec-20-17:27:52-2010]]

from http://www.graphviz.org/Gallery/directed/fsm.gv.txt
#+begin_src dot :file fsa.png
  digraph finite_state_machine {
          rankdir=LR;
          size="8,5"
          node [shape = doublecircle]; LR_0 LR_3 LR_4 LR_8;
          node [shape = circle];
          LR_0 -> LR_2 [ label = "SS(B)" ];
          LR_0 -> LR_1 [ label = "SS(S)" ];
          LR_1 -> LR_3 [ label = "S($end)" ];
          LR_2 -> LR_6 [ label = "SS(b)" ];
          LR_2 -> LR_5 [ label = "SS(a)" ];
          LR_2 -> LR_4 [ label = "S(A)" ];
          LR_5 -> LR_7 [ label = "S(b)" ];
          LR_5 -> LR_5 [ label = "S(a)" ];
          LR_6 -> LR_6 [ label = "S(b)" ];
          LR_6 -> LR_5 [ label = "S(a)" ];
          LR_7 -> LR_8 [ label = "S(b)" ];
          LR_7 -> LR_5 [ label = "S(a)" ];
          LR_8 -> LR_6 [ label = "S(b)" ];
          LR_8 -> LR_5 [ label = "S(a)" ];
  }
#+end_src

#+name:
[[file:fsa.png]]

***** utf8 and latin-1 encodings
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
#+tblname: toto
| é |

#+begin_src python :var t=toto :preamble # -*- coding: latin1 -*- :return [len(babel), len(local)]
  babel = unicode (t[0][0],"latin1")
  local = unicode ("é","latin1")
#+end_src

#+name:
| 2 | 2 |

***** tangle templates
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
#+name: template-heading
#+begin_src emacs-lisp
  some stuff here
#+end_src

#+name: template-footing
#+begin_src emacs-lisp
  some other stuff here
#+end_src

#+name: template
#+begin_src sh :results output :noweb yes :var body="body stuff"
heading=$(cat<<EOF
<<template-heading>>
EOF
)
footing=$(cat<<EOF
<<template-footing>>
EOF
)
echo $heading
echo "$body"
echo $footing
#+end_src

#+call: template[:noweb yes](body="something new")

#+name: template[:noweb yes](body="something new")
: some stuff here
: something new
: some other stuff here

***** missing lines on tangle
   :PROPERTIES:
   :ID:       83eb62fd-4147-405b-bdc2-567b2d5cbd70
   :DATE:     2010-12-13
   :END:
#+begin_src org :results latex :tangle latex-err.tex
  ,one
  ,two
  ,three
#+end_src

#+begin_src org :results latex :results replace
  ,- eric
  ,- schulte
#+end_src

#+name:
#+BEGIN_LaTeX
\begin{itemize}
\item eric
\item schulte
\end{itemize}
#+END_LaTeX

***** Python requires a utf-8 coding prefix
   :PROPERTIES:
   :DATE:     2010-12-02
   :END:
#+begin_src python :prefix # -*- coding: utf-8 -*- :return s
s = "é"
#+end_src

#+name:
: é

#+begin_src python :prefix # -*- coding: utf-8 -*- :results output
s = "é"
print(s)
#+end_src

#+name:
: é

***** empty lines in R session output
   :PROPERTIES:
   :DATE:     2010-12-01
   :END:
#+begin_src R :results output :session
  x <- 1;
  x
  x + 1
  x + 4
#+end_src R

#+name:
: [1] 1
: [1] 2
: [1] 5

***** sql variables
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
#+name: sql-param
| table       | valueTable0       |
| column      | valueColumn0      |
| type        | valueType0        |
| nullability | valueNullability0 |

I want to apply the values onto the following chunk of code:

#+name: add-column-in-table-0
#+begin_src sql :var table=sql-param[0,1] :var column=sql-param[1,1] :var type=sql-param[2,1] :var nullability=sql-param[3,1]
-- add column `@column' (if column does not exist yet)
IF NOT EXISTS (SELECT *
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '@table'
               AND COLUMN_NAME = '@column')
BEGIN
    ALTER TABLE $table
    ADD $column $type @nullability
END
#+end_src

***** =:eval query= shows the name
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
#+name: i-have-a-name
#+begin_src sh :eval query
  date
#+end_src

#+name: i-have-a-name
: Tue Nov 30 22:03:25 MST 2010

***** python with return header argument
   :PROPERTIES:
   :DATE:     2010-11-27
   :END:

#+begin_src python :return y
  x = 8
  y = 98
  2
#+end_src

#+name:
: 98

***** un-named R code blocks
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
#+begin_src R
  8
#+end_src

#+name:
: 8

#+begin_src emacs-lisp :eric
8  
#+end_src

#+name:
: 8

#+BEGIN_SRC R :session :results output
 xyz
#+END_SRC

#+BEGIN_SRC R :session *R-2* :results output |  xyz
9
#+END_SRC

#+name:
: [1] 9

***** safe lists for Haskell
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:

#+tblname: mixed-table
| 1 | first  |
| 2 | second |
| 3 | third  |
| 4 | fourth | 

#+name: rec-string-wrap
#+begin_src emacs-lisp :var data=mixed-table
  (defun rec-string-wrap (in)
    (if (listp in) (mapcar #'rec-string-wrap in) (format "%S" in)))
  (rec-string-wrap data)
#+end_src

#+begin_src haskell :var tbl=rec-string-wrap(data=mixed-table)
  map head tbl
#+end_src

#+name:
| 1 | 2 | 3 | 4 |

***** reading from single-quote-delim languages
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
#+BEGIN_SRC python
return [['607', 'Show license short, name on the deed'],
        ['255', "'(message (concat 'hello ' 'world))"]]
#+END_SRC

#+name:
| 607 | Show license short, name on the deed |
| 255 | '(message (concat 'hello ' 'world))  |

#+begin_src ruby
  [['607', 'Show license, short name on the deed'],
   ['255', "))'(message (concat 'hello ' 'world"]]
#+end_src

#+name:
| 607 | Show license, short name on the deed |
| 255 | ))'(message (concat 'hello ' 'world  |

#+begin_src haskell
  [["'single quotes'", "b"], ["\"double quotes\"", "d"]]
#+end_src

#+name:
| 'single quotes' | b |
| "double quotes" | d |

***** add column to table with awk
   :PROPERTIES:
   :question_author: Sébastien Vauban
   :DATE:     2010-11-23
   :END:
I want to *add a column* to the following table.

#+name: table-message
| This is line 1 of the message.        |
| This is line 2 of the message.        |
| This is the last line of the message. |

Its value should be dependant on a *regexp matching* the *current row*
(for example, if 1 is detected in the original column, then write "A"
in the new one, "B" if 2 is read, "C" if 3 is read, etc.).

Hence, I'm thinking using AWK as an easy solution.

    #+begin_src note
    I'm open to other ideas on how I could do this as easily. Just throw me
    ideas, if you have some.
    #+end_src

the easiest (for me) would be with the elisp =mapcar= function
#+begin_src emacs-lisp :var tbl=table-message
  (mapcar (lambda (row) (cons "New col" row)) tbl)
#+end_src

#+name:
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

*First* trial: add a column whose cell contents will be *fixed* (here,
equal to =New col=).

#+name: add-col
#+begin_src sh :var data=table-message :results output raw :exports both
echo "$data" | awk '// {print "| New col | " $0 " |";}'
#+end_src

#+name: add-col
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

***** lists as data types
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:

#+name: a-list
- org-mode
- and
- babel

#+name: a-list
#+begin_src emacs-lisp :var lst=a-list :results list
  (reverse lst)
#+end_src

also for a block inside of a list
1. First element
2. Second element -- has a block
   #+begin_src emacs-lisp
     (+ 1 1 1 1)
   #+end_src

   #+name:
   : 4

3. third element

***** introducing =wrap= header argument
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:
#+begin_src emacs-lisp :results wrap :exports both
  (mapcar (lambda (el) (list el (+ 1 (* el el)))) (number-sequence 0 10))
#+end_src

#+name:
#+BEGIN_RESULT
|  0 |   1 |
|  1 |   2 |
|  2 |   5 |
|  3 |  10 |
|  4 |  17 |
|  5 |  26 |
|  6 |  37 |
|  7 |  50 |
|  8 |  65 |
|  9 |  82 |
| 10 | 101 |
#+END_RESULT

now indented
- first
- second
  #+begin_src emacs-lisp :results wrap :exports both
    "something else"
  #+end_src

  #+name:
  #+BEGIN_RESULT
  : something else
  #+END_RESULT

***** sqlite
   :PROPERTIES:
   :DATE:     2010-11-10
   :END:
#+begin_src sqlite :db paper/climate.sqlite
  select count(*) from temps;
#+end_src

#+name:
: 422689

***** lob calls with header argument pass through
   :PROPERTIES:
   :DATE:     2010-11-08
   :END:

#+name: lob-header
#+begin_src emacs-lisp :var n=20
  n
#+end_src

#+call: lob-header[:results vector](n=15)

#+name: lob-header[:results vector](n=15)
| 15 |

#+call: lob-header(n=10) :results vector

#+name: lob-header(n=10)
| 10 |

need ob-ref.el to pass through the header arguments in "[]"s
#+begin_src emacs-lisp :var n=lob-header[:results vector](n=8)
  n
#+end_src

#+name:
| 8 |

#+begin_src emacs-lisp :var n=lob-header[:results vector](n=8)[0,0]
  n
#+end_src

#+name:
: 8

***** clojure code blocks and the lazies
   :PROPERTIES:
   :DATE:     2010-11-06
   :END:
#+begin_src emacs-lisp :results silent
  (defun org-babel-execute:clojure (body params)
    (with-temp-buffer
      (insert body)
      (read
       (slime-eval
        `(swank:interactive-eval-region 
          ,(buffer-substring-no-properties (point-min) (point-max)))))))
#+end_src

#+begin_src clojure
  (map (fn [el] (list el (* el el)))(range 10))
#+end_src

#+name:
| 0 |  0 |
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
| 9 | 81 |

***** shell blocks returning a file name
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
#+begin_src sh :file quick.txt :results output
  date
#+end_src

#+name:
[[file:quick.txt]]

***** playing with calc support
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
#+begin_src emacs-lisp
  (require 'ob-calc)
#+end_src

#+begin_src calc :var some=8
  some
  some
  '*
  8+8
  '+
#+end_src

#+name:
: 80

#+begin_src calc
  2*(8+8)
#+end_src

#+name:
: 32

#+begin_src calc
  2*e
#+end_src

#+name:
: 5.43656365692

#+begin_src calc :var something=9
  2*something
#+end_src

#+name:
: 18

***** passing arguments through call lines
   :PROPERTIES:
   :DATE:     2010-10-29
   :END:

#+name: test
#+begin_src R :session :file test.pdf :var myarg="bla"
  plot(1:10, main=myarg)
#+end_src

#+name: test
[[file:test.pdf]]

#+call: test(myarg="hiho")

#+name: test(myarg="hiho")
: test.pdf

***** simple gnuplot tests
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:
#+name: some-more-gnuplot
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=some-more-gnuplot
  plot "$data"
#+end_src

#+name:

Plotting data points from a table could look like this:
#+tblname: basic-plot
|   x |         y1 |         y2 |
|-----+------------+------------|
| 0.1 |      0.425 |      0.375 |
| 0.2 |     0.3125 |     0.3375 |
| 0.3 | 0.24999993 | 0.28333338 |
| 0.4 |      0.275 |    0.28125 |
| 0.5 |       0.26 |       0.27 |
| 0.6 | 0.25833338 | 0.24999993 |
| 0.7 | 0.24642845 | 0.23928553 |
| 0.8 |    0.23125 |     0.2375 |
| 0.9 | 0.23333323 |  0.2333332 |
|   1 |     0.2225 |       0.22 |

#+begin_src gnuplot :var data=basic-plot :exports code :file basic-plot.png
set title "Putting it All Together"

set xlabel "X"
set xrange [0:1]
set xtics 0,0.1,1

set ylabel "Y"
set yrange [0.2:0.5]
set ytics 0.2,0.05,0.5

plot data u 1:2 w p lw 2 title 'x vs. y1', \
     data u 1:3 w lp lw 1 title 'x vx. y2'
#+end_src

#+name:
[[file:basic-plot.png]]

***** latex headers in latex code blocks
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

#+begin_src latex :headers \usepackage{lmodern} :file name1.pdf
  Eric Schulte
#+end_src

#+name:
[[file:name1.pdf]]

#+begin_src latex :headers '("\\usepackage{mathpazo}" "\\usepackage{fullpage}") :file name2.pdf
  Eric Schulte
#+end_src

#+name:
[[file:name2.pdf]]

***** export-specific header arguments
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

#+headers: :var out=(if (and (boundp 'latexp) latexp) "latex" "not latex") 
#+begin_src emacs-lisp
  out
#+end_src

#+name:
: not latex

***** security problem with elisp in header arguments
   :PROPERTIES:
   :DATE:     2010-10-14
   :END:
#+begin_src emacs-lisp :var data=(setq org-confirm-babel-evaluate nil) :results silent
  (+ 1 1)
#+end_src

***** weaving with noweb links
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-10-13
   :END:

#+name: name
#+begin_src emacs-lisp
  (message "eric")
#+end_src

#+begin_src emacs-lisp :noweb tangle
  ;; name
  <<name>>
#+end_src

***** very very large numbers
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+tblname: numbers
|                           1 |
|                           2 |
|                          12 |
|                          45 |
|                         166 |
|                    12567890 |
| 231231282371983279389999999 |

#+begin_src emacs-lisp :var numbers=numbers
  (mapcar
   (lambda (line)
       (let ((number (car line)))
         (list number (type-of number))))
     numbers)
#+end_src

#+name:
|                      1 | integer |
|                      2 | integer |
|                     12 | integer |
|                     45 | integer |
|                    166 | integer |
|               12567890 | integer |
| 2.3123128237198328e+26 | float   |

***** preceding blank lines on tangle
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+begin_src emacs-lisp :results silent
  (setq org-babel-tangle-pad-newline nil)
#+end_src

#+begin_src sh :tangle something.reg
  # something
  echo "else"
#+end_src

***** index into a scalar
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+tblname: short-list
| a |
| b |

#+begin_src emacs-lisp :var scalar=short-list[0,0]
  scalar
#+end_src

#+name:
: a

***** cycle -- the input is the output
   :PROPERTIES:
   :DATE:     2010-09-29
   :END:
and the rhythm is the base and the base is the treble

#+name: cycle
| one   |
| two   |
| three |

#+name: cycle
#+begin_src emacs-lisp :var table=cycle
  (append (last table) (butlast table))
#+end_src

#+begin_src emacs-lisp :exports results
  (+ 1 1 1)
#+end_src

***** Letter
   :PROPERTIES:
   :DATE:     2010-09-21
   :END:

#+name: body
#+begin_src org :results latex
  ,My body includes a list:
  
  ,- one
  ,- two
  
  ,and a small table:
  
  ,| first | second |
  ,| other | last   |
  
  ,Not more.
#+end_src

#+begin_src latex :noweb yes :tangle yes
\documentclass[11pt]{isodoc}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\setupdocument{
    to = {Eric},
    subject = {Tough to understand what to do...},
    opening = {Hi},
    closing = {Best}
}

\begin{document}
\letter{%
<<body()>>
}
\end{document}
#+end_src

***** splitting code blocks
   :PROPERTIES:
   :DATE:     2010-09-19
   :END:
- with indentation
  #+begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-previous-src-block (&optional arg)
      "Jump to the previous source block.
    With optional prefix argument ARG, jump backward ARG many source blocks."
      (interactive "P")
      (condition-case nil
          (re-search-backward org-babel-src-block-regexp nil nil (or arg 1))
        (error (error "No previous code blocks")))
      (goto-char (match-beginning 0)) (org-show-context))
  #+end_src
  
  #+begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-split-block-maybe (&optional arg)
      "Split the current source code block on the cursor."
      (interactive "p")
      ((lambda (info)
         (if info
             (let ((lang (nth 0 info))
                   (indent (nth 6 info))
                   (stars (make-string (org-current-level) ?*)))
               (insert (concat (if (looking-at "^") "" "\n")
                               (make-string indent ? ) "#+end_src\n"
                               (if arg stars (make-string indent ? )) "\n"
                               (make-string indent ? ) "#+begin_src " lang
                               (if (looking-at "[\n\r]") "" "\n  "))))
           (message "Not in src block.")))
       (org-babel-get-src-block-info)))
    
    ;; other stuff
  #+end_src

***** header arguments on call line
   :PROPERTIES:
   :DATE:     2010-09-09
   :END:
#+name: eight
#+begin_src R
  8
#+end_src

#+call: eight() :results vector

#+name: eight()
| 8 |

maybe the following with the new proposed header arguments

#+call: eight[:session *R*]() :results vector

***** empty-string results
   :PROPERTIES:
   :DATE:     2010-09-08
   :END:
test me one two 3

#+begin_src emacs-lisp
#+end_src

More test

#+begin_src emacs-lisp
  (mapcar
   (lambda (pair)
     (list (car pair) (cdr pair)))
   params)
#+end_src

#+name:
| :cache    | no      |
| :colnames | no      |
| :comments |         |
| :exports  | code    |
| :hlines   | yes     |
| :noweb    | no      |
| :results  | replace |
| :session  | none    |
| :shebang  |         |
| :tangle   | no      |

***** tangle org-mode block
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+name: org-list
#+begin_src org :results latex
  - one
  - two
  - three
#+end_src

#+begin_src emacs-lisp :tangle example.tangled :noweb yes
  "
  <<org-list()>>
  "
#+end_src

***** remove results when nil is returned
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+begin_src emacs-lisp
  (progn (+ 1 1) nil)
#+end_src

#+name:

***** comparative speed of python evaluation
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+begin_src python :session test
  2+2
#+end_src

#+name:
: 4

#+begin_src python
  return 2+2
#+end_src

#+name:
: 4

#+begin_src python :session test
def add(a,b):
   return a+b
def sub(a,b):
   return a-b
add(sub(10,1),sub(10,2))
#+end_src

#+name:
: org_babel_python_eoe

***** customizable comment formats
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2010-09-05
   :END:

#+begin_src emacs-lisp :results silent
  (setq org-babel-tangle-comment-format-beg "{-# LINE %start-line \"%file\" #-}"
        org-babel-tangle-comment-format-end ""
        org-babel-tangle-pad-newline)
#+end_src

#+begin_src haskell :tangle Main.hs
  test = length
  main = print $ test [1,2,3]
#+end_src

I would like the following output in the tangled file Main.hs:

: {-# LINE 4 "Haskell.org" #-}
: test = length
: main = print $ test [1,2,3]

***** tangling with full comments
   :PROPERTIES:
   :comments: org
   :tangle:   full-comments.el
   :DATE:     2010-09-04
   :END:
The top block
#+begin_src emacs-lisp
  (message "first block")
#+end_src

here's some text which won't be tangled

****** subheading
    :PROPERTIES:
    :DATE:     2010-09-04
    :END:
another block
| 1 | first  |
| 2 | second |
#+begin_src emacs-lisp
  (message "second")
#+end_src

and finally a block with a =:noweb= header argument
#+begin_src emacs-lisp :noweb yes
  (progn
    <<tangle-el-the-second>>)
#+end_src

***** :var (buffer-file-name)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
during export (buffer-file-name) will return nil because the temporary
export buffer is not visiting any file.

/file=(vc-working-revision (buffer-file-name))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) "")) :exports results
  echo $file Revision
#+end_src

/file=(vc-working-revision (or (buffer-file-name) org-current-export-file))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) org-current-export-file)) :exports results
  echo $file Revision
#+end_src

***** quoting header args (e.g. :cmdline)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
#+begin_src C :cmdline 1 2 3 4 5 :includes <stdio.h>
  int main(int argc, char **argv){
    printf("argv[1] %s\n", argv[1]);
    return 0;
  }
#+end_src

#+name:
: argv[1] 1

***** :session evaluation on export
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
This first block is evaluated but /doesn't/ appear in export.

/:session *R* :exports none/
#+begin_src R :session *R* :exports none
  x <- 8
#+end_src

This second block /does/ appear in export.

#+begin_src R :session *R* :exports results
  x
#+end_src

***** ditaa with tilda in path
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
#+begin_src ditaa :file example.png
    +--------------+
    |              |
    |              |
    |              |
    |              |
    |              |
    +--------------+
#+end_src

***** scheme sessions
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
#+begin_src scheme :var number=9 :session *scheme* :scheme guile
  (+ number 0)
#+end_src

#+name:
: 9

#+begin_src scheme :var number=9 :session *scheme* :scheme racket
  (+ number 1)
#+end_src

#+name:
: 10

***** conditional tangling
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
#+begin_src emacs-lisp :results silent
  (setq tangle-tag "right")
#+end_src

****** first subheading						       :left:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "first"
#+end_src

****** second subheading					      :right:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "second"
#+end_src

***** pulling information from tags				       :blue:
   :PROPERTIES:
   :DATE:     2010-08-30
   :END:

#+begin_src R :var color=(car (org-get-tags-at (point))) :tangle example.R
  color
#+end_src

#+name:
: blue

***** initial scheme support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
#+name: numbers
#+begin_src scheme
  (map (lambda (el) (+ el 1)) '(1 2 3))
#+end_src

#+name:
| 2 | 3 | 4 |

#+begin_src scheme :var numbers=numbers
  (map (lambda (el) (- el 1)) numbers)
#+end_src

#+name:
| 1 | 2 | 3 |

***** initial javascript support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
using node.js

#+begin_src js
  var n = 0;
  n = n+1;
  return n
#+end_src

#+name:
: 1

#+name: cars
#+begin_src js
  var cars = ["Saab","Volvo","BMW"];
  return cars;
#+end_src

#+name: cars
| Saab | Volvo | BMW |

#+begin_src js :var cars=cars
  return cars[0][0];
#+end_src

#+name:
: Saab

#+begin_src js :var cars=cars
  return cars[0].length;
#+end_src

#+name:
: 3

***** wrapping up raw/org results
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
#+begin_src emacs-lisp :results org :exports results
  "- first
  - second
  - third
  "
#+end_src

#+name:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

***** trying out plantuml
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
setup
#+begin_src emacs-lisp :results silent
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path "~/src/org/contrib/scripts/plantuml.jar")
#+end_src

usage -- sequence diagram
#+begin_src plantuml :file tryout.png
  Alice -> Bob: synchronous call
  Alice ->> Bob: asynchronous call
#+end_src

#+name:
[[file:tryout.png]]

***** eval for side effect on export
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
- one plus one
  #+name: one-plus-one
  #+begin_src emacs-lisp :exports none :results silent
    (+ 1 1)
  #+end_src
- plus one is
  #+begin_src emacs-lisp :var two=one-plus-one :exports both
    (+ 1 two)
  #+end_src

***** eval and noeval
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
date, should export both, but won't output results because of presence
of the =:noeval= header argument.
#+begin_src sh :noeval :exports both
  date
#+end_src

should export code, so no need to do anything
#+begin_src sh
  date
#+end_src

should export nothing, and should not query
#+name: this-is-ls
#+begin_src sh :eval query :exports code
  date
#+end_src

should export results, and should trigger query above
#+begin_src emacs-lisp :var ls=this-is-ls :exports results
  ls
#+end_src

***** duplicate results on execute subtree
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
#+begin_src emacs-lisp :results org :exports results
  "- first
- second
- third
"
#+end_src

#+name:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

***** not caching
   :PROPERTIES:
   :session:  *R*
   :results:  output
   :exports:  both
   :cache:    yes
   :DATE:     2010-08-25
   :END:

#+begin_src R :noeval
  cat("random result:", runif(1), "\n")
  Sys.sleep(2)
  alarm()
#+end_src 

#+begin_src R :noeval
  cat("random result:", runif(1), "\n")
  Sys.sleep(2)
  alarm()
#+end_src 

****** cache on export
    :PROPERTIES:
    :DATE:     2010-08-25
    :END:
do we export cached blocks

#+begin_src emacs-lisp :cache yes :exports results
  (random)
#+end_src

#+name[46632b4fe2e3a23e847953c95adcba58c270b381]:
: 490528137

****** looks like this is a problem with info collection
    :PROPERTIES:
    :DATE:     2010-08-25
    :END:
#+begin_src emacs-lisp
  (format "%S" info)
#+end_src

#+begin_src emacs-lisp :results scalar :exports results :tangle yes :comments yes
  (mapcar (lambda (el) (list (car el) (cdr el))) (nth 2 info))
#+end_src

#+name[4184710f118ac768ea0d90632508792d695efd7a]:
| :cache    | yes                   |
| :colnames | no                    |
| :comments | yes                   |
| :exports  | results               |
| :hlines   | yes                   |
| :noweb    | no                    |
| :results  | output replace scalar |
| :session  | *R*                   |
| :shebang  |                       |
| :tangle   | yes                   |

#+begin_src emacs-lisp :exports results
  (message "calculating info")
  (org-babel-sha1-hash info)
#+end_src

#+name[0427db66afdc95462d1c8514b662829987d71ff5]:
: 0427db66afdc95462d1c8514b662829987d71ff5

***** issues with shell evaluation
   :PROPERTIES:
   :DATE:     2010-08-25
   :END:
#+begin_src sh :results silent
  cd ~/src/org/
  make
#+end_src

***** org results and replace
   :PROPERTIES:
   :DATE:     2010-08-18
   :END:

#+begin_src emacs-lisp :results org
  "| 1 | 2 |
| 2 | 3 |"
#+end_src

#+name:
| 1 | 2 |
| 2 | 3 |

#+begin_src R
  rnorm(1)
#+end_src

#+begin_src R
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+name:
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

#+begin_src R :colnames yes
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+name:
| V1 | V2 | V3 |
|----+----+----|
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

***** ledger example output text
   :PROPERTIES:
   :DATE:     2010-08-13
   :END:
#+name: ledger-stuff
#+begin_example
09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src sh :var stuff=ledger-stuff
  echo "$stuff"
#+end_src

***** tangle R and load
  :PROPERTIES:
  :tangle:   to-load.r
  :DATE:     2010-08-12
  :END:

evaluate this
#+begin_src emacs-lisp :results silent :tangle no
  (setq org-babel-post-tangle-hook nil)
  (add-hook 'org-babel-post-tangle-hook
            (lambda () (ess-load-file (buffer-file-name))))
#+end_src

then tangle

#+begin_src R :comments yes
x <- 10
#+end_src

#+begin_src R
 y <- 9
#+end_src

#+begin_src R :tangle file2.R
 y <- 9
#+end_src

***** lob -- writing results out to files
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
#+name: table
#+begin_src emacs-lisp
  (mapcar
   (lambda (el) (number-sequence el (+ el 3)))
   (number-sequence 0 4))
#+end_src

writes the results out as csv file
#+call: write(data=table, file="~/Desktop/example.csv") :results silent

writes the results out as tab separated file
#+call: write(data=table, file="~/Desktop/example.tsv") :results silent

write the results out as a normal org-mode file
#+call: write(data=table, file="~/Desktop/example.org") :results silent

***** lisp
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

#+begin_src lisp :var n=5
  (mapcar (lambda (el) (* el el)) (append '(1 7 3 4) (list n)))
#+end_src

#+name:
| 1 | 49 | 9 | 16 | 25 |

#+name: short-list
| 1 |
| 2 |
| 3 |

#+begin_src lisp :var lst=short-list :session t
  (+ 1 (length lst))
#+end_src

#+name:
: 4

***** importing the output of ledger
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
#+name: ledger-output
#+begin_example 
  09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
  09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
  09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src emacs-lisp :var ledger=ledger-output
  (with-temp-buffer
    (insert ledger)
    (message ledger)
    (org-table-convert-region (point-min) (point-max) 2)
    (org-table-to-lisp))
#+end_src

#+name:
| 09-Aug-21 CHEQUE : 9953055                | Expenses:Unknown | 166.70 EUR  | 166.70 EUR  |
| 09-Sep-17 CHEQUE : 7691785                | Expenses:Unknown | 100.00 EUR  | 266.70 EUR  |
| 09-Oct-16 REMISE CHEQUE N 8686318 001 105 | Expenses:Unknown | -525.00 EUR | -258.30 EUR |

***** comments in R blocks
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

#+begin_src R :session *R* :results output
  # this is a comment
  x <- rnorm(1)
  # this is another comment
  x
#+end_src

#+name:
: 
: [1] 1.320853

***** colnames to specific variables
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

#+tblname: spec-colnames
| one | two | thee |
|-----+-----+------|
| 1   | 2   | 3    |

#+tblname: nospec-colnames
| three | two | one |
|-------+-----+-----|
|     3 |   2 |   1 |

#+begin_src python :var nospec=nospec-colnames :var spec=spec-colnames :colnames '(spec)
  return nospec
#+end_src

#+name:
| one   | two | thee |
|-------+-----+------|
| three | two | one  |
| 3     | 2   | 1    |

***** caption on code block
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

#+caption: Examples of variable declaration.
#+label: sql-block
#+begin_src sql
SELECT 6*9;
#+end_src

***** palendromic primes
   :PROPERTIES:
   :DATE:     2010-07-20
   :END:
Note that because Haskell is funny about what can be typed into the
interpreter, the following should be loaded with
=org-babel-load-in-session=.
#+begin_src haskell
  palendromic_primes = [x | x <- [1..], prime x, palendrome x]
      where
        factors n = [x | x <- [1..floor(sqrt(fromIntegral(n)))], n `mod` x == 0]
        prime n = factors n == [1]
        primes = [x | x <- [2..], prime x]
        palendrome n = show(n) == reverse(show(n))
  
  palendromic_prime_distances = map (\(x,y)-> y-x) neighbors
      where
        neighbors = (zip palendromic_primes (tail palendromic_primes))
#+end_src

#+name: palendromic_prime_distances
#+begin_src haskell
  take 180 (zip [1..] palendromic_prime_distances)
#+end_src

For high-quality png output from gnuplot, the following sequence of
graphing to a =.eps= file, and then converting to a =.png= can be
useful.
#+name: dist-graph
#+begin_src gnuplot :var data=palendromic_prime_distances :file pps.eps
  set term postscript landscape color enhanced
  set log y
  set title "distance between consecutive palendromic primes"
  plot "$data" with fs notitle
#+end_src

The =convert= command is part of the [[http://www.imagemagick.org/script/index.php][imagemagick]] suite.
#+begin_src sh :var input=dist-graph :results file
  convert -depth 300 -rotate 90 $input pps.png
  echo "pps.png"
#+end_src

***** input from an example block
   :PROPERTIES:
   :DATE:     2010-07-13
   :END:
#+name: lorem
#+begin_example 
  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
  eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
  enimad minim veniam, quis nostrud exercitation ullamco laboris nisi
  ut aliquip ex ea commodo consequat. Duis aute irure dolor in
  reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
  pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
  culpa qui officia deserunt mollit anim id est laborum.
#+end_example

#+begin_src emacs-lisp :var lorem=lorem
  (message "%d words in Lorem" (length (split-string lorem)))
#+end_src

#+name:
: 68 words in Lorem

#+name: 1D
| 1 |
| 2 |
| 3 |
| 4 |

#+begin_src emacs-lisp :var lst=1D[:,0]
  lst
#+end_src

#+name:
: 1

***** limited precision
   :PROPERTIES:
   :DATE:     2010-07-12
   :END:

#+name: anova-example
| Effect | DFn | DFd |             SSn |              SSd |                F |                    p | p<.05 |              pes |
|--------+-----+-----+-----------------+------------------+------------------+----------------------+-------+------------------|
| Days   |   9 | 153 | 166235.12250176 | 151101.038615303 | 18.7026979326383 | 8.99534541600196e-21 | *     | 0.52384550792003 |

#+begin_src emacs-lisp :var tab=anova-example :colnames yes :cache yes
  (mapcar
   (lambda (row)
     (mapcar
      (lambda (cell) (if (numberp cell) (format "%.4f" cell) cell))
      row))
   tab)
#+end_src

#+name[16ac354f1e7a65594bb59e252ab221e6a4b10f80]:
| Effect |    DFn |      DFd |         SSn |         SSd |       F |                    p | p<.05 |    pes |
|--------+--------+----------+-------------+-------------+---------+----------------------+-------+--------|
| Days   | 9.0000 | 153.0000 | 166235.1225 | 151101.0386 | 18.7027 | 8.99534541600196e-21 | *     | 0.5238 |

***** fixing result insertion
   :PROPERTIES:
   :DATE:     2010-07-12
   :END:
needs to replace the results when there is a new hash

****** normal results
    :PROPERTIES:
    :DATE:     2010-07-12
    :END:
#+begin_src sh
  date
#+end_src

#+name:
: Mon Jul 12 22:18:16 PDT 2010

****** unnamed source block results
    :PROPERTIES:
    :DATE:     2010-07-12
    :END:
#+begin_src emacs-lisp :cache yes
  (+ 1 2 3 4)
#+end_src

#+name[16a776d6d139e1d39e99d736536a546df115c2dc]:
: 10

#+begin_src emacs-lisp :cache yes
  (list '(1 2 3) '(4 5 6))
#+end_src

#+name[53f489ed6977857b9945d79d06e575b2cbbebf11]:
| 1 | 2 | 3 |
| 4 | 5 | 6 |

****** named source block results
    :PROPERTIES:
    :DATE:     2010-07-12
    :END:

#+name: something-w-table
#+begin_src emacs-lisp
  (sleep-for 2)
  (list '(1 2 3) '(4 5 8))
#+end_src

#+name: something
#+begin_src emacs-lisp :cache yes
  (+ 1 2 3 4 8)
#+end_src

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enimad
minim veniam, quis nostrud exercitation ullamco laboris nisi ut
aliquip ex ea commodo consequat. Duis aute irure dolor in
reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
culpa qui officia deserunt mollit anim id est laborum.

# something else
#+name[d053f6643d9dc52a0e804c15f2a762da73a00a07]: something
: 18

#+attr_latex: width=0.4\textwidth
#+name[5fac69648ab749ef9ee88ea65b3d49d93f3f6cc8]: something-w-table
| 1 | 2 | 3 |
| 4 | 5 | 8 |

***** example w/o source name
   :PROPERTIES:
   :DATE:     2010-07-12
   :END:

delete emacs-lisp below for errors
#+begin_src emacs-lisp
  (* (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1))
#+end_src

***** tangle R and load
   :PROPERTIES:
   :tangle:   with-comments.r
   :comments: yes
   :DATE:     2010-07-09
   :END:

#+begin_src R :tangle no
  z <- 0
#+end_src

#+begin_src R
  x <- 8
#+end_src

#+begin_src R
  y <- 9
#+end_src

#+name: i-have-a-name
#+begin_src R 
  x+y+z
#+end_src

***** export blocks w/o languages
   :PROPERTIES:
   :DATE:     2010-07-09
   :END:
should raise an error

source
#+begin_src emacs-lisp
  ;; this is a comment
  (+ 1 1 1)
#+end_src

broken source
#+begin_src 
  (+ 2 2 2)
#+end_src

example
#+begin_example 
  this is exampled
#+end_example

#+begin_src ruby
  # this is the first
  [1, 2, 3, 4, 5].map{|r| r+1}
#+end_src

***** scratch
   :PROPERTIES:
   :DATE:     2010-07-08
   :END:

#+begin_src emacs-lisp :exports results
  (+ 1 1 1 1)
  (setq org-export-babel-evaluate t)
#+end_src

and now for src_emacs-lisp{87} an inline block

looking at paths
#+begin_src emacs-lisp
  (buffer-file-name)
#+end_src

***** Tom found a bug
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:

#+begin_src emacs-lisp :tangle something.el
  (list 1 (+ 2 3))
#+end_src

#+name:
| 1 | 5 |

***** dot
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:
#+begin_src dot :file models.png :cmdline -Tpng
  digraph data_relationships {
    "data_requirement" [shape=Mrecord, label="{DataRequirement|description\lformat\l}"]
    "data_product" [shape=Mrecord, label="{DataProduct|name\lversion\lpoc\lformat\l}"]
    "data_requirement" -> "data_product"
  }
#+end_src

#+name:
[[file:models.png]]

***** python errors
   :PROPERTIES:
   :DATE:     2010-07-04
   :END:
#+begin_src python :session :results value
  [1, [2], 3, 4]
#+end_src

#+name:
| 1 | (2) | 3 | 4 |

#+begin_src ruby :results output :session
  [1, 2, 3, 4, 6].map{|n| puts n}
#+end_src

#+name:
: 1
: 2
: 3
: 4
: 6

#+begin_src python :session :results output
  print 9
#+end_src

#+name: R-with-colnames
| one |
|-----|
| 1   |

#+begin_src R :results output
  "something"
#+end_src

#+name:
: [1] "something"

#+begin_src R :session *R* :results output
  1
  2
  3
  4
#+end_src

#+name:
: [1] 1
: [1] 2
: [1] 3
: [1] 4

#+begin_src perl :results output
  print "8\n";
  print "9\n";
#+end_src

#+name:
: 8
: 9

#+begin_src clojure
  (+ 8 7)
#+end_src

#+name:
: 15

#+begin_src clojure :session *clj*
  (println "eric")
#+end_src

#+name:
: nil

#+begin_src perl :results value
  8
#+end_src

#+name:
: 8

#+begin_src c++ :includes '(<stdio.h> <math.h> <cstdlib> <time.h>)
  printf("eric schulte\n");
#+end_src

#+name:
: eric schulte

#+begin_src sh
  echo 78
#+end_src

#+name:
: 78

***** table comment issue
   :PROPERTIES:
   :DATE:     2010-06-30
   :END:
#+BEGIN_changemargin {-4.2cm}{0cm}
  #+TBLNAME: AutresFPNVE
  #+ATTR_LaTeX: align=lrrrrr
  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Total                                    |                      |                 |                |            |    1062.02 |
  | ^ |                                          |                      |                 |                |            |      Total |
  #+tblfm: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+END_changemargin

save me!

#+begin_src org
  ,  #+TBLNAME: AutresFPNVE
  ,  #+ATTR_LaTeX: align=lrrrrr
  ,  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  ,  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  ,  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  ,  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  ,  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Total                                    |                      |                 |                |            |    1062.02 |
  ,  | ^ |                                          |                      |                 |                |            |      Total |
  ,  #+TBLFM: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+end_src

#+begin_example 
#+tblname: example
| 1 | 2 |
#+end_example

***** latex literals in export
      :PROPERTIES:
      :DATE:     2010-06-30
      :END:

     #+ATTR_LaTeX: width=\textwidth
     [[./composite-pattern.png]]

***** captions
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:

#+caption: I'm not removed from export
#+label: also-not-removed
| A | B |
| 1 | 2 |

***** booktabs
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:
#+tblname: months
| num | Abbrev. |
|-----+---------|
|   1 | Jan.    |
|   2 | Feb.    |
|   3 | Mar.    |

#+call: booktabs(table=months, align="r|l") :results latex :exports results

***** table-label
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
#+label: bam
| 1 |
| 2 |
| 3 |

***** haskell issues
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:

#+begin_src haskell
  length [1, 2]
#+end_src

#+name:
: 2

#+tblname: example-4-haskell
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |

#+begin_src haskell :var this=example-4-haskell
  length this
#+end_src

#+name:
: 7

***** complex
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
#+name: raw-data
#+begin_src sh :results scalar
  wget --quiet -qO- "http://ogdi.cloudapp.net/v1/dc/RecreationParks?format=json"
#+end_src

#+name: dc-parks
#+begin_src emacs-lisp :var keys='(ward area) :var data=raw-data
  (mapcar
    (lambda (lis) (mapcar (lambda (key) (cdr (assoc key lis))) keys))
    (cdr (car (with-temp-buffer
                (insert data) (goto-char (point-min))
                (json-read)))))
#+end_src

#+name: dc-parks-metric
#+begin_src ruby :var data=dc-parks
  data.map{|f| [f[0], 2.59 * f[1]]}
#+end_src

#+begin_src R :var parkData=dc-parks-metric :file parks.png :session *R*
  plot(parkData)
  title(main="Park size by Ward")
#+end_src

#+name:
[[file:parks.png]]

***** possible prefixes
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

| prefix   | remaining characters |
|----------+----------------------|
| ob-      |                    5 |
| org-b-   |                    2 |
| orgb-    |                    3 |
| org-bbl- |                    0 |
| bbl-     |                    4 |
| babel-   |                    2 |
#+TBLFM: $2='(sbe leftover (prefix $$1))

#+name: leftover
#+begin_src emacs-lisp :var prefix=""
  (-
   ;; length w/o .el
   (- 13 (length ".el"))
   ;; length of prefix
   (length prefix))
#+end_src

***** hlines in python
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+name: echo-table
#+begin_src python :var tab=many-cols :hlines yes :exports both :session
  return tab
#+end_src

#+begin_src emacs-lisp :var table=echo-table :exports none
  (butlast (apply #'append (mapcar (lambda (el) (list el 'hline)) table)))
#+end_src

#+call: echo-table(tab=many-cols)

#+begin_src python :exports results
  return [['foo', 'bar', 'baz'], ["a", "b", "None of the above"], ['1', 2, 3]]
#+end_src

#+begin_src emacs-lisp :exports results
  (message "Exist")
#+end_src

***** protecting block bodies
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
neither of these work as expected

#+begin_src org
  ,#+TITLE: stuff
  
  ,#+begin_src emacs-lisp
  ,  (message "something")
  ,#+end_src
  
  ,more stuffs
  
  ,#+resname: something
  ,: value
  
  ,# and a comment
#+end_src

#+begin_src org
  ,* example org
  
  ,# this is a comment
  ,this is not a comment
#+end_src


#+begin_src org
  ,* escaped org-mode markup
  
  ,this should be exported as is
  ,#+results: escaping-example
  ,: 24
#+end_src


#+begin_html 
<pre>
#comment
#+end_src
</pre>
#+end_html
final

***** multiple evals for refs
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
#+begin_src emacs-lisp
  (setq counter 0)
#+end_src

#+name:
: 0

#+name: counter
#+begin_src emacs-lisp
  (setq counter (+ 1 counter))
  counter
#+end_src

#+begin_src emacs-lisp :var counter_val=counter
  counter_val
#+end_src

#+name:
: 3

***** tangling
   :PROPERTIES:
   :DATE:     2010-06-17
   :END:

#+begin_src sh :shebang #!/bin/sh :tangle yes
  date
#+end_src

#+begin_src sh :shebang #!/bin/bash :tangle whoisme :exports both
  echo $USER
#+end_src

#+begin_src emacs-lisp :tangle yes :comments yes
  (message "BAM")
#+end_src

#+begin_src fortran :exports both
  1+8
#+end_src

***** cache on export
   :PROPERTIES:
   :DATE:     2010-06-17
   :END:
do we export cached blocks

#+begin_src sh :cache yes :exports results
  date
#+end_src

#+name[06ed73c6d8d022cf9c323d92af885952865add17]:
: Thu Jun 17 07:35:19 PDT 2010

***** foo org
   :PROPERTIES:
   :session:  *R*
   :DATE:     2010-06-16
   :END:
Figure \ref{fig:one} (p. \pageref{fig:one}) is produced by the following code
#+BEGIN_SRC R 
plot(x, y)
abline(out1)
#+END_SRC
Note that =x=, =y=, and =out1= are remembered from the preceding code
chunk.  We don't have to regenerate them.  All code chunks are part of
one R "session".
and more stuff here and then the results
#+attr_latex: width=0.8\textwidth,placement=[p]
#+label: fig:one
#+caption: Scatter Plot with Regression Line
[[file:fig1.pdf]]

***** comments not commented
   :PROPERTIES:
   :DATE:     2010-06-16
   :END:

# $some stuff
# some more stuff$ -- I should be a comment line

1) a source block inside of an =enumerate=
   #+name: plotxy
   #+begin_src emacs-lisp :exports results
     (message "I think so")
   #+end_src
   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src
   

   can cause problems

2) how about this one...

***** don't eat me!
   :PROPERTIES:
   :DATE:     2010-06-15
   :END:
1) a source block inside of an =enumerate=
   #+begin_src emacs-lisp :exports results
     (list (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry"))
   #+end_src

   #+name:
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |

   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src

   can cause problems

2) source blocks should be able to be on adjacent lines

***** simple reference
   :PROPERTIES:
   :DATE:     2010-06-13
   :END:
#+tblname: table-the-first
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src emacs-lisp :var data=table-the-first[1,1]
  data
#+end_src

#+name:
: 5

***** exporting with call lines
   :PROPERTIES:
   :DATE:     2010-06-11
   :END:
#+name: rpn-to-alg(alg)
#+begin_src clojure :results output :var alg="00+"
  (def binary-operators '(\+ \- \* \/))
  (def unary-operators '(\s))
  (defn rpn-to-alg [chars stack]
    (if (> (.size chars) 0)
      (let [el (first chars)]
        (if (some #{el} binary-operators)
          (rpn-to-alg (rest chars)
                      (cons
                       (apply str "(" (or (second stack) 1) " " el " " (or (first stack) 1) ")")
                       (rest (rest stack))))
          (if (some #{el} unary-operators)
            (rpn-to-alg (rest chars)
                        (cons
                         (apply str "(" el " " (or (first stack) 1) ")")
                         (rest (rest stack))))
            (rpn-to-alg (rest chars) (cons el stack)))))
      (first stack)))
  (println (apply str (rpn-to-alg (seq alg) '())))
#+end_src

#+name: distributed-best
: 73*x11/+4/++51xxx13*y/++6y5*6/6-+xx+*

#+call: rpn-to-alg(alg=distributed-best)
 
***** can't open indented results
      :PROPERTIES:
      :DATE:     2010-06-11
      :END:

      #+begin_src latex :packages '(("" "tikz") ("active,tightpage" "preview")) :file recursion.pdf
       	\begin{preview}
       	\ovalbox{
       	\begin{tikzpicture}
       	\node{$n$}
       	  child {
            node{$\left(\frac{n}{2}\right)^2$}
              child{
               	node{$\left(\frac{n}{4}\right)^2$}
               	node{$\left(\frac{n}{4}\right)^2$}
              }
            }
       	  child{
            node{$\left(\frac{n}{2}\right)^2$}
            child{
              node{$\left(\frac{n}{4}\right)^2$}
              node{$\left(\frac{n}{4}\right)^2$}
            }
       	  };
       	\end{tikzpicture}
       	}
       	\end{preview}
      #+end_src

      #+name:
      [[file:recursion.pdf]]

***** indented source-code blocks and indented results
      :PROPERTIES:
      :DATE:     2010-06-10
      :END:

       #+name: time
       #+begin_src emacs-lisp :results append
       	 ;; (list (list (current-time-string)))
       	 (current-time-string)
       #+end_src

       #+name: time
       | 1 | 2 | 3 |


           #+call: time() :results prepend

           #+name: time()
           | 1 | 2 | 3 |
           : Thu Jun 10 14:13:21 2010
           : Thu Jun 10 14:13:21 2010
           : : Thu Jun 10 14:13:21 2010
           : : Thu Jun 10 14:13:21 2010
           : : Thu Jun 10 14:13:21 2010
           : nil
           : nil
           : Thu Jun 10 14:11:22 2010
           : Thu Jun 10 14:11:20 2010
           : nil
           : nil
           : Thu Jun 10 14:06:04 2010
           : Thu Jun 10 14:06:03 2010
           : Thu Jun 10 14:05:51 2010
           : Thu Jun 10 14:05:57 2010
           : Thu Jun 10 14:06:00 2010

***** not expand inlines in examples
   :PROPERTIES:
   :DATE:     2010-06-08
   :END:

: src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

***** updating results "in-situ"
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+name: in-situ
: update me in place please -- Mon Jun  7 16:44:44 2010
: update me in place please -- Mon Jun  7 16:44:43 2010
: update me in place please -- Mon Jun  7 16:44:42 2010
: update me in place please -- Mon Jun  7 16:44:37 2010
: update me in place please -- Mon Jun  7 16:42:14 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:44:59 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:00 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:02 2010

the results should be *above* the block

#+name: in-situ
#+begin_src emacs-lisp :results prepend
  (format "update me in place please -- %s"
          (current-time-string))
#+end_src

#+name: in-situ
#+begin_src emacs-lisp :results append
  (format "update me in place please (at the bottom) -- %s"
          (current-time-string))
#+end_src

***** unwind-protect with narrowing
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

I'm not in the subtree

****** I'm in the subtree
    :PROPERTIES:
    :DATE:     2010-06-07
    :END:
#+begin_src emacs-lisp
  (+ 6 "I'm not a number!!")
#+end_src

***** stripping existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
#+name: trickily-located-somehwere-else
: I shouldn't be exported

Neither of the result strings for the following two code blocks should
be included in the export.  And only one of the bodies should be
included...

#+begin_src emacs-lisp :exports code
  (+ 1 1 1 1)
#+end_src

#+name:
: don't include me in the export!!!!!!!

#+name: trickily-located-somehwere-else
#+begin_src emacs-lisp :exports none
  (message "I shouldn't be exported")
#+end_src

***** non-empty comint prompt
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src ruby :session eric
  8 + 9
#+end_src

***** inhibiting evaluation on export
   :PROPERTIES:
   :noeval:   don't do it
   :DATE:     2010-06-07
   :END:

#+begin_src clojure :session eric :exports none
  (+ 1 1 1 1)
  (error)
#+end_src

***** indented source names
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

   #+name: i-am-indented
   #+begin_src emacs-lisp 
     (message "i am indented")
   #+end_src

#+name: i-am-indented
: i am indented

#+begin_src emacs-lisp :var output=i-am-indented
  (length output)
#+end_src

#+name:
: 13

  #+name:
  : eric

***** export with existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src emacs-lisp :exports none :results silent
  '((1 2) (3 4))
#+end_src

#+name:
| 1 | 2 |
| 3 | 4 |

#+begin_src ditaa :file /tmp/eric.png :exports none :results silent
    +---------------+
    |               |
    |               |
    |               |     +-----------------+
    |    Eric       |     |                 |
    |               |     |    Schulte      |
    |               |     |                 |
    |               |     +-----------------+
    +---------------+
#+end_src

#+name:
[[file:/tmp/eric.png]]

***** executing emacs-lisp on export
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src emacs-lisp
  (error "eric")
#+end_src

***** commas on tangling test
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
test comma protection on tangling

#+begin_src emacs-lisp :results silent
  (org-babel-add-interpreter "org")
  (add-to-list 'org-babel-tangle-langs '("org" "org"))
#+end_src

#+begin_src org :tangle commas.org
  ,* org-mode
  ,  :PROPERTIES:
  ,  :CUSTOM_ID: comma-protect
  ,  :END:
  
  ,#+begin_src emacs-lisp
  ,  protected?
  ,#+end_src
#+end_src

#+begin_example 
  ,* this should be
  # commented out
  
  and maybe not this...
#+end_example

***** simple table
   :PROPERTIES:
   :DATE:     2010-06-06
   :END:
#+begin_src emacs-lisp
  '((1 2 3) (4 5 6) (7 8 900))
#+end_src

#+name:
| 1 | 2 |   3 |
| 4 | 5 |   6 |
| 7 | 8 | 900 |

***** inline expressions
   :PROPERTIES:
   :session:  'default
   :DATE:     2010-06-06
   :END:

#+begin_src R :exports code :results silent
  x<-4
#+end_src

the sum of 1 and x is equal to src_R{x+1}, now I'll sneakily reset
this value in a hidden inline block src_R[:exports none]{x<-2}, so
it's value is now src_R{x}.

***** adding file names to literal values on export
   :PROPERTIES:
   :DATE:     2010-06-01
   :END:

#+name: three
: 9

#+begin_src R :var num=three :exports results
runif(n=num, min=0, max=1)
#+end_src

#+begin_src R :var num=3 :exports results
runif(n=num, min=0, max=1)
#+end_src

***** appending tangle
   :PROPERTIES:
   :tangle:   appended.el
   :DATE:     2010-05-28
   :END:
append all these block

#+begin_src emacs-lisp
  (message "block %d" 1)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 2)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 3)
#+end_src

***** visibility affecting execution
      :PROPERTIES:
      :DATE:     2010-05-27
      :END:
***** folding
    :PROPERTIES:
    :DATE:     2010-05-27
    :END:
lets test folding

****** folded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
#+begin_src emacs-lisp
  (message "folded1")
#+end_src

#+name:
: folded1

#+begin_src emacs-lisp
  (message "folded2")
#+end_src

#+name:
: folded2
******* unfolded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
#+begin_src emacs-lisp
  (message "unfolded1")
#+end_src

#+name:
: unfolded1
#+begin_src emacs-lisp
  (message "unfolded2")
#+end_src

#+name:
: unfolded2

***** empty code blocks -- and latex vs. LaTeX
   :PROPERTIES:
   :DATE:     2010-05-26
   :END:
eric
#+begin_src latex
  
#+end_src

michael
#+begin_src LaTeX
  
#+end_src

schulte
#+begin_src emacs-lisp
  (message "error")
#+end_src

***** colnames
   :PROPERTIES:
   :DATE:     2010-05-04
   :END:

#+tblname: A
| a | b | c |
|---+---+---|
| d | e | f |
| g | h | i |

#+begin_src python :var tab=A :colnames yes
return [[val + '*' for val in row] for row in tab]
#+end_src

#+name:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

#+tblname: A
| a | b | c |
| d | e | f |
| g | h | i |

#+begin_src ruby :var tab=A :colnames yes
tab.map{|r| r.map{|e| e+"*"} }
#+end_src

#+name:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

***** lisps not fully eval'd
   :PROPERTIES:
   :DATE:     2010-04-30
   :END:

#+begin_src emacs-lisp
  (message "one")
  (message "two")
#+end_src

#+name:
: two

#+begin_src clojure :session :default
  (println "one")
  (println "two")
  (+ 1 2)
#+end_src

#+name:
: 3

***** tangling org
   :PROPERTIES:
   :DATE:     2010-04-27
   :END:

#+begin_src org :tangle ~/Desktop/test.org
  ,* first
  ,| eric   | me     |
  ,| patton | my dog |
  
  ,* second
  
  ,some more stuff...
  
  ,#+HTML: <b>I bet this is quoted</b>
#+end_src

#+begin_src ruby :tangle ~/Desktop/test.rb
  # this is a comment
  eric.map{|l| puts l}
#+end_src

***** variable indexing
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
#+TBLNAME: MyTable
 |   X |  Y |
 |-----+----|
 |   0 |  0 |
 |   1 |  1 |
 |   2 |  4 |
 |   3 |  9 |
 |   4 | 16 |
 |   5 | 25 |
 |-----+----|
 | Sum | 55 |
 #+TBLFM: $2=$1*$1::@8$2=vsum(@2..@-1)

#+begin_src python :var sum=MyTable[2:7,1] :exports none
   return sum
#+end_src

#+name:
| 0 | 1 | 4 | 9 | 16 | 25 |

#+begin_src python :var sum=MyTable[9,1] :exports none
   return sum
#+end_src

#+name:
: 55

#+begin_src gnuplot :var data=MyTable[1:-2] :var sum=MyTable[7,1]
:results silent :exports none
  reset
  set label "Sum: %.0f",sum at graph 0.03, graph 0.93
  plot data with linespoints
#+end_src

***** colnames mismatched sizes
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
#+tblname: mismatch-colnames
| a |  b |
|---+----|
| 1 |  8 |
| 2 |  9 |
| 3 | 10 |
| 4 | 11 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2, 3]]
#+end_src

#+name:
| 1 | 2 | 3 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2]]
#+end_src

#+name:
| a | b |
|---+---|
| 1 | 2 |

#+begin_src python :var tab=mismatch-colnames :colnames yes
  return [1,2]
#+end_src

#+name:
| 1 | 2 |

***** test gnuplot
   :PROPERTIES:
   :DATE:     2010-04-17
   :END:

#+begin_src gnuplot
  plot sin(x), x+5
#+end_src

***** hline processing
   :PROPERTIES:
   :DATE:     2010-04-12
   :END:
#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+tblname: less-cols
| 1 |
|---|
| 2 |
| 3 |

#+tblname: less-cols2
| 1 | 2 | 3 |

#+begin_src emacs-lisp :var tab=many-cols
  (message "%S" tab)
  ;; (remove 'hline tab)
  ;; (flet ((rem-hline (el)
  ;;                   (if (listp el)
  ;;                       (remove nil (mapcar #'rem-hline el))
  ;;                     (if (equal 'hline el) nil el))))
  ;;   (rem-hline tab))
#+end_src

#+begin_src ruby :var tab=less-cols
  tab
#+end_src

#+name:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var one=2
  1 + 2
#+end_src

#+name:
: 3

#+begin_src python :var tab=less-cols
  return tab
#+end_src

#+name:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var tab=less-cols :colnames no
  tab
#+end_src

#+name:
| 1 |
| 2 |
| 3 |

#+begin_src emacs-lisp :var tab=row-and-col-names
   (message "%S" tab)
#+end_src

#+name:
: (("" "c1" "c2" "c3") hline ("r1" 1 4 7) ("r2" 2 5 8) ("r3" 3 6 9))

#+tblname: row-and-col-names
|    | c1 | c2 | c3 |
|----+----+----+----|
| r1 |  1 |  4 |  7 |
| r2 |  2 |  5 |  8 |
| r3 |  3 |  6 |  9 |

functions
#+begin_src emacs-lisp
  (defun org-babel-del-hlines (table)
    "Remove all 'hlines from TABLE."
    (remove 'hline table))
  
  (defun org-babel-get-colnames (table)
    "Return a cons cell, the `car' of which contains the TABLE
        less colnames, and the `cdr' of which contains a list of the
        column names"
    (if (equal 'hline (second table))
        (cons (cddr table) (car table))
      table))
    
  (defun org-babel-get-rownames (table)
    "Return a cons cell, the `car' of which contains the TABLE less
     colnames, and the `cdr' of which contains a list of the column
     names.  Note: this function removes any hlines in TABLE"
    (flet ((trans (table) (apply #'mapcar* #'list table)))
      (let ((table (trans (remove 'hline table))))
        (cons (cdr table) (car table)))))
  
  (defun org-babel-put-colnames (table colnames)
    "Add COLNAMES to TABLE if they exist."
    (if colnames (apply 'list colnames 'hline table) table))
  
  (defun org-babel-put-rownames (table rownames)
    "Add ROWNAMES to TABLE if they exist."
    (if rownames
        (mapcar (lambda (row)
                  (if (listp row)
                      (cons (or (pop rownames) "") row)
                    row)) table)
      table))
#+end_src

***** evaluate references
   :PROPERTIES:
   :DATE:     2010-04-09
   :END:

#+begin_src emacs-lisp :var var=`(+ 9 ,(- 19 7)) :tangle yes
  (message "var is %S" var)
#+end_src

#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+name:
: 3

#+begin_src ruby
  + 1 2
#+end_src

#+name:
: nil

***** tangling and variable resolution
  :PROPERTIES:
  :ID:       18b4f1be-bb1d-49bc-a651-c97406a35bdd
  :tangle:   yes
  :DATE:     2010-03-31
  :END:

#+name: A
#+begin_src emacs-lisp :eval no :expand yes :var id=(org-entry-get nil "ID" t) :var two=2
  (concat "This is the entry ID: " id)
#+end_src

#+name: A
: This is the entry ID: 18b4f1be-bb1d-49bc-a651-c97406a35bdd

***** latex attributes
   :PROPERTIES:
   :DATE:     2010-03-23
   :END:

#+ATTR_LaTeX: width=0.38\textwidth wrap placement={r}{0.4\textwidth}
#+begin_src ditaa :file=scrap.png
  +---------------------------+
  |                           |
  |       latex               |
  |                           |
  |      +------------+       |
  |      |            |       |
  |      |            |       |
  |      |       cBLU |       |
  |      +------------+       |
  |                      cPNK |
  +---------------------------+
#+end_src

***** access to variables set in property drawers
   :PROPERTIES:
   :special:  89
   :text: schulte
   :DATE:     2010-03-22
   :END:

: "(org-entry-get nil "special" t)"

#+begin_src emacs-lisp :var special=(string-to-number (org-entry-get nil "special" t))
  (+ special 1)
#+end_src

#+name:
: 90

#+begin_src emacs-lisp :var special=(org-entry-get nil "text" t)
  special  
#+end_src

#+name:
: schulte

***** variables into shell scripts
   :PROPERTIES:
   :DATE:     2010-02-23
   :END:
#+name: into-shell-scripts
| username | guest   |
| password | nothing |

#+begin_src sh :var username=into-shell-scripts[0,0] :var password=into-shell-scripts[1,1] :results output
  echo "$username -p $password"
#+end_src

#+name:
: username -p nothing

#+name: number-into-shell
: 9

#+begin_src sh :var num=number-into-shell
  for i in `seq $num`; do
      echo $i
  done
#+end_src

#+name:
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

***** results lines for function calls
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

#+call: fibonacci(input=5) :resname eric

#+name:
: 8

#+begin_src emacs-lisp :var fib=fibonacci(input=5)
  (message "fib(5)=%d" fib)
#+end_src

#+name:
: fib(5)=8

***** haskell variables
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

playing with Haskell

#+name: haskell-stuff
: 9

#+begin_src haskell :var num=haskell-stuff
  num + 1
#+end_src

#+begin_src ruby :var num=haskell-stuff
  num + 1
#+end_src

#+name:
: 10

***** list index w/function style name
   :PROPERTIES:
   :DATE:     2010-02-14
   :END:

#+name: function-style-index
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

#+name: function-style-indexing(data=function-style-index[1:4,0])
#+begin_src emacs-lisp
  (message "%S" data)
#+end_src

#+name: function-style-indexing
: ((1) (2) (3) (4))

***** looking at source name exports
   :PROPERTIES:
   :DATE:     2010-02-09
   :END:

#+name: fibonacci
#+begin_src emacs-lisp :var input=0
  (defun fib (n)
    (if (> n 1)
        (+ (fib (- n 1)) (fib (- n 2)))
        1))
  (fib input)
#+end_src

#+name: fibonacci
: 1

now applying our Fibonacci function

#+call: fibonacci(input=5)

***** short shell test
   :PROPERTIES:
   :DATE:     2010-02-07
   :END:

#+begin_src sh
  date
#+end_src

#+name:
: Sun Feb  7 10:17:44 MST 2010

#+tblname: fibs
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs
  echo "$table" |wc
#+end_src

#+name:
: 6      12      24

#+begin_src sh :var table=fibs
  echo "$table"
#+end_src

#+name:
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs :separator --
  echo "$table" | head -1
#+end_src

#+name:
: 1--1

***** tables to shell scripts ideas
   :PROPERTIES:
   :DATE:     2010-02-06
   :END:

#+tblname: sec
| Hello | World |


1) allowing the user to specify a separator with a header argument as
   follows
   #+begin_src sh :var table=sec :separator ,
     cat <<EOF
     $table
     EOF
   #+end_src
   
   which would result in something like

   : "Hello, World"

2) writing the table to a tab or comma separated file and then
   replacing =$table= in the source block body with the path to the
   file name, s.t. something like
   
   #+begin_src sh :var table=data
     wc $table
   #+end_src

   would return reasonable results

***** tangling w/o comments and shebang
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-02-05
   :END:

#+begin_src emacs-lisp :comments no :shebang (identity my-shebang)
  (message "I should have no comments")
#+end_src

#+begin_src emacs-lisp :comments no
  (setq my-shebang "foo")
#+end_src

#+name:
: foo

#+begin_src ruby :shebang #!/usr/bin/ruby
  puts :nonstandard_shebang
#+end_src

***** exporting to a file
   :PROPERTIES:
   :EXPORT_FILE_NAME: simple
   :EXPORT_TITLE: testing file export
   :DATE:     2010-02-03
   :END:

this is the contents

and a block
#+begin_src clojure
  (println "is a nice lisp")
#+end_src

ah, it works!

***** ditaa blocks
   :PROPERTIES:
   :DATE:     2010-02-03
   :END:

#+begin_src ditaa :file communication.png :cache yes
  -------------
#+end_src

#+name[4fbfc78b37abd8a788958d28a7335445e6042c96]:
[[file:communication.png]]

***** babel block overwrite
   :PROPERTIES:
   :DATE:     2010-01-18
   :END:

The first block overwrites
#+begin_src clojure
  (def overwriter "I'll show up everywhere")
#+end_src

this second block
#+begin_src diff
  3719d3718
  <       movl    $1024, 8(%esp)
#+end_src

***** load to session
   :PROPERTIES:
   :DATE:     2010-01-11
   :END:
#+begin_src clojure :session asm-gp
  (in-ns 'asm-gp)
#+end_src

#+begin_src ruby :session
  puts :eric
#+end_src

#+begin_src python :session
  5 + 1 
#+end_src

#+begin_src R :session
  6 + 1
#+end_src

#+begin_src sh :session
  date
#+end_src

#+begin_src ocaml :session
  eric
#+end_src

#+begin_src gnuplot :session
  plot sin(x)
#+end_src

***** links
   :PROPERTIES:
   :DATE:     2010-01-06
   :END:

can LaTeX link itself to the middle of a paragraph with a simple
inline link like <<keystone>> if not then we would probably need to
wrap source-code blocks in figures to make them referable.

how about a link back to [[keystone]]

The above appears to work in LaTeX, but not in HTML.

***** fancier export
   :PROPERTIES:
   :DATE:     2010-01-05
   :END:

#+name: square
#+begin_src emacs-lisp :var input=1
  (* input input)
#+end_src

***** exporting org-source
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:

#+begin_src org
  ,lets see how this org-mode code exports to html
  
  ,is this [[link]] blue?
  
  ,#+begin_src emacs-lisp
  ,  (+ 1 2)
  ,#+end_src
#+end_src

***** exporting and caching
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:
#+begin_src ditaa :file data/example.png :exports none
    +------------------+
    |  ditaa example   |
    |                  |
    |                  |
    +------------------+
#+end_src

#+name:
[[file:data/example.png]]

***** no noweb by default
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

#+name: sample
#+begin_src emacs-lisp 
  (message "sample")
#+end_src

#+begin_src emacs-lisp :noweb no
  <<sample>>
#+end_src

#+name:
: sample

***** looking at double quotes
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

#+tblname: double-quote-test-input
| test | this | 8 | 9 |

#+name: double-quote-test-output
#+begin_src python :var data=double-quote-test-input
  return data
#+end_src

#+name: double-quote-test-output
| test | this | 8 | 9 |

***** quoted session name
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:

#+begin_src sh :session "eric"
  echo 'name-me'
#+end_src

#+name:
: name-me

***** eval-buffer
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:
#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+name:
: 3

#+begin_src emacs-lisp
  (+ 3 4)
#+end_src

#+name:
: 7

***** sql exports to latex
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
example from email list
****** ECM
    :PROPERTIES:
    :DATE:     2009-11-30
    :END:

   - faire un script Bash (et =isql=) envoyant un /listing/ de stagiaires;

#+name: envoi-stg
   #+begin_src sql
       DECLARE @dateFmtStyleIn int; SET @dateFmtStyleIn = 120 -- ODBC canonical
       DECLARE @dateFmtStyleOut int; SET @dateFmtStyleOut = 103 -- French dd/mm/yyyy

       DECLARE @firstDayOfThisMonth smalldatetime
       SET @firstDayOfThisMonth = CONVERT(smalldatetime,
                                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                                          + '01' + ' 00:00:00',
                                          @dateFmtStyleIn)

       DECLARE @now smalldatetime
       SET @now = CONVERT(smalldatetime,
                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                          + CAST(DAY(GETDATE()) AS char(2)) + ' '
                          + CAST(DATEPART(hh, GETDATE()) AS char(2)) + ':'
                          + CAST(DATEPART(mi, GETDATE()) AS char(2)) + ':'
                          + '00',
                          @dateFmtStyleIn)

       SELECT pfiID
       FROM dossier
#+end_src

***** gnuplot variable expansion
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:

#+name: simple-function
#+begin_src emacs-lisp
  "sin(x)"
#+end_src

#+begin_src gnuplot :var fun=simple-function
  plot $fun
#+end_src

***** debug hints
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
from mailing list

- edebug-defun: (in emacs-lisp mode, C-u C-M-x) will mark the function
  so that when it is called, the interpreter stops and you can then
  single-step through it with <SPACE>. At each point, you can press
  "e" and evaluate variables (actually arbitrary expressions).
- Insert a strategically placed (debug) call and then call the
  function.  If/when the debug call is executed, you are dropped into
  the debugger and you can then evaluate arbitrary expressions.

***** whitespace/newline results issues
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

#+begin_src sh
  echo output
#+end_src

This
#+begin_src sh
  echo output
#+end_src
text here

results in

t#+results:
: output
ext here

#+begin_src emacs-lisp
  (+ 1 1)
#+end_src

#+name:
: 2

***** sh with sessions
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

#+begin_src sh :session eric
  cd ~/Desktop
#+end_src

#+begin_src sh :session eric
  cd ~/Desktop/clj/
  ls *.clj
#+end_src

#+name:
| "ants.clj" | "" | "concurrent.clj" | "" | "hello.clj" | "" | "spell-checker.clj" |

***** xml and n3
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

introduce org-babel to =xml= and =n3=
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
#+end_src

inform org-babel-tangle of their existence and file extensions
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

***** unresolved noweb references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results silent
  (setq org-babel-noweb-error-langs '("ruby"))
#+end_src

#+name: i-have-a-name
#+begin_src ruby 
  1 + 2
#+end_src


#+begin_src ruby :noweb
  <<i-have-a-name>> + 3
#+end_src

#+resname:
: 6

***** testing srcname aliases
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: two
#+begin_src emacs-lisp
  2
#+end_src

#+begin_src emacs-lisp :var input=two
  (+ input 1)
#+end_src

#+name[1ec6c8d3de6aaeac7b2720f1d801402e762875ea]:
: 3

***** =:table= results param
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :results table
  8
#+end_src

#+resname:
| 8 |

***** switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

***** switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

***** simple scalar
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp
  (+ 1 3)
#+end_src

#+resname:
: 4

***** simple R
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src R :session R
8
#+end_src

#+resname:
: 8

***** show all
   CLOCK: [2009-09-15 Tue 07:51]--[2009-09-15 Tue 08:51] =>  1:00
   :PROPERTIES:
   :exports:  both
   :DATE:     2009-11-20
   :END:

#+begin_src ditaa :file blue.png
   +----------------------+
   |                      |
   |                      |
   |          +-----------+
   |          |           |
   |          |           |
   |          |           |
   |          +-----------+
   |                      |
   +----------------------+
#+end_src

***** results switches
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src ruby :results output :results_switches -n
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example -n

-
--
---
----
-----
------
-------
--------
---------
#+end_example

#+begin_src ruby :results output
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example
  -
  --
  ---
  ----
  -----
  ------
  -------
  --------
  ---------
#+end_example

***** reference parts of tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+TBLNAME: squares
|  1 |   1 |
|  2 |   4 |
|  3 |   9 |
|  4 |  16 |
|  5 |  25 |
|  6 |  36 |
|  7 |  49 |
|  8 |  64 |
|  9 |  81 |
| 10 | 100 |
| 11 | 121 |
| 12 | 144 |
| 13 | 169 |
| 14 | 196 |
| 15 | 225 |
| 16 | 256 |
| 17 | 289 |
| 18 | 324 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=squares
set title "Implementing Gnuplot"
plot data using 1:2 with lines
#+end_src

***** quoted latex
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

The following latex isn't exported correctly

#+begin_latex
  \begin{code}
  data BTree = Leaf a
             | Node Tree Tree
  \end{code}
#+end_latex

#+begin_src haskell
  data BTree = Leaf a
             | Node Tree Tree
#+end_src

***** pretty print
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results scalar
  '(1 2 3 4)
#+end_src

***** =pp= results
      :PROPERTIES:
      :DATE:     2009-11-20
      :END:
****** python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src python :results pp :session
  ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']
#+end_src

#+resname:
: ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']

****** ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src ruby :results pp
  class Schulte
    attr_accessor :name, :age
  end
  
  eric = Schulte.new
  eric.name = "eric"
  eric.age = 27
  
  eric
#+end_src

#+resname:


#+begin_src ruby :results pp
  a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
  a
#+end_src

#+resname:
#+begin_example
[1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3]
#+end_example
***** noweb referernces
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: noweb-example
#+begin_src ruby 
  a = 28
#+end_src

#+begin_src ruby :noweb
  # <<noweb-example>>
  a + 4
#+end_src

#+resname:
: 32

***** persistent python
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src python :session :results silent
  import types
#+end_src

#+begin_src python :session
  types.FunctionType
#+end_src

#+resname:
: function

****** more persistent python
    :PROPERTIES:
    :session:  default
    :DATE:     2009-11-20
    :END:

#+begin_src python :results silent
  import types
#+end_src

#+begin_src python
  types.FunctionType
#+end_src

#+resname:
: function

***** multiple arguments
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :var first=9 :var second=10
  (+ first second)
#+end_src

#+resname:
: 19

***** lua export
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: determine the neighbors of the segments that the bisector hits
#+begin_src lua :tangle no :exports code
  local s1, s2 = intersecting_segs[1], intersecting_segs[2]
  local n1 = table_find_segment(cell.neighbors, s1)
  local n2 = table_find_segment(cell.neighbors, s2)
#+end_src

I got:
#+begin_example
\lstset{language=lua}
\begin{lstlisting}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{lstlisting}
#+end_example

Emacs -Q got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

Emacs -Q + Org-babel got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

***** latex pngs
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
$x \mapsto y$

****** Theorem
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
$|consts(t)| \leq sizes(t)$

- by induction on the structure of t
- base cases are $t \in [true, false, 0]$: 
  - $|consts(t)| = |[t]| = 1 = size(t)$
- inductive size
  - $t \in [succ(t_1), pred(t_1), iszero(t_1)]$:
    - $|consts(t)| = |consts(t_1)| = |[t]| \leq size(t_1) < size(t)$
  - $t = if\, t_1 \, then \, t_2 \, else t_3$
    - $|consts(t)| = |consts(t_1) \cup consts(t_1) \cup consts(t_1)|$
    - $\leq |consts(t_1)| + |consts(t_1)| + |consts(t_1)|$
    - $\leq size(t_1) + size(t_1) + size(t_1)$
    - $< size(t)$

***** later
   CLOCK: [2009-09-15 Tue 09:41]--[2009-09-15 Tue 09:51] =>  0:10
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
stuff here

***** indexing into results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: indexable-table
| eric    |
| michael |
| schulte |
| is      |
| my      |
| name    |

#+begin_src emacs-lisp :var data=indexable-table[2:4]
   data
#+end_src

#+name:
| schulte |
| is      |
| my      |

#+tblname: multidimensional-indexing
| 1 |  2 |
| 3 |  4 |
| 5 |  6 |
| 7 |  8 |
| 9 | 10 |

#+begin_src emacs-lisp :var data=multidimensional-indexing[0:-2]
   data
#+end_src

#+resname:
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
| 7 | 8 |

***** indexing into gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+tblname: squares
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |

#+begin_src gnuplot :var data=squares :results silent
plot data using 1:2 with lines
#+end_src

#+tblname: squares-with-sum
|  1 |  1 |
|  2 |  4 |
|  3 |  9 |
|  4 | 16 |
|  5 | 25 |
|  6 | 36 |
|----+----|
| 21 | 91 |

#+begin_src gnuplot :var data=squares-with-sum[0:-3] :results silent
  plot data using 1:2 with lines
#+end_src

***** indented
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   #+begin_src emacs-lisp
     (message "I ran!!")   
   #+end_src

#+resname:
: I ran!!

***** indentation
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src python
          9
#+end_src

***** hiding results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp
  (mapcar (lambda (el) (list el)) (number-sequence 0 20))
#+end_src

#+name:
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |

***** haskell
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src haskell
  powerSet :: [a] -> [[a]]
  powerSet = foldr (\ x ps -> map (\ y -> x : y) ps ++ ps ) [[]]
#+end_src

#+begin_src haskell
  powerSet [1, 2, 3]
#+end_src

***** haskell and tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src haskell
  sumListCond :: Int -> Int -> [Int] -> Int
  sumListCond l n xs
      | foldl (+) 0 (take l xs) <= n = sumListCond (l + 1) n xs
      | otherwise = foldl (+) 0 (take (l - 1) xs)
#+end_src
#+begin_src oz
  
#+end_src

***** gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src gnuplot
plot cosx
#+end_src


#+end_src
      
***** empty =output= results for emacs-lisp
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :results output
   8
#+end_src

#+resname:

***** elisp variables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ditaa :file (format "%d.png" 45)
      +-----------+
      |           |
      |           |
      |           |
      |           |
      +-----------+
#+end_src

#+name:
[[file:45.png]]

***** elisp references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results silent
   (setq first 10)
#+end_src

#+name: resolve(name=nil)
#+begin_src emacs-lisp :results silent
  (eval (intern name))
#+end_src

#+begin_src python :var a=resolve(name="first")
  return a + 10
#+end_src

***** dynamic table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+TBLNAME: todays-clock
#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
Clock summary at [2009-09-15 Tue 08:51], for Tuesday, September 15, 2009.

| L | Headline     | Time   |      |
|---+--------------+--------+------|
|   | *Total time* | *1:10* |      |
|---+--------------+--------+------|
| 1 | [[file:/Users/eschulte/Desktop/test.org::top][top]]          | 1:10   |    1 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]     |        | 1:00 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::later][later]]        |        | 0:10 |
#+END: clocktable

#+begin_src emacs-lisp :var data=todays-clock(1,1)
(message "table is %S" data)
#+end_src

#+resname:
: table is (("L" "Headline" "Time" "") hline ("" "*Total time*" "*1:10*" "") hline (1 "[[file:/Users/eschulte/Desktop/test.org::top][top]]" "1:10" 1) (2 "[[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]" "" "1:00") (2 "[[file:/Users/eschulte/Desktop/test.org::later][later]]" "" "0:10"))

#+begin_src R :session R-pie-example :var times=todays-clock :results silent
pie(times[2:length(times),4], labels = times[2:length(times),2])
#+end_src

***** code results
      :PROPERTIES:
      :DATE:     2009-11-20
      :END:
****** emacs lisp
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (lambda (item) (+ item el))) '(1 2 3 4 5))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
((lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el)))
#+END_SRC

#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (* el el)) '(1 2 3 89))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
(1 4 9 7921)
#+END_SRC

****** ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

#+begin_src ruby :results code
  [1, 2, 33, 4].map{|n| "the number #{n}"}
#+end_src

#+resname:
#+BEGIN_SRC ruby
  ["the number 1", "the number 2", "the number 33", "the number 4"]
#+END_SRC

#+begin_src ruby :session :results code 
  [1, 2, 33, 4].map{|n| n + 10 }
#+end_src

#+resname:
#+BEGIN_SRC ruby
[11, 12, 43, 14]
#+END_SRC

****** python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

#+begin_src python :results code
  ['one', 'two', 'three']
#+end_src

#+resname:
#+BEGIN_SRC python
['one', 'two', 'three']
#+END_SRC

#+begin_src python :results code
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

#+begin_src python :session :results code 
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

***** clojure
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src clojure :results silent
  (list 8 9)
#+end_src

***** changing source name
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: emacs-nine
#+begin_src emacs-lisp
  8
#+end_src

#+resname: emacs-nine
: 8

#+resname: emacs-eight
: 8

***** cached results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :cache yes
   (setq org-babel-default-header-args '((:session . "none")
                                         (:results . "replace")
                                         (:exports . "code")(:cache)))
#+end_src

#+name[937269632ae5b5eee5c93f9eb50e0bc55e34520d]:
| (:session . none) | (:results . replace) | (:exports . code) | (:cache) |

#+name: eric-schulte
#+begin_src emacs-lisp :cache yes
   (+ 5 7 1)
#+end_src

#+name[005b04829608b3d22b61686e90309af3a9a6fe7c]: eric-schulte
: 13

#+begin_src ditaa :file caching-example.png
    +--------------------+
    |                    |     +-----------+
    |                    |     |           |
    |                    |     |           |
    |      +----+        |     |           |
    |      |    |        |     +-----------+
    |      +----+        |
    |                    |
    +--------------------+
#+end_src

#+name[fd11ddbfd00f6038e6e37db71ddaf43d65b0e200]:
[[file:caching-example.png]]

***** asymptote
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src asymptote :file asymptote-test.png :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return 1+cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(a,0)$",(1,0),N);
  dot("$(2a,0)$",(2,0),N+E);
#+end_src

#+resname:
[[file:asymptote-test.png]]

***** asymptote cosine
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src asymptote :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  for(int i=0; i < 8; ++i) {
    real j = 0.125 + 0.125*i;
    real h(real t) {return j;};
    path k=polargraph(h, -(acos(j)), acos(j), operator ..);
    draw(k,blue);
  }
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(pi,0)$",(1,0),N);
#+end_src

***** and then more
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
and more stuffs here

***** advanced table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   | DATA             | WHAT       | WHERE       | HOW MUCH |
   |------------------+------------+-------------+----------|
   | [2009-09-25 Fri] |            |             |    28.95 |
   |------------------+------------+-------------+----------|
   |                  | food       | supermarket |     7.85 |
   |                  | ticket bus |             |      2.3 |
   |                  | tea + ice  | ice uno     |      4.4 |
   |                  | ticket     |             |     14.4 |
   |------------------+------------+-------------+----------|
   | [2009-09-26 Sat] |            |             |       41 |

#+begin_src emacs-lisp
  (let ((total 0) (responding t) purchases)
    (while responding
      (setq purchases
            (cons
             (list ""
                   (read-from-minibuffer "What: ")
                   (read-from-minibuffer "Where: ")
                   (read-minibuffer "How Much: "))
             purchases))
      (setq responding (y-or-n-p "more? ")))
    (append 
     purchases
     (list
      (list
       (format-time-string "%Y-%m-%d" (current-time))
       "" "" (progn
               (mapc (lambda (purchase)
                       (setq total (+ total (fourth purchase))))
                     purchases)
               total)))))
#+end_src

#+resname:
| ""           | "fish and chips" | "diner"  |  9.78 |
| ""           | "food"           | "subway" |  5.45 |
| "2009-09-29" | ""               | ""       | 15.23 |






















































*** catch and throw example
Captured [2014-06-06 Fri 11:26]
  (defun search-foo ()
         (catch 'loop
           (let ((i 0))
             (while (< i 10)
               (let ((j 0))
                 (while (< j 10)
                   (if (foo i j)
                       (throw 'loop (list i j)))
                   (setq j (1+ j))))
               (setq i (1+ i))))))
  [[info:elisp#Examples%20of%20Catch][info:elisp#Examples of Catch]]

*** assertion
(cl-assert FORM &optional SHOW-ARGS STRING &rest ARGS)

Verify that FORM returns non-nil; signal an error if not.
Second arg SHOW-ARGS means to include arguments of FORM in message.
Other args STRING and ARGS... are arguments to be passed to `error'.
They are not evaluated unless the assertion fails.  If STRING is
omitted, a default message listing FORM itself is used.

#+BEGIN_SRC emacs-lisp
(assert (equalp 2 2))
#+END_SRC

*** xml and n3
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

introduce org-babel to =xml= and =n3=

#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
#+end_src

inform org-babel-tangle of their existence and file extensions
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

*** custom query of user before evaluating code block
   :PROPERTIES:
   :DATE:     2012-02-08
   :END:
#+begin_src sh :eval (if (y-or-n-p "Run operation X?") "yes" "no")
  echo "Going ahead with operation X!"
#+end_src
*** call line which dumps out its own header argument info
   :PROPERTIES:
   :DATE:     2012-02-05
   :END:
This call line passes its in-buffer location to a code block.  Notice
that the call to =(point)= in the call line is saved into a header
argument named =:my-point= and is then retrieved by the variable
initialization.  This indirection is required because of /when/ and
/where/ the elisp forms in header arguments are evaluated, a simpler
call line like =#+call: show:((point))= would not work because the
form =(point)= would not be evaluated in the correct place.

#+call: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info)))) :special-header "foo"

The special header argument =:special-header= may be seen in the
output below.  The =results= variable is due to the way that call
lines are evaluated.  During evaluation a call line is converted into
a trivial elisp code block of the form
: #+begin_src emacs-lisp :var results=called-function()
:   results
: #+end_src
which is evaluated in place.

#+RESULTS: show[:my-point (point)]((cdr (assoc :my-point (nth 2 info))))
| (:var results ((:var nil)) ((:colname-names)) ((:rowname-names)) ((:result-params replace)) ((:result-type . value)) ((:comments . )) ((:shebang . )) ((:cache . no)) ((:padline . )) ((:noweb . yes)) ((:tangle . no)) ((:exports . code)) ((:results . replace)) ((:padnewline . yes)) ((:hlines . no)) ((:session . none))) |
| (:colname-names)                                                                                                                                                                                                                                                                                                               |
| (:rowname-names)                                                                                                                                                                                                                                                                                                               |
| (:result-params replace)                                                                                                                                                                                                                                                                                                       |
| (:result-type . value)                                                                                                                                                                                                                                                                                                         |
| (:comments . )                                                                                                                                                                                                                                                                                                                 |
| (:shebang . )                                                                                                                                                                                                                                                                                                                  |
| (:cache . no)                                                                                                                                                                                                                                                                                                                  |
| (:padline . )                                                                                                                                                                                                                                                                                                                  |
| (:noweb . yes)                                                                                                                                                                                                                                                                                                                 |
| (:tangle . no)                                                                                                                                                                                                                                                                                                                 |
| (:exports . code)                                                                                                                                                                                                                                                                                                              |
| (:results . replace)                                                                                                                                                                                                                                                                                                           |
| (:special-header . foo)                                                                                                                                                                                                                                                                                                        |
| (:padnewline . yes)                                                                                                                                                                                                                                                                                                            |
| (:hlines . no)                                                                                                                                                                                                                                                                                                                 |
| (:session . none)                                                                                                                                                                                                                                                                                                              |

This code block visits the location of the call line, and calculates
the info using the same mechanisms used by =org-babel-lob-execute=.
#+name: show
#+begin_src emacs-lisp :var call-line-location=0
  (let ((call-info (save-excursion
                     (goto-char call-line-location)
                     (org-babel-lob-get-info))))
    (mapcar #'list
            (org-babel-process-params
             (org-babel-merge-params
              org-babel-default-header-args
              (org-babel-params-from-properties)
              (org-babel-parse-header-arguments
               (org-babel-clean-text-properties
                (concat ":var results="
                        (mapconcat #'identity (butlast call-info) " "))))))))
#+end_src
*** noweb insertion edge cases
   :PROPERTIES:
   :DATE:     2012-01-24
   :END:
The =cat= line below is dangerously close to a noweb reference.  The
space after test.org keeps it from being interpreted as a noweb
reference.

#+begin_src sh :tangle test.out :noweb yes
  <<task1>>
  <<b>>
  cat <<test.org >> test.out2
#+end_src

#+begin_src sh :noweb-ref task1
 echo "hello world"
#+end_src

#+BEGIN_SRC sh :noweb-ref b
 echo "b"
#+END_SRC

*** issues with call lines result insertion
   :PROPERTIES:
   :session:  *R-babel*
   :DATE:     2012-01-24
   :END:
#+NAME: foo-for-R
#+HEADER: :var a="a1.png"
#+BEGIN_SRC R :results output silent
  cat("in foo-for-R block\n")
  cat.a <- function() { cat(a,"\n",sep="") }
  cat.a()
#+END_SRC

#+NAME: bar-for-R
#+begin_src R :results output raw replace :exports none
 cat.a()
#+end_src

Because there are three instances of the =bar-for-R()= call line, all
of their results are inserted into the same place in the file,
specifically the location of the =#+Results: bar-for-R()= line.  This
can be very confusing if you are expected each =bar-for-R()= line to
generate it's own results.

Should have all a1 stuff
#+call: foo-for-R(a="a1.png")
#+call: bar-for-R()

Should have all a2 stuff
#+call: foo-for-R(a="a2.png")
#+call: bar-for-R()

Should have all a3 stuff
#+call: foo-for-R(a="a3.png")
#+call: bar-for-R()

The solution demonstrated below is to add a nothing header argument to
each bar-for-R to make it unique.  Notice that the three =foo= lines
below don't include results, as their results are inserted at the
identical foo lines above.

Should have all a1 stuff
#+call: foo-for-R(a="a1.png")
#+call: bar-for-R[id=1]()

Should have all a2 stuff
#+call: foo-for-R(a="a2.png")
#+call: bar-for-R[id=2]()

Should have all a3 stuff
#+call: foo-for-R(a="a3.png")
#+call: bar-for-R[id=3]()

*** name src_emacs-lisp{org-current-export-file}
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
Fanciness with running code in header arguments.

One block to tangle.
#+BEGIN_SRC emacs-lisp :tangle yes
  (message "I am tangled")
#+END_SRC

One block to export.
#+BEGIN_SRC emacs-lisp :exports results :var foo=(org-babel-tangle)
  (message "I just tangled %S during export" foo)
#+END_SRC

*** inhibit some call line evaluation on export
   :PROPERTIES:
   :DATE:     2012-01-20
   :END:
A buffer in which we want =foo= to be run when called interactively
from /any/ call line, but to only be run by a single call line on
export.  Ensure this works by executing this buffer to html while
tracking =foo-called.times= with =tail -f /tmp/foo-called.times=.

#+NAME: foo
#+BEGIN_SRC sh :var id="foo"
  echo "called by $id at $(date +%s.%N)" |tee -a /tmp/foo-called.times
#+END_SRC

This will *not* be run on export.
#+call: foo[:eval no-export]("bar")

This *will* be run on export.
#+call: foo("baz")

*** code block export template
   :PROPERTIES:
   :DATE:     2012-01-14
   :END:

The =org-babel-exp-code-template= (see below for its documentation)
variable may be customized to control which information from code
blocks is exported.

- Example code block
  #+Name: foo
  #+BEGIN_SRC sh :bar baz
    echo qux
  #+END_SRC

- Evaluate this block to export (shows the export of the name).
  #+Name: do-export-name
  #+BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "\n=%name=:\n#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"))
      (org-export-as-html nil))
  #+END_SRC

- Evaluate this block to export (shows the export of header arguments).
  #+Name: do-export-header-arguments
  #+BEGIN_SRC emacs-lisp :results silent
    (let ((org-babel-exp-code-template
           "Header arguments for =%name=.
    | header  | value    |
    |---------+----------|
    | bar     | %bar     |
    | results | %results |\n#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"))
      (org-export-as-html nil))
  #+END_SRC

: ,----[org-babel-exp-code-template]
: | org-babel-exp-code-template is a variable defined in `ob-exp.el'.
: | Its value is "#+BEGIN_SRC %lang%flags\n%body\n#+END_SRC"
: | 
: | Documentation:
: | Template used to export the body of code blocks.
: | This template may be customized to include additional information
: | such as the code block name, or the values of particular header
: | arguments.  The template is filled out using `org-fill-template',
: | and the following %keys may be used.
: | 
: |  lang ------ the language of the code block
: |  name ------ the name of the code block
: |  body ------ the body of the code block
: |  flags ----- the flags passed to the code block
: | 
: | In addition to the keys mentioned above, every header argument
: | defined for the code block may be used as a key and will be
: | replaced with its value.
: | 
: | You can customize this variable.
: `----

*** simple R session
   :PROPERTIES:
   :DATE:     2011-09-21
   :END:
#+begin_src R :session R
  paste("Yep!")
#+end_src

#+name:
: Yep!

*** should this throw an error for no variable definition
   :PROPERTIES:
   :DATE:     2011-09-15
   :END:
Evaluating this block should raise an error that there are
uninitialized variables.

#+name: add-column-in-table(table="", column="", something, type="", else, nullability)
#+begin_src sql
-- add column `$column' (if column does not exist yet)
IF NOT EXISTS (SELECT *
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '$table'
               AND COLUMN_NAME = '$column')
BEGIN
    ALTER TABLE $table
    ADD $column $type $nullability
END
#+end_src

*** header arguments on call lines
   :PROPERTIES:
   :DATE:     2011-09-11
   :END:
#+name: simple-example
#+begin_src emacs-lisp
  "the result"
#+end_src

#+call: simple-example()

#+name: simple-example()
: the result

#+call: simple-example() :results raw

#+name: simple-example()
the result

*** removing result with a silent header argument
   :PROPERTIES:
   :DATE:     2011-09-07
   :END:
evaluating the following code block will remove the related result.

#+begin_src sh :results silent
  date +%Y-%m-%d
#+end_src

#+name:
: 2011-09-07

*** silent results in org but not in export
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
The results of the following code block will not be inserted during
interactive evaluation but will during export.

#+begin_src sh :results (if org-current-export-file "replace" "silent") :exports both
  echo  "I want to see this in HTML/PDF, but not in Org"
#+end_src

*** leading commas in code blocks
   :PROPERTIES:
   :DATE:     2011-09-06
   :END:
#+begin_src r :exports code
  a <- c(1
         , 2
         , 3)
#+end_src

#+begin_src org :exports code
  ,this one will have commas removed
  ,#+begin_src R
  ,  a <- c(1
  ,         , 2
  ,         , 3)
  ,#+end_src
#+end_src

*** returning file type to inline call line
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Donec
hendrerit tempor tellus. Donec pretium posuere tellus. Proin quam
nisl, tincidunt et, mattis eget, convallis nec, purus. Cum sociis
natoque penatibus et magnis dis parturient montes, nascetur ridiculus
mus. Nulla posuere. Donec vitae dolor. Nullam tristique diam non
turpis. call_nothing_to_something()[:results file] [[file:something.txt]]
Cras placerat accumsan nulla. Nullam rutrum. Nam vestibulum accumsan
nisl.

#+name: nothing_to_something
#+begin_src sh :file something.txt
  echo nothing
#+end_src

*** demarcation of indented blocks
   :PROPERTIES:
   :DATE:     2011-09-04
   :END:
Demarcating a block with the point part-way in a line should indent
the remainder of the line in the second block.
    #+begin_src sh
      echo 1
      echo 2
      echo 3
      echo 4
    #+end_src

becomes

    #+begin_src sh :results silent :session something
      echo 1
      echo 2
      echo
    #+end_src
    
    #+begin_src sh :results silent :session something
           3
      echo 4
    #+end_src

*** simple indexing
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
#+name: list-o-numbers
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src sh :var column=list-o-numbers[,0]
  echo $column
#+end_src

#+name:
: 1 4 7

*** simple gnuplot plotting of Org-mode tables
   :PROPERTIES:
   :DATE:     2011-09-01
   :END:
#+tblname: gnuplot-testing
| x |  y |
|---+----|
| 1 |  2 |
| 2 |  4 |
| 3 |  6 |
| 4 |  8 |
| 5 | 10 |
| 6 | 12 |
| 7 | 14 |
| 8 | 16 |

#+begin_src gnuplot :var data=gnuplot-testing :file output.eps
set term postscript
set title "test"
set auto x
set style data histogram
set style fill solid border -1
set boxwidth 0.9
plot data using 2:xtic(1)
#+end_src

*** simple short R block
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
#+BEGIN_SRC R
c(1,23,54,5)
#+END_SRC

#+name:
|  1 |
| 23 |
| 54 |
|  5 |

*** convert results to all string
   :PROPERTIES:
   :DATE:     2011-08-29
   :END:
#+name: hetero-table
#+begin_src emacs-lisp
  '((1 2 3 4)
    ("a" "b" "c" "d"))
#+end_src

#+name: all-to-string
#+begin_src emacs-lisp :var tbl='()
  (defun all-to-string (tbl)
    (if (listp tbl)
        (mapcar #'all-to-string tbl)
      (if (stringp tbl)
          tbl
        (format "%s" tbl))))
  (all-to-string tbl)
#+end_src

#+begin_src emacs-lisp :var tbl=hetero-table
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
#+end_src

#+name:
| nil | nil | nil | nil |
| t   | t   | t   | t   |

#+begin_src emacs-lisp :var tbl=all-to-string(hetero-table)
  (mapcar (lambda (row) (mapcar (lambda (cell) (stringp cell)) row)) tbl)
#+end_src

#+name:
| t | t | t | t |
| t | t | t | t |

*** two blocks and a table
   :PROPERTIES:
   :DATE:     2011-08-28
   :END:

#+name: stuff
#+begin_src sh
  echo 1
  echo 2
  echo 3
#+end_src

#+name: last-of-stuff
#+begin_src sh :var input=stuff
  echo "$input" |tail -1
#+end_src

| one |
| two |
| 3   |
#+TBLFM: @3$1='(sbe last-of-stuff)

*** inheriting the file property
   :PROPERTIES:
   :FILE: something.png
   :DATE:     2011-08-23
   :END:

#+begin_src ditaa
   +-----------------------------+
   |                             |
   |    +-----+                  |
   |    |     |   +---------+    |
   |    |     |   |         |    |
   |    +-----+   |         |    |
   |              |         |    |
   |   file       |         |    |
   | inheritance  +---------+    |
   |                             |
   +-----------------------------+
#+end_src

#+name:
[[file:something.png]]

*** a table with tags
   :PROPERTIES:
   :DATE:     2011-08-23
   :END:

#+TBLNAME: sandbox           :noexport:
| 1 |         2 | 3 |
| 4 | org-babel | 6 |

#+begin_src emacs-lisp :var table=sandbox
  (message "%S" table)
#+end_src

#+name:
: ((1 2 3) (4 "org-babel" 6))

*** shell script output not in table
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
#+begin_src sh :results scalar
  echo 1
  echo 2
  echo 3
#+end_src

#+name:
: 1
: 2
: 3

*** inline code block and downstream src blocks
   :PROPERTIES:
   :DATE:     2011-08-21
   :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
something src_sh{echo eric}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
#+begin_src sh
  echo schulte
#+end_src
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE

**** with R
    :PROPERTIES:
    :DATE:     2011-08-21
    :END:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
blah blah src_R[:results output]{cat(rnorm(2))}
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
#+begin_src R :eval never :exports none
  1+2
  a <- b + c
  xyz
#+end_src
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD

*** updating a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+name: this-is-another-table
| 0 | 0 | 0 |
| 0 | 0 | 0 |
| 0 | 0 | 0 |

#+name: this-is-another-table
#+begin_src emacs-lisp :var table=this-is-another-table
  (setf (nth 1 table) '(2 2 2))
  table
#+end_src

*** space around exported code blocks
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
try evaluating the following blocks, then removing their results with
M-x `org-babel-remove-result'

Verbiage to begin the paragraph
#+begin_src sh
  echo eric
#+end_src
and verbiage to end the same paragraph.

#+begin_src sh
  echo 1
  echo 2
#+end_src

and verbiage to end the same paragraph.

*** simple ditaa block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+begin_src ditaa :file work-flow.png
    +-------+             +--------+
    |       |             |        |
    | Org   |------------>| Tex    |
    |       |             |        |
    +-------+             +--------+
#+end_src

#+name:
[[file:work-flow.png]]

*** ruby code block
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+begin_src ruby
  1+2
#+end_src

#+name:
: 3

*** replacing a table
   :PROPERTIES:
   :DATE:     2011-08-19
   :END:
#+name: this-is-the-table
| 1 | 4 | 7 |
| 2 | 5 | 8 |
| 3 | 6 | 9 |

#+name: this-is-the-table
#+begin_src emacs-lisp :var table=this-is-the-table
  (mapcar (lambda (row) (mapcar (lambda (cell) (* cell 2)) row)) table)
#+end_src

*** tangle before evaluating a code block
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:

#+begin_src sh :var TANGLED=(org-babel-tangle) :tangle no
  wc $TANGLED
#+end_src

#+name:
: 2  2 11 it.sh

#+begin_src sh :tangle it.sh
  echo TEST
#+end_src

*** bug with undefined function copy-seq
   :PROPERTIES:
   :DATE:     2011-08-05
   :END:
#+begin_src R :session :exports both
  1:10
#+end_src

*** plot results with org-plot
   :PROPERTIES:
   :DATE:     2011-08-02
   :END:
#+name: disk-usage
#+begin_src sh :exports both
  df
#+end_src

#+PLOT: title:"Disk Usage" ind:6 deps:(5) type:2d with:histograms set:"yrange [0:100]"
#+name: disk-usage
| Filesystem | 1K-blocks |     Used | Available | Use% | Mounted   | on |
| /dev/sda6  |  28835836 |  8447712 |  18923344 |  31% | /         |    |
| none       |   2997072 |      676 |   2996396 |   1% | /dev      |    |
| none       |   3006056 |        0 |   3006056 |   0% | /dev/shm  |    |
| none       |   3006056 |       96 |   3005960 |   1% | /var/run  |    |
| none       |   3006056 |        0 |   3006056 |   0% | /var/lock |    |
| /dev/sda7  | 144176824 | 72225604 |  64627420 |  53% | /home     |    |

*** premature truncation of emacs-lisp results
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

#+begin_src emacs-lisp
  '(nil nil nil nil)
#+end_src

#+name:
: (nil nil nil nil)

*** non-defined code blocks can still tangle
   :PROPERTIES:
   :DATE:     2011-07-28
   :END:

#+begin_src text :tangle somewhere.txt
  This will still tangle out to a file, and it opens in text mode, which
  may be nice.  
#+end_src

*** expand noweb refs
   :PROPERTIES:
   :DATE:     2011-07-25
   :END:
#+name: def-something
#+begin_src sh
  SOMETHING=nothing
#+end_src

#+begin_src sh
  <<def-something>>
  echo $SOMETHING
#+end_src

*** returning file names -- interpreted as lists
   :PROPERTIES:
   :DATE:     2011-07-21
   :END:
#+begin_src sh :results scalar
  echo "[[file:./cv.cls]]"
#+end_src

#+name:
: [[file:./cv.cls]]

#+begin_src sh :results raw scalar
  echo "[[file:./cv.cls]]"
#+end_src

#+name:
[[file:./cv.cls]]

*** java code block
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
#+begin_src java :classname myfirstjavaprog
  class myfirstjavaprog
  {  
      public static void main(String args[])
      {
          System.out.println("Hello World!");
      }
  }
#+end_src

#+name:
: Hello World!

*** including noweb refs w/o last newline
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:
#+begin_src sh :noweb yes
  <<my-name>> |\
  <<capitalize-name>>
#+end_src

#+name: my-name
#+begin_src sh
  echo "eric schulte"
#+end_src

#+name: capitalize-name
#+begin_src sh
  sed 's/^e/E/;s/ s/ S/'
#+end_src

*** exporting a ditaa example
   :PROPERTIES:
   :DATE:     2011-07-19
   :END:

#+begin_src ditaa :file blue.png :cmdline -r
/---------------\
|    test       |
|        {cBLU} |
\---------------/
#+end_src

#+name:
[[file:blue.png]]

*** simple sbe example
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

|   1 |
|   2 |
|   3 |
|   4 |
|   5 |
|   6 |
| 3.5 |
#+TBLFM: @7$1='(sbe mean (lst @1..@6))

#+name: mean
#+begin_src emacs-lisp :var lst=()
  (let ((num (car lst)) (nums (cdr lst)))
    (/ (float (+ num (apply #'+ nums))) (1+ (length nums))))
#+end_src

*** eval never
   :PROPERTIES:
   :DATE:     2011-07-10
   :END:

#+begin_src emacs-lisp :eval (if org-export-current-backend "never" "yes") :exports results
  (message "launch missles")
#+end_src

#+name:
: launch missles

*** indexing into a list variable
   :PROPERTIES:
   :DATE:     2011-07-06
   :END:

#+begin_src emacs-lisp :var lst='(0 1 2)
  (first lst)
#+end_src

#+name:
: 0

or as a noweb reference

#+name: external-list
- 0
- 1
- 2

#+begin_src sh :noweb yes
  echo <<external-list()[0]>>
#+end_src

#+name:
: 0

*** data alias for resname
   :PROPERTIES:
   :DATE:     2011-07-05
   :END:
#+name: blah
: blahcontent

#+begin_src emacs-lisp :var it=blah
  it
#+end_src

#+name:
: blahcontent

*** find a resource by global id
   :PROPERTIES:
   :DATE:     2011-07-01
   :END:

#+begin_src emacs-lisp :var it=990f3218-6fce-44fb-bd0c-5f6076c0dadc
  it
#+end_src

#+name:
: 
: here it is

**** I'm the resource
    :PROPERTIES:
    :ID:       990f3218-6fce-44fb-bd0c-5f6076c0dadc
    :DATE:     2011-07-01
    :END:

here it is

*** define a block with a name for noweb expansion
   :PROPERTIES:
   :tangle:   yes
   :noweb:    yes
   :DATE:     2011-07-01
   :END:

#+name: simple(something="something")
#+begin_src emacs-lisp
  something
#+end_src

another block including the first block
#+begin_src emacs-lisp
  <<simple(something="something else")>>
#+end_src

*** longtable label and attr lines on code block results
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:

#+name: faz
#+begin_src emacs-lisp :exports results
  '((foo foo)
    (bar baz))
#+end_src

#+LABEL: Foo
#+name: faz
| foo | foo |
| bar | baz |

*** another test
   :PROPERTIES:
   :DATE:     2011-06-29
   :END:
#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

Here is a call_square(it=4), stuck in the middle of some prose.

Here is another 25^2=call_square(it=25).

*** un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

#+call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

#+name: minus
#+begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
#+end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

*** un-named variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: square
#+begin_src emacs-lisp :var it=0
  (* it it)
#+end_src

#+call: square(8)

first we can name the argument with call_square(it=4) =16=

then we can pass the argument unnamed with call_square(4) =16=

#+name: minus
#+begin_src emacs-lisp :var a=0 :var b=0
  (- a b)
#+end_src

To ensure that these arguments are passed in the correct order we can
use the following call_minus(8, 4) =-4=

*** multiple variables
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

Should work call_concat(1, 2, 3) =123= in order.

#+name: concat
#+begin_src emacs-lisp :var a=0 :var b=0 :var c=0
  (format "%S%S%S" a b c)
#+end_src

Should be positive call_lob-minus(4, 3) =1= by order.

*** inline call line
   :PROPERTIES:
   :DATE:     2011-06-27
   :END:

#+name: double
#+begin_src emacs-lisp :var it=0
  (* 2 it)
#+end_src

This is the number src_sh[:var it=double(it=1)]{echo $it} in the middle

The following exports as a normal call line
#+call: double(it=1)

Now here is an inline call call_double(it=1) stuck in the middle of
some prose.

This one should not be exported =call_double(it=2)= because it is
quoted.

Finally this next one should export, even though it starts a line
call_double(it=3) because sometimes inline blocks fold with a
paragraph.

And, a call with raw results call_double(4)[:results raw] should not
have quoted results.

*** text and graphics from R
   :PROPERTIES:
   :DATE:     2011-06-24
   :END:

#+begin_src R :results output :session
print(seq(1,10))
#+end_src

#+begin_src R :file example.png :results graphics :session
plot(seq(1,10))
#+end_src

#+name:
[[file:example.png]]

*** large code in inline blocks
   :PROPERTIES:
   :DATE:     2011-06-22
   :END:

#+name: big-block
#+begin_src emacs-lisp :exports none
  "something complex"
#+end_src

Here is some text with src_emacs-lisp[:var it=big-block]{it} in the middle.

*** clojure =:results scalar=
   :PROPERTIES:
   :DATE:     2011-06-21
   :END:
#+begin_src clojure :results scalar
  '(1 2 3)
#+end_src

*** expand variable during tangling
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2011-06-20
   :END:

#+begin_src sh :var VER=(vc-working-revision (buffer-file-name))
  echo $VER
#+end_src

*** scalar emacs lisp results
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
#+begin_src emacs-lisp :results scalar
  '(1 2 3)
#+end_src

#+name:
: (1 2 3)

*** python session
   :PROPERTIES:
   :DATE:     2011-06-19
   :END:
#+begin_src python :results output :session mypy 
x = 1
for i in range(1,5):
  x = x + i
  print x

print "I throw an error"
#+end_src

#+name:
: 
: ... ... ... 2
: 4
: 7
: 11
: I throw an error

#+begin_src python :results output :session
  print y
#+end_src

#+name:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
: NameError: name 'y' is not defined

*** named code block export
   :PROPERTIES:
   :DATE:     2011-06-13
   :END:
This has a name which is not exported.

#+name: rand(n)
#+begin_src R
  runif(n)
#+end_src

*** tangle test
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
#+begin_src R :tangle test.R :shebang #!/bin/cat :padline no
This is
a test
#+end_src

*** ruby with xmpfilter
   :PROPERTIES:
   :DATE:     2011-06-10
   :END:
#+begin_src ruby :results xmp code
  2 + 2 # =>
  3.times{ puts :hello }
#+end_src

#+name:
#+BEGIN_SRC ruby
2 + 2 # => 4
3.times{ puts :hello }
# >> hello
# >> hello
# >> hello
#+END_SRC

*** continued code blocks
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2011-06-10
   :END:
#+name: foo
#+begin_src emacs-lisp
  (message "foo:%S" 1)
#+end_src

#+begin_src emacs-lisp
  (message "un-named")
#+end_src

#+name: bar
#+begin_src emacs-lisp
  (message "bar:%S" 1)
#+end_src

#+name: foo
#+begin_src emacs-lisp
  (message "foo:%S" 2)
#+end_src

#+name: bar
#+begin_src emacs-lisp
  (message "bar:%S" 2)
#+end_src

#+begin_src emacs-lisp :tangle no :results silent
  (with-temp-buffer
    (insert-file-contents "~/src/lisp/org-make-triple.el")
    (eval-buffer))
#+end_src

*** simple shell
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src sh
  sleep 10 && ls
#+end_src

#+name:
| _config.yml     |
| data            |
| development.org |
| elsevier        |
| index.org       |
| paper           |
| publish.org     |
| scraps          |
| scraps.html     |
| scraps.org      |
| scraps.tex      |

#+begin_src ruby :session eric
  puts [1..4]
#+end_src

#+name:
: nil

*** quick testing new session code
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src sh :session test :results output
  echo foo
#+end_src

#+name:
: foo

#+begin_src ruby :results output :session simple
  puts "foo"
#+end_src

#+name:
: foo

*** =:file= and python
   :PROPERTIES:
   :DATE:     2011-06-06
   :END:
#+begin_src python :file /tmp/test.png
  return 1
#+end_src

#+name:
[[file:/tmp/test.png]]

*** testing new data names
   :PROPERTIES:
   :DATE:     2011-06-02
   :END:

#+name: simple-123
: 123

#+begin_src emacs-lisp :var simple=simple-123 :exports both
  (* simple 2)
#+end_src

results

data

my data is results

#+name:
: 246

*** default directory examples in lisp
   :PROPERTIES:
   :DATE:     2011-06-01
   :END:

#+begin_src lisp
  *default-pathname-defaults*
#+end_src

#+begin_src sh
  pwd
#+end_src

#+begin_src lisp :dir
  *default-pathname-defaults*
#+end_src

#+name:
: #P""

*** lisp body with multiple forms
   :PROPERTIES:
   :DATE:     2011-05-31
   :END:

#+begin_src lisp :results value
  (format t "~&eric")
  (+ 1 2)
#+end_src

#+name:
: 3

*** passing values through to STDIN of shell code blocks
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:
#+name: square-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+name: first-col
#+begin_src sh :stdin square-table
  awk '{print $1}'
#+end_src

#+begin_src sh :stdin first-col
  sed 's/4/middle/g'
#+end_src

#+name:
|      1 |
| middle |
|      7 |

*** awk example
   :PROPERTIES:
   :DATE:     2011-05-26
   :END:

#+name: simple-table
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src awk :stdin simple-table
  {print $1}
#+end_src

#+name:
| 1 |
| 4 |
| 7 |

*** don't match end_src inside of a block
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:

#+name: the_issue
#+begin_src sh :results output
  echo '#+end_src'
#+end_src

#+name: the_issue
: #+end_src block

*** append tables
   :PROPERTIES:
   :DATE:     2011-05-14
   :END:
#+name: table-names
- first-table
- second-table
- third-table

#+name: first-table
| a | 1 |
| b | 2 |

#+name: second-table
| c | 3 |
| d | 4 |

#+name: third-table
| e | 5 |
| f | 6 |

#+begin_src emacs-lisp :var table-names=table-names
  (mapcar #'org-babel-ref-resolve table-names)
#+end_src

#+name:
| (a 1) | (b 2) |
| (c 3) | (d 4) |
| (e 5) | (f 6) |

*** ocaml
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

#+begin_src ocaml
  [3;2;3] @ [3;2;3;4;5];;
#+end_src

#+name:
| 3 | 2 | 3 | 3 | 2 | 3 | 4 | 5 |

*** new names for results
   :PROPERTIES:
   :DATE:     2011-05-06
   :END:

#+name: simple
: 1

#+begin_src emacs-lisp :var data=simple
  data
#+end_src

#+name:
: 1

changing the variable used to label data
#+begin_src emacs-lisp :results silent
  (setq org-babel-result-fmt
        "^[ \t]*#\\+\\(TBLNAME\\|RESNAME\\|RESULTS\\|DATA\\):[ \t]*%s[ \t]*$")
#+end_src

#+name: not-so-simple
: 2

#+begin_src emacs-lisp :var data=not-so-simple
  data
#+end_src

#+name:
: 2

*** simple latex verbatim wrap example
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
#+begin_src emacs-lisp :results silent
  (setq org-export-latex-verbatim-wrap
        '("{\\scriptsize\n\\begin{verbatim}\n" . "\\end{verbatim}\n}\n"))
#+end_src

#+begin_src sh
  echo eric schulte
  echo another
#+end_src

*** inserting complicated results
   :PROPERTIES:
   :DATE:     2011-05-05
   :END:
#+begin_src emacs-lisp :results scalar
  ((lambda (result) (condition-case nil (read result) (error result)))
   "(:return
   (:ok \"{:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y*sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}\")
   13)")
#+end_src

#+name:
| :return | (:ok {:model #<MINLP f(x,y)={(x[0]-5)^2+(x[1]-3)^2-y*sqrt($x),2}>, :v #<Variables x={ 4.0, 4.0 } y={ 0 }>, :z nil}) | 13 |

*** automatic org-mode formatting
   :PROPERTIES:
   :DATE:     2011-04-27
   :END:

#+name: raw-results
#+begin_src sh :results output tabular
  echo "| 1 |"
  echo "| 2 |"
#+end_src

#+begin_src emacs-lisp :var in=raw-results
  (stringp in)
#+end_src

#+name:
: t

*** units in R plot
   :PROPERTIES:
   :DATE:     2011-04-21
   :END:
#+begin_src R  :results graphics :file test.png :width 8 :height 8 :res 200 :units cm
  x <- -10:10
  y <- x^2
  plot(x, y, type="l", col="red", lty=1)
#+end_src

#+name:
[[file:test.png]]

*** simple Oz example
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
#+begin_src oz :results output
  {Browse 'Hello'}
#+end_src

*** Ocaml appending blocks
   :PROPERTIES:
   :DATE:     2011-04-19
   :END:
block

#+begin_src ocaml
  [|1;2;3|];;
#+end_src

#+name:
| 1 | 2 | 3 |

*** complex numbers in tables and python, reference in table formula
   :PROPERTIES:
   :DATE:     2011-04-13
   :END:

#+name: parameter-variation(data=0)
#+begin_src python :result values
  return 'text'
#+end_src

|---------------------------------------|
| "(0.0331901438056,0.000535222885197)" |
| "(0.0333434157791,0.000537930174356)" |
| "(0.0345727512157,0.000559346040457)" |
| "(0.0353146483908,0.000571501584524)" |
| "(0.0355522909393,0.000574387067408)" |
| "(0.0356575682336,0.000574851263615)" |
| "(0.0357806926897,0.000575051685084)" |
|---------------------------------------|
| text                                  |
#+TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

| '(1 2 3 4) |
|------------|
|          4 |
#+TBLFM: @2$1='(sbe quote (it @1$1))

| (1 2 3 4) |
|-----------|
| #ERROR    |
#+TBLFM: @2$1='(sbe quote (it @1$1))

**** using vectors to represent complex number is lisp
    :PROPERTIES:
    :DATE:     2011-04-15
    :END:
| [1 2]            |
|------------------|
| real:1 complex:2 |
#+TBLFM: @2$1='(sbe real (it @1$1))

#+name: real(it='())
#+begin_src emacs-lisp
  (format "real:%d complex:%d" (aref it 0) (aref it 1))
#+end_src

**** reference the table in a table formula
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
#+name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
|-------------------------------------|
|                                   4 |
#+TBLFM: @2$1='(sbe quote (it "complex-data"))

**** externally referencing the table
    :PROPERTIES:
    :DATE:     2011-04-13
    :END:
#+name: complex-data
|-------------------------------------|
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |
#+TBLFM: @8$1='(sbe parameter-variation (nums @1$1..@7$1))

#+begin_src python :var data=complex-data
  return data
#+end_src

#+name:
| (0.0331901438056,0.000535222885197) |
| (0.0333434157791,0.000537930174356) |
| (0.0345727512157,0.000559346040457) |
| (0.0353146483908,0.000571501584524) |
| (0.0355522909393,0.000574387067408) |
| (0.0356575682336,0.000574851263615) |
| (0.0357806926897,0.000575051685084) |

*** emacs-lisp printing with output to string
   :PROPERTIES:
   :DATE:     2011-04-10
   :END:

#+begin_src emacs-lisp :results output
  (let ((dog (sqrt 2))
        (cat 7))
    (print (format "%s %f" "Dog: " (eval dog)))
    (print (format "%s %d" "Cat: " (eval cat)) nil)
    (print "Fish."))
#+end_src

#+name:
: 
: "Dog:  1.414214"
: 
: "Cat:  7"
: 
: "Fish."

#+begin_src emacs-lisp
  (let ((dog (sqrt 2))
        (cat 7))
    `((dog ,dog)
      (cat ,cat)
      (fish)))
#+end_src

#+name:
| dog  | 1.4142135623730951 |
| cat  |                  7 |
| fish |                    |

*** session associated with R block
   :PROPERTIES:
   :DATE:     2011-04-02
   :END:
#+begin_src R :session *chris*
  x <- 1
  y <- 2
  y-x
#+end_src

#+name:
: 1

*** vc-log
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

A version control log of this file.  The =vc-log= code block lives in
the library of babel.
#+call: vc-log() :exports results

*** tangling out vc information
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:

#+headers: :var STATE=(vc-state (or (buffer-file-name) org-current-export-file))
#+headers: :var REV=(vc-working-revision (or (buffer-file-name) org-current-export-file))
#+begin_src sh :tangle yes
  rm -rf ./R
  rm -f ./spreadSim.sub
  REVISION=$REV.$STATE
  tar -xf nsa.$REVISION.tar.gz
  $HOME/R/R/R-2.12.0/bin/Rscript --vanilla -e
"source('./R/generateLatinHypercubeScenarios.R'); doIt()"
  for SCENARIO in ./R/scenarios/*.R; do
    export SCENARIO=${SCENARIO#./R/scenarios/}
    qsub nsa.sub
  done
#+end_src

*** grabbing the current buffer during export
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
Eric

#+begin_src emacs-lisp :var buf=(buffer-file-name (current-buffer)) :exports both
  (message "buffer %S!" buf)
#+end_src

#+begin_src sh :exports results :results output
  git log -1
#+end_src

*** detangling example
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :shebang:  #!/bin/sh
   :ID:       7a22cf71-6be3-4fca-a700-4c8be8237303
   :DATE:     2011-04-01
   :END:

#+name: sh-for-tangling
#+begin_src sh
  echo "this is the `sh-for-tangling' code block"
  num=`expr 1 + 1`
  echo "the value of num is $num"
#+end_src

#+begin_src sh
  echo "this is an unnamed code block"
#+end_src

*** CL example
   :PROPERTIES:
   :DATE:     2011-04-01
   :END:
#+begin_src lisp
  (defun range (n &optional m)
    "Return the numbers in range."
    (loop for num from (if m n 0) to (if m m (- n 1)) collect num))
  
  (mapcar #'list (mapcar #'1+ (range 10)))
#+end_src

#+name:
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |

*** colnames with call lines
   :PROPERTIES:
   :DATE:     2011-03-29
   :END:
#+TBLNAME: data
| x | parameter | value |
|---+-----------+-------|
| 0 | heat      |    30 |
| 1 | heat      |    30 |

#+name: func5
#+begin_src R :var name=data :var a="one" :colnames yes
  names(name)
#+end_src

#+name: func5
| x         |
|-----------|
| x         |
| parameter |
| value     |

#+call: func5(name=data, a="two") :colnames yes

#+name: func5(name=data, a="two")
| x         |
|-----------|
| x         |
| parameter |
| value     |

*** macros during tangling
   :PROPERTIES:
   :ID:       d2ff9d6f-b413-4072-91a9-3ae8aa32032c
   :DATE:     2011-03-14
   :END:

First, add macro expansion to the new `org-babel-tangle-body-hook'.

#+begin_src emacs-lisp :results silent
  (add-hook 'org-babel-tangle-body-hook
            (lambda () (org-export-preprocess-apply-macros)))
#+end_src

Then define the macro.  Note: you may need to export the buffer before
tangling so that the macro definition is noticed and processed by
Org-mode.

#+MACRO: CONFIG_PARAM01 45

Then on both export and tangling the macro in the following code block
will be replaced.

#+begin_src sh :tangle yes
  echo org-mode set CONFIG_PARAMETER to: {{{CONFIG_PARAM01}}}
#+end_src

*** conflicting header arguments
   :PROPERTIES:
   :DATE:     2011-03-14
   :END:

code block
#+name: conflict-block
#+begin_src sh :exports results :results silent
  echo eric
#+end_src

call line
#+call: conflict-block() :exports results

#+name: conflict-block()
: eric

*** looks like a pipe in a table
   :PROPERTIES:
   :DATE:     2011-03-07
   :END:
#+name: clean
#+begin_src emacs-lisp :var in=""
  (flet ((clean (in)
                (if (listp in)
                    (mapcar #'clean in)
                  (if (stringp in)
                      (replace-regexp-in-string "¦" "|" in)
                    in))))
    (clean in))
#+end_src

#+name: regexps
| first  | (a¦b) |
| second | (1¦2) |

#+begin_src perl :var a=clean(in=regexps)[0,1] :var b=clean(in=regexps)[1,1]
  $a; $b;
#+end_src

#+name:
: (1|2)

*** eval results as a list
   :PROPERTIES:
   :DATE:     2011-03-06
   :END:
#+begin_src python :results value
  return "(mapcar (lambda (el) (+ 1 el)) '(1 2))"
#+end_src

#+name:
| 2 | 3 |

#+begin_src python :results value
  return "[1, 2]"
#+end_src

#+name:
| 1 | 2 |

#+begin_src python :results value
  return [1, 2]
#+end_src

#+name:
| 1 | 2 |

#+begin_src python :results value
  return "%r" % "[1 2]"
#+end_src

#+name:
: [1 2]

*** simple mysql
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
#+begin_src sql :engine mysql
  show tables;
#+end_src

*** export of inline R code
   :PROPERTIES:
   :DATE:     2011-03-03
   :END:
Here I test inline code evaluation in R.

#+begin_src R :session *R*
x <- 100
#+end_src

#+name:
: 100

Now I want to export the value of x, which should be
src_R[:session *R*]{x} .

Did the number 100 show up at the end of the previous sentence on export?

*** results org raw wrap
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
#+begin_src sh :results output org :exports none
  cat <<EOF
  - first
  - second
  EOF
#+end_src

#+name:
#+BEGIN_ORG
- first
- second
#+END_ORG

**** Version 1
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version only prints the org code for the table, but does not interprets it.
#+begin_src R :exports both :results output raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

**** Version 2
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
This version prints the table including the graph as expected, but
:results is used twice as a header argument.
#+begin_src R :results output :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

**** Version 3
    :PROPERTIES:
    :DATE:     2011-03-02
    :END:
Finally this version does only export the R code
#+begin_src R :exports both :results raw
  cat(
      "|--|--|\n",
      "|name|[[./pdf1.pdf]]|\n",
      "|--|--|\n"
      )
#+end_src

*** leading/trailing spaces
   :PROPERTIES:
   :DATE:     2011-03-02
   :END:
#+name: spaces-wrapped-string
- " pass through with space "

#+begin_src emacs-lisp :var res=spaces-wrapped-string[0]
  res
#+end_src

#+name:
:  pass through with space 

*** reference to a commented out subtree
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
**** COMMENT I don't export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
#+name: hidden-parameters
| 1 |
| 2 |
| 3 |
| 4 |

**** I do export
    :PROPERTIES:
    :DATE:     2011-02-28
    :END:
#+begin_src emacs-lisp :var params=hidden-parameters :exports both
  params
#+end_src

*** literal reference in a table with sbe
   :PROPERTIES:
   :DATE:     2011-02-28
   :END:

| "eric schulte" | 12 |
#+TBLFM: @1$2='(sbe length (in $1))

#+name: length
#+begin_src emacs-lisp :var in="foo"
  (length in)
#+end_src

*** strip hline before processing a variables indices
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+name: table-w-hline
| 1 | a |
|---+---|
| 2 | b |
| 3 | c |
| 4 | d |

#+begin_src emacs-lisp :var table=table-w-hline[1,1] :hlines no
  table
#+end_src

#+name:
: hline

#+tblname: perl-table-w-hline
| colA | colB |
|------+------|
| a1   | b1   |
| a2   | b2   |

#+headers: :var b=perl-table-w-hline[2..,1]
#+headers: :var a=perl-table-w-hline[2..,0]
#+begin_src perl :tangle yes
  $a; $b;
#+end_src 

*** passing elisp-looking variables to code blocks
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+begin_src perl :var it="(+ 1 1)" :results output
  printf "passed in %s", $it
#+end_src

#+name:
: passed in (+ 1 1)

#+name: elisp-looking-table
| 1 | (+ 1 1) |
| 2 | (a b c) |
| 3 | (+ 3 3) |

#+begin_src perl :var data=elisp-looking-table[1,1]
  $data
#+end_src

#+name:
: (a b c)

#+begin_src emacs-lisp :var data=elisp-looking-table[1,1]
  data
#+end_src

#+name:
: (a b c)

*** pass a vector to calc
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:

#+begin_src calc :var y=[1 2 3]
  y
#+end_src

#+name:
: [1 2 3]

#+begin_src calc :var y=[1 2 3]
  3 y
#+end_src

#+name:
: [3, 6, 9]

#+begin_src emacs-lisp :var data=[1 2 3]
  (elt data 1)
#+end_src

#+name:
: 2

#+begin_src calc
  1 * 8
#+end_src

#+name:
: 8

*** new block regexp tests
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:
**** Block 1 (Exports OK)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 1
#+END_SRC

**** Block 2 (Exports OK - double blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out


#+END_SRC

**** Block 3 (Fails - single blank line no white-space in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out

#+END_SRC

**** Block 4 (Gets consumed by previous Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 4
#+END_SRC

**** Block 5 (Fails - no lines in Block)
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
#+END_SRC

**** Block 6 (Gets consumed by previous Block
    :PROPERTIES:
    :DATE:     2011-02-27
    :END:

#+BEGIN_SRC sh :tangle test-out
Block 6
#+END_SRC

*** don't interpret tuples as elisp code
   :PROPERTIES:
   :DATE:     2011-02-27
   :END:
#+begin_src python :results value
  return (1,2)
#+end_src

#+name:
: (1, 2)

*** source block names in current buffer
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src emacs-lisp :results list
 (org-babel-src-block-names)
#+end_src

*** simple python block
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src python :return foo
  foo = 8
  foo += 1
#+end_src

#+name:
: 9

*** sh return a list of elements with spaces
   :PROPERTIES:
   :DATE:     2011-02-26
   :END:
#+begin_src sh :results list
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
#+end_src

#+name:
- ("eric" "schulte")
- ("dan" "davison")
- ("seb" "vauban")

#+begin_src sh :results scalar
  echo "eric schulte"
  echo "dan davison"
  echo "seb vauban"
#+end_src

#+name:
: eric schulte
: dan davison
: seb vauban

*** calc variables inside of parenthesis
   :PROPERTIES:
   :DATE:     2011-02-22
   :END:
#+BEGIN_SRC calc :var testvar=9000
testvar - 200
#+END_SRC

#+name:
: 8800

#+BEGIN_SRC calc :var testvar=9000
(testvar - 200) 800
#+END_SRC

#+name:
: 7040000

*** new lists
    :PROPERTIES:
    :DATE:     2011-02-21
    :END:
**** results embedded inside of a list
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
1. this has results
   #+name: something-in-a-list
   : foo
2. and this doesn't work
   #+begin_src emacs-lisp :var data=something-in-a-list
     data
   #+end_src

   #+name:
   : foo

**** reading and writing
    :PROPERTIES:
    :DATE:     2011-02-22
    :END:
#+name: simple-list
- 1
- two
- 3
- four


#+name: simple-list
#+begin_src emacs-lisp :var lst=simple-list :results list
  (reverse lst)
#+end_src

*** catch the file name during export
   :PROPERTIES:
   :DATE:     2011-02-21
   :END:

#+begin_src emacs-lisp :var file-name=(buffer-file-name) :exports both
  file-name
#+end_src

*** mentions of file names in file contents
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
directory to search
#+name: graph-dir
: graph-dir

list all files in dir
#+name: graph-files
#+begin_src sh :results vector :var dir=graph-dir
  find $dir -type f -exec basename {} \;
#+end_src

#+name: graph-files
| other |
| dan   |
| eric  |
| seb   |

association of files with mentions
#+name: graph-associations
#+begin_src sh :var dir=graph-dir :var files=graph-files
  for i in $files; do
      for j in `grep -l -r $i $dir`;do
          echo $i, `basename $j`
      done
  done
#+end_src

#+name: graph-associations
| other | eric |
| other | seb  |
| dan   | eric |
| eric  | seb  |
| seb   | dan  |

graphing with dot
#+name: to-dot
#+begin_src sh :var associations=graph-associations :results scalar
  echo "$associations"|awk '{print $1, "->", $2}'
#+end_src

#+name: to-dot
: other -> eric
: other -> seb
: dan -> eric
: eric -> seb
: seb -> dan

#+begin_src dot :var data=to-dot :file files.png
  digraph G{
    $data
  }
#+end_src

#+name:
[[file:files.png]]

*** export of inline code blocks which are silent
   :PROPERTIES:
   :DATE:     2011-02-20
   :END:
#+begin_src emacs-lisp :results silent
  (setf org-babel-default-inline-header-args
        '((:session . "none")
          (:results . (if (boundp 'org-current-export-file) "replace" "silent"))
          (:exports . "results")))
#+end_src

Here is an inline code block src_sh{echo 8} <- there

*** inline code block
   :PROPERTIES:
   :DATE:     2011-02-18
   :END:

here is an inline block src_R{1+1}

*** SQL --- example reading org-mode table into sql
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
#+tblname: example-table-for-sql
| a |  b |
|---+----|
| 1 | 10 |
| 2 | 11 |
| 3 | 12 |
| 4 | 13 |
| 5 | 14 |
| 6 | 15 |

#+headers: :var table=example-table-for-sql
#+begin_src sql :engine mysql
load data infile "$table" into mytable;
#+end_src

*** recutils
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:
#+begin_src sh :file book.rec
  cat <<EOF > book.rec
  # -*- mode: rec -*-
  %rec: Book
  %mandatory: Title
  %type: Location enum loaned home unknown
  %doc:
  + A book in my personal collection.
  
  Title: GNU Emacs Manual
  Author: Richard M. Stallman
  Publisher: FSF
  Location: home
  
  Title: The Colour of Magic
  Author: Terry Pratchett
  Location: loaned
  
  Title: Mio Cid
  Author: Anonymous
  Location: home
  
  Title: chapters.gnu.org administration guide
  Author: Nacho Gonzalez
  Author: Jose E. Marchesi
  Location: unknown
  
  Title: Yeelong User Manual
  Location: home
  
  # End of books.rec
  EOF
#+end_src

#+name:
[[file:book.rec]]

#+begin_src rec :data book.rec :fields Title,Author
  Location = 'loaned'
#+end_src

#+name:
| Title               | Author          |
| The Colour of Magic | Terry Pratchett |

#+begin_src rec :data book.rec :fields Title,Author
  
#+end_src

#+name:
| Title                                 | Author              | Author_2         |
| GNU Emacs Manual                      | Richard M. Stallman |                  |
| The Colour of Magic                   | Terry Pratchett     |                  |
| Mio Cid                               | Anonymous           |                  |
| chapters.gnu.org administration guide | Nacho Gonzalez      | Jose E. Marchesi |
| Yeelong User Manual                   |                     |                  |

*** passing keywords inside header arguments
   :PROPERTIES:
   :DATE:     2011-02-15
   :END:

#+begin_src emacs-lisp :var lst='(:no-expand :other)
  lst
#+end_src

#+name:
| :no-expand | other |

*** two vars in a properties block -- not possible
   :PROPERTIES:
   :var:      test1=7
   :var:      test2=8
   :DATE:     2011-02-10
   :END:

#+begin_src emacs-lisp
  (message "test1=%S test2=%S" test1 test2)
#+end_src

results in Error
: let: Symbol's value as variable is void: test2

**** an alternative
    :PROPERTIES:
    :var:      tests=all-tests
    :DATE:     2011-02-10
    :END:

#+tblname: all-tests
- 7
- 8

#+begin_src emacs-lisp :var eric=89
  (message "test1=%S test2=%S" (first tests) (second tests))
#+end_src

#+name:
: test1=7 test2=8

**** another alternative
    :PROPERTIES:
    :var:      vars=variables
    :DATE:     2011-06-21
    :END:

#+tblname: variables
| var1 | 1 |
| var2 | 2 |

#+begin_src python
  print vars[0][1]
  print vars[1][1]
#+end_src

*** how to set no-expand in properties
   :PROPERTIES:
   :no-expand: yes
   :DATE:     2011-02-10
   :END:

#+begin_src emacs-lisp :var something="other thing" :tangle no-expand.el
  :test
#+end_src

tangles to

*** non-inlined inline code block
   :PROPERTIES:
   :DATE:     2011-01-27
   :END:
The Date is src_sh[:results replace]{date} at the time of =this= export.

src_sh[:results replace]{ls}

*** simple calc example
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
#+begin_src calc 
2*3
#+end_src

#+name:
: 6

*** results replace not always working
   :PROPERTIES:
   :DATE:     2011-01-25
   :END:
#+begin_src sh :results output org replace :exports code
  for i in `seq 4`;do
      echo "- place $i in the list"
  done
#+end_src

#+name:
#+BEGIN_ORG
- place 1 in the list
- place 2 in the list
- place 3 in the list
- place 4 in the list
#+END_ORG

inline block src_emacs-lisp[:exports code :results replace]{(+ 1 1 1)} here is was

*** inserting wrappers eats following characters
    :PROPERTIES:
    :DATE:     2011-01-20
    :END:
**** Test
     :PROPERTIES:
     :DATE:     2011-01-20
     :END:
   
   #+begin_src emacs-lisp :results latex
     "\\begin{equation}\\frac{1}{2}\n\\end{equation}"
   #+end_src

   #+name:
   #+BEGIN_LaTeX
   \begin{equation}\frac{1}{2}
   \end{equation}
   #+END_LaTeX
   
**** Watch me die :-(
     :PROPERTIES:
     :DATE:     2011-01-20
     :END:

*** creating a directory when needed for tangling
   :PROPERTIES:
   :DATE:     2011-01-19
   :END:
#+begin_src clojure :tangle (prog1 "src/foo.clj" (make-directory "src" "."))
  (ns something)
#+end_src

a helper function for the above
#+begin_src emacs-lisp
  (defun mkdir-p (file &optional dir)
    "Create any parent directories of FILE if missing and return FILE."
    (make-directory (file-name-directory file) (or dir ".")) file)
#+end_src

allows the following
#+begin_src clojure :tangle (mkdir-p "src/foo.clj")
  (ns something)
#+end_src

There is now a new header argument controlling this behavior
#+begin_src emacs-lisp :mkdirp yes :tangle novel/nested/directories/finally.clj
  (message "contents")
#+end_src

*** passing arguments to the shell
   :PROPERTIES:
   :DATE:     2011-01-18
   :END:
#+name: something
: eric
:   schulte
:     yes
: more

#+name: something-list
| 1 |
| 2 |
| 3 |

#+begin_src sh :var data=something-list
  echo "$data"|wc -l
#+end_src

#+name:
: 3

#+begin_src emacs-lisp :results silent
  (setq org-babel-sh-var-quote-fmt "`cat <<'BABEL_TABLE'\n%s\nBABEL_TABLE\n`")
#+end_src

*** wrap noweb references in comments
   :PROPERTIES:
   :DATE:     2011-01-16
   :END:
#+name: wrappable
#+begin_src emacs-lisp
  (setq x (+ 4 x))
#+end_src

#+begin_src emacs-lisp :comments noweb :noweb yes :tangle yes
  (let ((x 1))
    (message "x=%s" x)
    <<wrappable>>
    (message "x=%s" x))
#+end_src

*** replace inline code block
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
This is src_emacs-lisp{(+ 1 2 3)} an inline block.

#+begin_src emacs-lisp
  (defun replace-inline-block ()
    (interactive)
    (if (save-excursion (re-search-backward "[ \f\t\n\r\v]" nil t)
                        (looking-at org-babel-inline-src-block-regexp))
        (replace-match
         ((lambda (el) (if (stringp el) el (format "%S" el)))
          (org-babel-execute-src-block)) nil nil nil 1)
      (error "not inside of an inline source block.")))
#+end_src

*** noweb then variables
   :PROPERTIES:
   :DATE:     2011-01-13
   :END:
#+name: replaced-first
#+begin_src latex
  \begin{itemize}
  \item first
  \item data
  \item third
  \end{itemize}
#+end_src

#+begin_src latex :var data="second" :noweb yes
  \section{ordinals}
  \label{sec:ordinals}
  <<replaced-first>>
#+end_src

*** empty strings as arguments
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:

#+begin_src emacs-lisp :results output :var foo=""
  (concat foo "bar")
#+end_src

#+name:
: bar

*** call lines
   :PROPERTIES:
   :DATE:     2011-01-11
   :END:
#+name: doubler
#+begin_src emacs-lisp :var n=2
  (* n 2)
#+end_src

#+call: doubler(n=3)

#+name: doubler(n=3)
: 6

#+call: doubler[:var n=3]()

#+name: doubler[:var n=3]()
: 6

*** language name abbreviations
   :PROPERTIES:
   :DATE:     2011-01-07
   :END:

#+begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("clj" . clojure))
#+end_src

#+begin_src clj
  (map (partial + 1) (range 20))
#+end_src

*** eval query
   :PROPERTIES:
   :DATE:     2010-12-21
   :END:
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate
        (lambda (lang body) (not (equal "ditaa" lang))))
#+end_src

#+name:
| lambda | (lang body) | (not (equal ditaa lang)) |

#+begin_src emacs-lisp :eval query
  (message "eval'd")
#+end_src

#+name:
: eval'd

#+begin_src ditaa
  ---
#+end_src

*** new file handling
   :PROPERTIES:
   :DATE:     2010-12-20
   :END:

#+begin_src sh :sep , :file dirlisting
  ls -l
#+end_src

#+name:
[[file:dirlisting]]

#+begin_src ruby :file ruby-out
  [[1, 2, 3, 4],
   [2, 4, 6, 8]]
#+end_src

#+name:
[[file:ruby-out]]

#+begin_src emacs-lisp :results file :results append
  (let ((today (replace-regexp-in-string "[ \t]" "-" (current-time-string))))
    (with-temp-file today
      (insert (message "I'm feeling %s"
                       (nth (random 3) (list "good" "bad" "just fine")))))
    today)
#+end_src

#+name:
[[file:Mon-Dec-20-17:27:52-2010]]

from http://www.graphviz.org/Gallery/directed/fsm.gv.txt
#+begin_src dot :file fsa.png
  digraph finite_state_machine {
          rankdir=LR;
          size="8,5"
          node [shape = doublecircle]; LR_0 LR_3 LR_4 LR_8;
          node [shape = circle];
          LR_0 -> LR_2 [ label = "SS(B)" ];
          LR_0 -> LR_1 [ label = "SS(S)" ];
          LR_1 -> LR_3 [ label = "S($end)" ];
          LR_2 -> LR_6 [ label = "SS(b)" ];
          LR_2 -> LR_5 [ label = "SS(a)" ];
          LR_2 -> LR_4 [ label = "S(A)" ];
          LR_5 -> LR_7 [ label = "S(b)" ];
          LR_5 -> LR_5 [ label = "S(a)" ];
          LR_6 -> LR_6 [ label = "S(b)" ];
          LR_6 -> LR_5 [ label = "S(a)" ];
          LR_7 -> LR_8 [ label = "S(b)" ];
          LR_7 -> LR_5 [ label = "S(a)" ];
          LR_8 -> LR_6 [ label = "S(b)" ];
          LR_8 -> LR_5 [ label = "S(a)" ];
  }
#+end_src

#+name:
[[file:fsa.png]]

*** utf8 and latin-1 encodings
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
#+tblname: toto
| é |

#+begin_src python :var t=toto :preamble # -*- coding: latin1 -*- :return [len(babel), len(local)]
  babel = unicode (t[0][0],"latin1")
  local = unicode ("é","latin1")
#+end_src

#+name:
| 2 | 2 |

*** tangle templates
   :PROPERTIES:
   :DATE:     2010-12-13
   :END:
#+name: template-heading
#+begin_src emacs-lisp
  some stuff here
#+end_src

#+name: template-footing
#+begin_src emacs-lisp
  some other stuff here
#+end_src

#+name: template
#+begin_src sh :results output :noweb yes :var body="body stuff"
heading=$(cat<<EOF
<<template-heading>>
EOF
)
footing=$(cat<<EOF
<<template-footing>>
EOF
)
echo $heading
echo "$body"
echo $footing
#+end_src

#+call: template[:noweb yes](body="something new")

#+name: template[:noweb yes](body="something new")
: some stuff here
: something new
: some other stuff here

*** missing lines on tangle
   :PROPERTIES:
   :ID:       83eb62fd-4147-405b-bdc2-567b2d5cbd70
   :DATE:     2010-12-13
   :END:
#+begin_src org :results latex :tangle latex-err.tex
  ,one
  ,two
  ,three
#+end_src

#+begin_src org :results latex :results replace
  ,- eric
  ,- schulte
#+end_src

#+name:
#+BEGIN_LaTeX
\begin{itemize}
\item eric
\item schulte
\end{itemize}
#+END_LaTeX

*** Python requires a utf-8 coding prefix
   :PROPERTIES:
   :DATE:     2010-12-02
   :END:
#+begin_src python :prefix # -*- coding: utf-8 -*- :return s
s = "é"
#+end_src

#+name:
: é

#+begin_src python :prefix # -*- coding: utf-8 -*- :results output
s = "é"
print(s)
#+end_src

#+name:
: é

*** empty lines in R session output
   :PROPERTIES:
   :DATE:     2010-12-01
   :END:
#+begin_src R :results output :session
  x <- 1;
  x
  x + 1
  x + 4
#+end_src R

#+name:
: [1] 1
: [1] 2
: [1] 5

*** sql variables
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
#+name: sql-param
| table       | valueTable0       |
| column      | valueColumn0      |
| type        | valueType0        |
| nullability | valueNullability0 |

I want to apply the values onto the following chunk of code:

#+name: add-column-in-table-0
#+begin_src sql :var table=sql-param[0,1] :var column=sql-param[1,1] :var type=sql-param[2,1] :var nullability=sql-param[3,1]
-- add column `@column' (if column does not exist yet)
IF NOT EXISTS (SELECT *
               FROM INFORMATION_SCHEMA.COLUMNS
               WHERE TABLE_NAME = '@table'
               AND COLUMN_NAME = '@column')
BEGIN
    ALTER TABLE $table
    ADD $column $type @nullability
END
#+end_src

*** =:eval query= shows the name
   :PROPERTIES:
   :DATE:     2010-11-30
   :END:
#+name: i-have-a-name
#+begin_src sh :eval query
  date
#+end_src

#+name: i-have-a-name
: Tue Nov 30 22:03:25 MST 2010

*** python with return header argument
   :PROPERTIES:
   :DATE:     2010-11-27
   :END:

#+begin_src python :return y
  x = 8
  y = 98
  2
#+end_src

#+name:
: 98

*** un-named R code blocks
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
#+begin_src R
  8
#+end_src

#+name:
: 8

#+begin_src emacs-lisp :eric
8  
#+end_src

#+name:
: 8

#+BEGIN_SRC R :session :results output
 xyz
#+END_SRC

#+BEGIN_SRC R :session *R-2* :results output |  xyz
9
#+END_SRC

#+name:
: [1] 9

*** safe lists for Haskell
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:

#+tblname: mixed-table
| 1 | first  |
| 2 | second |
| 3 | third  |
| 4 | fourth | 

#+name: rec-string-wrap
#+begin_src emacs-lisp :var data=mixed-table
  (defun rec-string-wrap (in)
    (if (listp in) (mapcar #'rec-string-wrap in) (format "%S" in)))
  (rec-string-wrap data)
#+end_src

#+begin_src haskell :var tbl=rec-string-wrap(data=mixed-table)
  map head tbl
#+end_src

#+name:
| 1 | 2 | 3 | 4 |

*** reading from single-quote-delim languages
   :PROPERTIES:
   :DATE:     2010-11-23
   :END:
#+BEGIN_SRC python
return [['607', 'Show license short, name on the deed'],
        ['255', "'(message (concat 'hello ' 'world))"]]
#+END_SRC

#+name:
| 607 | Show license short, name on the deed |
| 255 | '(message (concat 'hello ' 'world))  |

#+begin_src ruby
  [['607', 'Show license, short name on the deed'],
   ['255', "))'(message (concat 'hello ' 'world"]]
#+end_src

#+name:
| 607 | Show license, short name on the deed |
| 255 | ))'(message (concat 'hello ' 'world  |

#+begin_src haskell
  [["'single quotes'", "b"], ["\"double quotes\"", "d"]]
#+end_src

#+name:
| 'single quotes' | b |
| "double quotes" | d |

*** add column to table with awk
   :PROPERTIES:
   :question_author: Sébastien Vauban
   :DATE:     2010-11-23
   :END:
I want to *add a column* to the following table.

#+name: table-message
| This is line 1 of the message.        |
| This is line 2 of the message.        |
| This is the last line of the message. |

Its value should be dependant on a *regexp matching* the *current row*
(for example, if 1 is detected in the original column, then write "A"
in the new one, "B" if 2 is read, "C" if 3 is read, etc.).

Hence, I'm thinking using AWK as an easy solution.

    #+begin_src note
    I'm open to other ideas on how I could do this as easily. Just throw me
    ideas, if you have some.
    #+end_src

the easiest (for me) would be with the elisp =mapcar= function
#+begin_src emacs-lisp :var tbl=table-message
  (mapcar (lambda (row) (cons "New col" row)) tbl)
#+end_src

#+name:
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

*First* trial: add a column whose cell contents will be *fixed* (here,
equal to =New col=).

#+name: add-col
#+begin_src sh :var data=table-message :results output raw :exports both
echo "$data" | awk '// {print "| New col | " $0 " |";}'
#+end_src

#+name: add-col
| New col | This is line 1 of the message.        |
| New col | This is line 2 of the message.        |
| New col | This is the last line of the message. |

*** lists as data types
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:

#+name: a-list
- org-mode
- and
- babel

#+name: a-list
#+begin_src emacs-lisp :var lst=a-list :results list
  (reverse lst)
#+end_src

also for a block inside of a list
1. First element
2. Second element -- has a block
   #+begin_src emacs-lisp
     (+ 1 1 1 1)
   #+end_src

   #+name:
   : 4

3. third element

*** introducing =wrap= header argument
   :PROPERTIES:
   :DATE:     2010-11-19
   :END:
#+begin_src emacs-lisp :results wrap :exports both
  (mapcar (lambda (el) (list el (+ 1 (* el el)))) (number-sequence 0 10))
#+end_src

#+name:
#+BEGIN_RESULT
|  0 |   1 |
|  1 |   2 |
|  2 |   5 |
|  3 |  10 |
|  4 |  17 |
|  5 |  26 |
|  6 |  37 |
|  7 |  50 |
|  8 |  65 |
|  9 |  82 |
| 10 | 101 |
#+END_RESULT

now indented
- first
- second
  #+begin_src emacs-lisp :results wrap :exports both
    "something else"
  #+end_src

  #+name:
  #+BEGIN_RESULT
  : something else
  #+END_RESULT

*** sqlite
   :PROPERTIES:
   :DATE:     2010-11-10
   :END:
#+begin_src sqlite :db paper/climate.sqlite
  select count(*) from temps;
#+end_src

#+name:
: 422689

*** lob calls with header argument pass through
   :PROPERTIES:
   :DATE:     2010-11-08
   :END:

#+name: lob-header
#+begin_src emacs-lisp :var n=20
  n
#+end_src

#+call: lob-header[:results vector](n=15)

#+name: lob-header[:results vector](n=15)
| 15 |

#+call: lob-header(n=10) :results vector

#+name: lob-header(n=10)
| 10 |

need ob-ref.el to pass through the header arguments in "[]"s
#+begin_src emacs-lisp :var n=lob-header[:results vector](n=8)
  n
#+end_src

#+name:
| 8 |

#+begin_src emacs-lisp :var n=lob-header[:results vector](n=8)[0,0]
  n
#+end_src

#+name:
: 8

*** clojure code blocks and the lazies
   :PROPERTIES:
   :DATE:     2010-11-06
   :END:
#+begin_src emacs-lisp :results silent
  (defun org-babel-execute:clojure (body params)
    (with-temp-buffer
      (insert body)
      (read
       (slime-eval
        `(swank:interactive-eval-region 
          ,(buffer-substring-no-properties (point-min) (point-max)))))))
#+end_src

#+begin_src clojure
  (map (fn [el] (list el (* el el)))(range 10))
#+end_src

#+name:
| 0 |  0 |
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
| 9 | 81 |

*** shell blocks returning a file name
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
#+begin_src sh :file quick.txt :results output
  date
#+end_src

#+name:
[[file:quick.txt]]

*** playing with calc support
   :PROPERTIES:
   :DATE:     2010-11-03
   :END:
#+begin_src emacs-lisp
  (require 'ob-calc)
#+end_src

#+begin_src calc :var some=8
  some
  some
  '*
  8+8
  '+
#+end_src

#+name:
: 80

#+begin_src calc
  2*(8+8)
#+end_src

#+name:
: 32

#+begin_src calc
  2*e
#+end_src

#+name:
: 5.43656365692

#+begin_src calc :var something=9
  2*something
#+end_src

#+name:
: 18

*** passing arguments through call lines
   :PROPERTIES:
   :DATE:     2010-10-29
   :END:

#+name: test
#+begin_src R :session :file test.pdf :var myarg="bla"
  plot(1:10, main=myarg)
#+end_src

#+name: test
[[file:test.pdf]]

#+call: test(myarg="hiho")

#+name: test(myarg="hiho")
: test.pdf

*** simple gnuplot tests
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:
#+name: some-more-gnuplot
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |
| 7 | 49 |
| 8 | 64 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=some-more-gnuplot
  plot "$data"
#+end_src

#+name:

Plotting data points from a table could look like this:
#+tblname: basic-plot
|   x |         y1 |         y2 |
|-----+------------+------------|
| 0.1 |      0.425 |      0.375 |
| 0.2 |     0.3125 |     0.3375 |
| 0.3 | 0.24999993 | 0.28333338 |
| 0.4 |      0.275 |    0.28125 |
| 0.5 |       0.26 |       0.27 |
| 0.6 | 0.25833338 | 0.24999993 |
| 0.7 | 0.24642845 | 0.23928553 |
| 0.8 |    0.23125 |     0.2375 |
| 0.9 | 0.23333323 |  0.2333332 |
|   1 |     0.2225 |       0.22 |

#+begin_src gnuplot :var data=basic-plot :exports code :file basic-plot.png
set title "Putting it All Together"

set xlabel "X"
set xrange [0:1]
set xtics 0,0.1,1

set ylabel "Y"
set yrange [0.2:0.5]
set ytics 0.2,0.05,0.5

plot data u 1:2 w p lw 2 title 'x vs. y1', \
     data u 1:3 w lp lw 1 title 'x vx. y2'
#+end_src

#+name:
[[file:basic-plot.png]]

*** latex headers in latex code blocks
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

#+begin_src latex :headers \usepackage{lmodern} :file name1.pdf
  Eric Schulte
#+end_src

#+name:
[[file:name1.pdf]]

#+begin_src latex :headers '("\\usepackage{mathpazo}" "\\usepackage{fullpage}") :file name2.pdf
  Eric Schulte
#+end_src

#+name:
[[file:name2.pdf]]

*** export-specific header arguments
   :PROPERTIES:
   :DATE:     2010-10-26
   :END:

#+headers: :var out=(if (and (boundp 'latexp) latexp) "latex" "not latex") 
#+begin_src emacs-lisp
  out
#+end_src

#+name:
: not latex

*** security problem with elisp in header arguments
   :PROPERTIES:
   :DATE:     2010-10-14
   :END:
#+begin_src emacs-lisp :var data=(setq org-confirm-babel-evaluate nil) :results silent
  (+ 1 1)
#+end_src

*** weaving with noweb links
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-10-13
   :END:

#+name: name
#+begin_src emacs-lisp
  (message "eric")
#+end_src

#+begin_src emacs-lisp :noweb tangle
  ;; name
  <<name>>
#+end_src

*** very very large numbers
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+tblname: numbers
|                           1 |
|                           2 |
|                          12 |
|                          45 |
|                         166 |
|                    12567890 |
| 231231282371983279389999999 |

#+begin_src emacs-lisp :var numbers=numbers
  (mapcar
   (lambda (line)
       (let ((number (car line)))
         (list number (type-of number))))
     numbers)
#+end_src

#+name:
|                      1 | integer |
|                      2 | integer |
|                     12 | integer |
|                     45 | integer |
|                    166 | integer |
|               12567890 | integer |
| 2.3123128237198328e+26 | float   |

*** preceding blank lines on tangle
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+begin_src emacs-lisp :results silent
  (setq org-babel-tangle-pad-newline nil)
#+end_src

#+begin_src sh :tangle something.reg
  # something
  echo "else"
#+end_src

*** index into a scalar
   :PROPERTIES:
   :DATE:     2010-10-13
   :END:
#+tblname: short-list
| a |
| b |

#+begin_src emacs-lisp :var scalar=short-list[0,0]
  scalar
#+end_src

#+name:
: a

*** cycle -- the input is the output
   :PROPERTIES:
   :DATE:     2010-09-29
   :END:
and the rhythm is the base and the base is the treble

#+name: cycle
| one   |
| two   |
| three |

#+name: cycle
#+begin_src emacs-lisp :var table=cycle
  (append (last table) (butlast table))
#+end_src

#+begin_src emacs-lisp :exports results
  (+ 1 1 1)
#+end_src

*** Letter
   :PROPERTIES:
   :DATE:     2010-09-21
   :END:

#+name: body
#+begin_src org :results latex
  ,My body includes a list:
  
  ,- one
  ,- two
  
  ,and a small table:
  
  ,| first | second |
  ,| other | last   |
  
  ,Not more.
#+end_src

#+begin_src latex :noweb yes :tangle yes
\documentclass[11pt]{isodoc}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

\setupdocument{
    to = {Eric},
    subject = {Tough to understand what to do...},
    opening = {Hi},
    closing = {Best}
}

\begin{document}
\letter{%
<<body()>>
}
\end{document}
#+end_src

*** splitting code blocks
   :PROPERTIES:
   :DATE:     2010-09-19
   :END:
- with indentation
  #+begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-previous-src-block (&optional arg)
      "Jump to the previous source block.
    With optional prefix argument ARG, jump backward ARG many source blocks."
      (interactive "P")
      (condition-case nil
          (re-search-backward org-babel-src-block-regexp nil nil (or arg 1))
        (error (error "No previous code blocks")))
      (goto-char (match-beginning 0)) (org-show-context))
  #+end_src
  
  #+begin_src emacs-lisp
    ;;;###autoload
    (defun org-babel-split-block-maybe (&optional arg)
      "Split the current source code block on the cursor."
      (interactive "p")
      ((lambda (info)
         (if info
             (let ((lang (nth 0 info))
                   (indent (nth 6 info))
                   (stars (make-string (org-current-level) ?*)))
               (insert (concat (if (looking-at "^") "" "\n")
                               (make-string indent ? ) "#+end_src\n"
                               (if arg stars (make-string indent ? )) "\n"
                               (make-string indent ? ) "#+begin_src " lang
                               (if (looking-at "[\n\r]") "" "\n  "))))
           (message "Not in src block.")))
       (org-babel-get-src-block-info)))
    
    ;; other stuff
  #+end_src

*** header arguments on call line
   :PROPERTIES:
   :DATE:     2010-09-09
   :END:
#+name: eight
#+begin_src R
  8
#+end_src

#+call: eight() :results vector

#+name: eight()
| 8 |

maybe the following with the new proposed header arguments

#+call: eight[:session *R*]() :results vector

*** empty-string results
   :PROPERTIES:
   :DATE:     2010-09-08
   :END:
test me one two 3

#+begin_src emacs-lisp
#+end_src

More test

#+begin_src emacs-lisp
  (mapcar
   (lambda (pair)
     (list (car pair) (cdr pair)))
   params)
#+end_src

#+name:
| :cache    | no      |
| :colnames | no      |
| :comments |         |
| :exports  | code    |
| :hlines   | yes     |
| :noweb    | no      |
| :results  | replace |
| :session  | none    |
| :shebang  |         |
| :tangle   | no      |

*** tangle org-mode block
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+name: org-list
#+begin_src org :results latex
  - one
  - two
  - three
#+end_src

#+begin_src emacs-lisp :tangle example.tangled :noweb yes
  "
  <<org-list()>>
  "
#+end_src

*** remove results when nil is returned
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+begin_src emacs-lisp
  (progn (+ 1 1) nil)
#+end_src

#+name:

*** comparative speed of python evaluation
   :PROPERTIES:
   :DATE:     2010-09-07
   :END:
#+begin_src python :session test
  2+2
#+end_src

#+name:
: 4

#+begin_src python
  return 2+2
#+end_src

#+name:
: 4

#+begin_src python :session test
def add(a,b):
   return a+b
def sub(a,b):
   return a-b
add(sub(10,1),sub(10,2))
#+end_src

#+name:
: org_babel_python_eoe

*** customizable comment formats
   :PROPERTIES:
   :tangle:   yes
   :comments: yes
   :DATE:     2010-09-05
   :END:

#+begin_src emacs-lisp :results silent
  (setq org-babel-tangle-comment-format-beg "{-# LINE %start-line \"%file\" #-}"
        org-babel-tangle-comment-format-end ""
        org-babel-tangle-pad-newline)
#+end_src

#+begin_src haskell :tangle Main.hs
  test = length
  main = print $ test [1,2,3]
#+end_src

I would like the following output in the tangled file Main.hs:

: {-# LINE 4 "Haskell.org" #-}
: test = length
: main = print $ test [1,2,3]

*** tangling with full comments
   :PROPERTIES:
   :comments: org
   :tangle:   full-comments.el
   :DATE:     2010-09-04
   :END:
The top block
#+begin_src emacs-lisp
  (message "first block")
#+end_src

here's some text which won't be tangled

**** subheading
    :PROPERTIES:
    :DATE:     2010-09-04
    :END:
another block
| 1 | first  |
| 2 | second |
#+begin_src emacs-lisp
  (message "second")
#+end_src

and finally a block with a =:noweb= header argument
#+begin_src emacs-lisp :noweb yes
  (progn
    <<tangle-el-the-second>>)
#+end_src

*** :var (buffer-file-name)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
during export (buffer-file-name) will return nil because the temporary
export buffer is not visiting any file.

/file=(vc-working-revision (buffer-file-name))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) "")) :exports results
  echo $file Revision
#+end_src

/file=(vc-working-revision (or (buffer-file-name) org-current-export-file))/
#+begin_src sh :var file=(vc-working-revision (or (buffer-file-name) org-current-export-file)) :exports results
  echo $file Revision
#+end_src

*** quoting header args (e.g. :cmdline)
   :PROPERTIES:
   :DATE:     2010-09-03
   :END:
#+begin_src C :cmdline 1 2 3 4 5 :includes <stdio.h>
  int main(int argc, char **argv){
    printf("argv[1] %s\n", argv[1]);
    return 0;
  }
#+end_src

#+name:
: argv[1] 1

*** :session evaluation on export
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
This first block is evaluated but /doesn't/ appear in export.

/:session *R* :exports none/
#+begin_src R :session *R* :exports none
  x <- 8
#+end_src

This second block /does/ appear in export.

#+begin_src R :session *R* :exports results
  x
#+end_src

*** ditaa with tilda in path
   :PROPERTIES:
   :DATE:     2010-09-01
   :END:
#+begin_src ditaa :file example.png
    +--------------+
    |              |
    |              |
    |              |
    |              |
    |              |
    +--------------+
#+end_src

*** scheme sessions
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
#+begin_src scheme :var number=9 :session *scheme* :scheme guile
  (+ number 0)
#+end_src

#+name:
: 9

#+begin_src scheme :var number=9 :session *scheme* :scheme racket
  (+ number 1)
#+end_src

#+name:
: 10

*** conditional tangling
   :PROPERTIES:
   :DATE:     2010-08-31
   :END:
#+begin_src emacs-lisp :results silent
  (setq tangle-tag "right")
#+end_src

**** first subheading						       :left:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "first"
#+end_src

**** second subheading						      :right:
    :PROPERTIES:
    :DATE:     2010-08-31
    :END:
#+begin_src R :tangle (and (equal (car (org-get-tags-at (point))) tangle-tag) "yes")
  "second"
#+end_src

*** pulling information from tags				       :blue:
   :PROPERTIES:
   :DATE:     2010-08-30
   :END:

#+begin_src R :var color=(car (org-get-tags-at (point))) :tangle example.R
  color
#+end_src

#+name:
: blue

*** initial scheme support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
#+name: numbers
#+begin_src scheme
  (map (lambda (el) (+ el 1)) '(1 2 3))
#+end_src

#+name:
| 2 | 3 | 4 |

#+begin_src scheme :var numbers=numbers
  (map (lambda (el) (- el 1)) numbers)
#+end_src

#+name:
| 1 | 2 | 3 |

*** initial javascript support
   :PROPERTIES:
   :DATE:     2010-08-27
   :END:
using node.js

#+begin_src js
  var n = 0;
  n = n+1;
  return n
#+end_src

#+name:
: 1

#+name: cars
#+begin_src js
  var cars = ["Saab","Volvo","BMW"];
  return cars;
#+end_src

#+name: cars
| Saab | Volvo | BMW |

#+begin_src js :var cars=cars
  return cars[0][0];
#+end_src

#+name:
: Saab

#+begin_src js :var cars=cars
  return cars[0].length;
#+end_src

#+name:
: 3

*** wrapping up raw/org results
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
#+begin_src emacs-lisp :results org :exports results
  "- first
  - second
  - third
  "
#+end_src

#+name:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

*** trying out plantuml
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
setup
#+begin_src emacs-lisp :results silent
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path "~/src/org/contrib/scripts/plantuml.jar")
#+end_src

usage -- sequence diagram
#+begin_src plantuml :file tryout.png
  Alice -> Bob: synchronous call
  Alice ->> Bob: asynchronous call
#+end_src

#+name:
[[file:tryout.png]]

*** eval for side effect on export
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
- one plus one
  #+name: one-plus-one
  #+begin_src emacs-lisp :exports none :results silent
    (+ 1 1)
  #+end_src
- plus one is
  #+begin_src emacs-lisp :var two=one-plus-one :exports both
    (+ 1 two)
  #+end_src

*** eval and noeval
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
date, should export both, but won't output results because of presence
of the =:noeval= header argument.
#+begin_src sh :noeval :exports both
  date
#+end_src

should export code, so no need to do anything
#+begin_src sh
  date
#+end_src

should export nothing, and should not query
#+name: this-is-ls
#+begin_src sh :eval query :exports code
  date
#+end_src

should export results, and should trigger query above
#+begin_src emacs-lisp :var ls=this-is-ls :exports results
  ls
#+end_src

*** duplicate results on execute subtree
   :PROPERTIES:
   :DATE:     2010-08-26
   :END:
#+begin_src emacs-lisp :results org :exports results
  "- first
- second
- third
"
#+end_src

#+name:
#+BEGIN_SRC org
- first
- second
- third
#+END_SRC

*** issues with shell evaluation
   :PROPERTIES:
   :DATE:     2010-08-25
   :END:
#+begin_src sh :results silent
  cd ~/src/org/
  make
#+end_src

*** org results and replace
   :PROPERTIES:
   :DATE:     2010-08-18
   :END:

#+begin_src emacs-lisp :results org
  "| 1 | 2 |
| 2 | 3 |"
#+end_src

#+name:
| 1 | 2 |
| 2 | 3 |

#+begin_src R
  rnorm(1)
#+end_src

#+begin_src R
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+name:
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

#+begin_src R :colnames yes
  numbers <- matrix(c(51,43,22,92,28,21,68,22,9),ncol=3,byrow=TRUE)
  numbers
#+end_src

#+name:
| V1 | V2 | V3 |
|----+----+----|
| 51 | 43 | 22 |
| 92 | 28 | 21 |
| 68 | 22 |  9 |

*** ledger example output text
   :PROPERTIES:
   :DATE:     2010-08-13
   :END:
#+name: ledger-stuff
#+begin_example
09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src sh :var stuff=ledger-stuff
  echo "$stuff"
#+end_src

*** tangle R and load
  :PROPERTIES:
  :tangle:   to-load.r
  :DATE:     2010-08-12
  :END:

evaluate this
#+begin_src emacs-lisp :results silent :tangle no
  (setq org-babel-post-tangle-hook nil)
  (add-hook 'org-babel-post-tangle-hook
            (lambda () (ess-load-file (buffer-file-name))))
#+end_src

then tangle

#+begin_src R :comments yes
x <- 10
#+end_src

#+begin_src R
 y <- 9
#+end_src

#+begin_src R :tangle file2.R
 y <- 9
#+end_src

*** lob -- writing results out to files
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
#+name: table
#+begin_src emacs-lisp
  (mapcar
   (lambda (el) (number-sequence el (+ el 3)))
   (number-sequence 0 4))
#+end_src

writes the results out as csv file
#+call: write(data=table, file="~/Desktop/example.csv") :results silent

writes the results out as tab separated file
#+call: write(data=table, file="~/Desktop/example.tsv") :results silent

write the results out as a normal org-mode file
#+call: write(data=table, file="~/Desktop/example.org") :results silent

*** lisp
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

#+begin_src lisp :var n=5
  (mapcar (lambda (el) (* el el)) (append '(1 7 3 4) (list n)))
#+end_src

#+name:
| 1 | 49 | 9 | 16 | 25 |

#+name: short-list
| 1 |
| 2 |
| 3 |

#+begin_src lisp :var lst=short-list :session t
  (+ 1 (length lst))
#+end_src

#+name:
: 4

*** importing the output of ledger
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:
#+name: ledger-output
#+begin_example 
  09-Aug-21 CHEQUE : 9953055                    Expenses:Unknown                                    166.70 EUR            166.70 EUR
  09-Sep-17 CHEQUE : 7691785                    Expenses:Unknown                                    100.00 EUR            266.70 EUR
  09-Oct-16 REMISE CHEQUE N 8686318 001 105     Expenses:Unknown                                   -525.00 EUR           -258.30 EUR
#+end_example

#+begin_src emacs-lisp :var ledger=ledger-output
  (with-temp-buffer
    (insert ledger)
    (message ledger)
    (org-table-convert-region (point-min) (point-max) 2)
    (org-table-to-lisp))
#+end_src

#+name:
| 09-Aug-21 CHEQUE : 9953055                | Expenses:Unknown | 166.70 EUR  | 166.70 EUR  |
| 09-Sep-17 CHEQUE : 7691785                | Expenses:Unknown | 100.00 EUR  | 266.70 EUR  |
| 09-Oct-16 REMISE CHEQUE N 8686318 001 105 | Expenses:Unknown | -525.00 EUR | -258.30 EUR |

*** comments in R blocks
   :PROPERTIES:
   :DATE:     2010-08-12
   :END:

#+begin_src R :session *R* :results output
  # this is a comment
  x <- rnorm(1)
  # this is another comment
  x
#+end_src

#+name:
: 
: [1] 1.320853

*** colnames to specific variables
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

#+tblname: spec-colnames
| one | two | thee |
|-----+-----+------|
| 1   | 2   | 3    |

#+tblname: nospec-colnames
| three | two | one |
|-------+-----+-----|
|     3 |   2 |   1 |

#+begin_src python :var nospec=nospec-colnames :var spec=spec-colnames :colnames '(spec)
  return nospec
#+end_src

#+name:
| one   | two | thee |
|-------+-----+------|
| three | two | one  |
| 3     | 2   | 1    |

*** caption on code block
   :PROPERTIES:
   :DATE:     2010-07-22
   :END:

#+caption: Examples of variable declaration.
#+label: sql-block
#+begin_src sql
SELECT 6*9;
#+end_src

*** palendromic primes
   :PROPERTIES:
   :DATE:     2010-07-20
   :END:
Note that because Haskell is funny about what can be typed into the
interpreter, the following should be loaded with
=org-babel-load-in-session=.
#+begin_src haskell
  palendromic_primes = [x | x <- [1..], prime x, palendrome x]
      where
        factors n = [x | x <- [1..floor(sqrt(fromIntegral(n)))], n `mod` x == 0]
        prime n = factors n == [1]
        primes = [x | x <- [2..], prime x]
        palendrome n = show(n) == reverse(show(n))
  
  palendromic_prime_distances = map (\(x,y)-> y-x) neighbors
      where
        neighbors = (zip palendromic_primes (tail palendromic_primes))
#+end_src

#+name: palendromic_prime_distances
#+begin_src haskell
  take 180 (zip [1..] palendromic_prime_distances)
#+end_src

For high-quality png output from gnuplot, the following sequence of
graphing to a =.eps= file, and then converting to a =.png= can be
useful.
#+name: dist-graph
#+begin_src gnuplot :var data=palendromic_prime_distances :file pps.eps
  set term postscript landscape color enhanced
  set log y
  set title "distance between consecutive palendromic primes"
  plot "$data" with fs notitle
#+end_src

The =convert= command is part of the [[http://www.imagemagick.org/script/index.php][imagemagick]] suite.
#+begin_src sh :var input=dist-graph :results file
  convert -depth 300 -rotate 90 $input pps.png
  echo "pps.png"
#+end_src

*** input from an example block
   :PROPERTIES:
   :DATE:     2010-07-13
   :END:
#+name: lorem
#+begin_example 
  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
  eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
  enimad minim veniam, quis nostrud exercitation ullamco laboris nisi
  ut aliquip ex ea commodo consequat. Duis aute irure dolor in
  reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
  pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
  culpa qui officia deserunt mollit anim id est laborum.
#+end_example

#+begin_src emacs-lisp :var lorem=lorem
  (message "%d words in Lorem" (length (split-string lorem)))
#+end_src

#+name:
: 68 words in Lorem

#+name: 1D
| 1 |
| 2 |
| 3 |
| 4 |

#+begin_src emacs-lisp :var lst=1D[:,0]
  lst
#+end_src

#+name:
: 1

*** example w/o source name
   :PROPERTIES:
   :DATE:     2010-07-12
   :END:

delete emacs-lisp below for errors
#+begin_src emacs-lisp
  (* (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1) (+ 1 1 1))
#+end_src

*** tangle R and load
   :PROPERTIES:
   :tangle:   with-comments.r
   :comments: yes
   :DATE:     2010-07-09
   :END:

#+begin_src R :tangle no
  z <- 0
#+end_src

#+begin_src R
  x <- 8
#+end_src

#+begin_src R
  y <- 9
#+end_src

#+name: i-have-a-name
#+begin_src R 
  x+y+z
#+end_src

*** export blocks w/o languages
   :PROPERTIES:
   :DATE:     2010-07-09
   :END:
should raise an error

source
#+begin_src emacs-lisp
  ;; this is a comment
  (+ 1 1 1)
#+end_src

broken source
#+begin_src 
  (+ 2 2 2)
#+end_src

example
#+begin_example 
  this is exampled
#+end_example

#+begin_src ruby
  # this is the first
  [1, 2, 3, 4, 5].map{|r| r+1}
#+end_src

*** scratch
   :PROPERTIES:
   :DATE:     2010-07-08
   :END:

#+begin_src emacs-lisp :exports results
  (+ 1 1 1 1)
  (setq org-export-babel-evaluate t)
#+end_src

and now for src_emacs-lisp{87} an inline block

looking at paths
#+begin_src emacs-lisp
  (buffer-file-name)
#+end_src

*** Tom found a bug
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:

#+begin_src emacs-lisp :tangle something.el
  (list 1 (+ 2 3))
#+end_src

#+name:
| 1 | 5 |

*** dot
   :PROPERTIES:
   :DATE:     2010-07-06
   :END:
#+begin_src dot :file models.png :cmdline -Tpng
  digraph data_relationships {
    "data_requirement" [shape=Mrecord, label="{DataRequirement|description\lformat\l}"]
    "data_product" [shape=Mrecord, label="{DataProduct|name\lversion\lpoc\lformat\l}"]
    "data_requirement" -> "data_product"
  }
#+end_src

#+name:
[[file:models.png]]

*** python errors
   :PROPERTIES:
   :DATE:     2010-07-04
   :END:
#+begin_src python :session :results value
  [1, [2], 3, 4]
#+end_src

#+name:
| 1 | (2) | 3 | 4 |

#+begin_src ruby :results output :session
  [1, 2, 3, 4, 6].map{|n| puts n}
#+end_src

#+name:
: 1
: 2
: 3
: 4
: 6

#+begin_src python :session :results output
  print 9
#+end_src

#+name: R-with-colnames
| one |
|-----|
| 1   |

#+begin_src R :results output
  "something"
#+end_src

#+name:
: [1] "something"

#+begin_src R :session *R* :results output
  1
  2
  3
  4
#+end_src

#+name:
: [1] 1
: [1] 2
: [1] 3
: [1] 4

#+begin_src perl :results output
  print "8\n";
  print "9\n";
#+end_src

#+name:
: 8
: 9

#+begin_src clojure
  (+ 8 7)
#+end_src

#+name:
: 15

#+begin_src clojure :session *clj*
  (println "eric")
#+end_src

#+name:
: nil

#+begin_src perl :results value
  8
#+end_src

#+name:
: 8

#+begin_src c++ :includes '(<stdio.h> <math.h> <cstdlib> <time.h>)
  printf("eric schulte\n");
#+end_src

#+name:
: eric schulte

#+begin_src sh
  echo 78
#+end_src

#+name:
: 78

*** table comment issue
   :PROPERTIES:
   :DATE:     2010-06-30
   :END:
#+BEGIN_changemargin {-4.2cm}{0cm}
  #+TBLNAME: AutresFPNVE
  #+ATTR_LaTeX: align=lrrrrr
  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  |   | Total                                    |                      |                 |                |            |    1062.02 |
  | ^ |                                          |                      |                 |                |            |      Total |
  #+tblfm: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+END_changemargin

save me!

#+begin_src org
  ,  #+TBLNAME: AutresFPNVE
  ,  #+ATTR_LaTeX: align=lrrrrr
  ,  |   |                                          | Montant total (\EUR) | Taux amort (\%) | Part pro. (\%) | Déduc (\%) | NVE (\EUR) |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Documentation et formation               |                51.05 |                 |                |            |       0.00 |
  ,  |   | Communications GSM                       |               831.16 |             100 |             25 |        100 |     207.79 |
  ,  |   | Internet (Dommel)                        |               167.88 |             100 |             33 |        100 |      55.40 |
  ,  |   | Fournitures à amortir (ordinateur + GSM) |               762.51 |              33 |             80 |        100 |     201.30 |
  ,  |   | Restaurant                               |               304.70 |             100 |            100 |         69 |     210.24 |
  ,  |---+------------------------------------------+----------------------+-----------------+----------------+------------+------------|
  ,  |   | Total                                    |                      |                 |                |            |    1062.02 |
  ,  | ^ |                                          |                      |                 |                |            |      Total |
  ,  #+TBLFM: $7=$3*$4*$5*$6/1000000;%.2f::@2$3=51.05::@3$3=9.00+184.88+51.22+201.82+45.67+69.03+62.93+54.16+38.87+39.77+36.35+37.46::@4$3=12*13.99::@6$3=146.50+158.20;%.2f::@7$7=vsum(@-I..@-II);%.2f
#+end_src

#+begin_example 
#+tblname: example
| 1 | 2 |
#+end_example

*** latex literals in export
    :PROPERTIES:
    :DATE:     2010-06-30
    :END:

   #+ATTR_LaTeX: width=\textwidth
   [[./composite-pattern.png]]

*** captions
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:

#+caption: I'm not removed from export
#+label: also-not-removed
| A | B |
| 1 | 2 |

*** booktabs
   :PROPERTIES:
   :DATE:     2010-06-29
   :END:
#+tblname: months
| num | Abbrev. |
|-----+---------|
|   1 | Jan.    |
|   2 | Feb.    |
|   3 | Mar.    |

#+call: booktabs(table=months, align="r|l") :results latex :exports results

*** table-label
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
#+label: bam
| 1 |
| 2 |
| 3 |

*** haskell issues
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:

#+begin_src haskell
  length [1, 2]
#+end_src

#+name:
: 2

#+tblname: example-4-haskell
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |

#+begin_src haskell :var this=example-4-haskell
  length this
#+end_src

#+name:
: 7

*** complex
   :PROPERTIES:
   :DATE:     2010-06-28
   :END:
#+name: raw-data
#+begin_src sh :results scalar
  wget --quiet -qO- "http://ogdi.cloudapp.net/v1/dc/RecreationParks?format=json"
#+end_src

#+name: dc-parks
#+begin_src emacs-lisp :var keys='(ward area) :var data=raw-data
  (mapcar
    (lambda (lis) (mapcar (lambda (key) (cdr (assoc key lis))) keys))
    (cdr (car (with-temp-buffer
                (insert data) (goto-char (point-min))
                (json-read)))))
#+end_src

#+name: dc-parks-metric
#+begin_src ruby :var data=dc-parks
  data.map{|f| [f[0], 2.59 * f[1]]}
#+end_src

#+begin_src R :var parkData=dc-parks-metric :file parks.png :session *R*
  plot(parkData)
  title(main="Park size by Ward")
#+end_src

#+name:
[[file:parks.png]]

*** possible prefixes
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

| prefix   | remaining characters |
|----------+----------------------|
| ob-      |                    5 |
| org-b-   |                    2 |
| orgb-    |                    3 |
| org-bbl- |                    0 |
| bbl-     |                    4 |
| babel-   |                    2 |
#+TBLFM: $2='(sbe leftover (prefix $$1))

#+name: leftover
#+begin_src emacs-lisp :var prefix=""
  (-
   ;; length w/o .el
   (- 13 (length ".el"))
   ;; length of prefix
   (length prefix))
#+end_src

*** hlines in python
   :PROPERTIES:
   :DATE:     2010-06-26
   :END:

#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+name: echo-table
#+begin_src python :var tab=many-cols :hlines yes :exports both :session
  return tab
#+end_src

#+begin_src emacs-lisp :var table=echo-table :exports none
  (butlast (apply #'append (mapcar (lambda (el) (list el 'hline)) table)))
#+end_src

#+call: echo-table(tab=many-cols)

#+begin_src python :exports results
  return [['foo', 'bar', 'baz'], ["a", "b", "None of the above"], ['1', 2, 3]]
#+end_src

#+begin_src emacs-lisp :exports results
  (message "Exist")
#+end_src

*** protecting block bodies
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
neither of these work as expected

#+begin_src org
  ,#+TITLE: stuff
  
  ,#+begin_src emacs-lisp
  ,  (message "something")
  ,#+end_src
  
  ,more stuffs
  
  ,#+resname: something
  ,: value
  
  ,# and a comment
#+end_src

#+begin_src org
  ,* example org
  
  ,# this is a comment
  ,this is not a comment
#+end_src


#+begin_src org
  ,* escaped org-mode markup
  
  ,this should be exported as is
  ,#+results: escaping-example
  ,: 24
#+end_src


#+begin_html 
<pre>
#comment
#+end_src
</pre>
#+end_html
final

*** multiple evals for refs
   :PROPERTIES:
   :DATE:     2010-06-25
   :END:
#+begin_src emacs-lisp
  (setq counter 0)
#+end_src

#+name:
: 0

#+name: counter
#+begin_src emacs-lisp
  (setq counter (+ 1 counter))
  counter
#+end_src

#+begin_src emacs-lisp :var counter_val=counter
  counter_val
#+end_src

#+name:
: 3

*** tangling
   :PROPERTIES:
   :DATE:     2010-06-17
   :END:

#+begin_src sh :shebang #!/bin/sh :tangle yes
  date
#+end_src

#+begin_src sh :shebang #!/bin/bash :tangle whoisme :exports both
  echo $USER
#+end_src

#+begin_src emacs-lisp :tangle yes :comments yes
  (message "BAM")
#+end_src

#+begin_src fortran :exports both
  1+8
#+end_src

*** foo org
   :PROPERTIES:
   :session:  *R*
   :DATE:     2010-06-16
   :END:
Figure \ref{fig:one} (p. \pageref{fig:one}) is produced by the following code
#+BEGIN_SRC R 
plot(x, y)
abline(out1)
#+END_SRC
Note that =x=, =y=, and =out1= are remembered from the preceding code
chunk.  We don't have to regenerate them.  All code chunks are part of
one R "session".
and more stuff here and then the results
#+attr_latex: width=0.8\textwidth,placement=[p]
#+label: fig:one
#+caption: Scatter Plot with Regression Line
[[file:fig1.pdf]]

*** comments not commented
   :PROPERTIES:
   :DATE:     2010-06-16
   :END:

# $some stuff
# some more stuff$ -- I should be a comment line

1) a source block inside of an =enumerate=
   #+name: plotxy
   #+begin_src emacs-lisp :exports results
     (message "I think so")
   #+end_src
   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src
   

   can cause problems

2) how about this one...

*** don't eat me!
   :PROPERTIES:
   :DATE:     2010-06-15
   :END:
1) a source block inside of an =enumerate=
   #+begin_src emacs-lisp :exports results
     (list (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry")
           (list "I'm hungry" "I'm hungry"))
   #+end_src

   #+name:
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |
   | I'm hungry | I'm hungry |

   #+begin_src emacs-lisp
     (message "don't eat me")
   #+end_src

   can cause problems

2) source blocks should be able to be on adjacent lines

*** simple reference
   :PROPERTIES:
   :DATE:     2010-06-13
   :END:
#+tblname: table-the-first
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

#+begin_src emacs-lisp :var data=table-the-first[1,1]
  data
#+end_src

#+name:
: 5

*** exporting with call lines
   :PROPERTIES:
   :DATE:     2010-06-11
   :END:
#+name: rpn-to-alg(alg)
#+begin_src clojure :results output :var alg="00+"
  (def binary-operators '(\+ \- \* \/))
  (def unary-operators '(\s))
  (defn rpn-to-alg [chars stack]
    (if (> (.size chars) 0)
      (let [el (first chars)]
        (if (some #{el} binary-operators)
          (rpn-to-alg (rest chars)
                      (cons
                       (apply str "(" (or (second stack) 1) " " el " " (or (first stack) 1) ")")
                       (rest (rest stack))))
          (if (some #{el} unary-operators)
            (rpn-to-alg (rest chars)
                        (cons
                         (apply str "(" el " " (or (first stack) 1) ")")
                         (rest (rest stack))))
            (rpn-to-alg (rest chars) (cons el stack)))))
      (first stack)))
  (println (apply str (rpn-to-alg (seq alg) '())))
#+end_src

#+name: distributed-best
: 73*x11/+4/++51xxx13*y/++6y5*6/6-+xx+*

#+call: rpn-to-alg(alg=distributed-best)
 
*** can't open indented results
    :PROPERTIES:
    :DATE:     2010-06-11
    :END:

    #+begin_src latex :packages '(("" "tikz") ("active,tightpage" "preview")) :file recursion.pdf
      \begin{preview}
      \ovalbox{
      \begin{tikzpicture}
      \node{$n$}
       	child {
          node{$\left(\frac{n}{2}\right)^2$}
            child{
              node{$\left(\frac{n}{4}\right)^2$}
              node{$\left(\frac{n}{4}\right)^2$}
            }
          }
       	child{
          node{$\left(\frac{n}{2}\right)^2$}
          child{
            node{$\left(\frac{n}{4}\right)^2$}
            node{$\left(\frac{n}{4}\right)^2$}
          }
       	};
      \end{tikzpicture}
      }
      \end{preview}
    #+end_src

    #+name:
    [[file:recursion.pdf]]

*** indented source-code blocks and indented results
    :PROPERTIES:
    :DATE:     2010-06-10
    :END:

     #+name: time
     #+begin_src emacs-lisp :results append
       ;; (list (list (current-time-string)))
       (current-time-string)
     #+end_src

     #+name: time
     | 1 | 2 | 3 |


         #+call: time() :results prepend

         #+name: time()
         | 1 | 2 | 3 |
         : Thu Jun 10 14:13:21 2010
         : Thu Jun 10 14:13:21 2010
         : : Thu Jun 10 14:13:21 2010
         : : Thu Jun 10 14:13:21 2010
         : : Thu Jun 10 14:13:21 2010
         : nil
         : nil
         : Thu Jun 10 14:11:22 2010
         : Thu Jun 10 14:11:20 2010
         : nil
         : nil
         : Thu Jun 10 14:06:04 2010
         : Thu Jun 10 14:06:03 2010
         : Thu Jun 10 14:05:51 2010
         : Thu Jun 10 14:05:57 2010
         : Thu Jun 10 14:06:00 2010

*** not expand inlines in examples
   :PROPERTIES:
   :DATE:     2010-06-08
   :END:

: src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

src_emacs-lisp{(+ 1 2 3)}

#+begin_example 
  src_emacs-lisp{(+ 1 2 3)}
#+end_example

*** updating results "in-situ"
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+name: in-situ
: update me in place please -- Mon Jun  7 16:44:44 2010
: update me in place please -- Mon Jun  7 16:44:43 2010
: update me in place please -- Mon Jun  7 16:44:42 2010
: update me in place please -- Mon Jun  7 16:44:37 2010
: update me in place please -- Mon Jun  7 16:42:14 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:44:59 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:00 2010
: update me in place please (at the bottom) -- Mon Jun  7 16:45:02 2010

the results should be *above* the block

#+name: in-situ
#+begin_src emacs-lisp :results prepend
  (format "update me in place please -- %s"
          (current-time-string))
#+end_src

#+name: in-situ
#+begin_src emacs-lisp :results append
  (format "update me in place please (at the bottom) -- %s"
          (current-time-string))
#+end_src

*** unwind-protect with narrowing
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

I'm not in the subtree

**** I'm in the subtree
    :PROPERTIES:
    :DATE:     2010-06-07
    :END:
#+begin_src emacs-lisp
  (+ 6 "I'm not a number!!")
#+end_src

*** stripping existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
#+name: trickily-located-somehwere-else
: I shouldn't be exported

Neither of the result strings for the following two code blocks should
be included in the export.  And only one of the bodies should be
included...

#+begin_src emacs-lisp :exports code
  (+ 1 1 1 1)
#+end_src

#+name:
: don't include me in the export!!!!!!!

#+name: trickily-located-somehwere-else
#+begin_src emacs-lisp :exports none
  (message "I shouldn't be exported")
#+end_src

*** non-empty comint prompt
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src ruby :session eric
  8 + 9
#+end_src

*** inhibiting evaluation on export
   :PROPERTIES:
   :noeval:   don't do it
   :DATE:     2010-06-07
   :END:

#+begin_src clojure :session eric :exports none
  (+ 1 1 1 1)
  (error)
#+end_src

*** indented source names
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

   #+name: i-am-indented
   #+begin_src emacs-lisp 
     (message "i am indented")
   #+end_src

#+name: i-am-indented
: i am indented

#+begin_src emacs-lisp :var output=i-am-indented
  (length output)
#+end_src

#+name:
: 13

  #+name:
  : eric

*** export with existing results
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src emacs-lisp :exports none :results silent
  '((1 2) (3 4))
#+end_src

#+name:
| 1 | 2 |
| 3 | 4 |

#+begin_src ditaa :file /tmp/eric.png :exports none :results silent
    +---------------+
    |               |
    |               |
    |               |     +-----------------+
    |    Eric       |     |                 |
    |               |     |    Schulte      |
    |               |     |                 |
    |               |     +-----------------+
    +---------------+
#+end_src

#+name:
[[file:/tmp/eric.png]]

*** executing emacs-lisp on export
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:

#+begin_src emacs-lisp
  (error "eric")
#+end_src

*** commas on tangling test
   :PROPERTIES:
   :DATE:     2010-06-07
   :END:
test comma protection on tangling

#+begin_src emacs-lisp :results silent
  (org-babel-add-interpreter "org")
  (add-to-list 'org-babel-tangle-langs '("org" "org"))
#+end_src

#+begin_src org :tangle commas.org
  ,* org-mode
  ,  :PROPERTIES:
  ,  :CUSTOM_ID: comma-protect
  ,  :END:
  
  ,#+begin_src emacs-lisp
  ,  protected?
  ,#+end_src
#+end_src

#+begin_example 
  ,* this should be
  # commented out
  
  and maybe not this...
#+end_example

*** simple table
   :PROPERTIES:
   :DATE:     2010-06-06
   :END:
#+begin_src emacs-lisp
  '((1 2 3) (4 5 6) (7 8 900))
#+end_src

#+name:
| 1 | 2 |   3 |
| 4 | 5 |   6 |
| 7 | 8 | 900 |

*** inline expressions
   :PROPERTIES:
   :session:  'default
   :DATE:     2010-06-06
   :END:

#+begin_src R :exports code :results silent
  x<-4
#+end_src

the sum of 1 and x is equal to src_R{x+1}, now I'll sneakily reset
this value in a hidden inline block src_R[:exports none]{x<-2}, so
it's value is now src_R{x}.

*** adding file names to literal values on export
   :PROPERTIES:
   :DATE:     2010-06-01
   :END:

#+name: three
: 9

#+begin_src R :var num=three :exports results
runif(n=num, min=0, max=1)
#+end_src

#+begin_src R :var num=3 :exports results
runif(n=num, min=0, max=1)
#+end_src

*** appending tangle
   :PROPERTIES:
   :tangle:   appended.el
   :DATE:     2010-05-28
   :END:
append all these block

#+begin_src emacs-lisp
  (message "block %d" 1)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 2)
#+end_src

#+begin_src emacs-lisp
  (message "block %d" 3)
#+end_src

*** visibility affecting execution
    :PROPERTIES:
    :DATE:     2010-05-27
    :END:

**** folding
    :PROPERTIES:
    :DATE:     2010-05-27
    :END:
lets test folding

***** folded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
#+begin_src emacs-lisp
  (message "folded1")
#+end_src

#+name:
: folded1

#+begin_src emacs-lisp
  (message "folded2")
#+end_src

#+name:
: folded2
***** unfolded
     :PROPERTIES:
     :DATE:     2010-05-27
     :END:
#+begin_src emacs-lisp
  (message "unfolded1")
#+end_src

#+name:
: unfolded1
#+begin_src emacs-lisp
  (message "unfolded2")
#+end_src

#+name:
: unfolded2

*** empty code blocks -- and latex vs. LaTeX
   :PROPERTIES:
   :DATE:     2010-05-26
   :END:
eric
#+begin_src latex
  
#+end_src

michael
#+begin_src LaTeX
  
#+end_src

schulte
#+begin_src emacs-lisp
  (message "error")
#+end_src

*** colnames
   :PROPERTIES:
   :DATE:     2010-05-04
   :END:

#+tblname: A
| a | b | c |
|---+---+---|
| d | e | f |
| g | h | i |

#+begin_src python :var tab=A :colnames yes
return [[val + '*' for val in row] for row in tab]
#+end_src

#+name:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

#+tblname: A
| a | b | c |
| d | e | f |
| g | h | i |

#+begin_src ruby :var tab=A :colnames yes
tab.map{|r| r.map{|e| e+"*"} }
#+end_src

#+name:
| a  | b  | c  |
|----+----+----|
| d* | e* | f* |
| g* | h* | i* |

*** lisps not fully eval'd
   :PROPERTIES:
   :DATE:     2010-04-30
   :END:

#+begin_src emacs-lisp
  (message "one")
  (message "two")
#+end_src

#+name:
: two

#+begin_src clojure :session :default
  (println "one")
  (println "two")
  (+ 1 2)
#+end_src

#+name:
: 3

*** tangling org
   :PROPERTIES:
   :DATE:     2010-04-27
   :END:

#+begin_src org :tangle ~/Desktop/test.org
  ,* first
  ,| eric   | me     |
  ,| patton | my dog |
  
  ,* second
  
  ,some more stuff...
  
  ,#+HTML: <b>I bet this is quoted</b>
#+end_src

#+begin_src ruby :tangle ~/Desktop/test.rb
  # this is a comment
  eric.map{|l| puts l}
#+end_src

*** variable indexing
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
#+TBLNAME: MyTable
 |   X |  Y |
 |-----+----|
 |   0 |  0 |
 |   1 |  1 |
 |   2 |  4 |
 |   3 |  9 |
 |   4 | 16 |
 |   5 | 25 |
 |-----+----|
 | Sum | 55 |
 #+TBLFM: $2=$1*$1::@8$2=vsum(@2..@-1)

#+begin_src python :var sum=MyTable[2:7,1] :exports none
   return sum
#+end_src

#+name:
| 0 | 1 | 4 | 9 | 16 | 25 |

#+begin_src python :var sum=MyTable[9,1] :exports none
   return sum
#+end_src

#+name:
: 55

#+begin_src gnuplot :var data=MyTable[1:-2] :var sum=MyTable[7,1]
:results silent :exports none
  reset
  set label "Sum: %.0f",sum at graph 0.03, graph 0.93
  plot data with linespoints
#+end_src

*** colnames mismatched sizes
   :PROPERTIES:
   :DATE:     2010-04-23
   :END:
#+tblname: mismatch-colnames
| a |  b |
|---+----|
| 1 |  8 |
| 2 |  9 |
| 3 | 10 |
| 4 | 11 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2, 3]]
#+end_src

#+name:
| 1 | 2 | 3 |

#+begin_src python :var tab=mismatch-colnames
  return [[1, 2]]
#+end_src

#+name:
| a | b |
|---+---|
| 1 | 2 |

#+begin_src python :var tab=mismatch-colnames :colnames yes
  return [1,2]
#+end_src

#+name:
| 1 | 2 |

*** test gnuplot
   :PROPERTIES:
   :DATE:     2010-04-17
   :END:

#+begin_src gnuplot
  plot sin(x), x+5
#+end_src

*** hline processing
   :PROPERTIES:
   :DATE:     2010-04-12
   :END:
#+tblname: many-cols
| a | b | c |
|---+---+---|
| d | e | f |
|---+---+---|
| g | h | i |

#+tblname: less-cols
| 1 |
|---|
| 2 |
| 3 |

#+tblname: less-cols2
| 1 | 2 | 3 |

#+begin_src emacs-lisp :var tab=many-cols
  (message "%S" tab)
  ;; (remove 'hline tab)
  ;; (flet ((rem-hline (el)
  ;;                   (if (listp el)
  ;;                       (remove nil (mapcar #'rem-hline el))
  ;;                     (if (equal 'hline el) nil el))))
  ;;   (rem-hline tab))
#+end_src

#+begin_src ruby :var tab=less-cols
  tab
#+end_src

#+name:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var one=2
  1 + 2
#+end_src

#+name:
: 3

#+begin_src python :var tab=less-cols
  return tab
#+end_src

#+name:
| 1 |
|---|
| 2 |
| 3 |

#+begin_src ruby :var tab=less-cols :colnames no
  tab
#+end_src

#+name:
| 1 |
| 2 |
| 3 |

#+begin_src emacs-lisp :var tab=row-and-col-names
   (message "%S" tab)
#+end_src

#+name:
: (("" "c1" "c2" "c3") hline ("r1" 1 4 7) ("r2" 2 5 8) ("r3" 3 6 9))

#+tblname: row-and-col-names
|    | c1 | c2 | c3 |
|----+----+----+----|
| r1 |  1 |  4 |  7 |
| r2 |  2 |  5 |  8 |
| r3 |  3 |  6 |  9 |

functions
#+begin_src emacs-lisp
  (defun org-babel-del-hlines (table)
    "Remove all 'hlines from TABLE."
    (remove 'hline table))
  
  (defun org-babel-get-colnames (table)
    "Return a cons cell, the `car' of which contains the TABLE
        less colnames, and the `cdr' of which contains a list of the
        column names"
    (if (equal 'hline (second table))
        (cons (cddr table) (car table))
      table))
    
  (defun org-babel-get-rownames (table)
    "Return a cons cell, the `car' of which contains the TABLE less
     colnames, and the `cdr' of which contains a list of the column
     names.  Note: this function removes any hlines in TABLE"
    (flet ((trans (table) (apply #'mapcar* #'list table)))
      (let ((table (trans (remove 'hline table))))
        (cons (cdr table) (car table)))))
  
  (defun org-babel-put-colnames (table colnames)
    "Add COLNAMES to TABLE if they exist."
    (if colnames (apply 'list colnames 'hline table) table))
  
  (defun org-babel-put-rownames (table rownames)
    "Add ROWNAMES to TABLE if they exist."
    (if rownames
        (mapcar (lambda (row)
                  (if (listp row)
                      (cons (or (pop rownames) "") row)
                    row)) table)
      table))
#+end_src

*** evaluate references
   :PROPERTIES:
   :DATE:     2010-04-09
   :END:

#+begin_src emacs-lisp :var var=`(+ 9 ,(- 19 7)) :tangle yes
  (message "var is %S" var)
#+end_src

#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+name:
: 3

#+begin_src ruby
  + 1 2
#+end_src

#+name:
: nil

*** tangling and variable resolution
  :PROPERTIES:
  :ID:       18b4f1be-bb1d-49bc-a651-c97406a35bdd
  :tangle:   yes
  :DATE:     2010-03-31
  :END:

#+name: A
#+begin_src emacs-lisp :eval no :expand yes :var id=(org-entry-get nil "ID" t) :var two=2
  (concat "This is the entry ID: " id)
#+end_src

#+name: A
: This is the entry ID: 18b4f1be-bb1d-49bc-a651-c97406a35bdd

*** latex attributes
   :PROPERTIES:
   :DATE:     2010-03-23
   :END:

#+ATTR_LaTeX: width=0.38\textwidth wrap placement={r}{0.4\textwidth}
#+begin_src ditaa :file=scrap.png
  +---------------------------+
  |                           |
  |       latex               |
  |                           |
  |      +------------+       |
  |      |            |       |
  |      |            |       |
  |      |       cBLU |       |
  |      +------------+       |
  |                      cPNK |
  +---------------------------+
#+end_src

*** access to variables set in property drawers
   :PROPERTIES:
   :special:  89
   :text: schulte
   :DATE:     2010-03-22
   :END:

: "(org-entry-get nil "special" t)"

#+begin_src emacs-lisp :var special=(string-to-number (org-entry-get nil "special" t))
  (+ special 1)
#+end_src

#+name:
: 90

#+begin_src emacs-lisp :var special=(org-entry-get nil "text" t)
  special  
#+end_src

#+name:
: schulte

*** variables into shell scripts
   :PROPERTIES:
   :DATE:     2010-02-23
   :END:
#+name: into-shell-scripts
| username | guest   |
| password | nothing |

#+begin_src sh :var username=into-shell-scripts[0,0] :var password=into-shell-scripts[1,1] :results output
  echo "$username -p $password"
#+end_src

#+name:
: username -p nothing

#+name: number-into-shell
: 9

#+begin_src sh :var num=number-into-shell
  for i in `seq $num`; do
      echo $i
  done
#+end_src

#+name:
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

*** results lines for function calls
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

#+call: fibonacci(input=5) :resname eric

#+name:
: 8

#+begin_src emacs-lisp :var fib=fibonacci(input=5)
  (message "fib(5)=%d" fib)
#+end_src

#+name:
: fib(5)=8

*** haskell variables
   :PROPERTIES:
   :DATE:     2010-02-15
   :END:

playing with Haskell

#+name: haskell-stuff
: 9

#+begin_src haskell :var num=haskell-stuff
  num + 1
#+end_src

#+begin_src ruby :var num=haskell-stuff
  num + 1
#+end_src

#+name:
: 10

*** list index w/function style name
   :PROPERTIES:
   :DATE:     2010-02-14
   :END:

#+name: function-style-index
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

#+name: function-style-indexing(data=function-style-index[1:4,0])
#+begin_src emacs-lisp
  (message "%S" data)
#+end_src

#+name: function-style-indexing
: ((1) (2) (3) (4))

*** looking at source name exports
   :PROPERTIES:
   :DATE:     2010-02-09
   :END:

#+name: fibonacci
#+begin_src emacs-lisp :var input=0
  (defun fib (n)
    (if (> n 1)
        (+ (fib (- n 1)) (fib (- n 2)))
        1))
  (fib input)
#+end_src

#+name: fibonacci
: 1

now applying our Fibonacci function

#+call: fibonacci(input=5)

*** short shell test
   :PROPERTIES:
   :DATE:     2010-02-07
   :END:

#+begin_src sh
  date
#+end_src

#+name:
: Sun Feb  7 10:17:44 MST 2010

#+tblname: fibs
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs
  echo "$table" |wc
#+end_src

#+name:
: 6      12      24

#+begin_src sh :var table=fibs
  echo "$table"
#+end_src

#+name:
| 1 | 1 |
| 2 | 1 |
| 3 | 2 |
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

#+begin_src sh :var table=fibs :separator --
  echo "$table" | head -1
#+end_src

#+name:
: 1--1

*** tables to shell scripts ideas
   :PROPERTIES:
   :DATE:     2010-02-06
   :END:

#+tblname: sec
| Hello | World |


1) allowing the user to specify a separator with a header argument as
   follows
   #+begin_src sh :var table=sec :separator ,
     cat <<EOF
     $table
     EOF
   #+end_src
   
   which would result in something like

   : "Hello, World"

2) writing the table to a tab or comma separated file and then
   replacing =$table= in the source block body with the path to the
   file name, s.t. something like
   
   #+begin_src sh :var table=data
     wc $table
   #+end_src

   would return reasonable results

*** tangling w/o comments and shebang
   :PROPERTIES:
   :tangle:   yes
   :DATE:     2010-02-05
   :END:

#+begin_src emacs-lisp :comments no :shebang (identity my-shebang)
  (message "I should have no comments")
#+end_src

#+begin_src emacs-lisp :comments no
  (setq my-shebang "foo")
#+end_src

#+name:
: foo

#+begin_src ruby :shebang #!/usr/bin/ruby
  puts :nonstandard_shebang
#+end_src

*** exporting to a file
   :PROPERTIES:
   :EXPORT_FILE_NAME: simple
   :EXPORT_TITLE: testing file export
   :DATE:     2010-02-03
   :END:

this is the contents

and a block
#+begin_src clojure
  (println "is a nice lisp")
#+end_src

ah, it works!

*** babel block overwrite
   :PROPERTIES:
   :DATE:     2010-01-18
   :END:

The first block overwrites
#+begin_src clojure
  (def overwriter "I'll show up everywhere")
#+end_src

this second block
#+begin_src diff
  3719d3718
  <       movl    $1024, 8(%esp)
#+end_src

*** load to session
   :PROPERTIES:
   :DATE:     2010-01-11
   :END:
#+begin_src clojure :session asm-gp
  (in-ns 'asm-gp)
#+end_src

#+begin_src ruby :session
  puts :eric
#+end_src

#+begin_src python :session
  5 + 1 
#+end_src

#+begin_src R :session
  6 + 1
#+end_src

#+begin_src sh :session
  date
#+end_src

#+begin_src ocaml :session
  eric
#+end_src

#+begin_src gnuplot :session
  plot sin(x)
#+end_src

*** links
   :PROPERTIES:
   :DATE:     2010-01-06
   :END:

can LaTeX link itself to the middle of a paragraph with a simple
inline link like <<keystone>> if not then we would probably need to
wrap source-code blocks in figures to make them referable.

how about a link back to [[keystone]]

The above appears to work in LaTeX, but not in HTML.

*** fancier export
   :PROPERTIES:
   :DATE:     2010-01-05
   :END:

#+name: square
#+begin_src emacs-lisp :var input=1
  (* input input)
#+end_src

*** exporting org-source
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:

#+begin_src org
  ,lets see how this org-mode code exports to html
  
  ,is this [[link]] blue?
  
  ,#+begin_src emacs-lisp
  ,  (+ 1 2)
  ,#+end_src
#+end_src

*** exporting and caching
   :PROPERTIES:
   :DATE:     2009-12-23
   :END:
#+begin_src ditaa :file data/example.png :exports none
    +------------------+
    |  ditaa example   |
    |                  |
    |                  |
    +------------------+
#+end_src

#+name:
[[file:data/example.png]]

*** no noweb by default
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

#+name: sample
#+begin_src emacs-lisp 
  (message "sample")
#+end_src

#+begin_src emacs-lisp :noweb no
  <<sample>>
#+end_src

#+name:
: sample

*** looking at double quotes
   :PROPERTIES:
   :DATE:     2009-12-18
   :END:

#+tblname: double-quote-test-input
| test | this | 8 | 9 |

#+name: double-quote-test-output
#+begin_src python :var data=double-quote-test-input
  return data
#+end_src

#+name: double-quote-test-output
| test | this | 8 | 9 |

*** quoted session name
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:

#+begin_src sh :session "eric"
  echo 'name-me'
#+end_src

#+name:
: name-me

*** eval-buffer
   :PROPERTIES:
   :DATE:     2009-12-04
   :END:
#+begin_src emacs-lisp
  (+ 1 2)
#+end_src

#+name:
: 3

#+begin_src emacs-lisp
  (+ 3 4)
#+end_src

#+name:
: 7

*** sql exports to latex
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
example from email list
**** ECM
    :PROPERTIES:
    :DATE:     2009-11-30
    :END:

   - faire un script Bash (et =isql=) envoyant un /listing/ de stagiaires;

#+name: envoi-stg
   #+begin_src sql
       DECLARE @dateFmtStyleIn int; SET @dateFmtStyleIn = 120 -- ODBC canonical
       DECLARE @dateFmtStyleOut int; SET @dateFmtStyleOut = 103 -- French dd/mm/yyyy

       DECLARE @firstDayOfThisMonth smalldatetime
       SET @firstDayOfThisMonth = CONVERT(smalldatetime,
                                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                                          + '01' + ' 00:00:00',
                                          @dateFmtStyleIn)

       DECLARE @now smalldatetime
       SET @now = CONVERT(smalldatetime,
                          CAST(YEAR(GETDATE()) AS char(4)) + '-'
                          + CAST(MONTH(GETDATE()) AS char(2)) + '-'
                          + CAST(DAY(GETDATE()) AS char(2)) + ' '
                          + CAST(DATEPART(hh, GETDATE()) AS char(2)) + ':'
                          + CAST(DATEPART(mi, GETDATE()) AS char(2)) + ':'
                          + '00',
                          @dateFmtStyleIn)

       SELECT pfiID
       FROM dossier
#+end_src

*** gnuplot variable expansion
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:

#+name: simple-function
#+begin_src emacs-lisp
  "sin(x)"
#+end_src

#+begin_src gnuplot :var fun=simple-function
  plot $fun
#+end_src

*** debug hints
   :PROPERTIES:
   :DATE:     2009-11-30
   :END:
from mailing list

- edebug-defun: (in emacs-lisp mode, C-u C-M-x) will mark the function
  so that when it is called, the interpreter stops and you can then
  single-step through it with <SPACE>. At each point, you can press
  "e" and evaluate variables (actually arbitrary expressions).
- Insert a strategically placed (debug) call and then call the
  function.  If/when the debug call is executed, you are dropped into
  the debugger and you can then evaluate arbitrary expressions.

*** whitespace/newline results issues
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

#+begin_src sh
  echo output
#+end_src

This
#+begin_src sh
  echo output
#+end_src
text here

results in

t#+results:
: output
ext here

#+begin_src emacs-lisp
  (+ 1 1)
#+end_src

#+name:
: 2

*** sh with sessions
   :PROPERTIES:
   :DATE:     2009-11-27
   :END:

#+begin_src sh :session eric
  cd ~/Desktop
#+end_src

#+begin_src sh :session eric
  cd ~/Desktop/clj/
  ls *.clj
#+end_src

#+name:
| "ants.clj" | "" | "concurrent.clj" | "" | "hello.clj" | "" | "spell-checker.clj" |

*** xml and n3
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

introduce org-babel to =xml= and =n3=
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-interpreters "xml")
  (add-to-list 'org-babel-interpreters "n3")
#+end_src

inform org-babel-tangle of their existence and file extensions
#+begin_src emacs-lisp :results silent
  (add-to-list 'org-babel-tangle-langs '("xml" "xml"))
  (add-to-list 'org-babel-tangle-langs '("n3" "n3"))
#+end_src

#+begin_src xml :tangle example
  <first>
  </first>
#+end_src

#+begin_src n3 :tangle example
  n3 stuff
#+end_src

*** unresolved noweb references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results silent
  (setq org-babel-noweb-error-langs '("ruby"))
#+end_src

#+name: i-have-a-name
#+begin_src ruby 
  1 + 2
#+end_src


#+begin_src ruby :noweb
  <<i-have-a-name>> + 3
#+end_src

#+resname:
: 6

*** =:table= results param
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :results table
  8
#+end_src

#+resname:
| 8 |

*** switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

*** switches and references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric
#+end_src

#+resname[bb4cebabe38a5d3d43835acebdbe17aa3314cef6]:
: imp

Line no. [[(imp)]] is important!

#+begin_src ruby -n -r -l "(ref:%s)" :results output
  class Schulte
    def self.eric
      puts :imp # (ref:imp)
    end
  end
  Schulte.eric # (ref:output)
#+end_src

#+resname: eric
: imp

*** simple scalar
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp
  (+ 1 3)
#+end_src

#+resname:
: 4

*** simple R
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src R :session R
8
#+end_src

#+resname:
: 8

*** show all
   CLOCK: [2009-09-15 Tue 07:51]--[2009-09-15 Tue 08:51] =>  1:00
   :PROPERTIES:
   :exports:  both
   :DATE:     2009-11-20
   :END:

#+begin_src ditaa :file blue.png
   +----------------------+
   |                      |
   |                      |
   |          +-----------+
   |          |           |
   |          |           |
   |          |           |
   |          +-----------+
   |                      |
   +----------------------+
#+end_src

*** results switches
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src ruby :results output :results_switches -n
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example -n

-
--
---
----
-----
------
-------
--------
---------
#+end_example

#+begin_src ruby :results output
  10.times do |n|
    puts "-"*n
  end
#+end_src

#+resname:
#+begin_example
  -
  --
  ---
  ----
  -----
  ------
  -------
  --------
  ---------
#+end_example

*** reference parts of tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+TBLNAME: squares
|  1 |   1 |
|  2 |   4 |
|  3 |   9 |
|  4 |  16 |
|  5 |  25 |
|  6 |  36 |
|  7 |  49 |
|  8 |  64 |
|  9 |  81 |
| 10 | 100 |
| 11 | 121 |
| 12 | 144 |
| 13 | 169 |
| 14 | 196 |
| 15 | 225 |
| 16 | 256 |
| 17 | 289 |
| 18 | 324 |
#+TBLFM: $2=$1*$1

#+begin_src gnuplot :var data=squares
set title "Implementing Gnuplot"
plot data using 1:2 with lines
#+end_src

*** quoted latex
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

The following latex isn't exported correctly

#+begin_latex
  \begin{code}
  data BTree = Leaf a
             | Node Tree Tree
  \end{code}
#+end_latex

#+begin_src haskell
  data BTree = Leaf a
             | Node Tree Tree
#+end_src

*** pretty print
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results scalar
  '(1 2 3 4)
#+end_src

*** =pp= results
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
**** python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src python :results pp :session
  ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']
#+end_src

#+resname:
: ['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three']

**** ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src ruby :results pp
  class Schulte
    attr_accessor :name, :age
  end
  
  eric = Schulte.new
  eric.name = "eric"
  eric.age = 27
  
  eric
#+end_src

#+resname:


#+begin_src ruby :results pp
  a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
  a
#+end_src

#+resname:
#+begin_example
[1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3,
 1,
 2,
 3]
#+end_example

*** persistent python
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src python :session :results silent
  import types
#+end_src

#+begin_src python :session
  types.FunctionType
#+end_src

#+resname:
: function

**** more persistent python
    :PROPERTIES:
    :session:  default
    :DATE:     2009-11-20
    :END:

#+begin_src python :results silent
  import types
#+end_src

#+begin_src python
  types.FunctionType
#+end_src

#+resname:
: function

*** noweb referernces
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: noweb-example
#+begin_src ruby 
  a = 28
#+end_src

#+begin_src ruby :noweb
  # <<noweb-example>>
  a + 4
#+end_src

#+resname:
: 32

*** multiple arguments
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :var first=9 :var second=10
  (+ first second)
#+end_src

#+resname:
: 19

*** lua export
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: determine the neighbors of the segments that the bisector hits
#+begin_src lua :tangle no :exports code
  local s1, s2 = intersecting_segs[1], intersecting_segs[2]
  local n1 = table_find_segment(cell.neighbors, s1)
  local n2 = table_find_segment(cell.neighbors, s2)
#+end_src

I got:
#+begin_example
\lstset{language=lua}
\begin{lstlisting}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{lstlisting}
#+end_example

Emacs -Q got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

Emacs -Q + Org-babel got:
#+begin_example
\begin{verbatim}
local s1, s2 = intersecting_segs[1], intersecting_segs[2]
local n1 = table_find_segment(cell.neighbors, s1)
local n2 = table_find_segment(cell.neighbors, s2)
\end{verbatim}
#+end_example

*** latex pngs
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
$x \mapsto y$

**** Theorem
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
$|consts(t)| \leq sizes(t)$

- by induction on the structure of t
- base cases are $t \in [true, false, 0]$: 
  - $|consts(t)| = |[t]| = 1 = size(t)$
- inductive size
  - $t \in [succ(t_1), pred(t_1), iszero(t_1)]$:
    - $|consts(t)| = |consts(t_1)| = |[t]| \leq size(t_1) < size(t)$
  - $t = if\, t_1 \, then \, t_2 \, else t_3$
    - $|consts(t)| = |consts(t_1) \cup consts(t_1) \cup consts(t_1)|$
    - $\leq |consts(t_1)| + |consts(t_1)| + |consts(t_1)|$
    - $\leq size(t_1) + size(t_1) + size(t_1)$
    - $< size(t)$

*** later
   CLOCK: [2009-09-15 Tue 09:41]--[2009-09-15 Tue 09:51] =>  0:10
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
stuff here

*** indexing into results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: indexable-table
| eric    |
| michael |
| schulte |
| is      |
| my      |
| name    |

#+begin_src emacs-lisp :var data=indexable-table[2:4]
   data
#+end_src

#+name:
| schulte |
| is      |
| my      |

#+tblname: multidimensional-indexing
| 1 |  2 |
| 3 |  4 |
| 5 |  6 |
| 7 |  8 |
| 9 | 10 |

#+begin_src emacs-lisp :var data=multidimensional-indexing[0:-2]
   data
#+end_src

#+resname:
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
| 7 | 8 |

*** indexing into gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+tblname: squares
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |
| 5 | 25 |
| 6 | 36 |

#+begin_src gnuplot :var data=squares :results silent
plot data using 1:2 with lines
#+end_src

#+tblname: squares-with-sum
|  1 |  1 |
|  2 |  4 |
|  3 |  9 |
|  4 | 16 |
|  5 | 25 |
|  6 | 36 |
|----+----|
| 21 | 91 |

#+begin_src gnuplot :var data=squares-with-sum[0:-3] :results silent
  plot data using 1:2 with lines
#+end_src

*** indented
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   #+begin_src emacs-lisp
     (message "I ran!!")   
   #+end_src

#+resname:
: I ran!!

*** indentation
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src python
          9
#+end_src

*** hiding results
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp
  (mapcar (lambda (el) (list el)) (number-sequence 0 20))
#+end_src

#+name:
|  0 |
|  1 |
|  2 |
|  3 |
|  4 |
|  5 |
|  6 |
|  7 |
|  8 |
|  9 |
| 10 |
| 11 |
| 12 |
| 13 |
| 14 |
| 15 |
| 16 |
| 17 |
| 18 |
| 19 |
| 20 |

*** haskell
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src haskell
  powerSet :: [a] -> [[a]]
  powerSet = foldr (\ x ps -> map (\ y -> x : y) ps ++ ps ) [[]]
#+end_src

#+begin_src haskell
  powerSet [1, 2, 3]
#+end_src

*** haskell and tables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src haskell
  sumListCond :: Int -> Int -> [Int] -> Int
  sumListCond l n xs
      | foldl (+) 0 (take l xs) <= n = sumListCond (l + 1) n xs
      | otherwise = foldl (+) 0 (take (l - 1) xs)
#+end_src
#+begin_src oz
  
#+end_src

*** gnuplot
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src gnuplot
plot cosx
#+end_src


#+end_src
      
*** empty =output= results for emacs-lisp
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src emacs-lisp :results output
   8
#+end_src

#+resname:

*** elisp variables
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src ditaa :file (format "%d.png" 45)
      +-----------+
      |           |
      |           |
      |           |
      |           |
      +-----------+
#+end_src

#+name:
[[file:45.png]]

*** elisp references
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src emacs-lisp :results silent
   (setq first 10)
#+end_src

#+name: resolve(name=nil)
#+begin_src emacs-lisp :results silent
  (eval (intern name))
#+end_src

#+begin_src python :var a=resolve(name="first")
  return a + 10
#+end_src

*** dynamic table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+TBLNAME: todays-clock
#+BEGIN: clocktable :maxlevel 2 :block today :scope tree1 :link t
Clock summary at [2009-09-15 Tue 08:51], for Tuesday, September 15, 2009.

| L | Headline     | Time   |      |
|---+--------------+--------+------|
|   | *Total time* | *1:10* |      |
|---+--------------+--------+------|
| 1 | [[file:/Users/eschulte/Desktop/test.org::top][top]]          | 1:10   |    1 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]     |        | 1:00 |
| 2 | [[file:/Users/eschulte/Desktop/test.org::later][later]]        |        | 0:10 |
#+END: clocktable

#+begin_src emacs-lisp :var data=todays-clock(1,1)
(message "table is %S" data)
#+end_src

#+resname:
: table is (("L" "Headline" "Time" "") hline ("" "*Total time*" "*1:10*" "") hline (1 "[[file:/Users/eschulte/Desktop/test.org::top][top]]" "1:10" 1) (2 "[[file:/Users/eschulte/Desktop/test.org::show%20all][show all]]" "" "1:00") (2 "[[file:/Users/eschulte/Desktop/test.org::later][later]]" "" "0:10"))

#+begin_src R :session R-pie-example :var times=todays-clock :results silent
pie(times[2:length(times),4], labels = times[2:length(times),2])
#+end_src

*** code results
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
**** emacs lisp
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:
#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (lambda (item) (+ item el))) '(1 2 3 4 5))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
((lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el))
 (lambda
   (item)
   (+ item el)))
#+END_SRC

#+begin_src emacs-lisp :results code
  (mapcar (lambda (el) (* el el)) '(1 2 3 89))
#+end_src

#+resname:
#+BEGIN_SRC emacs-lisp
(1 4 9 7921)
#+END_SRC

**** ruby
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

#+begin_src ruby :results code
  [1, 2, 33, 4].map{|n| "the number #{n}"}
#+end_src

#+resname:
#+BEGIN_SRC ruby
  ["the number 1", "the number 2", "the number 33", "the number 4"]
#+END_SRC

#+begin_src ruby :session :results code 
  [1, 2, 33, 4].map{|n| n + 10 }
#+end_src

#+resname:
#+BEGIN_SRC ruby
[11, 12, 43, 14]
#+END_SRC

**** python
    :PROPERTIES:
    :DATE:     2009-11-20
    :END:

#+begin_src python :results code
  ['one', 'two', 'three']
#+end_src

#+resname:
#+BEGIN_SRC python
['one', 'two', 'three']
#+END_SRC

#+begin_src python :results code
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

#+begin_src python :session :results code 
  [1, 2, 33, 4]
#+end_src

#+resname:
#+BEGIN_SRC python
[1, 2, 33, 4]
#+END_SRC

*** clojure
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src clojure :results silent
  (list 8 9)
#+end_src

*** changing source name
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+name: emacs-nine
#+begin_src emacs-lisp
  8
#+end_src

#+resname: emacs-nine
: 8

#+resname: emacs-eight
: 8

*** asymptote
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:

#+begin_src asymptote :file asymptote-test.png :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return 1+cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(a,0)$",(1,0),N);
  dot("$(2a,0)$",(2,0),N+E);
#+end_src

#+resname:
[[file:asymptote-test.png]]

*** asymptote cosine
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
#+begin_src asymptote :exports code
  import graph;
  
  size(0,4cm);
  
  real f(real t) {return cos(t);}
  
  path g=polargraph(f,0,2pi,operator ..)--cycle;
  filldraw(g,pink);
  
  for(int i=0; i < 8; ++i) {
    real j = 0.125 + 0.125*i;
    real h(real t) {return j;};
    path k=polargraph(h, -(acos(j)), acos(j), operator ..);
    draw(k,blue);
  }
  
  xaxis("$x$",above=true);
  yaxis("$y$",above=true);
  
  dot("$(pi,0)$",(1,0),N);
#+end_src

*** and then more
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
and more stuffs here

*** advanced table
   :PROPERTIES:
   :DATE:     2009-11-20
   :END:
   | DATA             | WHAT       | WHERE       | HOW MUCH |
   |------------------+------------+-------------+----------|
   | [2009-09-25 Fri] |            |             |    28.95 |
   |------------------+------------+-------------+----------|
   |                  | food       | supermarket |     7.85 |
   |                  | ticket bus |             |      2.3 |
   |                  | tea + ice  | ice uno     |      4.4 |
   |                  | ticket     |             |     14.4 |
   |------------------+------------+-------------+----------|
   | [2009-09-26 Sat] |            |             |       41 |

#+begin_src emacs-lisp
  (let ((total 0) (responding t) purchases)
    (while responding
      (setq purchases
            (cons
             (list ""
                   (read-from-minibuffer "What: ")
                   (read-from-minibuffer "Where: ")
                   (read-minibuffer "How Much: "))
             purchases))
      (setq responding (y-or-n-p "more? ")))
    (append 
     purchases
     (list
      (list
       (format-time-string "%Y-%m-%d" (current-time))
       "" "" (progn
               (mapc (lambda (purchase)
                       (setq total (+ total (fourth purchase))))
                     purchases)
               total)))))
#+end_src

#+resname:
| ""           | "fish and chips" | "diner"  |  9.78 |
| ""           | "food"           | "subway" |  5.45 |
| "2009-09-29" | ""               | ""       | 15.23 |


* "Languages and Machines" 
** intro 
*** Church-Turing thesis
*** Turing machines
*** analysis of effective computation 

**** deterministic finite automata
     
     src blocks are an easy derivation of this

***** properties
      read-once
      state and input symbol determine instruction to execute

***** application examples
      switching circuits
      lexical analysis of programming languages

** language definition and effective computation 
   "Language definition and computibility are not two unrelated topics
   that fall under the broad heading of computer science theory, but
   rather are inextricably intertwined. the computations of a machine
   can be used to recognize a language; an input string is accepted by
   the machine if the computation initiated with the string indicates
   it's syntactic correctness. Thus each machine has an associated
   language, the set of strings accepted by the machine. The
   computational capabilities of each family of abstract machines is
   characterized by the languages accepted by the machines in the
   family. With this in mind, we begin our investigations into the
   related topics of language definition and effective computation."
   -- T. Sudkamp, "Languages and Machines"   

** foundations 
*** intro
**** theoretical computer science
     explores 
     the capabilities and limitations 
     of algorithmic problem solving

**** formal language theory
     provides the foundation 
     for the definition 
     of programming languages
     and compiler design
     
***** roots
      linguistics
      mathematical logic
      computer science

**** abstract machines
     are built to recognize
     the syntactic properties
     of languages
     and to compute functions

**** the relationship between 
     the grammatical generation of languages 
     and the recognition of languages
     by automata
     is a central theme
     of "Languages and Machines"

***** grammars were developed
      to provide a mechanism
      for describing
      natural (spoken and written) languages
      and have become the primary tool
      for the formal specification
      of programming languages

**** set-theoretic definition of language
     sufficiently broad to include
     both natural and formal languages
     but generality is gained
     at the expense
     of not providing a technique
     for mechanically generating
     the strings of the language

***** to overcome this shortcoming
      recursive definitions
      and set operations
      are used to give 
      finite specifications
      of languages

**** development of the regular sets
     a family of languages
     that arises 
     in automata theory
     formal language theory
     switching circuits
     and neural networks
     
*** mathematical preliminaries
**** set-theory
**** cartesian product, relations and functions
**** equivalence relations
**** countable and uncountable sets
**** recursive definitions
**** mathematical induction					       :@doc:
     
     Establishing the relationships between the elements of sets and
     operations on the sets requires the capability of constructing
     proofs to verify the hypothesized properties.
     
     It is impossible to prove that a property holds for every member
     in an infinite set by considering each element individually. 

     The principle of mathematical induction gives sufficient
     conditions for proving that a property holds for every element in
     a recursively defined set. 

     Induction uses the family of nested sets generated by the
     recursive process to extend a property from the basis to the
     entire set.

***** principle of mathematical induction

      Let x be a set defined by recursion from the basis
      X(subscript 0) and let X(subscript 0...i,...) be the sequence of
      sets generated by the recursive process.

      Also let P be a property defined on the elements of X.

      If it can be shown that
      
      i) P holds for each element in X(subscript 0),
      
      ii) whenever P holds for every element in the sets X(subscript
      0...i,...), P also holds for every element in X(subscript (i +
      1)),

      then, by the principle of mathematical induction, P holds for
      every element in X.

      The soundness of the principle of mathematical induction can be
      intuitively exhibited using the sequence of sets constructed by
      a recursive definition. 

      Shading the circle X(subscript i) indicates that P holds for
      every element of X(subscript i).

      The first condition requires that the interior set be
      shaded. 

      Condition (ii) states that the shading can be extended from any
      circle to the next concentric circle. 

      (Fig. 1.3) illustrates how this process eventually shades the
      entire set X.

      Figure 1.3 Principle of mathematical induction.

      The justification for the principle of mathematical induction
      should be clear from the preceeding argument. 

      Another justification can be obtained by assuming that
      conditions (i) and (ii) are satisfied but P is not true for
      every element in X.

      If P does not hold for all elements of X, then there is at least
      one set X(subscript i) for which P does not universally hold.

      Let X(subscript j) be the first such set.

      Since condition (i) asserts that P holds for all elements of
      X(subscript 0), j cannot be zero.

      Now P holds for all elements of X(subscript j-1) by our choice
      of j.

      Condition (ii) then requires that P hold for all elements in
      X(subscript j).

      This implies that there is no first set in the sequence for
      which the property P fails.

      Consequently, P must be true for all the X(subscript i)'s, and
      therefore for X.

      An inductive proof consists of three distinct steps. 

      The first step is proving that the property P holds for each
      element of a basis set. 

      This corresponds to establishing condition (i) in the definition
      of the principle of mathematical induction. 

      The second step is the statement of the inductive
      hypothesis. 

      The inductive hypothesis is the assumption that the property P
      holds for every element in the sets X(subscript 0...n). 

      The inductive step then proves, using the inductive hypothesis,
      that P can be extended to each element in X(subscript (n +
      1)). 

      Completing the inductive stepsatisfies the requirement of the
      principle of mathematical induction. 

      Thus, it can be concluded that P is true for all elements of X.

**** directed graphs						       :@doc:
     A mathematical structure consists of functions and relations on a
     set or sets and distinguished elements from the sets. A
     distinguished element is an element of a set that has special
     properties that distinguish it from the other elements. The
     natural numbers as defined in Definitions 1.5.1, can be expressed
     as a structure (N, s, 0). The set N contains that natural
     numbers, s is a unary function on N, and 0 is a distinguished
     element of N. Zero is distinguished because of its explicit role
     in the definition of the natural numbers. 

     (search lisp intro for comments on 'empty-object' being a 'funny
     kind of constant' rather than a memory allocation construct)

     Graphs are frequently used in both formal language theory and
     automata theory because they provide the ability to portray the
     essential features of a mathematical entity in a diagram, which
     aids the intuitive understanding of the concept. Formally, a
     directed graph is a mathematical structure consisting of a set N
     and a binary relation A on N. The elements of N are called the
     nodes, or vertices, of the graph, and the elements of A are
     called arcs, or edges. The relation A is referred to as the
     adjacency relation. A node y is said to be adjacent to x when
     ( [ x , y ] memberOf A ). An arc from x to y in a directed graph
     is depicted by an arrow from x to y. Using the arrow metaphor, y
     is called the head of the arc and x the tail. The in-degree of a
     node x is the number of arcs with x as the head. The out-degree
     of x is the number of arcs with x as the tail. Node a in Figure
     1.4 has in-degree two and out-degree one.

     A path of length n from x to y in a directed graph is a sequence
     of nodes x(subscript 0...n) satisfying

     N = { a, b, c, d} 
     A = { [ a , b ], [ b , a ], [ b , c ],
           [ b , d ], [ c , b ], [ c , d ],
	   [ d , a ], [ d , d ] }

     | node-vertice x | in-degree arc-edges | out-degree arc-edges |
     | node-vertice a | 2 arc-edge          | 1 arc-edge           |
     | node-vertice b | 2 arc-edge          | 3 arc-edge           |
     | node-vertice c | 1 arc-edge          | 2 arc-edge           |
     | node-vertice d | 3 arc-edge          | 2 arc-edge           |

*** languages
    
    The concept of languages includes a variety of seemingly distinct
    catagories: natural languages, computer languages, and
    mathematical languages. A general definition of language must
    encompass these various types of languages. In this chapter, a
    purely set-theoric definition of language is given: A language is
    a set of strings over an alphabet. This is the broadest possible
    definition, there are no inherent restrictions on the form of the
    strings that constitute a language.

    Languages of interest are not made of up arbitrary strings, but
    rather strings that satisfy certain properties. These properties
    define the syntax of the language. Recursive definitions and set
    operations are used to enforce syntactic restrictions on the
    strings of a language. The chapter concludes with the introduction
    of a faily of languages known as the regular sets. A regular set
    is constructed recursively from the empty set and singleton
    sets. Although we introduce the regular sets via a set-theoric
    construction, as we progress we will see that they occur naturally
    as the languages generated by regular grammars and recognized by
    finite-state machines.

**** strings and languages
**** finite specification of languages
**** regular set and expressions
** context-free grammars and parsing 

   The syntax of a language specifies the permissible forms of the
   strings of the language. In chapter 2, set theoric operations and
   recursive definitions were used to construct the strings of a
   language. These string building tools, although, primative, were
   adequate for enforcing simple constraints  on the order and number
   of elements in a string. In this section we introduce a formal
   system for string generation known as a context-free grammar. An
   element of the language is constructed from the start symbol of the
   grammar using rules that define permissable string
   transformations. The derivation of a string consists of a sequence
   of acceptable transformations.

   Context-free grammars, like recursive definitions, generate the
   strings of a language. The flexibility provided by the rules of a
   context-free grammar has proven well suited for defining the syntax
   of programming languages. The grammar that generates the
   programming language Pascal is used to demonstrate the context-free
   definition of several common programming language constructs.

   The process of analyzing a string for syntactic correctness is
   known as parsing. Defining the syntax of a language by a set of
   context-free rules facilitates the development of parsing
   algorithms. Several simple parsers, based on algorithms for
   traversing directed graphs, are presented in chapter 4. These
   algorithms systematically examine derivations to determine if a
   string is derivable from the start symbol of the grammar.

   Context-free grammars are members of a family of the string
   generation systems known as phrase-structure grammars. Another
   family of grammars, the regular grammars, is introduced as a
   special case of context-free grammars. These two types of grammars,
   along with two additional types of grammars, make up the sequence
   of increasingly powerful string generation systems known as the
   Chomsky hierarchy of grammars. The relationships between the
   grammars of the Chomsky hierarchy will be examined in chapter 10.

*** context-free grammars

     1. <sentence>        --> <noun-phrase> <verb-phrase>
     2. <sentence>        --> <noun-phrase> <verb> <direct-object-phrase>
     3. <noun-phrase>     --> <proper-noun>
     4.                   --> <determiner> <common-noun>
     5. <proper-noun>     --> John
     6.                   --> Jill
     7. <common-noun>     --> car
     8.                   --> hamburger
     9. <determiner>      --> a
    10.                   --> the
    11. <verb-phrase>     --> <verb> <adverb>
    12.                   --> <verb>
    13. <verb>            --> drives
    14.                   --> eats
    15. <adverb>          --> slowly
    16.                   --> frequently
    17. <adjective-list>  --> <adjective> <adjective-list>
    18.                   --> null sting, the lambda, that funny kind of constant
    19. <adjective>       --> big
    20.                   --> juicy
    21.                   --> brown

    The definition of <adjective-list> follows the standard recursive
    pattern. Rule 17 defines <adjective-list> in terms of itself while
    Rule 18 provides the basis of the recursive definition. The null sting
    on the right hand side of Rule 18 indicates that the application
    of this rule replaces <adjective-list> with the null
    sting. Repeated applications of Rule 17 generate a sequence of
    adjectives. Rules for <direct-object-phrase> are constructed using
    <adjective-list>: 

    22. <dir-obj-phrase> --> <adjective-list> <proper-noun>
    23.                  --> <determiner> <adjective-list> <common-noun>

    The sentence 'John eats a big juicy hamburger' can be derived by
    the following sequence of rule applications:

    Derivation                                                     Rule Applied
    >> <noun-phrase> <verb> <direct-object-phrase>                   2
    >> <proper-noun> <verb> <direct-object-phrase>                   3
    >> John <verb> <direct-object-phrase>                            5
    >> John eats <direct-object-phrase>                             14
    >> John eats <determiner> <adjective-list> <common-noun>        23
    >> John eats a <adjective-list> <common-noun>                    9
    >> John eats a <adjective> <adjective-list> <common-noun>       17
    >> John eats a big <adjective-list> <common-noun>               19 
    >> John eats a big <adjective> <adjective-list> <common-noun>   17
    >> John eats a big juicy <adjective-list> <common-noun>         20
    >> John eats a big juicy <common-noun>                          18
    >> John eats a big juicy hamburger                               8

    The generation of sentences is strictly a function of the
    rules. The string 'the car eats slowly' is a sentence in the
    language since it has the form <noun-phrase> <verb-phrase>
    outlined by Rule 1. This illustrates the important distinction
    between syntax and semantics;

    the generation of sentences is concerned with the form of the
    derived string without regard to any underlying meaning that may
    be associated with the terminal symbols.

    By Rules 3 and 4, a noun phrase consists of a proper noun or a
    common noun preceeded by a determiner. The variable
    <adjective-list> may be incorporated into the <noun-phrase> rules,
    permitting adjectives to modify a noun:

    3'. <noun-phrase>  --> <adjective-list> <proper-noun>
    4'.                --> <determiner> <adjective-list> <common-noun>

    With this modification, the string 'big John eats frequently' can
    be derived from the variable <sentence>.
 
**** context-free grammars and languages
**** examples of grammars and languages
**** regular grammars
**** grammars and languages revisited
**** a context-free grammar for pascl
**** arithmetic expressions
*** parsing: an introduction
**** leftmost derivations and ambiguity
**** the graph of a grammar
**** a breadth-first top-down parser
**** a depth-first top-down parser
**** bottom-up parsing
**** a depth-first bottom-up parser
*** normal forms
**** elimination of lambda rules
**** elimination of chain rules
**** useless symbols
**** Chomsky normal form
**** removal of direct left recursion
**** Greibach normal form
** automata and languages 
*** finite automata
**** a finite state machine
**** deterministic finite automata
**** state diagrams and examples
**** nondeterministic finite automata
**** lambda transitions
**** removing nondeterminism
**** dfa minimization
*** regular languages and sets
**** finite automata and regular sets
**** expression graphs
**** regular grammars and finite automata
**** closure properties of regular languages
**** a nonregular language
**** the pumping lemma for regular languages
**** the Myhill-Nerode Theorem
*** pushdown automata and context-free languages
**** pushdown automata
**** variations on the pda theme
**** pushdown automata and context-free languages
**** the pumping lemma for context-free languages
**** closure properties of context-free languages
**** a two-stack automaton
*** Turing machines
**** the standard Turing machine
**** Turing machines as language acceptors
**** alternative acceptance criteria
**** multitrack machines
**** two-way tape machines
**** multitape machines
**** nondeterministic Turing machines
**** Turing machines as language enumerators
*** the Chomsky hierarchy
**** unrestricted grammars
**** context-sensitive grammars
**** linear-bounded automata
**** the Chomsky hierarchy
** decidability and computability 
*** decidability
**** decision problems
**** the Church-Turing thesis
**** the halting problem for Turing machines
**** a universal machine
**** reducibility
**** Rice's theorem
**** an unsolvable word problem
**** the post correspondence problem
**** undecidable problems in context-free grammars
*** numeric computation
**** computation of functions
**** numeric computation
**** sequential operation of Turing machines
**** composition of functions
**** toward a programming language
*** mu-recursive functions
**** primitive recursive functions
**** some primitive recursive functions
**** bounded operators
**** division functions
**** Godel numbering and course-of-value recursion
**** computable partial functions
**** Turing computability and mu-recursive functions
**** the Church-Turing thesis revisited
** computational complexity 
*** time complexity of a Turing machine
**** linear speedup
**** rates of growth
**** complexity and Turing machine variations
**** properties of time complexity
**** nondeterministic complexity
**** space complexity
*** tractibility and NP-complete problems
**** tractible and intractible decision problems
**** the class NP
**** P = NP?
**** the satisfiability problem
**** additional NP-complete problems
**** derivative complexity classes
** deterministic parsing 
*** LL(k) grammars
**** lookahead in context-free grammars
**** FIRST, FOLLOW and lookahead sets
**** strong LL(k) grammars
**** construction of FIRST(k) sets
**** construction of FOLLOW(k) sets
**** a strong LL(1) grammar
**** a strong LL(k) parser
**** LL(k) grammars
*** LR(k) grammars
**** LR(0) contexts
**** an LR(0) parser
**** the LR(0) machine
**** acceptance by the LR(0) machine
**** LR(1) grammars
** index of notation
** the greek alphabet
** Backus-Naur definition of pascal
** subject index 


